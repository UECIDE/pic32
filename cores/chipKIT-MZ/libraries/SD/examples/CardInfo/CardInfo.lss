/home/matt/.uecide/compilers/pic32-gcc/bin/pic32-objdump -h -S /tmp/build-58616285-14a2-4e04-b79e-dd3963e9547a/CardInfo.elf 

/tmp/build-58616285-14a2-4e04-b79e-dd3963e9547a/CardInfo.elf:     file format elf32-tradlittlemips

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00000010  9d001000  9d001000  00011000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .image_ptr_table 00000008  9d0000f8  9d0000f8  000100f8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .app_excpt    00000010  9d000180  9d000180  00010180  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .vector_0     00000014  9d000200  9d000200  00010200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .vector_1     00000014  9d000220  9d000220  00010220  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .vector_2     00000014  9d000240  9d000240  00010240  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .vector_3     00000014  9d000260  9d000260  00010260  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .vector_4     00000014  9d000280  9d000280  00010280  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .vector_5     00000014  9d0002a0  9d0002a0  000102a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .vector_6     00000014  9d0002c0  9d0002c0  000102c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .vector_7     00000014  9d0002e0  9d0002e0  000102e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .vector_8     00000014  9d000300  9d000300  00010300  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .vector_9     00000014  9d000320  9d000320  00010320  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .vector_10    00000014  9d000340  9d000340  00010340  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .vector_11    00000014  9d000360  9d000360  00010360  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .vector_12    00000014  9d000380  9d000380  00010380  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .vector_13    00000014  9d0003a0  9d0003a0  000103a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .vector_14    00000014  9d0003c0  9d0003c0  000103c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .vector_15    00000014  9d0003e0  9d0003e0  000103e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .vector_16    00000014  9d000400  9d000400  00010400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .vector_17    00000014  9d000420  9d000420  00010420  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .vector_18    00000014  9d000440  9d000440  00010440  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .vector_19    00000014  9d000460  9d000460  00010460  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .vector_20    00000014  9d000480  9d000480  00010480  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .vector_21    00000014  9d0004a0  9d0004a0  000104a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 25 .vector_22    00000014  9d0004c0  9d0004c0  000104c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 26 .vector_23    00000014  9d0004e0  9d0004e0  000104e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .vector_24    00000014  9d000500  9d000500  00010500  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .vector_25    00000014  9d000520  9d000520  00010520  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 29 .vector_26    00000014  9d000540  9d000540  00010540  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 30 .vector_27    00000014  9d000560  9d000560  00010560  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .vector_28    00000014  9d000580  9d000580  00010580  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .vector_29    00000014  9d0005a0  9d0005a0  000105a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .vector_30    00000014  9d0005c0  9d0005c0  000105c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 34 .vector_31    00000014  9d0005e0  9d0005e0  000105e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 35 .vector_32    00000014  9d000600  9d000600  00010600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 36 .vector_33    00000014  9d000620  9d000620  00010620  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 37 .vector_34    00000014  9d000640  9d000640  00010640  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 38 .vector_35    00000014  9d000660  9d000660  00010660  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 39 .vector_36    00000014  9d000680  9d000680  00010680  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 40 .vector_37    00000014  9d0006a0  9d0006a0  000106a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 41 .vector_38    00000014  9d0006c0  9d0006c0  000106c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 42 .vector_39    00000014  9d0006e0  9d0006e0  000106e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 43 .vector_40    00000014  9d000700  9d000700  00010700  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 44 .vector_41    00000014  9d000720  9d000720  00010720  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 45 .vector_42    00000014  9d000740  9d000740  00010740  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 46 .vector_43    00000014  9d000760  9d000760  00010760  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 47 .vector_44    00000014  9d000780  9d000780  00010780  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 48 .vector_45    00000014  9d0007a0  9d0007a0  000107a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 49 .vector_46    00000014  9d0007c0  9d0007c0  000107c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 50 .vector_47    00000014  9d0007e0  9d0007e0  000107e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 51 .vector_48    00000014  9d000800  9d000800  00010800  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 52 .vector_49    00000014  9d000820  9d000820  00010820  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 53 .vector_50    00000014  9d000840  9d000840  00010840  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 54 .vector_51    00000014  9d000860  9d000860  00010860  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 55 .vector_52    00000014  9d000880  9d000880  00010880  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 56 .vector_53    00000014  9d0008a0  9d0008a0  000108a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 57 .vector_54    00000014  9d0008c0  9d0008c0  000108c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 58 .vector_55    00000014  9d0008e0  9d0008e0  000108e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 59 .vector_56    00000014  9d000900  9d000900  00010900  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 60 .vector_57    00000014  9d000920  9d000920  00010920  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 61 .vector_58    00000014  9d000940  9d000940  00010940  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 62 .vector_59    00000014  9d000960  9d000960  00010960  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 63 .vector_60    00000014  9d000980  9d000980  00010980  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 64 .vector_61    00000014  9d0009a0  9d0009a0  000109a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 65 .vector_62    00000014  9d0009c0  9d0009c0  000109c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 66 .vector_63    00000014  9d0009e0  9d0009e0  000109e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 67 .startup      000001e0  9d001010  9d001010  00011010  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 68 .text         0000688c  9d0011f0  9d0011f0  000111f0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 69 .init         00000024  9d007a7c  9d007a7c  00017a7c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 70 .fini         0000001c  9d007aa0  9d007aa0  00017aa0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 71 .ctors        00000010  9d007abc  9d007abc  00017abc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 72 .dtors        00000008  9d007acc  9d007acc  00017acc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 73 .header_info  0000004c  9d007ad4  9d007ad4  00017ad4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 74 .ram_exchange_data 00000008  a0000000  a0000000  00023000  2**0
                  CONTENTS
 75 .rodata       000003ec  9d007b20  9d007b20  00017b20  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 76 .data         00000908  a0000008  9d007f0c  00020008  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 77 .sdata        0000001c  a0000910  9d008814  00020910  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 78 .sbss         000000b8  a000092c  9d008830  0002092c  2**2
                  ALLOC
 79 .bss          00000f10  a0000a00  9d008830  00020a00  2**9
                  ALLOC
 80 .heap         00000800  a0001910  9d008830  00021910  2**0
                  ALLOC
 81 .stack        00000800  a0002110  9d008830  00022110  2**0
                  ALLOC
 82 .comment      00000095  00000000  00000000  00023008  2**0
                  CONTENTS, READONLY
 83 .debug_aranges 00001948  00000000  00000000  000230a0  2**3
                  CONTENTS, READONLY, DEBUGGING
 84 .debug_pubnames 00002cb0  00000000  00000000  000249e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 85 .debug_info   0003ba60  00000000  00000000  00027698  2**0
                  CONTENTS, READONLY, DEBUGGING
 86 .debug_abbrev 0000ac6a  00000000  00000000  000630f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 87 .debug_line   0000f787  00000000  00000000  0006dd62  2**0
                  CONTENTS, READONLY, DEBUGGING
 88 .debug_frame  000030e8  00000000  00000000  0007d4ec  2**2
                  CONTENTS, READONLY, DEBUGGING
 89 .debug_str    00009346  00000000  00000000  000805d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 90 .debug_loc    00021491  00000000  00000000  0008991a  2**0
                  CONTENTS, READONLY, DEBUGGING
 91 .debug_pubtypes 000035e6  00000000  00000000  000aadab  2**0
                  CONTENTS, READONLY, DEBUGGING
 92 .debug_ranges 00004e30  00000000  00000000  000ae398  2**3
                  CONTENTS, READONLY, DEBUGGING
 93 .gnu.attributes 00000010  00000000  00000000  000b31c8  2**0
                  CONTENTS, READONLY
 94 .mdebug.abi32 00000000  a0003000  a0003000  00023000  2**0
                  CONTENTS, ALLOC, LOAD, DATA

Disassembly of section .reset:

9d001000 <_reset>:
9d001000:	3c1a9d00 	lui	k0,0x9d00
9d001004:	275a1010 	addiu	k0,k0,4112
9d001008:	03400008 	jr	k0
9d00100c:	00000000 	nop

Disassembly of section .app_excpt:

9d000180 <_gen_exception>:
9d000180:	3c1a9d00 	lui	k0,0x9d00
9d000184:	275a74bc 	addiu	k0,k0,29884
9d000188:	03400008 	jr	k0
9d00018c:	00000000 	nop

Disassembly of section .vector_0:

9d000200 <__vector_0>:
    lw       k0,4 * number (k0); \
    jr       k0; \
    .end VECTOR_SYMBOLNAME(number); \
    .size VECTOR_SYMBOLNAME(number), .-VECTOR_SYMBOLNAME(number);

 VECTOR_ENTRY(0)
9d000200:	3c1aa000 	lui	k0,0xa000
9d000204:	275a0008 	addiu	k0,k0,8
9d000208:	8f5a0000 	lw	k0,0(k0)
9d00020c:	03400008 	jr	k0
9d000210:	00000000 	nop

Disassembly of section .vector_1:

9d000220 <__vector_1>:
 VECTOR_ENTRY(1)
9d000220:	3c1aa000 	lui	k0,0xa000
9d000224:	275a0008 	addiu	k0,k0,8
9d000228:	8f5a0004 	lw	k0,4(k0)
9d00022c:	03400008 	jr	k0
9d000230:	00000000 	nop

Disassembly of section .vector_2:

9d000240 <__vector_2>:
 VECTOR_ENTRY(2)
9d000240:	3c1aa000 	lui	k0,0xa000
9d000244:	275a0008 	addiu	k0,k0,8
9d000248:	8f5a0008 	lw	k0,8(k0)
9d00024c:	03400008 	jr	k0
9d000250:	00000000 	nop

Disassembly of section .vector_3:

9d000260 <__vector_3>:
 VECTOR_ENTRY(3)
9d000260:	3c1aa000 	lui	k0,0xa000
9d000264:	275a0008 	addiu	k0,k0,8
9d000268:	8f5a000c 	lw	k0,12(k0)
9d00026c:	03400008 	jr	k0
9d000270:	00000000 	nop

Disassembly of section .vector_4:

9d000280 <__vector_4>:
 VECTOR_ENTRY(4)
9d000280:	3c1aa000 	lui	k0,0xa000
9d000284:	275a0008 	addiu	k0,k0,8
9d000288:	8f5a0010 	lw	k0,16(k0)
9d00028c:	03400008 	jr	k0
9d000290:	00000000 	nop

Disassembly of section .vector_5:

9d0002a0 <__vector_5>:
 VECTOR_ENTRY(5)
9d0002a0:	3c1aa000 	lui	k0,0xa000
9d0002a4:	275a0008 	addiu	k0,k0,8
9d0002a8:	8f5a0014 	lw	k0,20(k0)
9d0002ac:	03400008 	jr	k0
9d0002b0:	00000000 	nop

Disassembly of section .vector_6:

9d0002c0 <__vector_6>:
 VECTOR_ENTRY(6)
9d0002c0:	3c1aa000 	lui	k0,0xa000
9d0002c4:	275a0008 	addiu	k0,k0,8
9d0002c8:	8f5a0018 	lw	k0,24(k0)
9d0002cc:	03400008 	jr	k0
9d0002d0:	00000000 	nop

Disassembly of section .vector_7:

9d0002e0 <__vector_7>:
 VECTOR_ENTRY(7)
9d0002e0:	3c1aa000 	lui	k0,0xa000
9d0002e4:	275a0008 	addiu	k0,k0,8
9d0002e8:	8f5a001c 	lw	k0,28(k0)
9d0002ec:	03400008 	jr	k0
9d0002f0:	00000000 	nop

Disassembly of section .vector_8:

9d000300 <__vector_8>:
 VECTOR_ENTRY(8)
9d000300:	3c1aa000 	lui	k0,0xa000
9d000304:	275a0008 	addiu	k0,k0,8
9d000308:	8f5a0020 	lw	k0,32(k0)
9d00030c:	03400008 	jr	k0
9d000310:	00000000 	nop

Disassembly of section .vector_9:

9d000320 <__vector_9>:
 VECTOR_ENTRY(9)
9d000320:	3c1aa000 	lui	k0,0xa000
9d000324:	275a0008 	addiu	k0,k0,8
9d000328:	8f5a0024 	lw	k0,36(k0)
9d00032c:	03400008 	jr	k0
9d000330:	00000000 	nop

Disassembly of section .vector_10:

9d000340 <__vector_10>:
 VECTOR_ENTRY(10)
9d000340:	3c1aa000 	lui	k0,0xa000
9d000344:	275a0008 	addiu	k0,k0,8
9d000348:	8f5a0028 	lw	k0,40(k0)
9d00034c:	03400008 	jr	k0
9d000350:	00000000 	nop

Disassembly of section .vector_11:

9d000360 <__vector_11>:
 VECTOR_ENTRY(11)
9d000360:	3c1aa000 	lui	k0,0xa000
9d000364:	275a0008 	addiu	k0,k0,8
9d000368:	8f5a002c 	lw	k0,44(k0)
9d00036c:	03400008 	jr	k0
9d000370:	00000000 	nop

Disassembly of section .vector_12:

9d000380 <__vector_12>:
 VECTOR_ENTRY(12)
9d000380:	3c1aa000 	lui	k0,0xa000
9d000384:	275a0008 	addiu	k0,k0,8
9d000388:	8f5a0030 	lw	k0,48(k0)
9d00038c:	03400008 	jr	k0
9d000390:	00000000 	nop

Disassembly of section .vector_13:

9d0003a0 <__vector_13>:
 VECTOR_ENTRY(13)
9d0003a0:	3c1aa000 	lui	k0,0xa000
9d0003a4:	275a0008 	addiu	k0,k0,8
9d0003a8:	8f5a0034 	lw	k0,52(k0)
9d0003ac:	03400008 	jr	k0
9d0003b0:	00000000 	nop

Disassembly of section .vector_14:

9d0003c0 <__vector_14>:
 VECTOR_ENTRY(14)
9d0003c0:	3c1aa000 	lui	k0,0xa000
9d0003c4:	275a0008 	addiu	k0,k0,8
9d0003c8:	8f5a0038 	lw	k0,56(k0)
9d0003cc:	03400008 	jr	k0
9d0003d0:	00000000 	nop

Disassembly of section .vector_15:

9d0003e0 <__vector_15>:
 VECTOR_ENTRY(15)
9d0003e0:	3c1aa000 	lui	k0,0xa000
9d0003e4:	275a0008 	addiu	k0,k0,8
9d0003e8:	8f5a003c 	lw	k0,60(k0)
9d0003ec:	03400008 	jr	k0
9d0003f0:	00000000 	nop

Disassembly of section .vector_16:

9d000400 <__vector_16>:
 VECTOR_ENTRY(16)
9d000400:	3c1aa000 	lui	k0,0xa000
9d000404:	275a0008 	addiu	k0,k0,8
9d000408:	8f5a0040 	lw	k0,64(k0)
9d00040c:	03400008 	jr	k0
9d000410:	00000000 	nop

Disassembly of section .vector_17:

9d000420 <__vector_17>:
 VECTOR_ENTRY(17)
9d000420:	3c1aa000 	lui	k0,0xa000
9d000424:	275a0008 	addiu	k0,k0,8
9d000428:	8f5a0044 	lw	k0,68(k0)
9d00042c:	03400008 	jr	k0
9d000430:	00000000 	nop

Disassembly of section .vector_18:

9d000440 <__vector_18>:
 VECTOR_ENTRY(18)
9d000440:	3c1aa000 	lui	k0,0xa000
9d000444:	275a0008 	addiu	k0,k0,8
9d000448:	8f5a0048 	lw	k0,72(k0)
9d00044c:	03400008 	jr	k0
9d000450:	00000000 	nop

Disassembly of section .vector_19:

9d000460 <__vector_19>:
 VECTOR_ENTRY(19)
9d000460:	3c1aa000 	lui	k0,0xa000
9d000464:	275a0008 	addiu	k0,k0,8
9d000468:	8f5a004c 	lw	k0,76(k0)
9d00046c:	03400008 	jr	k0
9d000470:	00000000 	nop

Disassembly of section .vector_20:

9d000480 <__vector_20>:
 VECTOR_ENTRY(20)
9d000480:	3c1aa000 	lui	k0,0xa000
9d000484:	275a0008 	addiu	k0,k0,8
9d000488:	8f5a0050 	lw	k0,80(k0)
9d00048c:	03400008 	jr	k0
9d000490:	00000000 	nop

Disassembly of section .vector_21:

9d0004a0 <__vector_21>:
 VECTOR_ENTRY(21)
9d0004a0:	3c1aa000 	lui	k0,0xa000
9d0004a4:	275a0008 	addiu	k0,k0,8
9d0004a8:	8f5a0054 	lw	k0,84(k0)
9d0004ac:	03400008 	jr	k0
9d0004b0:	00000000 	nop

Disassembly of section .vector_22:

9d0004c0 <__vector_22>:
 VECTOR_ENTRY(22)
9d0004c0:	3c1aa000 	lui	k0,0xa000
9d0004c4:	275a0008 	addiu	k0,k0,8
9d0004c8:	8f5a0058 	lw	k0,88(k0)
9d0004cc:	03400008 	jr	k0
9d0004d0:	00000000 	nop

Disassembly of section .vector_23:

9d0004e0 <__vector_23>:
 VECTOR_ENTRY(23)
9d0004e0:	3c1aa000 	lui	k0,0xa000
9d0004e4:	275a0008 	addiu	k0,k0,8
9d0004e8:	8f5a005c 	lw	k0,92(k0)
9d0004ec:	03400008 	jr	k0
9d0004f0:	00000000 	nop

Disassembly of section .vector_24:

9d000500 <__vector_24>:
 VECTOR_ENTRY(24)
9d000500:	3c1aa000 	lui	k0,0xa000
9d000504:	275a0008 	addiu	k0,k0,8
9d000508:	8f5a0060 	lw	k0,96(k0)
9d00050c:	03400008 	jr	k0
9d000510:	00000000 	nop

Disassembly of section .vector_25:

9d000520 <__vector_25>:
 VECTOR_ENTRY(25)
9d000520:	3c1aa000 	lui	k0,0xa000
9d000524:	275a0008 	addiu	k0,k0,8
9d000528:	8f5a0064 	lw	k0,100(k0)
9d00052c:	03400008 	jr	k0
9d000530:	00000000 	nop

Disassembly of section .vector_26:

9d000540 <__vector_26>:
 VECTOR_ENTRY(26)
9d000540:	3c1aa000 	lui	k0,0xa000
9d000544:	275a0008 	addiu	k0,k0,8
9d000548:	8f5a0068 	lw	k0,104(k0)
9d00054c:	03400008 	jr	k0
9d000550:	00000000 	nop

Disassembly of section .vector_27:

9d000560 <__vector_27>:
 VECTOR_ENTRY(27)
9d000560:	3c1aa000 	lui	k0,0xa000
9d000564:	275a0008 	addiu	k0,k0,8
9d000568:	8f5a006c 	lw	k0,108(k0)
9d00056c:	03400008 	jr	k0
9d000570:	00000000 	nop

Disassembly of section .vector_28:

9d000580 <__vector_28>:
 VECTOR_ENTRY(28)
9d000580:	3c1aa000 	lui	k0,0xa000
9d000584:	275a0008 	addiu	k0,k0,8
9d000588:	8f5a0070 	lw	k0,112(k0)
9d00058c:	03400008 	jr	k0
9d000590:	00000000 	nop

Disassembly of section .vector_29:

9d0005a0 <__vector_29>:
 VECTOR_ENTRY(29)
9d0005a0:	3c1aa000 	lui	k0,0xa000
9d0005a4:	275a0008 	addiu	k0,k0,8
9d0005a8:	8f5a0074 	lw	k0,116(k0)
9d0005ac:	03400008 	jr	k0
9d0005b0:	00000000 	nop

Disassembly of section .vector_30:

9d0005c0 <__vector_30>:
 VECTOR_ENTRY(30)
9d0005c0:	3c1aa000 	lui	k0,0xa000
9d0005c4:	275a0008 	addiu	k0,k0,8
9d0005c8:	8f5a0078 	lw	k0,120(k0)
9d0005cc:	03400008 	jr	k0
9d0005d0:	00000000 	nop

Disassembly of section .vector_31:

9d0005e0 <__vector_31>:
 VECTOR_ENTRY(31)
9d0005e0:	3c1aa000 	lui	k0,0xa000
9d0005e4:	275a0008 	addiu	k0,k0,8
9d0005e8:	8f5a007c 	lw	k0,124(k0)
9d0005ec:	03400008 	jr	k0
9d0005f0:	00000000 	nop

Disassembly of section .vector_32:

9d000600 <__vector_32>:
 VECTOR_ENTRY(32)
9d000600:	3c1aa000 	lui	k0,0xa000
9d000604:	275a0008 	addiu	k0,k0,8
9d000608:	8f5a0080 	lw	k0,128(k0)
9d00060c:	03400008 	jr	k0
9d000610:	00000000 	nop

Disassembly of section .vector_33:

9d000620 <__vector_33>:
 VECTOR_ENTRY(33)
9d000620:	3c1aa000 	lui	k0,0xa000
9d000624:	275a0008 	addiu	k0,k0,8
9d000628:	8f5a0084 	lw	k0,132(k0)
9d00062c:	03400008 	jr	k0
9d000630:	00000000 	nop

Disassembly of section .vector_34:

9d000640 <__vector_34>:
 VECTOR_ENTRY(34)
9d000640:	3c1aa000 	lui	k0,0xa000
9d000644:	275a0008 	addiu	k0,k0,8
9d000648:	8f5a0088 	lw	k0,136(k0)
9d00064c:	03400008 	jr	k0
9d000650:	00000000 	nop

Disassembly of section .vector_35:

9d000660 <__vector_35>:
 VECTOR_ENTRY(35)
9d000660:	3c1aa000 	lui	k0,0xa000
9d000664:	275a0008 	addiu	k0,k0,8
9d000668:	8f5a008c 	lw	k0,140(k0)
9d00066c:	03400008 	jr	k0
9d000670:	00000000 	nop

Disassembly of section .vector_36:

9d000680 <__vector_36>:
 VECTOR_ENTRY(36)
9d000680:	3c1aa000 	lui	k0,0xa000
9d000684:	275a0008 	addiu	k0,k0,8
9d000688:	8f5a0090 	lw	k0,144(k0)
9d00068c:	03400008 	jr	k0
9d000690:	00000000 	nop

Disassembly of section .vector_37:

9d0006a0 <__vector_37>:
 VECTOR_ENTRY(37)
9d0006a0:	3c1aa000 	lui	k0,0xa000
9d0006a4:	275a0008 	addiu	k0,k0,8
9d0006a8:	8f5a0094 	lw	k0,148(k0)
9d0006ac:	03400008 	jr	k0
9d0006b0:	00000000 	nop

Disassembly of section .vector_38:

9d0006c0 <__vector_38>:
 VECTOR_ENTRY(38)
9d0006c0:	3c1aa000 	lui	k0,0xa000
9d0006c4:	275a0008 	addiu	k0,k0,8
9d0006c8:	8f5a0098 	lw	k0,152(k0)
9d0006cc:	03400008 	jr	k0
9d0006d0:	00000000 	nop

Disassembly of section .vector_39:

9d0006e0 <__vector_39>:
 VECTOR_ENTRY(39)
9d0006e0:	3c1aa000 	lui	k0,0xa000
9d0006e4:	275a0008 	addiu	k0,k0,8
9d0006e8:	8f5a009c 	lw	k0,156(k0)
9d0006ec:	03400008 	jr	k0
9d0006f0:	00000000 	nop

Disassembly of section .vector_40:

9d000700 <__vector_40>:
 VECTOR_ENTRY(40)
9d000700:	3c1aa000 	lui	k0,0xa000
9d000704:	275a0008 	addiu	k0,k0,8
9d000708:	8f5a00a0 	lw	k0,160(k0)
9d00070c:	03400008 	jr	k0
9d000710:	00000000 	nop

Disassembly of section .vector_41:

9d000720 <__vector_41>:
 VECTOR_ENTRY(41)
9d000720:	3c1aa000 	lui	k0,0xa000
9d000724:	275a0008 	addiu	k0,k0,8
9d000728:	8f5a00a4 	lw	k0,164(k0)
9d00072c:	03400008 	jr	k0
9d000730:	00000000 	nop

Disassembly of section .vector_42:

9d000740 <__vector_42>:
 VECTOR_ENTRY(42)
9d000740:	3c1aa000 	lui	k0,0xa000
9d000744:	275a0008 	addiu	k0,k0,8
9d000748:	8f5a00a8 	lw	k0,168(k0)
9d00074c:	03400008 	jr	k0
9d000750:	00000000 	nop

Disassembly of section .vector_43:

9d000760 <__vector_43>:
 VECTOR_ENTRY(43)
9d000760:	3c1aa000 	lui	k0,0xa000
9d000764:	275a0008 	addiu	k0,k0,8
9d000768:	8f5a00ac 	lw	k0,172(k0)
9d00076c:	03400008 	jr	k0
9d000770:	00000000 	nop

Disassembly of section .vector_44:

9d000780 <__vector_44>:
 VECTOR_ENTRY(44)
9d000780:	3c1aa000 	lui	k0,0xa000
9d000784:	275a0008 	addiu	k0,k0,8
9d000788:	8f5a00b0 	lw	k0,176(k0)
9d00078c:	03400008 	jr	k0
9d000790:	00000000 	nop

Disassembly of section .vector_45:

9d0007a0 <__vector_45>:
 VECTOR_ENTRY(45)
9d0007a0:	3c1aa000 	lui	k0,0xa000
9d0007a4:	275a0008 	addiu	k0,k0,8
9d0007a8:	8f5a00b4 	lw	k0,180(k0)
9d0007ac:	03400008 	jr	k0
9d0007b0:	00000000 	nop

Disassembly of section .vector_46:

9d0007c0 <__vector_46>:
 VECTOR_ENTRY(46)
9d0007c0:	3c1aa000 	lui	k0,0xa000
9d0007c4:	275a0008 	addiu	k0,k0,8
9d0007c8:	8f5a00b8 	lw	k0,184(k0)
9d0007cc:	03400008 	jr	k0
9d0007d0:	00000000 	nop

Disassembly of section .vector_47:

9d0007e0 <__vector_47>:
 VECTOR_ENTRY(47)
9d0007e0:	3c1aa000 	lui	k0,0xa000
9d0007e4:	275a0008 	addiu	k0,k0,8
9d0007e8:	8f5a00bc 	lw	k0,188(k0)
9d0007ec:	03400008 	jr	k0
9d0007f0:	00000000 	nop

Disassembly of section .vector_48:

9d000800 <__vector_48>:
 VECTOR_ENTRY(48)
9d000800:	3c1aa000 	lui	k0,0xa000
9d000804:	275a0008 	addiu	k0,k0,8
9d000808:	8f5a00c0 	lw	k0,192(k0)
9d00080c:	03400008 	jr	k0
9d000810:	00000000 	nop

Disassembly of section .vector_49:

9d000820 <__vector_49>:
 VECTOR_ENTRY(49)
9d000820:	3c1aa000 	lui	k0,0xa000
9d000824:	275a0008 	addiu	k0,k0,8
9d000828:	8f5a00c4 	lw	k0,196(k0)
9d00082c:	03400008 	jr	k0
9d000830:	00000000 	nop

Disassembly of section .vector_50:

9d000840 <__vector_50>:
 VECTOR_ENTRY(50)
9d000840:	3c1aa000 	lui	k0,0xa000
9d000844:	275a0008 	addiu	k0,k0,8
9d000848:	8f5a00c8 	lw	k0,200(k0)
9d00084c:	03400008 	jr	k0
9d000850:	00000000 	nop

Disassembly of section .vector_51:

9d000860 <__vector_51>:
 VECTOR_ENTRY(51)
9d000860:	3c1aa000 	lui	k0,0xa000
9d000864:	275a0008 	addiu	k0,k0,8
9d000868:	8f5a00cc 	lw	k0,204(k0)
9d00086c:	03400008 	jr	k0
9d000870:	00000000 	nop

Disassembly of section .vector_52:

9d000880 <__vector_52>:
 VECTOR_ENTRY(52)
9d000880:	3c1aa000 	lui	k0,0xa000
9d000884:	275a0008 	addiu	k0,k0,8
9d000888:	8f5a00d0 	lw	k0,208(k0)
9d00088c:	03400008 	jr	k0
9d000890:	00000000 	nop

Disassembly of section .vector_53:

9d0008a0 <__vector_53>:
 VECTOR_ENTRY(53)
9d0008a0:	3c1aa000 	lui	k0,0xa000
9d0008a4:	275a0008 	addiu	k0,k0,8
9d0008a8:	8f5a00d4 	lw	k0,212(k0)
9d0008ac:	03400008 	jr	k0
9d0008b0:	00000000 	nop

Disassembly of section .vector_54:

9d0008c0 <__vector_54>:
 VECTOR_ENTRY(54)
9d0008c0:	3c1aa000 	lui	k0,0xa000
9d0008c4:	275a0008 	addiu	k0,k0,8
9d0008c8:	8f5a00d8 	lw	k0,216(k0)
9d0008cc:	03400008 	jr	k0
9d0008d0:	00000000 	nop

Disassembly of section .vector_55:

9d0008e0 <__vector_55>:
 VECTOR_ENTRY(55)
9d0008e0:	3c1aa000 	lui	k0,0xa000
9d0008e4:	275a0008 	addiu	k0,k0,8
9d0008e8:	8f5a00dc 	lw	k0,220(k0)
9d0008ec:	03400008 	jr	k0
9d0008f0:	00000000 	nop

Disassembly of section .vector_56:

9d000900 <__vector_56>:
 VECTOR_ENTRY(56)
9d000900:	3c1aa000 	lui	k0,0xa000
9d000904:	275a0008 	addiu	k0,k0,8
9d000908:	8f5a00e0 	lw	k0,224(k0)
9d00090c:	03400008 	jr	k0
9d000910:	00000000 	nop

Disassembly of section .vector_57:

9d000920 <__vector_57>:
 VECTOR_ENTRY(57)
9d000920:	3c1aa000 	lui	k0,0xa000
9d000924:	275a0008 	addiu	k0,k0,8
9d000928:	8f5a00e4 	lw	k0,228(k0)
9d00092c:	03400008 	jr	k0
9d000930:	00000000 	nop

Disassembly of section .vector_58:

9d000940 <__vector_58>:
 VECTOR_ENTRY(58)
9d000940:	3c1aa000 	lui	k0,0xa000
9d000944:	275a0008 	addiu	k0,k0,8
9d000948:	8f5a00e8 	lw	k0,232(k0)
9d00094c:	03400008 	jr	k0
9d000950:	00000000 	nop

Disassembly of section .vector_59:

9d000960 <__vector_59>:
 VECTOR_ENTRY(59)
9d000960:	3c1aa000 	lui	k0,0xa000
9d000964:	275a0008 	addiu	k0,k0,8
9d000968:	8f5a00ec 	lw	k0,236(k0)
9d00096c:	03400008 	jr	k0
9d000970:	00000000 	nop

Disassembly of section .vector_60:

9d000980 <__vector_60>:
 VECTOR_ENTRY(60)
9d000980:	3c1aa000 	lui	k0,0xa000
9d000984:	275a0008 	addiu	k0,k0,8
9d000988:	8f5a00f0 	lw	k0,240(k0)
9d00098c:	03400008 	jr	k0
9d000990:	00000000 	nop

Disassembly of section .vector_61:

9d0009a0 <__vector_61>:
 VECTOR_ENTRY(61)
9d0009a0:	3c1aa000 	lui	k0,0xa000
9d0009a4:	275a0008 	addiu	k0,k0,8
9d0009a8:	8f5a00f4 	lw	k0,244(k0)
9d0009ac:	03400008 	jr	k0
9d0009b0:	00000000 	nop

Disassembly of section .vector_62:

9d0009c0 <__vector_62>:
 VECTOR_ENTRY(62)
9d0009c0:	3c1aa000 	lui	k0,0xa000
9d0009c4:	275a0008 	addiu	k0,k0,8
9d0009c8:	8f5a00f8 	lw	k0,248(k0)
9d0009cc:	03400008 	jr	k0
9d0009d0:	00000000 	nop

Disassembly of section .vector_63:

9d0009e0 <__vector_63>:
 VECTOR_ENTRY(63)
9d0009e0:	3c1aa000 	lui	k0,0xa000
9d0009e4:	275a0008 	addiu	k0,k0,8
9d0009e8:	8f5a00fc 	lw	k0,252(k0)
9d0009ec:	03400008 	jr	k0
9d0009f0:	00000000 	nop

Disassembly of section .startup:

9d001010 <_startup>:
9d001010:	401a6000 	mfc0	k0,c0_status
9d001014:	7f5a04c0 	ext	k0,k0,0x13,0x1
9d001018:	13400005 	beqz	k0,9d001030 <_no_nmi>
9d00101c:	00000000 	nop
9d001020:	3c1a9d00 	lui	k0,0x9d00
9d001024:	275a75a4 	addiu	k0,k0,30116
9d001028:	03400008 	jr	k0
9d00102c:	00000000 	nop

9d001030 <_no_nmi>:
9d001030:	3c1da002 	lui	sp,0xa002
9d001034:	27bd0000 	addiu	sp,sp,0
9d001038:	3c1ca001 	lui	gp,0xa001
9d00103c:	279c8900 	addiu	gp,gp,-30464
9d001040:	40096002 	mfc0	t1,c0_srsctl
9d001044:	01205820 	add	t3,t1,zero
9d001048:	7d2a1e80 	ext	t2,t1,0x1a,0x4
9d00104c:	7d494984 	ins	t1,t2,0x6,0x4
9d001050:	40896002 	mtc0	t1,c0_srsctl
9d001054:	41dce000 	wrpgpr	gp,gp
9d001058:	408b6002 	mtc0	t3,c0_srsctl
9d00105c:	3c089d00 	lui	t0,0x9d00
9d001060:	25087594 	addiu	t0,t0,30100
9d001064:	0100f809 	jalr	t0
9d001068:	00000000 	nop
9d00106c:	3c08a000 	lui	t0,0xa000
9d001070:	2508092c 	addiu	t0,t0,2348
9d001074:	3c09a000 	lui	t1,0xa000
9d001078:	25291910 	addiu	t1,t1,6416
9d00107c:	10000006 	b	9d001098 <_bss_check>
9d001080:	00000000 	nop

9d001084 <_bss_init>:
9d001084:	ad000000 	sw	zero,0(t0)
9d001088:	ad000004 	sw	zero,4(t0)
9d00108c:	ad000008 	sw	zero,8(t0)
9d001090:	ad00000c 	sw	zero,12(t0)
9d001094:	25080010 	addiu	t0,t0,16

9d001098 <_bss_check>:
9d001098:	0109082b 	sltu	at,t0,t1
9d00109c:	1420fff9 	bnez	at,9d001084 <_bss_init>
9d0010a0:	00000000 	nop
9d0010a4:	3c089d00 	lui	t0,0x9d00
9d0010a8:	25087f0c 	addiu	t0,t0,32524
9d0010ac:	3c09a000 	lui	t1,0xa000
9d0010b0:	25290008 	addiu	t1,t1,8
9d0010b4:	3c0aa000 	lui	t2,0xa000
9d0010b8:	254a092c 	addiu	t2,t2,2348
9d0010bc:	10000005 	b	9d0010d4 <_init_check>
9d0010c0:	00000000 	nop

9d0010c4 <_init_data>:
9d0010c4:	8d0b0000 	lw	t3,0(t0)
9d0010c8:	ad2b0000 	sw	t3,0(t1)
9d0010cc:	25080004 	addiu	t0,t0,4
9d0010d0:	25290004 	addiu	t1,t1,4

9d0010d4 <_init_check>:
9d0010d4:	012a082b 	sltu	at,t1,t2
9d0010d8:	1420fffa 	bnez	at,9d0010c4 <_init_data>
9d0010dc:	00000000 	nop
9d0010e0:	3c090000 	lui	t1,0x0
9d0010e4:	25290000 	addiu	t1,t1,0
9d0010e8:	1120001d 	beqz	t1,9d001160 <_ramfunc_done>
9d0010ec:	00000000 	nop
9d0010f0:	3c089d01 	lui	t0,0x9d01
9d0010f4:	25088830 	addiu	t0,t0,-30672
9d0010f8:	3c09a000 	lui	t1,0xa000
9d0010fc:	25293000 	addiu	t1,t1,12288
9d001100:	3c0aa000 	lui	t2,0xa000
9d001104:	254a3000 	addiu	t2,t2,12288

9d001108 <_init_ramfunc>:
9d001108:	8d0b0000 	lw	t3,0(t0)
9d00110c:	ad2b0000 	sw	t3,0(t1)
9d001110:	25080004 	addiu	t0,t0,4
9d001114:	25290004 	addiu	t1,t1,4

9d001118 <_ramfunc_check>:
9d001118:	012a082b 	sltu	at,t1,t2
9d00111c:	1420fffa 	bnez	at,9d001108 <_init_ramfunc>
9d001120:	00000000 	nop
9d001124:	3c090000 	lui	t1,0x0
9d001128:	25293000 	addiu	t1,t1,12288
9d00112c:	3c0abf88 	lui	t2,0xbf88
9d001130:	254a2010 	addiu	t2,t2,8208
9d001134:	ad490000 	sw	t1,0(t2)
9d001138:	3c090002 	lui	t1,0x2
9d00113c:	25290000 	addiu	t1,t1,0
9d001140:	3c0abf88 	lui	t2,0xbf88
9d001144:	254a2020 	addiu	t2,t2,8224
9d001148:	ad490000 	sw	t1,0(t2)
9d00114c:	3c090002 	lui	t1,0x2
9d001150:	25290000 	addiu	t1,t1,0
9d001154:	3c0abf88 	lui	t2,0xbf88
9d001158:	254a2030 	addiu	t2,t2,8240
9d00115c:	ad490000 	sw	t1,0(t2)

9d001160 <_ramfunc_done>:
9d001160:	40804800 	mtc0	zero,c0_count
9d001164:	240affff 	li	t2,-1
9d001168:	408a5800 	mtc0	t2,c0_compare
9d00116c:	3c099d00 	lui	t1,0x9d00
9d001170:	25290000 	addiu	t1,t1,0
9d001174:	40897801 	mtc0	t1,c0_ebase
9d001178:	3c090000 	lui	t1,0x0
9d00117c:	25290001 	addiu	t1,t1,1
9d001180:	240a0000 	li	t2,0
9d001184:	7d2a4944 	ins	t2,t1,0x5,0x5
9d001188:	408a6001 	mtc0	t2,c0_intctl
9d00118c:	3c090080 	lui	t1,0x80
9d001190:	40896800 	mtc0	t1,c0_cause
9d001194:	40088000 	mfc0	t0,c0_config
9d001198:	7d090580 	ext	t1,t0,0x16,0x1
9d00119c:	00094c40 	sll	t1,t1,0x11
9d0011a0:	40086000 	mfc0	t0,c0_status
9d0011a4:	3c010058 	lui	at,0x58
9d0011a8:	01014024 	and	t0,t0,at
9d0011ac:	01284025 	or	t0,t1,t0
9d0011b0:	40886000 	mtc0	t0,c0_status
9d0011b4:	3c089d00 	lui	t0,0x9d00
9d0011b8:	2508759c 	addiu	t0,t0,30108
9d0011bc:	0100f809 	jalr	t0
9d0011c0:	00000000 	nop
9d0011c4:	40086000 	mfc0	t0,c0_status
9d0011c8:	3c01ffbf 	lui	at,0xffbf
9d0011cc:	3421ffff 	ori	at,at,0xffff
9d0011d0:	01014024 	and	t0,t0,at
9d0011d4:	40886000 	mtc0	t0,c0_status
9d0011d8:	30840000 	andi	a0,a0,0x0
9d0011dc:	30a50000 	andi	a1,a1,0x0
9d0011e0:	3c089d00 	lui	t0,0x9d00
9d0011e4:	250811f0 	addiu	t0,t0,4592
9d0011e8:	01000008 	jr	t0
9d0011ec:	00000000 	nop

Disassembly of section .text:

9d0011f0 <_main_entry>:
9d0011f0:	0f401e9f 	jal	9d007a7c <_text_end>
9d0011f4:	00000000 	nop
9d0011f8:	30840000 	andi	a0,a0,0x0
9d0011fc:	30a50000 	andi	a1,a1,0x0
9d001200:	0f4012cb 	jal	9d004b2c <main>
9d001204:	00000000 	nop
9d001208:	1000fffd 	b	9d001200 <_main_entry+0x10>
9d00120c:	00000000 	nop

9d001210 <__do_global_dtors_aux>:
9d001210:	27bdffd8 	addiu	sp,sp,-40
9d001214:	afb2001c 	sw	s2,28(sp)
9d001218:	3c12a000 	lui	s2,0xa000
9d00121c:	92420a00 	lbu	v0,2560(s2)
9d001220:	afbf0024 	sw	ra,36(sp)
9d001224:	afb30020 	sw	s3,32(sp)
9d001228:	afb10018 	sw	s1,24(sp)
9d00122c:	14400020 	bnez	v0,9d0012b0 <__do_global_dtors_aux+0xa0>
9d001230:	afb00014 	sw	s0,20(sp)
9d001234:	3c119d00 	lui	s1,0x9d00
9d001238:	3c109d00 	lui	s0,0x9d00
9d00123c:	3c13a000 	lui	s3,0xa000
9d001240:	26317acc 	addiu	s1,s1,31436
9d001244:	26107ad0 	addiu	s0,s0,31440
9d001248:	8e620a04 	lw	v0,2564(s3)
9d00124c:	02118023 	subu	s0,s0,s1
9d001250:	00108083 	sra	s0,s0,0x2
9d001254:	2610ffff 	addiu	s0,s0,-1
9d001258:	0050182b 	sltu	v1,v0,s0
9d00125c:	5060000c 	beqzl	v1,9d001290 <__do_global_dtors_aux+0x80>
9d001260:	3c020000 	lui	v0,0x0
9d001264:	24420001 	addiu	v0,v0,1
9d001268:	00021880 	sll	v1,v0,0x2
9d00126c:	02231821 	addu	v1,s1,v1
9d001270:	8c630000 	lw	v1,0(v1)
9d001274:	0060f809 	jalr	v1
9d001278:	ae620a04 	sw	v0,2564(s3)
9d00127c:	8e620a04 	lw	v0,2564(s3)
9d001280:	0050182b 	sltu	v1,v0,s0
9d001284:	1460fff8 	bnez	v1,9d001268 <__do_global_dtors_aux+0x58>
9d001288:	24420001 	addiu	v0,v0,1
9d00128c:	3c020000 	lui	v0,0x0
9d001290:	24420000 	addiu	v0,v0,0
9d001294:	10400005 	beqz	v0,9d0012ac <__do_global_dtors_aux+0x9c>
9d001298:	24020001 	li	v0,1
9d00129c:	3c04a000 	lui	a0,0xa000
9d0012a0:	0c000000 	jal	90000000 <_imageExecutionJumpToFirstInFlash+0x8e000000>
9d0012a4:	24840008 	addiu	a0,a0,8
9d0012a8:	24020001 	li	v0,1
9d0012ac:	a2420a00 	sb	v0,2560(s2)
9d0012b0:	8fbf0024 	lw	ra,36(sp)
9d0012b4:	8fb30020 	lw	s3,32(sp)
9d0012b8:	8fb2001c 	lw	s2,28(sp)
9d0012bc:	8fb10018 	lw	s1,24(sp)
9d0012c0:	8fb00014 	lw	s0,20(sp)
9d0012c4:	03e00008 	jr	ra
9d0012c8:	27bd0028 	addiu	sp,sp,40

9d0012cc <frame_dummy>:
9d0012cc:	3c020000 	lui	v0,0x0
9d0012d0:	27bdffe8 	addiu	sp,sp,-24
9d0012d4:	24420000 	addiu	v0,v0,0
9d0012d8:	10400006 	beqz	v0,9d0012f4 <frame_dummy+0x28>
9d0012dc:	afbf0014 	sw	ra,20(sp)
9d0012e0:	3c04a000 	lui	a0,0xa000
9d0012e4:	3c05a000 	lui	a1,0xa000
9d0012e8:	24840008 	addiu	a0,a0,8
9d0012ec:	0c000000 	jal	90000000 <_imageExecutionJumpToFirstInFlash+0x8e000000>
9d0012f0:	24a50a08 	addiu	a1,a1,2568
9d0012f4:	3c04a000 	lui	a0,0xa000
9d0012f8:	8c820008 	lw	v0,8(a0)
9d0012fc:	10400007 	beqz	v0,9d00131c <frame_dummy+0x50>
9d001300:	3c190000 	lui	t9,0x0
9d001304:	27390000 	addiu	t9,t9,0
9d001308:	13200004 	beqz	t9,9d00131c <frame_dummy+0x50>
9d00130c:	8fbf0014 	lw	ra,20(sp)
9d001310:	24840008 	addiu	a0,a0,8
9d001314:	03200008 	jr	t9
9d001318:	27bd0018 	addiu	sp,sp,24
9d00131c:	8fbf0014 	lw	ra,20(sp)
9d001320:	03e00008 	jr	ra
9d001324:	27bd0018 	addiu	sp,sp,24

9d001328 <setup>:
9d001328:	27bdffd8 	addiu	sp,sp,-40
9d00132c:	27848060 	addiu	a0,gp,-32672
9d001330:	24052580 	li	a1,9600
9d001334:	afbf0024 	sw	ra,36(sp)
9d001338:	afb30020 	sw	s3,32(sp)
9d00133c:	afb2001c 	sw	s2,28(sp)
9d001340:	afb10018 	sw	s1,24(sp)
9d001344:	0f40153c 	jal	9d0054f0 <_ZN9USBSerial5beginEm>
9d001348:	afb00014 	sw	s0,20(sp)
9d00134c:	0f401539 	jal	9d0054e4 <_ZN9USBSerialcviEv>
9d001350:	27848060 	addiu	a0,gp,-32672
9d001354:	1040fffd 	beqz	v0,9d00134c <setup+0x24>
9d001358:	00000000 	nop
9d00135c:	0f401207 	jal	9d00481c <delay>
9d001360:	240403e8 	li	a0,1000
9d001364:	3c059d00 	lui	a1,0x9d00
9d001368:	27848060 	addiu	a0,gp,-32672
9d00136c:	0f401305 	jal	9d004c14 <_ZN5Print5printEPKc>
9d001370:	24a57b20 	addiu	a1,a1,31520
9d001374:	2404001b 	li	a0,27
9d001378:	0f4010b3 	jal	9d0042cc <pinMode>
9d00137c:	24050001 	li	a1,1
9d001380:	2404001b 	li	a0,27
9d001384:	0f4010fb 	jal	9d0043ec <digitalWrite>
9d001388:	24050001 	li	a1,1
9d00138c:	2404001b 	li	a0,27
9d001390:	0f4010b3 	jal	9d0042cc <pinMode>
9d001394:	24050001 	li	a1,1
9d001398:	3c10a000 	lui	s0,0xa000
9d00139c:	2404001b 	li	a0,27
9d0013a0:	0f4010fb 	jal	9d0043ec <digitalWrite>
9d0013a4:	24050001 	li	a1,1
9d0013a8:	26040a20 	addiu	a0,s0,2592
9d0013ac:	24050001 	li	a1,1
9d0013b0:	0f400655 	jal	9d001954 <_ZN7Sd2Card4initEhh>
9d0013b4:	2406001b 	li	a2,27
9d0013b8:	1040005b 	beqz	v0,9d001528 <setup+0x200>
9d0013bc:	27848060 	addiu	a0,gp,-32672
9d0013c0:	3c059d00 	lui	a1,0x9d00
9d0013c4:	0f401380 	jal	9d004e00 <_ZN5Print7printlnEPKc>
9d0013c8:	24a57be0 	addiu	a1,a1,31712
9d0013cc:	3c059d00 	lui	a1,0x9d00
9d0013d0:	27848060 	addiu	a0,gp,-32672
9d0013d4:	0f401305 	jal	9d004c14 <_ZN5Print5printEPKc>
9d0013d8:	24a57c0c 	addiu	a1,a1,31756
9d0013dc:	26020a20 	addiu	v0,s0,2592
9d0013e0:	9042000c 	lbu	v0,12(v0)
9d0013e4:	24030002 	li	v1,2
9d0013e8:	10430073 	beq	v0,v1,9d0015b8 <setup+0x290>
9d0013ec:	24030003 	li	v1,3
9d0013f0:	1043007c 	beq	v0,v1,9d0015e4 <setup+0x2bc>
9d0013f4:	24030001 	li	v1,1
9d0013f8:	10430075 	beq	v0,v1,9d0015d0 <setup+0x2a8>
9d0013fc:	27848060 	addiu	a0,gp,-32672
9d001400:	3c059d00 	lui	a1,0x9d00
9d001404:	0f401380 	jal	9d004e00 <_ZN5Print7printlnEPKc>
9d001408:	24a57c2c 	addiu	a1,a1,31788
   * \return The value one, true, is returned for success and
   * the value zero, false, is returned for failure.  Reasons for
   * failure include not finding a valid partition, not finding a valid
   * FAT file system or an I/O error.
   */
  uint8_t init(Sd2Card* dev) { return init(dev, 1) ? true : init(dev, 0);}
9d00140c:	3c11a000 	lui	s1,0xa000
9d001410:	26240a38 	addiu	a0,s1,2616
9d001414:	26050a20 	addiu	a1,s0,2592
9d001418:	0f400df2 	jal	9d0037c8 <_ZN8SdVolume4initEP7Sd2Cardh>
9d00141c:	24060001 	li	a2,1
9d001420:	50400056 	beqzl	v0,9d00157c <setup+0x254>
9d001424:	3c05a000 	lui	a1,0xa000
9d001428:	3c059d00 	lui	a1,0x9d00
9d00142c:	26310a38 	addiu	s1,s1,2616
9d001430:	27848060 	addiu	a0,gp,-32672
9d001434:	0f401305 	jal	9d004c14 <_ZN5Print5printEPKc>
9d001438:	24a57c80 	addiu	a1,a1,31872
9d00143c:	92250020 	lbu	a1,32(s1)
9d001440:	2406000a 	li	a2,10
9d001444:	0f401375 	jal	9d004dd4 <_ZN5Print7printlnEhi>
9d001448:	27848060 	addiu	a0,gp,-32672
9d00144c:	0f401367 	jal	9d004d9c <_ZN5Print7printlnEv>
9d001450:	27848060 	addiu	a0,gp,-32672
9d001454:	8e22000c 	lw	v0,12(s1)
9d001458:	92330004 	lbu	s3,4(s1)
9d00145c:	3c059d00 	lui	a1,0x9d00
9d001460:	27848060 	addiu	a0,gp,-32672
9d001464:	72629802 	mul	s3,s3,v0
9d001468:	0f401305 	jal	9d004c14 <_ZN5Print5printEPKc>
9d00146c:	24a57c94 	addiu	a1,a1,31892
9d001470:	2406000a 	li	a2,10
9d001474:	27848060 	addiu	a0,gp,-32672
   */
  uint8_t open(SdFile& dirFile, uint16_t index, uint8_t oflag) {  // NOLINT
    return open(&dirFile, index, oflag);
  }
  /** \deprecated Use: uint8_t SdFile::openRoot(SdVolume* vol); */
  uint8_t openRoot(SdVolume& vol) {return openRoot(&vol);}  // NOLINT
9d001478:	3c10a000 	lui	s0,0xa000
9d00147c:	00139a40 	sll	s3,s3,0x9
9d001480:	0f40138c 	jal	9d004e30 <_ZN5Print7printlnEli>
9d001484:	02602821 	move	a1,s3
9d001488:	3c059d00 	lui	a1,0x9d00
9d00148c:	27848060 	addiu	a0,gp,-32672
9d001490:	0f401305 	jal	9d004c14 <_ZN5Print5printEPKc>
9d001494:	24a57cac 	addiu	a1,a1,31916
9d001498:	2a720000 	slti	s2,s3,0
9d00149c:	266203ff 	addiu	v0,s3,1023
9d0014a0:	0052980b 	movn	s3,v0,s2
9d0014a4:	00139283 	sra	s2,s3,0xa
9d0014a8:	2406000a 	li	a2,10
9d0014ac:	02402821 	move	a1,s2
9d0014b0:	0f40138c 	jal	9d004e30 <_ZN5Print7printlnEli>
9d0014b4:	27848060 	addiu	a0,gp,-32672
9d0014b8:	3c059d00 	lui	a1,0x9d00
9d0014bc:	27848060 	addiu	a0,gp,-32672
9d0014c0:	0f401305 	jal	9d004c14 <_ZN5Print5printEPKc>
9d0014c4:	24a57cc4 	addiu	a1,a1,31940
9d0014c8:	264203ff 	addiu	v0,s2,1023
9d0014cc:	2a430000 	slti	v1,s2,0
9d0014d0:	0043900b 	movn	s2,v0,v1
9d0014d4:	2406000a 	li	a2,10
9d0014d8:	00122a83 	sra	a1,s2,0xa
9d0014dc:	0f40138c 	jal	9d004e30 <_ZN5Print7printlnEli>
9d0014e0:	27848060 	addiu	a0,gp,-32672
9d0014e4:	3c059d00 	lui	a1,0x9d00
9d0014e8:	27848060 	addiu	a0,gp,-32672
9d0014ec:	0f401380 	jal	9d004e00 <_ZN5Print7printlnEPKc>
9d0014f0:	24a57cdc 	addiu	a1,a1,31964
9d0014f4:	26040a60 	addiu	a0,s0,2656
9d0014f8:	0f40081b 	jal	9d00206c <_ZN6SdFile8openRootEP8SdVolume>
9d0014fc:	02202821 	move	a1,s1
9d001500:	26040a60 	addiu	a0,s0,2656
9d001504:	8fbf0024 	lw	ra,36(sp)
9d001508:	8fb30020 	lw	s3,32(sp)
9d00150c:	8fb2001c 	lw	s2,28(sp)
9d001510:	8fb10018 	lw	s1,24(sp)
9d001514:	8fb00014 	lw	s0,20(sp)
9d001518:	24050007 	li	a1,7
9d00151c:	00003021 	move	a2,zero
9d001520:	0b400af8 	j	9d002be0 <_ZN6SdFile2lsEhh>
9d001524:	27bd0028 	addiu	sp,sp,40
9d001528:	3c059d00 	lui	a1,0x9d00
9d00152c:	0f401380 	jal	9d004e00 <_ZN5Print7printlnEPKc>
9d001530:	24a57b3c 	addiu	a1,a1,31548
9d001534:	3c059d00 	lui	a1,0x9d00
9d001538:	27848060 	addiu	a0,gp,-32672
9d00153c:	0f401380 	jal	9d004e00 <_ZN5Print7printlnEPKc>
9d001540:	24a57b64 	addiu	a1,a1,31588
9d001544:	3c059d00 	lui	a1,0x9d00
9d001548:	27848060 	addiu	a0,gp,-32672
9d00154c:	0f401380 	jal	9d004e00 <_ZN5Print7printlnEPKc>
9d001550:	24a57b80 	addiu	a1,a1,31616
9d001554:	3c059d00 	lui	a1,0x9d00
9d001558:	8fbf0024 	lw	ra,36(sp)
9d00155c:	8fb30020 	lw	s3,32(sp)
9d001560:	8fb2001c 	lw	s2,28(sp)
9d001564:	8fb10018 	lw	s1,24(sp)
9d001568:	8fb00014 	lw	s0,20(sp)
9d00156c:	27848060 	addiu	a0,gp,-32672
9d001570:	24a57b9c 	addiu	a1,a1,31644
9d001574:	0b401380 	j	9d004e00 <_ZN5Print7printlnEPKc>
9d001578:	27bd0028 	addiu	sp,sp,40
   * \return The value one, true, is returned for success and
   * the value zero, false, is returned for failure.  Reasons for
   * failure include not finding a valid partition, not finding a valid
   * FAT file system or an I/O error.
   */
  uint8_t init(Sd2Card* dev) { return init(dev, 1) ? true : init(dev, 0);}
9d00157c:	26240a38 	addiu	a0,s1,2616
9d001580:	24a50a20 	addiu	a1,a1,2592
9d001584:	0f400df2 	jal	9d0037c8 <_ZN8SdVolume4initEP7Sd2Cardh>
9d001588:	00003021 	move	a2,zero
9d00158c:	1440ffa6 	bnez	v0,9d001428 <setup+0x100>
9d001590:	8fbf0024 	lw	ra,36(sp)
9d001594:	3c059d00 	lui	a1,0x9d00
9d001598:	8fb30020 	lw	s3,32(sp)
9d00159c:	8fb2001c 	lw	s2,28(sp)
9d0015a0:	8fb10018 	lw	s1,24(sp)
9d0015a4:	8fb00014 	lw	s0,20(sp)
9d0015a8:	27848060 	addiu	a0,gp,-32672
9d0015ac:	24a57c34 	addiu	a1,a1,31796
9d0015b0:	0b401380 	j	9d004e00 <_ZN5Print7printlnEPKc>
9d0015b4:	27bd0028 	addiu	sp,sp,40
9d0015b8:	3c059d00 	lui	a1,0x9d00
9d0015bc:	27848060 	addiu	a0,gp,-32672
9d0015c0:	0f401380 	jal	9d004e00 <_ZN5Print7printlnEPKc>
9d0015c4:	24a57c20 	addiu	a1,a1,31776
9d0015c8:	0b400504 	j	9d001410 <setup+0xe8>
9d0015cc:	3c11a000 	lui	s1,0xa000
9d0015d0:	3c059d00 	lui	a1,0x9d00
9d0015d4:	0f401380 	jal	9d004e00 <_ZN5Print7printlnEPKc>
9d0015d8:	24a57c1c 	addiu	a1,a1,31772
9d0015dc:	0b400504 	j	9d001410 <setup+0xe8>
9d0015e0:	3c11a000 	lui	s1,0xa000
9d0015e4:	3c059d00 	lui	a1,0x9d00
9d0015e8:	27848060 	addiu	a0,gp,-32672
9d0015ec:	0f401380 	jal	9d004e00 <_ZN5Print7printlnEPKc>
9d0015f0:	24a57c24 	addiu	a1,a1,31780
9d0015f4:	0b400504 	j	9d001410 <setup+0xe8>
9d0015f8:	3c11a000 	lui	s1,0xa000

9d0015fc <loop>:
9d0015fc:	03e00008 	jr	ra
9d001600:	00000000 	nop

9d001604 <_GLOBAL__I_card>:
9d001604:	27bdffe0 	addiu	sp,sp,-32
9d001608:	afb00018 	sw	s0,24(sp)
#include <DSPI.h>
#include <WProgram.h>
class Sd2Card {
    public:
        /** Construct an instance of Sd2Card. */
        Sd2Card(void) : errorCode_(0), inBlock_(0), partialBlockRead_(0), type_(0), _cs(10), _spi(new DSPI0) {}
9d00160c:	3c10a000 	lui	s0,0xa000
9d001610:	26100a20 	addiu	s0,s0,2592
9d001614:	2404002c 	li	a0,44
9d001618:	2402000a 	li	v0,10
9d00161c:	afbf001c 	sw	ra,28(sp)
9d001620:	a2000005 	sb	zero,5(s0)
9d001624:	a2000006 	sb	zero,6(s0)
9d001628:	a200000a 	sb	zero,10(s0)
9d00162c:	a200000c 	sb	zero,12(s0)
9d001630:	0f401d17 	jal	9d00745c <_Znwm>
9d001634:	a2020010 	sb	v0,16(s0)
9d001638:	00402021 	move	a0,v0
9d00163c:	0f400fbc 	jal	9d003ef0 <_ZN5DSPI0C1Ev>
9d001640:	afa20010 	sw	v0,16(sp)
9d001644:	8fa20010 	lw	v0,16(sp)
 * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
 */
class SdVolume {
 public:
  /** Create an instance of SdVolume */
  SdVolume(void) :allocSearchStart_(2), fatType_(0) {}
9d001648:	3c04a000 	lui	a0,0xa000
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
9d00164c:	3c03a000 	lui	v1,0xa000
 * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
 */
class SdVolume {
 public:
  /** Create an instance of SdVolume */
  SdVolume(void) :allocSearchStart_(2), fatType_(0) {}
9d001650:	24860a38 	addiu	a2,a0,2616
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
9d001654:	24650a60 	addiu	a1,v1,2656
 * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
 */
class SdVolume {
 public:
  /** Create an instance of SdVolume */
  SdVolume(void) :allocSearchStart_(2), fatType_(0) {}
9d001658:	a0c00020 	sb	zero,32(a2)
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
9d00165c:	a0a00005 	sb	zero,5(a1)
9d001660:	ae020014 	sw	v0,20(s0)
9d001664:	8fbf001c 	lw	ra,28(sp)
 * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
 */
class SdVolume {
 public:
  /** Create an instance of SdVolume */
  SdVolume(void) :allocSearchStart_(2), fatType_(0) {}
9d001668:	24020002 	li	v0,2
9d00166c:	ac820a38 	sw	v0,2616(a0)
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
9d001670:	3c029d00 	lui	v0,0x9d00
9d001674:	24427d20 	addiu	v0,v0,32032
9d001678:	8fb00018 	lw	s0,24(sp)
9d00167c:	ac620a60 	sw	v0,2656(v1)
9d001680:	03e00008 	jr	ra
9d001684:	27bd0020 	addiu	sp,sp,32

9d001688 <_ZN7Sd2Card6spiRecEv>:
    extern void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, byte data);
}


/** Soft SPI receive */
uint8_t Sd2Card::spiRec(void) {
9d001688:	27bdffe8 	addiu	sp,sp,-24
9d00168c:	afb00010 	sw	s0,16(sp)
9d001690:	00808021 	move	s0,a0
    uint8_t data = 0;
    if (_spi) {
9d001694:	8c840014 	lw	a0,20(a0)
9d001698:	10800008 	beqz	a0,9d0016bc <_ZN7Sd2Card6spiRecEv+0x34>
9d00169c:	afbf0014 	sw	ra,20(sp)
        data = _spi->transfer(0xFF);
9d0016a0:	0f400ed9 	jal	9d003b64 <_ZN4DSPI8transferEm>
9d0016a4:	240500ff 	li	a1,255
        digitalWrite(_mosi, HIGH);
        digitalWrite(_miso, HIGH);
        data = shiftIn(_miso, _clk, MSBFIRST);
    }
    return data;
}
9d0016a8:	8fbf0014 	lw	ra,20(sp)
9d0016ac:	304200ff 	andi	v0,v0,0xff
9d0016b0:	8fb00010 	lw	s0,16(sp)
9d0016b4:	03e00008 	jr	ra
9d0016b8:	27bd0018 	addiu	sp,sp,24
    uint8_t data = 0;
    if (_spi) {
        data = _spi->transfer(0xFF);
    } else {
        // output pin high - like sending 0XFF
        digitalWrite(_mosi, HIGH);
9d0016bc:	9204000d 	lbu	a0,13(s0)
9d0016c0:	0f4010fb 	jal	9d0043ec <digitalWrite>
9d0016c4:	24050001 	li	a1,1
        digitalWrite(_miso, HIGH);
9d0016c8:	9204000e 	lbu	a0,14(s0)
9d0016cc:	0f4010fb 	jal	9d0043ec <digitalWrite>
9d0016d0:	24050001 	li	a1,1
        data = shiftIn(_miso, _clk, MSBFIRST);
9d0016d4:	9204000e 	lbu	a0,14(s0)
9d0016d8:	9205000f 	lbu	a1,15(s0)
    }
    return data;
}
9d0016dc:	8fbf0014 	lw	ra,20(sp)
9d0016e0:	8fb00010 	lw	s0,16(sp)
        data = _spi->transfer(0xFF);
    } else {
        // output pin high - like sending 0XFF
        digitalWrite(_mosi, HIGH);
        digitalWrite(_miso, HIGH);
        data = shiftIn(_miso, _clk, MSBFIRST);
9d0016e4:	24060001 	li	a2,1
9d0016e8:	0b40104f 	j	9d00413c <shiftIn>
9d0016ec:	27bd0018 	addiu	sp,sp,24

9d0016f0 <_ZN7Sd2Card7spiSendEh>:
    }
    return data;
}
//------------------------------------------------------------------------------
/** Soft SPI send */
void Sd2Card::spiSend(uint8_t data) {
9d0016f0:	27bdffe0 	addiu	sp,sp,-32
9d0016f4:	afb00018 	sw	s0,24(sp)
9d0016f8:	00808021 	move	s0,a0
    if (_spi) {
9d0016fc:	8c840014 	lw	a0,20(a0)
    }
    return data;
}
//------------------------------------------------------------------------------
/** Soft SPI send */
void Sd2Card::spiSend(uint8_t data) {
9d001700:	afbf001c 	sw	ra,28(sp)
    if (_spi) {
9d001704:	10800006 	beqz	a0,9d001720 <_ZN7Sd2Card7spiSendEh+0x30>
9d001708:	30a700ff 	andi	a3,a1,0xff
        _spi->transfer(data);
    } else {
        digitalWrite(_miso, HIGH);
        shiftOut(_mosi, _clk, MSBFIRST, data);
    }
}
9d00170c:	8fbf001c 	lw	ra,28(sp)
9d001710:	8fb00018 	lw	s0,24(sp)
}
//------------------------------------------------------------------------------
/** Soft SPI send */
void Sd2Card::spiSend(uint8_t data) {
    if (_spi) {
        _spi->transfer(data);
9d001714:	00e02821 	move	a1,a3
9d001718:	0b400ed9 	j	9d003b64 <_ZN4DSPI8transferEm>
9d00171c:	27bd0020 	addiu	sp,sp,32
    } else {
        digitalWrite(_miso, HIGH);
9d001720:	9204000e 	lbu	a0,14(s0)
9d001724:	24050001 	li	a1,1
9d001728:	0f4010fb 	jal	9d0043ec <digitalWrite>
9d00172c:	afa70010 	sw	a3,16(sp)
        shiftOut(_mosi, _clk, MSBFIRST, data);
9d001730:	9204000d 	lbu	a0,13(s0)
9d001734:	9205000f 	lbu	a1,15(s0)
9d001738:	8fa70010 	lw	a3,16(sp)
    }
}
9d00173c:	8fbf001c 	lw	ra,28(sp)
9d001740:	8fb00018 	lw	s0,24(sp)
void Sd2Card::spiSend(uint8_t data) {
    if (_spi) {
        _spi->transfer(data);
    } else {
        digitalWrite(_miso, HIGH);
        shiftOut(_mosi, _clk, MSBFIRST, data);
9d001744:	24060001 	li	a2,1
9d001748:	0b401087 	j	9d00421c <shiftOut>
9d00174c:	27bd0020 	addiu	sp,sp,32

9d001750 <_ZN7Sd2Card14chipSelectHighEv>:
  }
}

//------------------------------------------------------------------------------
void Sd2Card::chipSelectHigh(void) {
  digitalWrite(_cs, HIGH);
9d001750:	90840010 	lbu	a0,16(a0)
9d001754:	0b4010fb 	j	9d0043ec <digitalWrite>
9d001758:	24050001 	li	a1,1

9d00175c <_ZN7Sd2Card13chipSelectLowEv>:
}
//------------------------------------------------------------------------------
void Sd2Card::chipSelectLow(void) {
9d00175c:	27bdffe8 	addiu	sp,sp,-24
9d001760:	afbf0014 	sw	ra,20(sp)
9d001764:	afb00010 	sw	s0,16(sp)
9d001768:	00808021 	move	s0,a0
    digitalWrite(_cs, LOW);
9d00176c:	90840010 	lbu	a0,16(a0)
9d001770:	0f4010fb 	jal	9d0043ec <digitalWrite>
9d001774:	00002821 	move	a1,zero
  digitalWrite(chipSelectPin_, LOW);
9d001778:	92040004 	lbu	a0,4(s0)
}
9d00177c:	8fbf0014 	lw	ra,20(sp)
9d001780:	8fb00010 	lw	s0,16(sp)
  digitalWrite(_cs, HIGH);
}
//------------------------------------------------------------------------------
void Sd2Card::chipSelectLow(void) {
    digitalWrite(_cs, LOW);
  digitalWrite(chipSelectPin_, LOW);
9d001784:	00002821 	move	a1,zero
9d001788:	0b4010fb 	j	9d0043ec <digitalWrite>
9d00178c:	27bd0018 	addiu	sp,sp,24

9d001790 <_ZN7Sd2Card7readEndEv>:
  chipSelectHigh();
  return false;
}
//------------------------------------------------------------------------------
/** Skip remaining data in a block when in partial block read mode. */
void Sd2Card::readEnd(void) {
9d001790:	27bdffe8 	addiu	sp,sp,-24
9d001794:	afb00010 	sw	s0,16(sp)
9d001798:	afbf0014 	sw	ra,20(sp)
  if (inBlock_) {
9d00179c:	90820006 	lbu	v0,6(a0)
9d0017a0:	14400005 	bnez	v0,9d0017b8 <_ZN7Sd2Card7readEndEv+0x28>
9d0017a4:	00808021 	move	s0,a0
        spiRec();
    }
    chipSelectHigh();
    inBlock_ = 0;
  }
}
9d0017a8:	0b4005f7 	j	9d0017dc <_ZN7Sd2Card7readEndEv+0x4c>
9d0017ac:	8fbf0014 	lw	ra,20(sp)
/** Skip remaining data in a block when in partial block read mode. */
void Sd2Card::readEnd(void) {
  if (inBlock_) {
      // skip data and crc
    while (offset_++ < 514) {
        spiRec();
9d0017b0:	0f4005a2 	jal	9d001688 <_ZN7Sd2Card6spiRecEv>
9d0017b4:	02002021 	move	a0,s0
//------------------------------------------------------------------------------
/** Skip remaining data in a block when in partial block read mode. */
void Sd2Card::readEnd(void) {
  if (inBlock_) {
      // skip data and crc
    while (offset_++ < 514) {
9d0017b8:	96020008 	lhu	v0,8(s0)
9d0017bc:	24430001 	addiu	v1,v0,1
9d0017c0:	2c420202 	sltiu	v0,v0,514
9d0017c4:	1440fffa 	bnez	v0,9d0017b0 <_ZN7Sd2Card7readEndEv+0x20>
9d0017c8:	a6030008 	sh	v1,8(s0)
        spiRec();
    }
    chipSelectHigh();
9d0017cc:	0f4005d4 	jal	9d001750 <_ZN7Sd2Card14chipSelectHighEv>
9d0017d0:	02002021 	move	a0,s0
    inBlock_ = 0;
9d0017d4:	a2000006 	sb	zero,6(s0)
  }
}
9d0017d8:	8fbf0014 	lw	ra,20(sp)
9d0017dc:	8fb00010 	lw	s0,16(sp)
9d0017e0:	03e00008 	jr	ra
9d0017e4:	27bd0018 	addiu	sp,sp,24

9d0017e8 <_ZN7Sd2Card11waitNotBusyEt>:
  //  | (sckRateID & 2 ? (1 << SPR0) : 0);
  return true;
}
//------------------------------------------------------------------------------
// wait for card to go not busy
uint8_t Sd2Card::waitNotBusy(uint16_t timeoutMillis) {
9d0017e8:	27bdffd8 	addiu	sp,sp,-40
9d0017ec:	afb30020 	sw	s3,32(sp)
9d0017f0:	afb2001c 	sw	s2,28(sp)
9d0017f4:	afb10018 	sw	s1,24(sp)
9d0017f8:	afb00014 	sw	s0,20(sp)
9d0017fc:	afbf0024 	sw	ra,36(sp)
9d001800:	00808821 	move	s1,a0
  uint16_t t0 = millis();
9d001804:	0f401204 	jal	9d004810 <millis>
9d001808:	30b3ffff 	andi	s3,a1,0xffff
9d00180c:	3052ffff 	andi	s2,v0,0xffff
  do {
    if (spiRec() == 0XFF) return true;
9d001810:	0b40060d 	j	9d001834 <_ZN7Sd2Card11waitNotBusyEt+0x4c>
9d001814:	241000ff 	li	s0,255
  }
  while (((uint16_t)millis() - t0) < timeoutMillis);
9d001818:	0f401204 	jal	9d004810 <millis>
9d00181c:	00000000 	nop
}
//------------------------------------------------------------------------------
// wait for card to go not busy
uint8_t Sd2Card::waitNotBusy(uint16_t timeoutMillis) {
  uint16_t t0 = millis();
  do {
9d001820:	3042ffff 	andi	v0,v0,0xffff
9d001824:	00521023 	subu	v0,v0,s2
9d001828:	0053102a 	slt	v0,v0,s3
9d00182c:	10400006 	beqz	v0,9d001848 <_ZN7Sd2Card11waitNotBusyEt+0x60>
9d001830:	8fbf0024 	lw	ra,36(sp)
    if (spiRec() == 0XFF) return true;
9d001834:	0f4005a2 	jal	9d001688 <_ZN7Sd2Card6spiRecEv>
9d001838:	02202021 	move	a0,s1
9d00183c:	1450fff6 	bne	v0,s0,9d001818 <_ZN7Sd2Card11waitNotBusyEt+0x30>
9d001840:	24020001 	li	v0,1
  }
  while (((uint16_t)millis() - t0) < timeoutMillis);
  return false;
}
9d001844:	8fbf0024 	lw	ra,36(sp)
9d001848:	8fb30020 	lw	s3,32(sp)
9d00184c:	8fb2001c 	lw	s2,28(sp)
9d001850:	8fb10018 	lw	s1,24(sp)
9d001854:	8fb00014 	lw	s0,20(sp)
9d001858:	03e00008 	jr	ra
9d00185c:	27bd0028 	addiu	sp,sp,40

9d001860 <_ZN7Sd2Card11cardCommandEhm>:
        shiftOut(_mosi, _clk, MSBFIRST, data);
    }
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg) {
9d001860:	27bdffd8 	addiu	sp,sp,-40
9d001864:	afb00010 	sw	s0,16(sp)
9d001868:	00808021 	move	s0,a0
9d00186c:	afbf0024 	sw	ra,36(sp)
9d001870:	afb40020 	sw	s4,32(sp)
9d001874:	afb3001c 	sw	s3,28(sp)
9d001878:	afb20018 	sw	s2,24(sp)
9d00187c:	afb10014 	sw	s1,20(sp)
9d001880:	30b200ff 	andi	s2,a1,0xff
  // end read if in partialBlockRead mode
  readEnd();
9d001884:	0f4005e4 	jal	9d001790 <_ZN7Sd2Card7readEndEv>
9d001888:	00c08821 	move	s1,a2

  // select card
  chipSelectLow();
9d00188c:	0f4005d7 	jal	9d00175c <_ZN7Sd2Card13chipSelectLowEv>
9d001890:	02002021 	move	a0,s0

  // wait up to 300 ms if busy
  waitNotBusy(300);
9d001894:	02002021 	move	a0,s0
9d001898:	0f4005fa 	jal	9d0017e8 <_ZN7Sd2Card11waitNotBusyEt>
9d00189c:	2405012c 	li	a1,300

  // send command
  spiSend(cmd | 0x40);
9d0018a0:	02002021 	move	a0,s0
9d0018a4:	0f4005bc 	jal	9d0016f0 <_ZN7Sd2Card7spiSendEh>
9d0018a8:	36450040 	ori	a1,s2,0x40
9d0018ac:	24140018 	li	s4,24

  // send argument
  for (int8_t s = 24; s >= 0; s -= 8) spiSend(arg >> s);
9d0018b0:	2413fff8 	li	s3,-8
9d0018b4:	02912806 	srlv	a1,s1,s4
9d0018b8:	02002021 	move	a0,s0
9d0018bc:	2694fff8 	addiu	s4,s4,-8
9d0018c0:	0f4005bc 	jal	9d0016f0 <_ZN7Sd2Card7spiSendEh>
9d0018c4:	30a500ff 	andi	a1,a1,0xff
9d0018c8:	1693fffb 	bne	s4,s3,9d0018b8 <_ZN7Sd2Card11cardCommandEhm+0x58>
9d0018cc:	02912806 	srlv	a1,s1,s4

  // send CRC
  uint8_t crc = 0XFF;
  if (cmd == CMD0) crc = 0X95;  // correct crc for CMD0 with arg 0
9d0018d0:	12400005 	beqz	s2,9d0018e8 <_ZN7Sd2Card11cardCommandEhm+0x88>
9d0018d4:	24050095 	li	a1,149
  if (cmd == CMD8) crc = 0X87;  // correct crc for CMD8 with arg 0X1AA
9d0018d8:	240500ff 	li	a1,255
9d0018dc:	3a520008 	xori	s2,s2,0x8
9d0018e0:	24020087 	li	v0,135
9d0018e4:	0052280a 	movz	a1,v0,s2
  spiSend(crc);
9d0018e8:	0f4005bc 	jal	9d0016f0 <_ZN7Sd2Card7spiSendEh>
9d0018ec:	02002021 	move	a0,s0

  // wait for response
  for (uint8_t i = 0; ((status_ = spiRec()) & 0X80) && i != 0XFF; i++);
9d0018f0:	00008821 	move	s1,zero
9d0018f4:	0f4005a2 	jal	9d001688 <_ZN7Sd2Card6spiRecEv>
9d0018f8:	02002021 	move	a0,s0
9d0018fc:	7c021c20 	seb	v1,v0
9d001900:	04600009 	bltz	v1,9d001928 <_ZN7Sd2Card11cardCommandEhm+0xc8>
9d001904:	a202000b 	sb	v0,11(s0)
  return status_;
}
9d001908:	8fbf0024 	lw	ra,36(sp)
9d00190c:	8fb40020 	lw	s4,32(sp)
9d001910:	8fb3001c 	lw	s3,28(sp)
9d001914:	8fb20018 	lw	s2,24(sp)
9d001918:	8fb10014 	lw	s1,20(sp)
9d00191c:	8fb00010 	lw	s0,16(sp)
9d001920:	03e00008 	jr	ra
9d001924:	27bd0028 	addiu	sp,sp,40
  if (cmd == CMD0) crc = 0X95;  // correct crc for CMD0 with arg 0
  if (cmd == CMD8) crc = 0X87;  // correct crc for CMD8 with arg 0X1AA
  spiSend(crc);

  // wait for response
  for (uint8_t i = 0; ((status_ = spiRec()) & 0X80) && i != 0XFF; i++);
9d001928:	2631ffff 	addiu	s1,s1,-1
9d00192c:	323100ff 	andi	s1,s1,0xff
9d001930:	1620fff0 	bnez	s1,9d0018f4 <_ZN7Sd2Card11cardCommandEhm+0x94>
9d001934:	8fbf0024 	lw	ra,36(sp)
  return status_;
}
9d001938:	8fb40020 	lw	s4,32(sp)
9d00193c:	8fb3001c 	lw	s3,28(sp)
9d001940:	8fb20018 	lw	s2,24(sp)
9d001944:	8fb10014 	lw	s1,20(sp)
9d001948:	8fb00010 	lw	s0,16(sp)
9d00194c:	03e00008 	jr	ra
9d001950:	27bd0028 	addiu	sp,sp,40

9d001954 <_ZN7Sd2Card4initEhh>:
 *
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.  The reason for failure
 * can be determined by calling errorCode() and errorData().
 */
uint8_t Sd2Card::init(uint8_t sckRateID, uint8_t chipSelectPin) {
9d001954:	27bdffd0 	addiu	sp,sp,-48
9d001958:	afb00018 	sw	s0,24(sp)
9d00195c:	00808021 	move	s0,a0
    _cs = chipSelectPin;

    if (_spi) {
9d001960:	8c840014 	lw	a0,20(a0)
 *
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.  The reason for failure
 * can be determined by calling errorCode() and errorData().
 */
uint8_t Sd2Card::init(uint8_t sckRateID, uint8_t chipSelectPin) {
9d001964:	afbf002c 	sw	ra,44(sp)
9d001968:	afb40028 	sw	s4,40(sp)
9d00196c:	afb30024 	sw	s3,36(sp)
9d001970:	afb20020 	sw	s2,32(sp)
9d001974:	afb1001c 	sw	s1,28(sp)
    _cs = chipSelectPin;

    if (_spi) {
9d001978:	10800064 	beqz	a0,9d001b0c <_ZN7Sd2Card4initEhh+0x1b8>
9d00197c:	a2060010 	sb	a2,16(s0)
        _spi->begin();
9d001980:	0f400ed7 	jal	9d003b5c <_ZN4DSPI5beginEv>
9d001984:	00000000 	nop
	_spi->setSpeed(125000UL);
9d001988:	8e040014 	lw	a0,20(s0)
9d00198c:	3c050001 	lui	a1,0x1
9d001990:	0f400e78 	jal	9d0039e0 <_ZN4DSPI8setSpeedEm>
9d001994:	34a5e848 	ori	a1,a1,0xe848
        pinMode(_mosi, OUTPUT);
        pinMode(_miso, INPUT);
        pinMode(_clk, OUTPUT);
    }
    
    pinMode(_cs, OUTPUT);
9d001998:	92040010 	lbu	a0,16(s0)
9d00199c:	24050001 	li	a1,1
9d0019a0:	0f4010b3 	jal	9d0042cc <pinMode>
9d0019a4:	00009821 	move	s3,zero
    digitalWrite(_cs, HIGH);
9d0019a8:	92040010 	lbu	a0,16(s0)
9d0019ac:	24050001 	li	a1,1
9d0019b0:	0f4010fb 	jal	9d0043ec <digitalWrite>
9d0019b4:	2412000a 	li	s2,10

    errorCode_ = inBlock_ = partialBlockRead_ = type_ = 0;
9d0019b8:	a200000c 	sb	zero,12(s0)
9d0019bc:	a200000a 	sb	zero,10(s0)
9d0019c0:	a2000006 	sb	zero,6(s0)

    // 16-bit init start time allows over a minute
    uint16_t t0 = (uint16_t)millis();
9d0019c4:	0f401204 	jal	9d004810 <millis>
9d0019c8:	a2000005 	sb	zero,5(s0)
    uint32_t arg;

    chipSelectHigh();
9d0019cc:	02002021 	move	a0,s0
9d0019d0:	0f4005d4 	jal	9d001750 <_ZN7Sd2Card14chipSelectHighEv>
9d0019d4:	3051ffff 	andi	s1,v0,0xffff

    // must supply min of 74 clock cycles with CS high.
    for (uint8_t i = 0; i < 10; i++) spiSend(0XFF);
9d0019d8:	26730001 	addiu	s3,s3,1
9d0019dc:	02002021 	move	a0,s0
9d0019e0:	240500ff 	li	a1,255
9d0019e4:	0f4005bc 	jal	9d0016f0 <_ZN7Sd2Card7spiSendEh>
9d0019e8:	327300ff 	andi	s3,s3,0xff
9d0019ec:	5672fffb 	bnel	s3,s2,9d0019dc <_ZN7Sd2Card4initEhh+0x88>
9d0019f0:	26730001 	addiu	s3,s3,1

    chipSelectLow();
9d0019f4:	0f4005d7 	jal	9d00175c <_ZN7Sd2Card13chipSelectLowEv>
9d0019f8:	02002021 	move	a0,s0

    // command to go idle in SPI mode
    while ((status_ = cardCommand(CMD0, 0)) != R1_IDLE_STATE) {
9d0019fc:	24120001 	li	s2,1
9d001a00:	02002021 	move	a0,s0
9d001a04:	00002821 	move	a1,zero
9d001a08:	0f400618 	jal	9d001860 <_ZN7Sd2Card11cardCommandEhm>
9d001a0c:	00003021 	move	a2,zero
9d001a10:	10520015 	beq	v0,s2,9d001a68 <_ZN7Sd2Card4initEhh+0x114>
9d001a14:	a202000b 	sb	v0,11(s0)
        if (((uint16_t)millis() - t0) > SD_INIT_TIMEOUT) {
9d001a18:	0f401204 	jal	9d004810 <millis>
9d001a1c:	00000000 	nop
9d001a20:	3042ffff 	andi	v0,v0,0xffff
9d001a24:	00511023 	subu	v0,v0,s1
9d001a28:	284207d1 	slti	v0,v0,2001
9d001a2c:	1440fff5 	bnez	v0,9d001a04 <_ZN7Sd2Card4initEhh+0xb0>
9d001a30:	02002021 	move	a0,s0
        uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
            cardCommand(CMD55, 0);
            return cardCommand(cmd, arg);
        }
        uint8_t cardCommand(uint8_t cmd, uint32_t arg);
        void error(uint8_t code) {errorCode_ = code;}
9d001a34:	24020001 	li	v0,1
9d001a38:	a2020005 	sb	v0,5(s0)
   	 setSckRate(sckRateID);
    }
    return true;

fail:
    chipSelectHigh();
9d001a3c:	0f4005d4 	jal	9d001750 <_ZN7Sd2Card14chipSelectHighEv>
9d001a40:	02002021 	move	a0,s0
    return false;
9d001a44:	00001021 	move	v0,zero
}
9d001a48:	8fbf002c 	lw	ra,44(sp)
9d001a4c:	8fb40028 	lw	s4,40(sp)
9d001a50:	8fb30024 	lw	s3,36(sp)
9d001a54:	8fb20020 	lw	s2,32(sp)
9d001a58:	8fb1001c 	lw	s1,28(sp)
9d001a5c:	8fb00018 	lw	s0,24(sp)
9d001a60:	03e00008 	jr	ra
9d001a64:	27bd0030 	addiu	sp,sp,48
            error(SD_CARD_ERROR_CMD0);
            goto fail;
        }
    }
    // check SD version
    if ((cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
9d001a68:	02002021 	move	a0,s0
9d001a6c:	24050008 	li	a1,8
9d001a70:	0f400618 	jal	9d001860 <_ZN7Sd2Card11cardCommandEhm>
9d001a74:	240601aa 	li	a2,426
9d001a78:	30420004 	andi	v0,v0,0x4
9d001a7c:	0000a021 	move	s4,zero
9d001a80:	10400017 	beqz	v0,9d001ae0 <_ZN7Sd2Card4initEhh+0x18c>
9d001a84:	24130004 	li	s3,4
        uint8_t readRegister(uint8_t cmd, void* buf);
        uint8_t sendWriteCommand(uint32_t blockNumber, uint32_t eraseCount);
        void chipSelectHigh(void);
        void chipSelectLow(void);
        void type(uint8_t value) {type_ = value;}
9d001a88:	a212000c 	sb	s2,12(s0)
            goto fail;
        }
        type(SD_CARD_TYPE_SD2);
    }
    // initialize card and send host supports SDHC if SD2
    arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
9d001a8c:	00009021 	move	s2,zero
        uint8_t _cs;
        DSPI *_spi;

        // private functions
        uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
            cardCommand(CMD55, 0);
9d001a90:	24050037 	li	a1,55
9d001a94:	00003021 	move	a2,zero
9d001a98:	0f400618 	jal	9d001860 <_ZN7Sd2Card11cardCommandEhm>
9d001a9c:	02002021 	move	a0,s0
            return cardCommand(cmd, arg);
9d001aa0:	02002021 	move	a0,s0
9d001aa4:	24050029 	li	a1,41
9d001aa8:	0f400618 	jal	9d001860 <_ZN7Sd2Card11cardCommandEhm>
9d001aac:	02403021 	move	a2,s2

    while ((status_ = cardAcmd(ACMD41, arg)) != R1_READY_STATE) {
9d001ab0:	10400021 	beqz	v0,9d001b38 <_ZN7Sd2Card4initEhh+0x1e4>
9d001ab4:	a202000b 	sb	v0,11(s0)
        // check for timeout
        if (((uint16_t)millis() - t0) > SD_INIT_TIMEOUT) {
9d001ab8:	0f401204 	jal	9d004810 <millis>
9d001abc:	00000000 	nop
9d001ac0:	3042ffff 	andi	v0,v0,0xffff
9d001ac4:	00511023 	subu	v0,v0,s1
9d001ac8:	284207d1 	slti	v0,v0,2001
9d001acc:	1440fff1 	bnez	v0,9d001a94 <_ZN7Sd2Card4initEhh+0x140>
9d001ad0:	24050037 	li	a1,55
        }
        uint8_t cardCommand(uint8_t cmd, uint32_t arg);
        void error(uint8_t code) {errorCode_ = code;}
9d001ad4:	24020008 	li	v0,8
            error(SD_CARD_ERROR_ACMD41);
            goto fail;
9d001ad8:	0b40068f 	j	9d001a3c <_ZN7Sd2Card4initEhh+0xe8>
9d001adc:	a2020005 	sb	v0,5(s0)
    // check SD version
    if ((cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
        type(SD_CARD_TYPE_SD1);
    } else {
        // only need last byte of r7 response
        for (uint8_t i = 0; i < 4; i++) status_ = spiRec();
9d001ae0:	02002021 	move	a0,s0
9d001ae4:	0f4005a2 	jal	9d001688 <_ZN7Sd2Card6spiRecEv>
9d001ae8:	26940001 	addiu	s4,s4,1
9d001aec:	329400ff 	andi	s4,s4,0xff
9d001af0:	1693fffb 	bne	s4,s3,9d001ae0 <_ZN7Sd2Card4initEhh+0x18c>
9d001af4:	a202000b 	sb	v0,11(s0)
        if (status_ != 0XAA) {
9d001af8:	240300aa 	li	v1,170
9d001afc:	1043001d 	beq	v0,v1,9d001b74 <_ZN7Sd2Card4initEhh+0x220>
9d001b00:	24020002 	li	v0,2
            error(SD_CARD_ERROR_CMD8);
            goto fail;
9d001b04:	0b40068f 	j	9d001a3c <_ZN7Sd2Card4initEhh+0xe8>
9d001b08:	a2020005 	sb	v0,5(s0)

    if (_spi) {
        _spi->begin();
	_spi->setSpeed(125000UL);
    } else {
        pinMode(_mosi, OUTPUT);
9d001b0c:	9204000d 	lbu	a0,13(s0)
9d001b10:	0f4010b3 	jal	9d0042cc <pinMode>
9d001b14:	24050001 	li	a1,1
        pinMode(_miso, INPUT);
9d001b18:	9204000e 	lbu	a0,14(s0)
9d001b1c:	0f4010b3 	jal	9d0042cc <pinMode>
9d001b20:	00002821 	move	a1,zero
        pinMode(_clk, OUTPUT);
9d001b24:	9204000f 	lbu	a0,15(s0)
9d001b28:	0f4010b3 	jal	9d0042cc <pinMode>
9d001b2c:	24050001 	li	a1,1
    }
    
    pinMode(_cs, OUTPUT);
9d001b30:	0b400667 	j	9d00199c <_ZN7Sd2Card4initEhh+0x48>
9d001b34:	92040010 	lbu	a0,16(s0)
            error(SD_CARD_ERROR_ACMD41);
            goto fail;
        }
    }
    // if SD2 read OCR register to check for SDHC card
    if (type() == SD_CARD_TYPE_SD2) {
9d001b38:	9203000c 	lbu	v1,12(s0)
9d001b3c:	24020002 	li	v0,2
9d001b40:	1062000f 	beq	v1,v0,9d001b80 <_ZN7Sd2Card4initEhh+0x22c>
9d001b44:	02002021 	move	a0,s0
        }
        if ((spiRec() & 0XC0) == 0XC0) type(SD_CARD_TYPE_SDHC);
        // discard rest of ocr - contains allowed voltage range
        for (uint8_t i = 0; i < 3; i++) spiRec();
    }
    chipSelectHigh();
9d001b48:	0f4005d4 	jal	9d001750 <_ZN7Sd2Card14chipSelectHighEv>
9d001b4c:	02002021 	move	a0,s0

    if (_spi) {
9d001b50:	8e040014 	lw	a0,20(s0)
9d001b54:	1080ffbc 	beqz	a0,9d001a48 <_ZN7Sd2Card4initEhh+0xf4>
9d001b58:	24020001 	li	v0,1
	_spi->setSpeed(10000000UL);
9d001b5c:	3c050098 	lui	a1,0x98
9d001b60:	34a59680 	ori	a1,a1,0x9680
9d001b64:	0f400e78 	jal	9d0039e0 <_ZN4DSPI8setSpeedEm>
9d001b68:	afa20010 	sw	v0,16(sp)
9d001b6c:	0b400692 	j	9d001a48 <_ZN7Sd2Card4initEhh+0xf4>
9d001b70:	8fa20010 	lw	v0,16(sp)
        uint8_t readRegister(uint8_t cmd, void* buf);
        uint8_t sendWriteCommand(uint32_t blockNumber, uint32_t eraseCount);
        void chipSelectHigh(void);
        void chipSelectLow(void);
        void type(uint8_t value) {type_ = value;}
9d001b74:	a202000c 	sb	v0,12(s0)
            goto fail;
        }
        type(SD_CARD_TYPE_SD2);
    }
    // initialize card and send host supports SDHC if SD2
    arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
9d001b78:	0b4006a4 	j	9d001a90 <_ZN7Sd2Card4initEhh+0x13c>
9d001b7c:	3c124000 	lui	s2,0x4000
            goto fail;
        }
    }
    // if SD2 read OCR register to check for SDHC card
    if (type() == SD_CARD_TYPE_SD2) {
        if (cardCommand(CMD58, 0)) {
9d001b80:	2405003a 	li	a1,58
9d001b84:	0f400618 	jal	9d001860 <_ZN7Sd2Card11cardCommandEhm>
9d001b88:	00003021 	move	a2,zero
9d001b8c:	10400003 	beqz	v0,9d001b9c <_ZN7Sd2Card4initEhh+0x248>
9d001b90:	24020006 	li	v0,6
            error(SD_CARD_ERROR_CMD58);
            goto fail;
9d001b94:	0b40068f 	j	9d001a3c <_ZN7Sd2Card4initEhh+0xe8>
9d001b98:	a2020005 	sb	v0,5(s0)
        }
        if ((spiRec() & 0XC0) == 0XC0) type(SD_CARD_TYPE_SDHC);
9d001b9c:	0f4005a2 	jal	9d001688 <_ZN7Sd2Card6spiRecEv>
9d001ba0:	02002021 	move	a0,s0
9d001ba4:	304200c0 	andi	v0,v0,0xc0
9d001ba8:	240300c0 	li	v1,192
9d001bac:	14430003 	bne	v0,v1,9d001bbc <_ZN7Sd2Card4initEhh+0x268>
9d001bb0:	00000000 	nop
9d001bb4:	24020003 	li	v0,3
9d001bb8:	a202000c 	sb	v0,12(s0)
        // discard rest of ocr - contains allowed voltage range
        for (uint8_t i = 0; i < 3; i++) spiRec();
9d001bbc:	0f4005a2 	jal	9d001688 <_ZN7Sd2Card6spiRecEv>
9d001bc0:	02002021 	move	a0,s0
9d001bc4:	0f4005a2 	jal	9d001688 <_ZN7Sd2Card6spiRecEv>
9d001bc8:	02002021 	move	a0,s0
9d001bcc:	0f4005a2 	jal	9d001688 <_ZN7Sd2Card6spiRecEv>
9d001bd0:	02002021 	move	a0,s0
9d001bd4:	0b4006d2 	j	9d001b48 <_ZN7Sd2Card4initEhh+0x1f4>
9d001bd8:	00000000 	nop

9d001bdc <_ZN7Sd2Card14waitStartBlockEv>:
  while (((uint16_t)millis() - t0) < timeoutMillis);
  return false;
}
//------------------------------------------------------------------------------
/** Wait for start block token */
uint8_t Sd2Card::waitStartBlock(void) {
9d001bdc:	27bdffe0 	addiu	sp,sp,-32
9d001be0:	afb20018 	sw	s2,24(sp)
9d001be4:	afb10014 	sw	s1,20(sp)
9d001be8:	afb00010 	sw	s0,16(sp)
9d001bec:	afbf001c 	sw	ra,28(sp)
  uint16_t t0 = millis();
9d001bf0:	0f401204 	jal	9d004810 <millis>
9d001bf4:	00808021 	move	s0,a0
9d001bf8:	3052ffff 	andi	s2,v0,0xffff
  while ((status_ = spiRec()) == 0XFF) {
9d001bfc:	0b400708 	j	9d001c20 <_ZN7Sd2Card14waitStartBlockEv+0x44>
9d001c00:	241100ff 	li	s1,255
    if (((uint16_t)millis() - t0) > SD_READ_TIMEOUT) {
9d001c04:	0f401204 	jal	9d004810 <millis>
9d001c08:	00000000 	nop
9d001c0c:	3042ffff 	andi	v0,v0,0xffff
9d001c10:	00521023 	subu	v0,v0,s2
9d001c14:	2842012d 	slti	v0,v0,301
9d001c18:	10400014 	beqz	v0,9d001c6c <_ZN7Sd2Card14waitStartBlockEv+0x90>
9d001c1c:	2402000f 	li	v0,15
}
//------------------------------------------------------------------------------
/** Wait for start block token */
uint8_t Sd2Card::waitStartBlock(void) {
  uint16_t t0 = millis();
  while ((status_ = spiRec()) == 0XFF) {
9d001c20:	0f4005a2 	jal	9d001688 <_ZN7Sd2Card6spiRecEv>
9d001c24:	02002021 	move	a0,s0
9d001c28:	1051fff6 	beq	v0,s1,9d001c04 <_ZN7Sd2Card14waitStartBlockEv+0x28>
9d001c2c:	a202000b 	sb	v0,11(s0)
    if (((uint16_t)millis() - t0) > SD_READ_TIMEOUT) {
      error(SD_CARD_ERROR_READ_TIMEOUT);
      goto fail;
    }
  }
  if (status_ != DATA_START_BLOCK) {
9d001c30:	240400fe 	li	a0,254
9d001c34:	10440006 	beq	v0,a0,9d001c50 <_ZN7Sd2Card14waitStartBlockEv+0x74>
9d001c38:	24030001 	li	v1,1
        uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
            cardCommand(CMD55, 0);
            return cardCommand(cmd, arg);
        }
        uint8_t cardCommand(uint8_t cmd, uint32_t arg);
        void error(uint8_t code) {errorCode_ = code;}
9d001c3c:	2402000d 	li	v0,13
9d001c40:	a2020005 	sb	v0,5(s0)
    goto fail;
  }
  return true;

 fail:
  chipSelectHigh();
9d001c44:	0f4005d4 	jal	9d001750 <_ZN7Sd2Card14chipSelectHighEv>
9d001c48:	02002021 	move	a0,s0
  return false;
9d001c4c:	00001821 	move	v1,zero
}
9d001c50:	8fbf001c 	lw	ra,28(sp)
9d001c54:	00601021 	move	v0,v1
9d001c58:	8fb20018 	lw	s2,24(sp)
9d001c5c:	8fb10014 	lw	s1,20(sp)
9d001c60:	8fb00010 	lw	s0,16(sp)
9d001c64:	03e00008 	jr	ra
9d001c68:	27bd0020 	addiu	sp,sp,32
uint8_t Sd2Card::waitStartBlock(void) {
  uint16_t t0 = millis();
  while ((status_ = spiRec()) == 0XFF) {
    if (((uint16_t)millis() - t0) > SD_READ_TIMEOUT) {
      error(SD_CARD_ERROR_READ_TIMEOUT);
      goto fail;
9d001c6c:	0b400711 	j	9d001c44 <_ZN7Sd2Card14waitStartBlockEv+0x68>
9d001c70:	a2020005 	sb	v0,5(s0)

9d001c74 <_ZN7Sd2Card8readDataEmttPh>:
 * \param[in] count Number of bytes to read
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::readData(uint32_t block,
        uint16_t offset, uint16_t count, uint8_t* dst) {
9d001c74:	27bdffd8 	addiu	sp,sp,-40
9d001c78:	afb00014 	sw	s0,20(sp)
9d001c7c:	30f0ffff 	andi	s0,a3,0xffff
9d001c80:	afb30020 	sw	s3,32(sp)
9d001c84:	afb2001c 	sw	s2,28(sp)
9d001c88:	afb10018 	sw	s1,24(sp)
9d001c8c:	afbf0024 	sw	ra,36(sp)
9d001c90:	00809821 	move	s3,a0
9d001c94:	00a01821 	move	v1,a1
9d001c98:	8fb20038 	lw	s2,56(sp)
9d001c9c:	30d1ffff 	andi	s1,a2,0xffff
  if (count == 0) return true;
9d001ca0:	1200001a 	beqz	s0,9d001d0c <_ZN7Sd2Card8readDataEmttPh+0x98>
9d001ca4:	24020001 	li	v0,1
  if ((count + offset) > 512) {
9d001ca8:	02111021 	addu	v0,s0,s1
9d001cac:	28420201 	slti	v0,v0,513
9d001cb0:	10400013 	beqz	v0,9d001d00 <_ZN7Sd2Card8readDataEmttPh+0x8c>
9d001cb4:	00000000 	nop
    goto fail;
  }
  if (!inBlock_ || block != block_ || offset < offset_) {
9d001cb8:	90820006 	lbu	v0,6(a0)
9d001cbc:	50400005 	beqzl	v0,9d001cd4 <_ZN7Sd2Card8readDataEmttPh+0x60>
9d001cc0:	9266000c 	lbu	a2,12(s3)
9d001cc4:	8c820000 	lw	v0,0(a0)
9d001cc8:	50450017 	beql	v0,a1,9d001d28 <_ZN7Sd2Card8readDataEmttPh+0xb4>
9d001ccc:	94820008 	lhu	v0,8(a0)
    block_ = block;
    // use address if not SDHC card
    if (type()!= SD_CARD_TYPE_SDHC) block <<= 9;
9d001cd0:	9266000c 	lbu	a2,12(s3)
9d001cd4:	00031240 	sll	v0,v1,0x9
  if (count == 0) return true;
  if ((count + offset) > 512) {
    goto fail;
  }
  if (!inBlock_ || block != block_ || offset < offset_) {
    block_ = block;
9d001cd8:	ae630000 	sw	v1,0(s3)
    // use address if not SDHC card
    if (type()!= SD_CARD_TYPE_SDHC) block <<= 9;
9d001cdc:	38c60003 	xori	a2,a2,0x3
    if (cardCommand(CMD17, block)) {
9d001ce0:	0046180b 	movn	v1,v0,a2
9d001ce4:	02602021 	move	a0,s3
9d001ce8:	24050011 	li	a1,17
9d001cec:	0f400618 	jal	9d001860 <_ZN7Sd2Card11cardCommandEhm>
9d001cf0:	00603021 	move	a2,v1
9d001cf4:	1040002d 	beqz	v0,9d001dac <_ZN7Sd2Card8readDataEmttPh+0x138>
9d001cf8:	24020003 	li	v0,3
9d001cfc:	a2620005 	sb	v0,5(s3)
  }

  return true;

 fail:
  chipSelectHigh();
9d001d00:	0f4005d4 	jal	9d001750 <_ZN7Sd2Card14chipSelectHighEv>
9d001d04:	02602021 	move	a0,s3
  return false;
9d001d08:	00001021 	move	v0,zero
}
9d001d0c:	8fbf0024 	lw	ra,36(sp)
9d001d10:	8fb30020 	lw	s3,32(sp)
9d001d14:	8fb2001c 	lw	s2,28(sp)
9d001d18:	8fb10018 	lw	s1,24(sp)
9d001d1c:	8fb00014 	lw	s0,20(sp)
9d001d20:	03e00008 	jr	ra
9d001d24:	27bd0028 	addiu	sp,sp,40
        uint16_t offset, uint16_t count, uint8_t* dst) {
  if (count == 0) return true;
  if ((count + offset) > 512) {
    goto fail;
  }
  if (!inBlock_ || block != block_ || offset < offset_) {
9d001d28:	0222202b 	sltu	a0,s1,v0
9d001d2c:	5480ffe9 	bnezl	a0,9d001cd4 <_ZN7Sd2Card8readDataEmttPh+0x60>
9d001d30:	9266000c 	lbu	a2,12(s3)
  }



  // skip data before offset
  for (;offset_ < offset; offset_++) {
9d001d34:	0051102b 	sltu	v0,v0,s1
9d001d38:	5040000a 	beqzl	v0,9d001d64 <_ZN7Sd2Card8readDataEmttPh+0xf0>
9d001d3c:	8e640014 	lw	a0,20(s3)
    spiRec();
9d001d40:	0f4005a2 	jal	9d001688 <_ZN7Sd2Card6spiRecEv>
9d001d44:	02602021 	move	a0,s3
  }



  // skip data before offset
  for (;offset_ < offset; offset_++) {
9d001d48:	96620008 	lhu	v0,8(s3)
9d001d4c:	24420001 	addiu	v0,v0,1
9d001d50:	3042ffff 	andi	v0,v0,0xffff
9d001d54:	0051182b 	sltu	v1,v0,s1
9d001d58:	1460fff9 	bnez	v1,9d001d40 <_ZN7Sd2Card8readDataEmttPh+0xcc>
9d001d5c:	a6620008 	sh	v0,8(s3)
    spiRec();
  }
  // transfer data
  if (_spi != NULL) {
9d001d60:	8e640014 	lw	a0,20(s3)
9d001d64:	10800019 	beqz	a0,9d001dcc <_ZN7Sd2Card8readDataEmttPh+0x158>
9d001d68:	02002821 	move	a1,s0
    _spi->transfer(count, 0xFF, dst);
9d001d6c:	240600ff 	li	a2,255
9d001d70:	0f400f10 	jal	9d003c40 <_ZN4DSPI8transferEthPh>
9d001d74:	02403821 	move	a3,s2
      for (uint16_t i = 0; i < count; i++) {
        dst[i] = spiRec();
      }
  }

  offset_ += count;
9d001d78:	96630008 	lhu	v1,8(s3)
  if (!partialBlockRead_ || offset_ >= 512) {
9d001d7c:	9262000a 	lbu	v0,10(s3)
      for (uint16_t i = 0; i < count; i++) {
        dst[i] = spiRec();
      }
  }

  offset_ += count;
9d001d80:	02038021 	addu	s0,s0,v1
9d001d84:	3210ffff 	andi	s0,s0,0xffff
  if (!partialBlockRead_ || offset_ >= 512) {
9d001d88:	10400004 	beqz	v0,9d001d9c <_ZN7Sd2Card8readDataEmttPh+0x128>
9d001d8c:	a6700008 	sh	s0,8(s3)
9d001d90:	2e100200 	sltiu	s0,s0,512
9d001d94:	1600ffdd 	bnez	s0,9d001d0c <_ZN7Sd2Card8readDataEmttPh+0x98>
9d001d98:	24020001 	li	v0,1
    // read rest of data, checksum and set chip select high
    readEnd();
9d001d9c:	0f4005e4 	jal	9d001790 <_ZN7Sd2Card7readEndEv>
9d001da0:	02602021 	move	a0,s3
  }

  return true;
9d001da4:	0b400743 	j	9d001d0c <_ZN7Sd2Card8readDataEmttPh+0x98>
9d001da8:	24020001 	li	v0,1
    if (type()!= SD_CARD_TYPE_SDHC) block <<= 9;
    if (cardCommand(CMD17, block)) {
      error(SD_CARD_ERROR_CMD17);
      goto fail;
    }
    if (!waitStartBlock()) {
9d001dac:	0f4006f7 	jal	9d001bdc <_ZN7Sd2Card14waitStartBlockEv>
9d001db0:	02602021 	move	a0,s3
9d001db4:	1040ffd2 	beqz	v0,9d001d00 <_ZN7Sd2Card8readDataEmttPh+0x8c>
9d001db8:	24020001 	li	v0,1
      goto fail;
    }
    offset_ = 0;
    inBlock_ = 1;
9d001dbc:	a2620006 	sb	v0,6(s3)
      goto fail;
    }
    if (!waitStartBlock()) {
      goto fail;
    }
    offset_ = 0;
9d001dc0:	a6600008 	sh	zero,8(s3)
    inBlock_ = 1;
9d001dc4:	0b40074d 	j	9d001d34 <_ZN7Sd2Card8readDataEmttPh+0xc0>
9d001dc8:	00001021 	move	v0,zero
  // skip data before offset
  for (;offset_ < offset; offset_++) {
    spiRec();
  }
  // transfer data
  if (_spi != NULL) {
9d001dcc:	00008821 	move	s1,zero
    _spi->transfer(count, 0xFF, dst);
  } else {
      for (uint16_t i = 0; i < count; i++) {
9d001dd0:	26310001 	addiu	s1,s1,1
        dst[i] = spiRec();
9d001dd4:	02602021 	move	a0,s3
9d001dd8:	0f4005a2 	jal	9d001688 <_ZN7Sd2Card6spiRecEv>
9d001ddc:	3231ffff 	andi	s1,s1,0xffff
  }
  // transfer data
  if (_spi != NULL) {
    _spi->transfer(count, 0xFF, dst);
  } else {
      for (uint16_t i = 0; i < count; i++) {
9d001de0:	0230182b 	sltu	v1,s1,s0
        dst[i] = spiRec();
9d001de4:	a2420000 	sb	v0,0(s2)
  }
  // transfer data
  if (_spi != NULL) {
    _spi->transfer(count, 0xFF, dst);
  } else {
      for (uint16_t i = 0; i < count; i++) {
9d001de8:	1460fff9 	bnez	v1,9d001dd0 <_ZN7Sd2Card8readDataEmttPh+0x15c>
9d001dec:	26520001 	addiu	s2,s2,1
        dst[i] = spiRec();
      }
  }

  offset_ += count;
9d001df0:	0b40075f 	j	9d001d7c <_ZN7Sd2Card8readDataEmttPh+0x108>
9d001df4:	96630008 	lhu	v1,8(s3)

9d001df8 <_ZN7Sd2Card9readBlockEmPh>:
 * \param[out] dst Pointer to the location that will receive the data.

 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::readBlock(uint32_t block, uint8_t* dst) {
9d001df8:	27bdffe0 	addiu	sp,sp,-32
  return readData(block, 0, 512, dst);
9d001dfc:	afa60010 	sw	a2,16(sp)
9d001e00:	24070200 	li	a3,512
 * \param[out] dst Pointer to the location that will receive the data.

 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::readBlock(uint32_t block, uint8_t* dst) {
9d001e04:	afbf001c 	sw	ra,28(sp)
  return readData(block, 0, 512, dst);
9d001e08:	0f40071d 	jal	9d001c74 <_ZN7Sd2Card8readDataEmttPh>
9d001e0c:	00003021 	move	a2,zero
}
9d001e10:	8fbf001c 	lw	ra,28(sp)
9d001e14:	03e00008 	jr	ra
9d001e18:	27bd0020 	addiu	sp,sp,32

9d001e1c <_ZN7Sd2Card9writeDataEhPKh>:
  }
  return writeData(WRITE_MULTIPLE_TOKEN, src);
}
//------------------------------------------------------------------------------
// send one block of data for write block or write multiple blocks
uint8_t Sd2Card::writeData(uint8_t token, const uint8_t* src) {
9d001e1c:	27bdffd8 	addiu	sp,sp,-40
9d001e20:	afb00018 	sw	s0,24(sp)

    spiSend(token);
9d001e24:	30a500ff 	andi	a1,a1,0xff
  }
  return writeData(WRITE_MULTIPLE_TOKEN, src);
}
//------------------------------------------------------------------------------
// send one block of data for write block or write multiple blocks
uint8_t Sd2Card::writeData(uint8_t token, const uint8_t* src) {
9d001e28:	00808021 	move	s0,a0

    spiSend(token);
9d001e2c:	afa60010 	sw	a2,16(sp)
  }
  return writeData(WRITE_MULTIPLE_TOKEN, src);
}
//------------------------------------------------------------------------------
// send one block of data for write block or write multiple blocks
uint8_t Sd2Card::writeData(uint8_t token, const uint8_t* src) {
9d001e30:	afbf0024 	sw	ra,36(sp)
9d001e34:	afb20020 	sw	s2,32(sp)

    spiSend(token);
9d001e38:	0f4005bc 	jal	9d0016f0 <_ZN7Sd2Card7spiSendEh>
9d001e3c:	afb1001c 	sw	s1,28(sp)
    if (_spi != NULL) {
9d001e40:	8e040014 	lw	a0,20(s0)
9d001e44:	1080001b 	beqz	a0,9d001eb4 <_ZN7Sd2Card9writeDataEhPKh+0x98>
9d001e48:	8fa60010 	lw	a2,16(sp)
        _spi->transfer(512, (uint8_t *)src);
9d001e4c:	0f400ee6 	jal	9d003b98 <_ZN4DSPI8transferEtPh>
9d001e50:	24050200 	li	a1,512
        for (uint16_t i = 0; i < 512; i++) {
            spiSend(src[i]);
        }
    }

    spiSend(0xff);  // dummy crc
9d001e54:	240500ff 	li	a1,255
9d001e58:	0f4005bc 	jal	9d0016f0 <_ZN7Sd2Card7spiSendEh>
9d001e5c:	02002021 	move	a0,s0
    spiSend(0xff);  // dummy crc
9d001e60:	02002021 	move	a0,s0
9d001e64:	0f4005bc 	jal	9d0016f0 <_ZN7Sd2Card7spiSendEh>
9d001e68:	240500ff 	li	a1,255

    status_ = spiRec();
9d001e6c:	0f4005a2 	jal	9d001688 <_ZN7Sd2Card6spiRecEv>
9d001e70:	02002021 	move	a0,s0
    if ((status_ & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
9d001e74:	3044001f 	andi	a0,v0,0x1f
9d001e78:	24030005 	li	v1,5
    }

    spiSend(0xff);  // dummy crc
    spiSend(0xff);  // dummy crc

    status_ = spiRec();
9d001e7c:	a202000b 	sb	v0,11(s0)
    if ((status_ & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
9d001e80:	10830006 	beq	a0,v1,9d001e9c <_ZN7Sd2Card9writeDataEhPKh+0x80>
9d001e84:	24020001 	li	v0,1
9d001e88:	24020011 	li	v0,17
9d001e8c:	a2020005 	sb	v0,5(s0)
        error(SD_CARD_ERROR_WRITE);
        chipSelectHigh();
9d001e90:	0f4005d4 	jal	9d001750 <_ZN7Sd2Card14chipSelectHighEv>
9d001e94:	02002021 	move	a0,s0
        return false;
9d001e98:	00001021 	move	v0,zero
    }
    return true;
}
9d001e9c:	8fbf0024 	lw	ra,36(sp)
9d001ea0:	8fb20020 	lw	s2,32(sp)
9d001ea4:	8fb1001c 	lw	s1,28(sp)
9d001ea8:	8fb00018 	lw	s0,24(sp)
9d001eac:	03e00008 	jr	ra
9d001eb0:	27bd0028 	addiu	sp,sp,40
// send one block of data for write block or write multiple blocks
uint8_t Sd2Card::writeData(uint8_t token, const uint8_t* src) {

    spiSend(token);
    if (_spi != NULL) {
        _spi->transfer(512, (uint8_t *)src);
9d001eb4:	00c09021 	move	s2,a2
  }
  return writeData(WRITE_MULTIPLE_TOKEN, src);
}
//------------------------------------------------------------------------------
// send one block of data for write block or write multiple blocks
uint8_t Sd2Card::writeData(uint8_t token, const uint8_t* src) {
9d001eb8:	24d10200 	addiu	s1,a2,512
    spiSend(token);
    if (_spi != NULL) {
        _spi->transfer(512, (uint8_t *)src);
    } else {
        for (uint16_t i = 0; i < 512; i++) {
            spiSend(src[i]);
9d001ebc:	92450000 	lbu	a1,0(s2)
9d001ec0:	02002021 	move	a0,s0
9d001ec4:	0f4005bc 	jal	9d0016f0 <_ZN7Sd2Card7spiSendEh>
9d001ec8:	26520001 	addiu	s2,s2,1

    spiSend(token);
    if (_spi != NULL) {
        _spi->transfer(512, (uint8_t *)src);
    } else {
        for (uint16_t i = 0; i < 512; i++) {
9d001ecc:	5651fffc 	bnel	s2,s1,9d001ec0 <_ZN7Sd2Card9writeDataEhPKh+0xa4>
9d001ed0:	92450000 	lbu	a1,0(s2)
            spiSend(src[i]);
        }
    }

    spiSend(0xff);  // dummy crc
9d001ed4:	0b400796 	j	9d001e58 <_ZN7Sd2Card9writeDataEhPKh+0x3c>
9d001ed8:	240500ff 	li	a1,255

9d001edc <_ZN7Sd2Card10writeBlockEmPKh>:
 * \param[in] blockNumber Logical block to be written.
 * \param[in] src Pointer to the location of the data to be written.
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t* src) {
9d001edc:	27bdffe0 	addiu	sp,sp,-32
9d001ee0:	afb10018 	sw	s1,24(sp)
9d001ee4:	afb00014 	sw	s0,20(sp)
9d001ee8:	afbf001c 	sw	ra,28(sp)
9d001eec:	00a01021 	move	v0,a1
9d001ef0:	00808021 	move	s0,a0
#if SD_PROTECT_BLOCK_ZERO
  // don't allow write to first block
  if (blockNumber == 0) {
9d001ef4:	14a0000b 	bnez	a1,9d001f24 <_ZN7Sd2Card10writeBlockEmPKh+0x48>
9d001ef8:	00c08821 	move	s1,a2
9d001efc:	24020012 	li	v0,18
9d001f00:	a0820005 	sb	v0,5(a0)
  }
  chipSelectHigh();
  return true;

 fail:
  chipSelectHigh();
9d001f04:	0f4005d4 	jal	9d001750 <_ZN7Sd2Card14chipSelectHighEv>
9d001f08:	02002021 	move	a0,s0
  return false;
9d001f0c:	00001021 	move	v0,zero
}
9d001f10:	8fbf001c 	lw	ra,28(sp)
9d001f14:	8fb10018 	lw	s1,24(sp)
9d001f18:	8fb00014 	lw	s0,20(sp)
9d001f1c:	03e00008 	jr	ra
9d001f20:	27bd0020 	addiu	sp,sp,32
    error(SD_CARD_ERROR_WRITE_BLOCK_ZERO);
    goto fail;
  }
#endif  // SD_PROTECT_BLOCK_ZERO
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
9d001f24:	9086000c 	lbu	a2,12(a0)
9d001f28:	00051a40 	sll	v1,a1,0x9
  if (cardCommand(CMD24, blockNumber)) {
9d001f2c:	24050018 	li	a1,24
    error(SD_CARD_ERROR_WRITE_BLOCK_ZERO);
    goto fail;
  }
#endif  // SD_PROTECT_BLOCK_ZERO
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
9d001f30:	38c60003 	xori	a2,a2,0x3
  if (cardCommand(CMD24, blockNumber)) {
9d001f34:	0066100b 	movn	v0,v1,a2
9d001f38:	0f400618 	jal	9d001860 <_ZN7Sd2Card11cardCommandEhm>
9d001f3c:	00403021 	move	a2,v0
9d001f40:	10400003 	beqz	v0,9d001f50 <_ZN7Sd2Card10writeBlockEmPKh+0x74>
9d001f44:	24020004 	li	v0,4
    error(SD_CARD_ERROR_CMD24);
    goto fail;
9d001f48:	0b4007c1 	j	9d001f04 <_ZN7Sd2Card10writeBlockEmPKh+0x28>
9d001f4c:	a2020005 	sb	v0,5(s0)
  }
  if (!writeData(DATA_START_BLOCK, src)) goto fail;
9d001f50:	02002021 	move	a0,s0
9d001f54:	240500fe 	li	a1,254
9d001f58:	0f400787 	jal	9d001e1c <_ZN7Sd2Card9writeDataEhPKh>
9d001f5c:	02203021 	move	a2,s1
9d001f60:	1040ffe8 	beqz	v0,9d001f04 <_ZN7Sd2Card10writeBlockEmPKh+0x28>
9d001f64:	02002021 	move	a0,s0

  // wait for flash programming to complete
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
9d001f68:	0f4005fa 	jal	9d0017e8 <_ZN7Sd2Card11waitNotBusyEt>
9d001f6c:	24050258 	li	a1,600
9d001f70:	14400003 	bnez	v0,9d001f80 <_ZN7Sd2Card10writeBlockEmPKh+0xa4>
9d001f74:	24020015 	li	v0,21
    error(SD_CARD_ERROR_WRITE_TIMEOUT);
    goto fail;
9d001f78:	0b4007c1 	j	9d001f04 <_ZN7Sd2Card10writeBlockEmPKh+0x28>
9d001f7c:	a2020005 	sb	v0,5(s0)
  }

  // response is r2 so get and check two bytes for nonzero
  if (cardCommand(CMD13, 0) || spiRec()) {
9d001f80:	02002021 	move	a0,s0
9d001f84:	2405000d 	li	a1,13
9d001f88:	0f400618 	jal	9d001860 <_ZN7Sd2Card11cardCommandEhm>
9d001f8c:	00003021 	move	a2,zero
9d001f90:	10400003 	beqz	v0,9d001fa0 <_ZN7Sd2Card10writeBlockEmPKh+0xc4>
9d001f94:	24020014 	li	v0,20
    error(SD_CARD_ERROR_WRITE_PROGRAMMING);
    goto fail;
9d001f98:	0b4007c1 	j	9d001f04 <_ZN7Sd2Card10writeBlockEmPKh+0x28>
9d001f9c:	a2020005 	sb	v0,5(s0)
    error(SD_CARD_ERROR_WRITE_TIMEOUT);
    goto fail;
  }

  // response is r2 so get and check two bytes for nonzero
  if (cardCommand(CMD13, 0) || spiRec()) {
9d001fa0:	0f4005a2 	jal	9d001688 <_ZN7Sd2Card6spiRecEv>
9d001fa4:	02002021 	move	a0,s0
9d001fa8:	5440fffb 	bnezl	v0,9d001f98 <_ZN7Sd2Card10writeBlockEmPKh+0xbc>
9d001fac:	24020014 	li	v0,20
    error(SD_CARD_ERROR_WRITE_PROGRAMMING);
    goto fail;
  }
  chipSelectHigh();
9d001fb0:	0f4005d4 	jal	9d001750 <_ZN7Sd2Card14chipSelectHighEv>
9d001fb4:	02002021 	move	a0,s0
  return true;
9d001fb8:	0b4007c4 	j	9d001f10 <_ZN7Sd2Card10writeBlockEmPKh+0x34>
9d001fbc:	24020001 	li	v0,1

9d001fc0 <_ZN6SdFile10addClusterEv>:
// suppress cpplint warnings with NOLINT comment
void (*SdFile::oldDateTime_)(uint16_t& date, uint16_t& time) = NULL;  // NOLINT
#endif  // ALLOW_DEPRECATED_FUNCTIONS
//------------------------------------------------------------------------------
// add a cluster to a file
uint8_t SdFile::addCluster() {
9d001fc0:	27bdffe8 	addiu	sp,sp,-24
9d001fc4:	afb00010 	sw	s0,16(sp)
9d001fc8:	00808021 	move	s0,a0
  if (!vol_->allocContiguous(1, &curCluster_)) return false;
9d001fcc:	8c840020 	lw	a0,32(a0)
9d001fd0:	24050001 	li	a1,1
// suppress cpplint warnings with NOLINT comment
void (*SdFile::oldDateTime_)(uint16_t& date, uint16_t& time) = NULL;  // NOLINT
#endif  // ALLOW_DEPRECATED_FUNCTIONS
//------------------------------------------------------------------------------
// add a cluster to a file
uint8_t SdFile::addCluster() {
9d001fd4:	afbf0014 	sw	ra,20(sp)
  if (!vol_->allocContiguous(1, &curCluster_)) return false;
9d001fd8:	0f400d5d 	jal	9d003574 <_ZN8SdVolume15allocContiguousEmPm>
9d001fdc:	26060008 	addiu	a2,s0,8
9d001fe0:	1040000a 	beqz	v0,9d00200c <_ZN6SdFile10addClusterEv+0x4c>
9d001fe4:	00001821 	move	v1,zero

  // if first cluster of file link to directory entry
  if (firstCluster_ == 0) {
9d001fe8:	8e02001c 	lw	v0,28(s0)
9d001fec:	14400007 	bnez	v0,9d00200c <_ZN6SdFile10addClusterEv+0x4c>
9d001ff0:	24030001 	li	v1,1
    firstCluster_ = curCluster_;
    flags_ |= F_FILE_DIR_DIRTY;
9d001ff4:	92050004 	lbu	a1,4(s0)
uint8_t SdFile::addCluster() {
  if (!vol_->allocContiguous(1, &curCluster_)) return false;

  // if first cluster of file link to directory entry
  if (firstCluster_ == 0) {
    firstCluster_ = curCluster_;
9d001ff8:	8e040008 	lw	a0,8(s0)
    flags_ |= F_FILE_DIR_DIRTY;
9d001ffc:	2402ff80 	li	v0,-128
9d002000:	00a21025 	or	v0,a1,v0
uint8_t SdFile::addCluster() {
  if (!vol_->allocContiguous(1, &curCluster_)) return false;

  // if first cluster of file link to directory entry
  if (firstCluster_ == 0) {
    firstCluster_ = curCluster_;
9d002004:	ae04001c 	sw	a0,28(s0)
    flags_ |= F_FILE_DIR_DIRTY;
9d002008:	a2020004 	sb	v0,4(s0)
  }
  return true;
}
9d00200c:	8fbf0014 	lw	ra,20(sp)
9d002010:	00601021 	move	v0,v1
9d002014:	8fb00010 	lw	s0,16(sp)
9d002018:	03e00008 	jr	ra
9d00201c:	27bd0018 	addiu	sp,sp,24

9d002020 <_ZN6SdFile13cacheDirEntryEh>:
  return true;
}
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
dir_t* SdFile::cacheDirEntry(uint8_t action) {
9d002020:	27bdffe8 	addiu	sp,sp,-24
9d002024:	afb00010 	sw	s0,16(sp)
9d002028:	00808021 	move	s0,a0
  if (!SdVolume::cacheRawBlock(dirBlock_, action)) return NULL;
9d00202c:	8c840010 	lw	a0,16(a0)
  return true;
}
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
dir_t* SdFile::cacheDirEntry(uint8_t action) {
9d002030:	afbf0014 	sw	ra,20(sp)
  if (!SdVolume::cacheRawBlock(dirBlock_, action)) return NULL;
9d002034:	0f400c8f 	jal	9d00323c <_ZN8SdVolume13cacheRawBlockEmh>
9d002038:	30a500ff 	andi	a1,a1,0xff
9d00203c:	10400006 	beqz	v0,9d002058 <_ZN6SdFile13cacheDirEntryEh+0x38>
9d002040:	00001821 	move	v1,zero
  return SdVolume::cacheBuffer_.dir + dirIndex_;
9d002044:	92020014 	lbu	v0,20(s0)
9d002048:	3c03a000 	lui	v1,0xa000
9d00204c:	24630a84 	addiu	v1,v1,2692
9d002050:	00021140 	sll	v0,v0,0x5
9d002054:	00621821 	addu	v1,v1,v0
}
9d002058:	8fbf0014 	lw	ra,20(sp)
9d00205c:	00601021 	move	v0,v1
9d002060:	8fb00010 	lw	s0,16(sp)
9d002064:	03e00008 	jr	ra
9d002068:	27bd0018 	addiu	sp,sp,24

9d00206c <_ZN6SdFile8openRootEP8SdVolume>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 * Reasons for failure include the FAT volume has not been initialized
 * or it a FAT12 volume.
 */
uint8_t SdFile::openRoot(SdVolume* vol) {
9d00206c:	27bdffe0 	addiu	sp,sp,-32
9d002070:	afb20018 	sw	s2,24(sp)
9d002074:	afb10014 	sw	s1,20(sp)
9d002078:	afb00010 	sw	s0,16(sp)
9d00207c:	afbf001c 	sw	ra,28(sp)
  // error if file is already open
  if (isOpen()) return false;
9d002080:	90820005 	lbu	v0,5(a0)
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 * Reasons for failure include the FAT volume has not been initialized
 * or it a FAT12 volume.
 */
uint8_t SdFile::openRoot(SdVolume* vol) {
9d002084:	00808021 	move	s0,a0
9d002088:	00a09021 	move	s2,a1
  // error if file is already open
  if (isOpen()) return false;
9d00208c:	14400007 	bnez	v0,9d0020ac <_ZN6SdFile8openRootEP8SdVolume+0x40>
9d002090:	00008821 	move	s1,zero
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(char* str) {
  write_P(str);
  println();
}
9d002094:	90a20020 	lbu	v0,32(a1)
 */
uint8_t SdFile::openRoot(SdVolume* vol) {
  // error if file is already open
  if (isOpen()) return false;

  if (vol->fatType() == 16) {
9d002098:	24030010 	li	v1,16
9d00209c:	1043000a 	beq	v0,v1,9d0020c8 <_ZN6SdFile8openRootEP8SdVolume+0x5c>
9d0020a0:	24030020 	li	v1,32
    type_ = FAT_FILE_TYPE_ROOT16;
    firstCluster_ = 0;
    fileSize_ = 32 * vol->rootDirEntryCount();
  } else if (vol->fatType() == 32) {
9d0020a4:	1043001d 	beq	v0,v1,9d00211c <_ZN6SdFile8openRootEP8SdVolume+0xb0>
9d0020a8:	24020003 	li	v0,3

  // root has no directory entry
  dirBlock_ = 0;
  dirIndex_ = 0;
  return true;
}
9d0020ac:	8fbf001c 	lw	ra,28(sp)
9d0020b0:	02201021 	move	v0,s1
9d0020b4:	8fb20018 	lw	s2,24(sp)
9d0020b8:	8fb10014 	lw	s1,20(sp)
9d0020bc:	8fb00010 	lw	s0,16(sp)
9d0020c0:	03e00008 	jr	ra
9d0020c4:	27bd0020 	addiu	sp,sp,32
uint8_t SdFile::openRoot(SdVolume* vol) {
  // error if file is already open
  if (isOpen()) return false;

  if (vol->fatType() == 16) {
    type_ = FAT_FILE_TYPE_ROOT16;
9d0020c8:	24020002 	li	v0,2
9d0020cc:	a0820005 	sb	v0,5(a0)
  /** \return The logical block number for the start of the first FAT. */
  uint32_t fatStartBlock(void) const {return fatStartBlock_;}
  /** \return The FAT type of the volume. Values are 12, 16 or 32. */
  uint8_t fatType(void) const {return fatType_;}
  /** \return The number of entries in the root directory for FAT16 volumes. */
  uint32_t rootDirEntryCount(void) const {return rootDirEntryCount_;}
9d0020d0:	94a20022 	lhu	v0,34(a1)
    firstCluster_ = 0;
9d0020d4:	ac80001c 	sw	zero,28(a0)
    fileSize_ = 32 * vol->rootDirEntryCount();
9d0020d8:	00021140 	sll	v0,v0,0x5
9d0020dc:	ac820018 	sw	v0,24(a0)
    // volume is not initialized or FAT12
    return false;
  }
  vol_ = vol;
  // read only
  flags_ = O_READ;
9d0020e0:	24020001 	li	v0,1
9d0020e4:	a2020004 	sb	v0,4(s0)
  curCluster_ = 0;
  curPosition_ = 0;

  // root has no directory entry
  dirBlock_ = 0;
  dirIndex_ = 0;
9d0020e8:	a2000014 	sb	zero,20(s0)
  return true;
}
9d0020ec:	8fbf001c 	lw	ra,28(sp)
  curPosition_ = 0;

  // root has no directory entry
  dirBlock_ = 0;
  dirIndex_ = 0;
  return true;
9d0020f0:	24110001 	li	s1,1
    if (!vol->chainSize(firstCluster_, &fileSize_)) return false;
  } else {
    // volume is not initialized or FAT12
    return false;
  }
  vol_ = vol;
9d0020f4:	ae120020 	sw	s2,32(s0)

  // root has no directory entry
  dirBlock_ = 0;
  dirIndex_ = 0;
  return true;
}
9d0020f8:	02201021 	move	v0,s1
  vol_ = vol;
  // read only
  flags_ = O_READ;

  // set to start of file
  curCluster_ = 0;
9d0020fc:	ae000008 	sw	zero,8(s0)
  curPosition_ = 0;
9d002100:	ae00000c 	sw	zero,12(s0)

  // root has no directory entry
  dirBlock_ = 0;
9d002104:	ae000010 	sw	zero,16(s0)
  dirIndex_ = 0;
  return true;
}
9d002108:	8fb20018 	lw	s2,24(sp)
9d00210c:	8fb10014 	lw	s1,20(sp)
9d002110:	8fb00010 	lw	s0,16(sp)
9d002114:	03e00008 	jr	ra
9d002118:	27bd0020 	addiu	sp,sp,32
  if (vol->fatType() == 16) {
    type_ = FAT_FILE_TYPE_ROOT16;
    firstCluster_ = 0;
    fileSize_ = 32 * vol->rootDirEntryCount();
  } else if (vol->fatType() == 32) {
    type_ = FAT_FILE_TYPE_ROOT32;
9d00211c:	a0820005 	sb	v0,5(a0)
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(char* str) {
  write_P(str);
  println();
}
9d002120:	8ca50024 	lw	a1,36(a1)
    firstCluster_ = 0;
    fileSize_ = 32 * vol->rootDirEntryCount();
  } else if (vol->fatType() == 32) {
    type_ = FAT_FILE_TYPE_ROOT32;
    firstCluster_ = vol->rootDirStart();
    if (!vol->chainSize(firstCluster_, &fileSize_)) return false;
9d002124:	02402021 	move	a0,s2
9d002128:	26060018 	addiu	a2,s0,24
9d00212c:	0f400cea 	jal	9d0033a8 <_ZNK8SdVolume9chainSizeEmPm>
9d002130:	ae05001c 	sw	a1,28(s0)
9d002134:	1440ffeb 	bnez	v0,9d0020e4 <_ZN6SdFile8openRootEP8SdVolume+0x78>
9d002138:	24020001 	li	v0,1

  // root has no directory entry
  dirBlock_ = 0;
  dirIndex_ = 0;
  return true;
}
9d00213c:	0b40082c 	j	9d0020b0 <_ZN6SdFile8openRootEP8SdVolume+0x44>
9d002140:	8fbf001c 	lw	ra,28(sp)

9d002144 <_ZN6SdFile12printDirNameERK14directoryEntryh>:
/** %Print the name field of a directory entry in 8.3 format to Serial.
 *
 * \param[in] dir The directory structure containing the name.
 * \param[in] width Blank fill name if length is less than \a width.
 */
void SdFile::printDirName(const dir_t& dir, uint8_t width) {
9d002144:	27bdffc8 	addiu	sp,sp,-56
9d002148:	afb70030 	sw	s7,48(sp)
9d00214c:	afb6002c 	sw	s6,44(sp)
9d002150:	afb50028 	sw	s5,40(sp)
9d002154:	afb40024 	sw	s4,36(sp)
9d002158:	afb30020 	sw	s3,32(sp)
9d00215c:	afb2001c 	sw	s2,28(sp)
9d002160:	afb10018 	sw	s1,24(sp)
9d002164:	afb00014 	sw	s0,20(sp)
9d002168:	afbf0034 	sw	ra,52(sp)
9d00216c:	0080a021 	move	s4,a0
9d002170:	30b000ff 	andi	s0,a1,0xff
  uint8_t w = 0;
  for (uint8_t i = 0; i < 11; i++) {
9d002174:	0080b821 	move	s7,a0
9d002178:	0000b021 	move	s6,zero
 *
 * \param[in] dir The directory structure containing the name.
 * \param[in] width Blank fill name if length is less than \a width.
 */
void SdFile::printDirName(const dir_t& dir, uint8_t width) {
  uint8_t w = 0;
9d00217c:	0000a821 	move	s5,zero
  for (uint8_t i = 0; i < 11; i++) {
    if (dir.name[i] == ' ')continue;
9d002180:	24120020 	li	s2,32
    if (i == 8) {
9d002184:	24130008 	li	s3,8
 * \param[in] dir The directory structure containing the name.
 * \param[in] width Blank fill name if length is less than \a width.
 */
void SdFile::printDirName(const dir_t& dir, uint8_t width) {
  uint8_t w = 0;
  for (uint8_t i = 0; i < 11; i++) {
9d002188:	0b40086c 	j	9d0021b0 <_ZN6SdFile12printDirNameERK14directoryEntryh+0x6c>
9d00218c:	2411000b 	li	s1,11
    if (dir.name[i] == ' ')continue;
    if (i == 8) {
      Serial.print('.');
      w++;
    }
    Serial.write(dir.name[i]);
9d002190:	27848060 	addiu	a0,gp,-32672
9d002194:	0f401454 	jal	9d005150 <_ZN9USBSerial5writeEh>
9d002198:	26b50001 	addiu	s5,s5,1
    w++;
9d00219c:	32b500ff 	andi	s5,s5,0xff
 * \param[in] dir The directory structure containing the name.
 * \param[in] width Blank fill name if length is less than \a width.
 */
void SdFile::printDirName(const dir_t& dir, uint8_t width) {
  uint8_t w = 0;
  for (uint8_t i = 0; i < 11; i++) {
9d0021a0:	26d60001 	addiu	s6,s6,1
9d0021a4:	32d600ff 	andi	s6,s6,0xff
9d0021a8:	12d1000d 	beq	s6,s1,9d0021e0 <_ZN6SdFile12printDirNameERK14directoryEntryh+0x9c>
9d0021ac:	26f70001 	addiu	s7,s7,1
    if (dir.name[i] == ' ')continue;
9d0021b0:	92e50000 	lbu	a1,0(s7)
9d0021b4:	50b2fffb 	beql	a1,s2,9d0021a4 <_ZN6SdFile12printDirNameERK14directoryEntryh+0x60>
9d0021b8:	26d60001 	addiu	s6,s6,1
    if (i == 8) {
9d0021bc:	16d3fff5 	bne	s6,s3,9d002194 <_ZN6SdFile12printDirNameERK14directoryEntryh+0x50>
9d0021c0:	27848060 	addiu	a0,gp,-32672
      Serial.print('.');
9d0021c4:	2405002e 	li	a1,46
9d0021c8:	00003021 	move	a2,zero
9d0021cc:	0f401365 	jal	9d004d94 <_ZN5Print5printEci>
9d0021d0:	26b50001 	addiu	s5,s5,1
      w++;
9d0021d4:	32b500ff 	andi	s5,s5,0xff
9d0021d8:	0b400864 	j	9d002190 <_ZN6SdFile12printDirNameERK14directoryEntryh+0x4c>
9d0021dc:	92e50000 	lbu	a1,0(s7)
static inline uint8_t DIR_IS_FILE(const dir_t* dir) {
  return (dir->attributes & DIR_ATT_FILE_TYPE_MASK) == 0;
}
/** Directory entry is for a subdirectory */
static inline uint8_t DIR_IS_SUBDIR(const dir_t* dir) {
  return (dir->attributes & DIR_ATT_FILE_TYPE_MASK) == DIR_ATT_DIRECTORY;
9d0021e0:	9283000b 	lbu	v1,11(s4)
    }
    Serial.write(dir.name[i]);
    w++;
  }
  if (DIR_IS_SUBDIR(&dir)) {
9d0021e4:	24020010 	li	v0,16
9d0021e8:	30630018 	andi	v1,v1,0x18
9d0021ec:	10620018 	beq	v1,v0,9d002250 <_ZN6SdFile12printDirNameERK14directoryEntryh+0x10c>
9d0021f0:	27848060 	addiu	a0,gp,-32672
    Serial.print('/');
    w++;
  }
  while (w < width) {
9d0021f4:	02b0102b 	sltu	v0,s5,s0
9d0021f8:	1040000b 	beqz	v0,9d002228 <_ZN6SdFile12printDirNameERK14directoryEntryh+0xe4>
9d0021fc:	8fbf0034 	lw	ra,52(sp)
    Serial.print(' ');
    w++;
9d002200:	26b50001 	addiu	s5,s5,1
  if (DIR_IS_SUBDIR(&dir)) {
    Serial.print('/');
    w++;
  }
  while (w < width) {
    Serial.print(' ');
9d002204:	27848060 	addiu	a0,gp,-32672
9d002208:	24050020 	li	a1,32
9d00220c:	00003021 	move	a2,zero
9d002210:	0f401365 	jal	9d004d94 <_ZN5Print5printEci>
9d002214:	32b500ff 	andi	s5,s5,0xff
  }
  if (DIR_IS_SUBDIR(&dir)) {
    Serial.print('/');
    w++;
  }
  while (w < width) {
9d002218:	02b0102b 	sltu	v0,s5,s0
9d00221c:	1440fff9 	bnez	v0,9d002204 <_ZN6SdFile12printDirNameERK14directoryEntryh+0xc0>
9d002220:	26b50001 	addiu	s5,s5,1
    Serial.print(' ');
    w++;
  }
}
9d002224:	8fbf0034 	lw	ra,52(sp)
9d002228:	8fb70030 	lw	s7,48(sp)
9d00222c:	8fb6002c 	lw	s6,44(sp)
9d002230:	8fb50028 	lw	s5,40(sp)
9d002234:	8fb40024 	lw	s4,36(sp)
9d002238:	8fb30020 	lw	s3,32(sp)
9d00223c:	8fb2001c 	lw	s2,28(sp)
9d002240:	8fb10018 	lw	s1,24(sp)
9d002244:	8fb00014 	lw	s0,20(sp)
9d002248:	03e00008 	jr	ra
9d00224c:	27bd0038 	addiu	sp,sp,56
    }
    Serial.write(dir.name[i]);
    w++;
  }
  if (DIR_IS_SUBDIR(&dir)) {
    Serial.print('/');
9d002250:	2405002f 	li	a1,47
9d002254:	00003021 	move	a2,zero
9d002258:	0f401365 	jal	9d004d94 <_ZN5Print5printEci>
9d00225c:	26b50001 	addiu	s5,s5,1
    w++;
9d002260:	0b40087d 	j	9d0021f4 <_ZN6SdFile12printDirNameERK14directoryEntryh+0xb0>
9d002264:	32b500ff 	andi	s5,s5,0xff

9d002268 <_ZN6SdFile14printTwoDigitsEh>:
 *
 * \param[in] v Value to be printed, 0 <= \a v <= 99
 */
void SdFile::printTwoDigits(uint8_t v) {
  char str[3];
  str[0] = '0' + v/10;
9d002268:	3c02cccc 	lui	v0,0xcccc
//------------------------------------------------------------------------------
/** %Print a value as two digits to Serial.
 *
 * \param[in] v Value to be printed, 0 <= \a v <= 99
 */
void SdFile::printTwoDigits(uint8_t v) {
9d00226c:	308300ff 	andi	v1,a0,0xff
  char str[3];
  str[0] = '0' + v/10;
9d002270:	3442cccd 	ori	v0,v0,0xcccd
9d002274:	00620019 	multu	v1,v0
//------------------------------------------------------------------------------
/** %Print a value as two digits to Serial.
 *
 * \param[in] v Value to be printed, 0 <= \a v <= 99
 */
void SdFile::printTwoDigits(uint8_t v) {
9d002278:	27bdffe0 	addiu	sp,sp,-32
  char str[3];
  str[0] = '0' + v/10;
  str[1] = '0' + v % 10;
  str[2] = 0;
  Serial.print(str);
9d00227c:	27a50010 	addiu	a1,sp,16
9d002280:	27848060 	addiu	a0,gp,-32672
//------------------------------------------------------------------------------
/** %Print a value as two digits to Serial.
 *
 * \param[in] v Value to be printed, 0 <= \a v <= 99
 */
void SdFile::printTwoDigits(uint8_t v) {
9d002284:	afbf001c 	sw	ra,28(sp)
  char str[3];
  str[0] = '0' + v/10;
  str[1] = '0' + v % 10;
  str[2] = 0;
9d002288:	a3a00012 	sb	zero,18(sp)
 *
 * \param[in] v Value to be printed, 0 <= \a v <= 99
 */
void SdFile::printTwoDigits(uint8_t v) {
  char str[3];
  str[0] = '0' + v/10;
9d00228c:	00001010 	mfhi	v0
9d002290:	000210c2 	srl	v0,v0,0x3
  str[1] = '0' + v % 10;
9d002294:	00023840 	sll	a3,v0,0x1
9d002298:	000230c0 	sll	a2,v0,0x3
9d00229c:	00e63021 	addu	a2,a3,a2
9d0022a0:	00661823 	subu	v1,v1,a2
 *
 * \param[in] v Value to be printed, 0 <= \a v <= 99
 */
void SdFile::printTwoDigits(uint8_t v) {
  char str[3];
  str[0] = '0' + v/10;
9d0022a4:	24420030 	addiu	v0,v0,48
  str[1] = '0' + v % 10;
9d0022a8:	24630030 	addiu	v1,v1,48
 *
 * \param[in] v Value to be printed, 0 <= \a v <= 99
 */
void SdFile::printTwoDigits(uint8_t v) {
  char str[3];
  str[0] = '0' + v/10;
9d0022ac:	a3a20010 	sb	v0,16(sp)
  str[1] = '0' + v % 10;
  str[2] = 0;
  Serial.print(str);
9d0022b0:	0f401305 	jal	9d004c14 <_ZN5Print5printEPKc>
9d0022b4:	a3a30011 	sb	v1,17(sp)
}
9d0022b8:	8fbf001c 	lw	ra,28(sp)
9d0022bc:	03e00008 	jr	ra
9d0022c0:	27bd0020 	addiu	sp,sp,32

9d0022c4 <_ZN6SdFile12printFatTimeEt>:
 *
 * Format is hh:mm:ss.
 *
 * \param[in] fatTime The time field from a directory entry.
 */
void SdFile::printFatTime(uint16_t fatTime) {
9d0022c4:	27bdffe8 	addiu	sp,sp,-24
9d0022c8:	afb00010 	sw	s0,16(sp)
9d0022cc:	3090ffff 	andi	s0,a0,0xffff
9d0022d0:	afbf0014 	sw	ra,20(sp)
  printTwoDigits(FAT_HOUR(fatTime));
9d0022d4:	0f40089a 	jal	9d002268 <_ZN6SdFile14printTwoDigitsEh>
9d0022d8:	001022c2 	srl	a0,s0,0xb
  Serial.print(':');
9d0022dc:	2405003a 	li	a1,58
9d0022e0:	00003021 	move	a2,zero
9d0022e4:	0f401365 	jal	9d004d94 <_ZN5Print5printEci>
9d0022e8:	27848060 	addiu	a0,gp,-32672
  printTwoDigits(FAT_MINUTE(fatTime));
9d0022ec:	0f40089a 	jal	9d002268 <_ZN6SdFile14printTwoDigitsEh>
9d0022f0:	7e042940 	ext	a0,s0,0x5,0x6
  Serial.print(':');
9d0022f4:	27848060 	addiu	a0,gp,-32672
9d0022f8:	2405003a 	li	a1,58
9d0022fc:	0f401365 	jal	9d004d94 <_ZN5Print5printEci>
9d002300:	00003021 	move	a2,zero
static inline uint8_t FAT_MINUTE(uint16_t fatTime) {
  return(fatTime >> 5) & 0X3F;
}
/** second part of FAT directory time field */
static inline uint8_t FAT_SECOND(uint16_t fatTime) {
  return 2*(fatTime & 0X1F);
9d002304:	3204001f 	andi	a0,s0,0x1f
  printTwoDigits(FAT_SECOND(fatTime));
}
9d002308:	8fbf0014 	lw	ra,20(sp)
9d00230c:	8fb00010 	lw	s0,16(sp)
void SdFile::printFatTime(uint16_t fatTime) {
  printTwoDigits(FAT_HOUR(fatTime));
  Serial.print(':');
  printTwoDigits(FAT_MINUTE(fatTime));
  Serial.print(':');
  printTwoDigits(FAT_SECOND(fatTime));
9d002310:	00042040 	sll	a0,a0,0x1
9d002314:	0b40089a 	j	9d002268 <_ZN6SdFile14printTwoDigitsEh>
9d002318:	27bd0018 	addiu	sp,sp,24

9d00231c <_ZN6SdFile12printFatDateEt>:
 *
 *  Format is yyyy-mm-dd.
 *
 * \param[in] fatDate The date field from a directory entry.
 */
void SdFile::printFatDate(uint16_t fatDate) {
9d00231c:	27bdffe8 	addiu	sp,sp,-24
9d002320:	afb00010 	sw	s0,16(sp)
9d002324:	3090ffff 	andi	s0,a0,0xffff
static inline uint16_t FAT_DATE(uint16_t year, uint8_t month, uint8_t day) {
  return (year - 1980) << 9 | month << 5 | day;
}
/** year part of FAT directory date field */
static inline uint16_t FAT_YEAR(uint16_t fatDate) {
  return 1980 + (fatDate >> 9);
9d002328:	00102a43 	sra	a1,s0,0x9
  Serial.print(FAT_YEAR(fatDate));
9d00232c:	27848060 	addiu	a0,gp,-32672
9d002330:	24a507bc 	addiu	a1,a1,1980
 *
 *  Format is yyyy-mm-dd.
 *
 * \param[in] fatDate The date field from a directory entry.
 */
void SdFile::printFatDate(uint16_t fatDate) {
9d002334:	afbf0014 	sw	ra,20(sp)
  Serial.print(FAT_YEAR(fatDate));
9d002338:	0f401363 	jal	9d004d8c <_ZN5Print5printEii>
9d00233c:	2406000a 	li	a2,10
  Serial.print('-');
9d002340:	2405002d 	li	a1,45
9d002344:	00003021 	move	a2,zero
9d002348:	0f401365 	jal	9d004d94 <_ZN5Print5printEci>
9d00234c:	27848060 	addiu	a0,gp,-32672
  printTwoDigits(FAT_MONTH(fatDate));
9d002350:	0f40089a 	jal	9d002268 <_ZN6SdFile14printTwoDigitsEh>
9d002354:	7e041940 	ext	a0,s0,0x5,0x4
  Serial.print('-');
9d002358:	27848060 	addiu	a0,gp,-32672
9d00235c:	2405002d 	li	a1,45
9d002360:	0f401365 	jal	9d004d94 <_ZN5Print5printEci>
9d002364:	00003021 	move	a2,zero
  printTwoDigits(FAT_DAY(fatDate));
9d002368:	3204001f 	andi	a0,s0,0x1f
}
9d00236c:	8fbf0014 	lw	ra,20(sp)
9d002370:	8fb00010 	lw	s0,16(sp)
void SdFile::printFatDate(uint16_t fatDate) {
  Serial.print(FAT_YEAR(fatDate));
  Serial.print('-');
  printTwoDigits(FAT_MONTH(fatDate));
  Serial.print('-');
  printTwoDigits(FAT_DAY(fatDate));
9d002374:	0b40089a 	j	9d002268 <_ZN6SdFile14printTwoDigitsEh>
9d002378:	27bd0018 	addiu	sp,sp,24

9d00237c <_ZN6SdFile4readEPvt>:
 * if end of file is reached.
 * If an error occurs, read() returns -1.  Possible errors include
 * read() called before a file has been opened, corrupt file system
 * or an I/O error occurred.
 */
int16_t SdFile::read(void* buf, uint16_t nbyte) {
9d00237c:	27bdffb8 	addiu	sp,sp,-72
9d002380:	afb50034 	sw	s5,52(sp)
9d002384:	afb3002c 	sw	s3,44(sp)
9d002388:	afbf0044 	sw	ra,68(sp)
9d00238c:	afbe0040 	sw	s8,64(sp)
9d002390:	afb7003c 	sw	s7,60(sp)
9d002394:	afb60038 	sw	s6,56(sp)
9d002398:	afb40030 	sw	s4,48(sp)
9d00239c:	afb20028 	sw	s2,40(sp)
9d0023a0:	afb10024 	sw	s1,36(sp)
9d0023a4:	afb00020 	sw	s0,32(sp)
9d0023a8:	0080a821 	move	s5,a0
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(char* str) {
  write_P(str);
  println();
}
9d0023ac:	90840005 	lbu	a0,5(a0)
 * if end of file is reached.
 * If an error occurs, read() returns -1.  Possible errors include
 * read() called before a file has been opened, corrupt file system
 * or an I/O error occurred.
 */
int16_t SdFile::read(void* buf, uint16_t nbyte) {
9d0023b0:	30d3ffff 	andi	s3,a2,0xffff
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);

  // error if not open or write only
  if (!isOpen() || !(flags_ & O_READ)) return -1;
9d0023b4:	1080006b 	beqz	a0,9d002564 <_ZN6SdFile4readEPvt+0x1e8>
9d0023b8:	2402ffff 	li	v0,-1
9d0023bc:	92a30004 	lbu	v1,4(s5)
9d0023c0:	30630001 	andi	v1,v1,0x1
9d0023c4:	50600068 	beqzl	v1,9d002568 <_ZN6SdFile4readEPvt+0x1ec>
9d0023c8:	8fbf0044 	lw	ra,68(sp)

  // max bytes left in file
  if (nbyte > (fileSize_ - curPosition_)) nbyte = fileSize_ - curPosition_;
9d0023cc:	8ea20018 	lw	v0,24(s5)
9d0023d0:	8eb7000c 	lw	s7,12(s5)
9d0023d4:	00571023 	subu	v0,v0,s7
9d0023d8:	0053182b 	sltu	v1,v0,s3
9d0023dc:	3042ffff 	andi	v0,v0,0xffff
9d0023e0:	0043980b 	movn	s3,v0,v1

  // amount left to read
  uint16_t toRead = nbyte;
  while (toRead > 0) {
9d0023e4:	1260005e 	beqz	s3,9d002560 <_ZN6SdFile4readEPvt+0x1e4>
9d0023e8:	3c12a000 	lui	s2,0xa000
    uint32_t block;  // raw device block number
    uint16_t offset = curPosition_ & 0X1FF;  // offset in block
    if (type_ == FAT_FILE_TYPE_ROOT16) {
9d0023ec:	24110002 	li	s1,2
 * If an error occurs, read() returns -1.  Possible errors include
 * read() called before a file has been opened, corrupt file system
 * or an I/O error occurred.
 */
int16_t SdFile::read(void* buf, uint16_t nbyte) {
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
9d0023f0:	00a0f021 	move	s8,a1
9d0023f4:	0260b021 	move	s6,s3
        if (curPosition_ == 0) {
          // use first cluster in file
          curCluster_ = firstCluster_;
        } else {
          // get next cluster from FAT
          if (!vol_->fatGet(curCluster_, &curCluster_)) return -1;
9d0023f8:	26b40008 	addiu	s4,s5,8
      block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
    }
    uint16_t n = toRead;

    // amount to be read from current block
    if (n > (512 - offset)) n = 512 - offset;
9d0023fc:	24100200 	li	s0,512
      if (!vol_->readData(block, offset, n, dst)) return -1;
      dst += n;
    } else {
      // read block to cache and copy data to caller
      if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) return -1;
      uint8_t* src = SdVolume::cacheBuffer_.data + offset;
9d002400:	26520a84 	addiu	s2,s2,2692
  // amount left to read
  uint16_t toRead = nbyte;
  while (toRead > 0) {
    uint32_t block;  // raw device block number
    uint16_t offset = curPosition_ & 0X1FF;  // offset in block
    if (type_ == FAT_FILE_TYPE_ROOT16) {
9d002404:	10910039 	beq	a0,s1,9d0024ec <_ZN6SdFile4readEPvt+0x170>
9d002408:	32e301ff 	andi	v1,s7,0x1ff
      block = vol_->rootDirStart() + (curPosition_ >> 9);
    } else {
      uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
9d00240c:	8ea40020 	lw	a0,32(s5)
  uint16_t rootDirEntryCount_;  // number of entries in FAT16 root dir
  uint32_t rootDirStart_;       // root start block for FAT16, cluster for FAT32
  //----------------------------------------------------------------------------
  uint8_t allocContiguous(uint32_t count, uint32_t* curCluster);
  uint8_t blockOfCluster(uint32_t position) const {
          return (position >> 9) & (blocksPerCluster_ - 1);}
9d002410:	00171242 	srl	v0,s7,0x9
9d002414:	90870004 	lbu	a3,4(a0)
9d002418:	24e7ffff 	addiu	a3,a3,-1
9d00241c:	00473824 	and	a3,v0,a3
      if (offset == 0 && blockOfCluster == 0) {
9d002420:	14600064 	bnez	v1,9d0025b4 <_ZN6SdFile4readEPvt+0x238>
9d002424:	30e700ff 	andi	a3,a3,0xff
9d002428:	54e00005 	bnezl	a3,9d002440 <_ZN6SdFile4readEPvt+0xc4>
9d00242c:	8ea20008 	lw	v0,8(s5)
        // start of new cluster
        if (curPosition_ == 0) {
9d002430:	56e00058 	bnezl	s7,9d002594 <_ZN6SdFile4readEPvt+0x218>
9d002434:	8ea50008 	lw	a1,8(s5)
          // use first cluster in file
          curCluster_ = firstCluster_;
9d002438:	8ea2001c 	lw	v0,28(s5)
9d00243c:	aea20008 	sw	v0,8(s5)
  uint32_t clusterStartBlock(uint32_t cluster) const {
           return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);}
9d002440:	90850010 	lbu	a1,16(a0)
9d002444:	8c970014 	lw	s7,20(a0)
9d002448:	2442fffe 	addiu	v0,v0,-2
9d00244c:	00a21004 	sllv	v0,v0,a1
   */
  uint8_t type(void) const {return type_;}
  uint8_t truncate(uint32_t size);
  /** \return Unbuffered read flag. */
  uint8_t unbufferedRead(void) const {
    return flags_ & F_FILE_UNBUFFERED_READ;
9d002450:	92a50004 	lbu	a1,4(s5)
  //----------------------------------------------------------------------------
  uint8_t allocContiguous(uint32_t count, uint32_t* curCluster);
  uint8_t blockOfCluster(uint32_t position) const {
          return (position >> 9) & (blocksPerCluster_ - 1);}
  uint32_t clusterStartBlock(uint32_t cluster) const {
           return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);}
9d002454:	00f73821 	addu	a3,a3,s7
        } else {
          // get next cluster from FAT
          if (!vol_->fatGet(curCluster_, &curCluster_)) return -1;
        }
      }
      block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
9d002458:	00e22021 	addu	a0,a3,v0
    }
    uint16_t n = toRead;

    // amount to be read from current block
    if (n > (512 - offset)) n = 512 - offset;
9d00245c:	02031023 	subu	v0,s0,v1
9d002460:	0056b82a 	slt	s7,v0,s6

    // no buffering needed if n == 512 or user requests no buffering
    if ((unbufferedRead() || n == 512) &&
9d002464:	30a50040 	andi	a1,a1,0x40
      block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
    }
    uint16_t n = toRead;

    // amount to be read from current block
    if (n > (512 - offset)) n = 512 - offset;
9d002468:	3042ffff 	andi	v0,v0,0xffff
9d00246c:	02d7100a 	movz	v0,s6,s7

    // no buffering needed if n == 512 or user requests no buffering
    if ((unbufferedRead() || n == 512) &&
9d002470:	30a500ff 	andi	a1,a1,0xff
9d002474:	14a0002a 	bnez	a1,9d002520 <_ZN6SdFile4readEPvt+0x1a4>
9d002478:	0040b821 	move	s7,v0
9d00247c:	10500029 	beq	v0,s0,9d002524 <_ZN6SdFile4readEPvt+0x1a8>
9d002480:	8f828010 	lw	v0,-32752(gp)
      block != SdVolume::cacheBlockNumber_) {
      if (!vol_->readData(block, offset, n, dst)) return -1;
      dst += n;
    } else {
      // read block to cache and copy data to caller
      if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) return -1;
9d002484:	00002821 	move	a1,zero
9d002488:	0f400c8f 	jal	9d00323c <_ZN8SdVolume13cacheRawBlockEmh>
9d00248c:	afa3001c 	sw	v1,28(sp)
9d002490:	1040004a 	beqz	v0,9d0025bc <_ZN6SdFile4readEPvt+0x240>
9d002494:	8fa3001c 	lw	v1,28(sp)
      uint8_t* src = SdVolume::cacheBuffer_.data + offset;
9d002498:	02431821 	addu	v1,s2,v1
      uint8_t* end = src + n;
9d00249c:	00773021 	addu	a2,v1,s7
      while (src != end) *dst++ = *src++;
9d0024a0:	10660009 	beq	v1,a2,9d0024c8 <_ZN6SdFile4readEPvt+0x14c>
9d0024a4:	00601021 	move	v0,v1
9d0024a8:	03c02021 	move	a0,s8
9d0024ac:	90450000 	lbu	a1,0(v0)
9d0024b0:	24420001 	addiu	v0,v0,1
9d0024b4:	a0850000 	sb	a1,0(a0)
9d0024b8:	14c2fffc 	bne	a2,v0,9d0024ac <_ZN6SdFile4readEPvt+0x130>
9d0024bc:	24840001 	addiu	a0,a0,1
 * if end of file is reached.
 * If an error occurs, read() returns -1.  Possible errors include
 * read() called before a file has been opened, corrupt file system
 * or an I/O error occurred.
 */
int16_t SdFile::read(void* buf, uint16_t nbyte) {
9d0024c0:	00c31823 	subu	v1,a2,v1
    } else {
      // read block to cache and copy data to caller
      if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) return -1;
      uint8_t* src = SdVolume::cacheBuffer_.data + offset;
      uint8_t* end = src + n;
      while (src != end) *dst++ = *src++;
9d0024c4:	03c3f021 	addu	s8,s8,v1
    }
    curPosition_ += n;
9d0024c8:	8ea2000c 	lw	v0,12(s5)
    toRead -= n;
9d0024cc:	02d7b023 	subu	s6,s6,s7
9d0024d0:	32d6ffff 	andi	s6,s6,0xffff
      if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) return -1;
      uint8_t* src = SdVolume::cacheBuffer_.data + offset;
      uint8_t* end = src + n;
      while (src != end) *dst++ = *src++;
    }
    curPosition_ += n;
9d0024d4:	02e2b821 	addu	s7,s7,v0
  // max bytes left in file
  if (nbyte > (fileSize_ - curPosition_)) nbyte = fileSize_ - curPosition_;

  // amount left to read
  uint16_t toRead = nbyte;
  while (toRead > 0) {
9d0024d8:	12c00021 	beqz	s6,9d002560 <_ZN6SdFile4readEPvt+0x1e4>
9d0024dc:	aeb7000c 	sw	s7,12(s5)
9d0024e0:	92a40005 	lbu	a0,5(s5)
    uint32_t block;  // raw device block number
    uint16_t offset = curPosition_ & 0X1FF;  // offset in block
    if (type_ == FAT_FILE_TYPE_ROOT16) {
9d0024e4:	1491ffc9 	bne	a0,s1,9d00240c <_ZN6SdFile4readEPvt+0x90>
9d0024e8:	32e301ff 	andi	v1,s7,0x1ff
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(char* str) {
  write_P(str);
  println();
}
9d0024ec:	8ea20020 	lw	v0,32(s5)
   */
  uint8_t type(void) const {return type_;}
  uint8_t truncate(uint32_t size);
  /** \return Unbuffered read flag. */
  uint8_t unbufferedRead(void) const {
    return flags_ & F_FILE_UNBUFFERED_READ;
9d0024f0:	92a50004 	lbu	a1,4(s5)
  uint16_t toRead = nbyte;
  while (toRead > 0) {
    uint32_t block;  // raw device block number
    uint16_t offset = curPosition_ & 0X1FF;  // offset in block
    if (type_ == FAT_FILE_TYPE_ROOT16) {
      block = vol_->rootDirStart() + (curPosition_ >> 9);
9d0024f4:	0017ba42 	srl	s7,s7,0x9
9d0024f8:	8c420024 	lw	v0,36(v0)

    // amount to be read from current block
    if (n > (512 - offset)) n = 512 - offset;

    // no buffering needed if n == 512 or user requests no buffering
    if ((unbufferedRead() || n == 512) &&
9d0024fc:	30a50040 	andi	a1,a1,0x40
9d002500:	30a500ff 	andi	a1,a1,0xff
  uint16_t toRead = nbyte;
  while (toRead > 0) {
    uint32_t block;  // raw device block number
    uint16_t offset = curPosition_ & 0X1FF;  // offset in block
    if (type_ == FAT_FILE_TYPE_ROOT16) {
      block = vol_->rootDirStart() + (curPosition_ >> 9);
9d002504:	02e22021 	addu	a0,s7,v0
      block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
    }
    uint16_t n = toRead;

    // amount to be read from current block
    if (n > (512 - offset)) n = 512 - offset;
9d002508:	02031023 	subu	v0,s0,v1
9d00250c:	0056b82a 	slt	s7,v0,s6
9d002510:	3042ffff 	andi	v0,v0,0xffff
9d002514:	02d7100a 	movz	v0,s6,s7

    // no buffering needed if n == 512 or user requests no buffering
    if ((unbufferedRead() || n == 512) &&
9d002518:	10a0ffd8 	beqz	a1,9d00247c <_ZN6SdFile4readEPvt+0x100>
9d00251c:	0040b821 	move	s7,v0
9d002520:	8f828010 	lw	v0,-32752(gp)
9d002524:	1082ffd7 	beq	a0,v0,9d002484 <_ZN6SdFile4readEPvt+0x108>
9d002528:	00802821 	move	a1,a0
  }
  uint8_t readBlock(uint32_t block, uint8_t* dst) {
    return sdCard_->readBlock(block, dst);}
  uint8_t readData(uint32_t block, uint16_t offset,
    uint16_t count, uint8_t* dst) {
      return sdCard_->readData(block, offset, count, dst);
9d00252c:	8f848030 	lw	a0,-32720(gp)
9d002530:	00603021 	move	a2,v1
9d002534:	02e03821 	move	a3,s7
9d002538:	0f40071d 	jal	9d001c74 <_ZN7Sd2Card8readDataEmttPh>
9d00253c:	afbe0010 	sw	s8,16(sp)
      block != SdVolume::cacheBlockNumber_) {
      if (!vol_->readData(block, offset, n, dst)) return -1;
9d002540:	1040001e 	beqz	v0,9d0025bc <_ZN6SdFile4readEPvt+0x240>
9d002544:	02d7b023 	subu	s6,s6,s7
      if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) return -1;
      uint8_t* src = SdVolume::cacheBuffer_.data + offset;
      uint8_t* end = src + n;
      while (src != end) *dst++ = *src++;
    }
    curPosition_ += n;
9d002548:	8ea2000c 	lw	v0,12(s5)

    // no buffering needed if n == 512 or user requests no buffering
    if ((unbufferedRead() || n == 512) &&
      block != SdVolume::cacheBlockNumber_) {
      if (!vol_->readData(block, offset, n, dst)) return -1;
      dst += n;
9d00254c:	03d7f021 	addu	s8,s8,s7
      uint8_t* src = SdVolume::cacheBuffer_.data + offset;
      uint8_t* end = src + n;
      while (src != end) *dst++ = *src++;
    }
    curPosition_ += n;
    toRead -= n;
9d002550:	32d6ffff 	andi	s6,s6,0xffff
      if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) return -1;
      uint8_t* src = SdVolume::cacheBuffer_.data + offset;
      uint8_t* end = src + n;
      while (src != end) *dst++ = *src++;
    }
    curPosition_ += n;
9d002554:	02e2b821 	addu	s7,s7,v0
  // max bytes left in file
  if (nbyte > (fileSize_ - curPosition_)) nbyte = fileSize_ - curPosition_;

  // amount left to read
  uint16_t toRead = nbyte;
  while (toRead > 0) {
9d002558:	16c0ffe1 	bnez	s6,9d0024e0 <_ZN6SdFile4readEPvt+0x164>
9d00255c:	aeb7000c 	sw	s7,12(s5)
      while (src != end) *dst++ = *src++;
    }
    curPosition_ += n;
    toRead -= n;
  }
  return nbyte;
9d002560:	7c131620 	seh	v0,s3
}
9d002564:	8fbf0044 	lw	ra,68(sp)
9d002568:	8fbe0040 	lw	s8,64(sp)
9d00256c:	8fb7003c 	lw	s7,60(sp)
9d002570:	8fb60038 	lw	s6,56(sp)
9d002574:	8fb50034 	lw	s5,52(sp)
9d002578:	8fb40030 	lw	s4,48(sp)
9d00257c:	8fb3002c 	lw	s3,44(sp)
9d002580:	8fb20028 	lw	s2,40(sp)
9d002584:	8fb10024 	lw	s1,36(sp)
9d002588:	8fb00020 	lw	s0,32(sp)
9d00258c:	03e00008 	jr	ra
9d002590:	27bd0048 	addiu	sp,sp,72
        if (curPosition_ == 0) {
          // use first cluster in file
          curCluster_ = firstCluster_;
        } else {
          // get next cluster from FAT
          if (!vol_->fatGet(curCluster_, &curCluster_)) return -1;
9d002594:	02803021 	move	a2,s4
9d002598:	afa3001c 	sw	v1,28(sp)
9d00259c:	0f400cb5 	jal	9d0032d4 <_ZNK8SdVolume6fatGetEmPm>
9d0025a0:	afa70018 	sw	a3,24(sp)
9d0025a4:	8fa3001c 	lw	v1,28(sp)
9d0025a8:	10400004 	beqz	v0,9d0025bc <_ZN6SdFile4readEPvt+0x240>
9d0025ac:	8fa70018 	lw	a3,24(sp)
9d0025b0:	8ea40020 	lw	a0,32(s5)
9d0025b4:	0b400910 	j	9d002440 <_ZN6SdFile4readEPvt+0xc4>
9d0025b8:	8ea20008 	lw	v0,8(s5)
    }
    curPosition_ += n;
    toRead -= n;
  }
  return nbyte;
}
9d0025bc:	8fbf0044 	lw	ra,68(sp)
      block != SdVolume::cacheBlockNumber_) {
      if (!vol_->readData(block, offset, n, dst)) return -1;
      dst += n;
    } else {
      // read block to cache and copy data to caller
      if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) return -1;
9d0025c0:	2402ffff 	li	v0,-1
    }
    curPosition_ += n;
    toRead -= n;
  }
  return nbyte;
}
9d0025c4:	8fbe0040 	lw	s8,64(sp)
9d0025c8:	8fb7003c 	lw	s7,60(sp)
9d0025cc:	8fb60038 	lw	s6,56(sp)
9d0025d0:	8fb50034 	lw	s5,52(sp)
9d0025d4:	8fb40030 	lw	s4,48(sp)
9d0025d8:	8fb3002c 	lw	s3,44(sp)
9d0025dc:	8fb20028 	lw	s2,40(sp)
9d0025e0:	8fb10024 	lw	s1,36(sp)
9d0025e4:	8fb00020 	lw	s0,32(sp)
9d0025e8:	03e00008 	jr	ra
9d0025ec:	27bd0048 	addiu	sp,sp,72

9d0025f0 <_ZN6SdFile12readDirCacheEv>:
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
dir_t* SdFile::readDirCache(void) {
  // error if not directory
  if (!isDir()) return NULL;
9d0025f0:	90820005 	lbu	v0,5(a0)
  return n < 0 ? -1 : 0;
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
dir_t* SdFile::readDirCache(void) {
9d0025f4:	27bdffd8 	addiu	sp,sp,-40
9d0025f8:	afb20020 	sw	s2,32(sp)
  // error if not directory
  if (!isDir()) return NULL;
9d0025fc:	2c420002 	sltiu	v0,v0,2
  return n < 0 ? -1 : 0;
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
dir_t* SdFile::readDirCache(void) {
9d002600:	afb1001c 	sw	s1,28(sp)
9d002604:	afbf0024 	sw	ra,36(sp)
9d002608:	afb00018 	sw	s0,24(sp)
9d00260c:	00808821 	move	s1,a0
  // error if not directory
  if (!isDir()) return NULL;
9d002610:	10400008 	beqz	v0,9d002634 <_ZN6SdFile12readDirCacheEv+0x44>
9d002614:	00009021 	move	s2,zero
  // advance to next entry
  curPosition_ += 31;

  // return pointer to entry
  return (SdVolume::cacheBuffer_.dir + i);
}
9d002618:	8fbf0024 	lw	ra,36(sp)
9d00261c:	02401021 	move	v0,s2
9d002620:	8fb20020 	lw	s2,32(sp)
9d002624:	8fb1001c 	lw	s1,28(sp)
9d002628:	8fb00018 	lw	s0,24(sp)
9d00262c:	03e00008 	jr	ra
9d002630:	27bd0028 	addiu	sp,sp,40
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int16_t read(void) {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
9d002634:	27a50010 	addiu	a1,sp,16
9d002638:	24060001 	li	a2,1
9d00263c:	0f4008df 	jal	9d00237c <_ZN6SdFile4readEPvt>
9d002640:	8c90000c 	lw	s0,12(a0)
9d002644:	24030001 	li	v1,1
9d002648:	1443fff4 	bne	v0,v1,9d00261c <_ZN6SdFile12readDirCacheEv+0x2c>
9d00264c:	8fbf0024 	lw	ra,36(sp)

  // use read to locate and cache block
  if (read() < 0) return NULL;

  // advance to next entry
  curPosition_ += 31;
9d002650:	8e22000c 	lw	v0,12(s1)

  // return pointer to entry
  return (SdVolume::cacheBuffer_.dir + i);
9d002654:	3c12a000 	lui	s2,0xa000
9d002658:	321001e0 	andi	s0,s0,0x1e0

  // use read to locate and cache block
  if (read() < 0) return NULL;

  // advance to next entry
  curPosition_ += 31;
9d00265c:	2442001f 	addiu	v0,v0,31

  // return pointer to entry
  return (SdVolume::cacheBuffer_.dir + i);
9d002660:	26520a84 	addiu	s2,s2,2692

  // use read to locate and cache block
  if (read() < 0) return NULL;

  // advance to next entry
  curPosition_ += 31;
9d002664:	ae22000c 	sw	v0,12(s1)

  // return pointer to entry
  return (SdVolume::cacheBuffer_.dir + i);
9d002668:	0b400986 	j	9d002618 <_ZN6SdFile12readDirCacheEv+0x28>
9d00266c:	02509021 	addu	s2,s2,s0

9d002670 <_ZN6SdFile7seekSetEm>:
 * \param[in] pos The new position in bytes from the beginning of the file.
 *
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t SdFile::seekSet(uint32_t pos) {
9d002670:	27bdffd8 	addiu	sp,sp,-40
9d002674:	afb2001c 	sw	s2,28(sp)
9d002678:	afb10018 	sw	s1,24(sp)
9d00267c:	afbf0024 	sw	ra,36(sp)
9d002680:	afb30020 	sw	s3,32(sp)
9d002684:	afb00014 	sw	s0,20(sp)
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(char* str) {
  write_P(str);
  println();
}
9d002688:	90830005 	lbu	v1,5(a0)
 * \param[in] pos The new position in bytes from the beginning of the file.
 *
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t SdFile::seekSet(uint32_t pos) {
9d00268c:	00809021 	move	s2,a0
9d002690:	00a08821 	move	s1,a1
  // error if file not open or seek past end of file
  if (!isOpen() || pos > fileSize_) return false;
9d002694:	10600023 	beqz	v1,9d002724 <_ZN6SdFile7seekSetEm+0xb4>
9d002698:	00001021 	move	v0,zero
9d00269c:	8c840018 	lw	a0,24(a0)
9d0026a0:	0085202b 	sltu	a0,a0,a1
9d0026a4:	54800020 	bnezl	a0,9d002728 <_ZN6SdFile7seekSetEm+0xb8>
9d0026a8:	8fbf0024 	lw	ra,36(sp)

  if (type_ == FAT_FILE_TYPE_ROOT16) {
9d0026ac:	24020002 	li	v0,2
9d0026b0:	5062001b 	beql	v1,v0,9d002720 <_ZN6SdFile7seekSetEm+0xb0>
9d0026b4:	ae51000c 	sw	s1,12(s2)
    curPosition_ = pos;
    return true;
  }
  if (pos == 0) {
9d0026b8:	12200023 	beqz	s1,9d002748 <_ZN6SdFile7seekSetEm+0xd8>
9d0026bc:	2624ffff 	addiu	a0,s1,-1
    curCluster_ = 0;
    curPosition_ = 0;
    return true;
  }
  // calculate cluster index for cur and new position
  uint32_t nCur = (curPosition_ - 1) >> (vol_->clusterSizeShift_ + 9);
9d0026c0:	8e430020 	lw	v1,32(s2)
9d0026c4:	8e42000c 	lw	v0,12(s2)
9d0026c8:	90730010 	lbu	s3,16(v1)
9d0026cc:	2443ffff 	addiu	v1,v0,-1
9d0026d0:	26730009 	addiu	s3,s3,9
9d0026d4:	02631806 	srlv	v1,v1,s3
  uint32_t nNew = (pos - 1) >> (vol_->clusterSizeShift_ + 9);
9d0026d8:	02649806 	srlv	s3,a0,s3

  if (nNew < nCur || curPosition_ == 0) {
9d0026dc:	0263202b 	sltu	a0,s3,v1
9d0026e0:	54800017 	bnezl	a0,9d002740 <_ZN6SdFile7seekSetEm+0xd0>
9d0026e4:	8e42001c 	lw	v0,28(s2)
9d0026e8:	50400015 	beqzl	v0,9d002740 <_ZN6SdFile7seekSetEm+0xd0>
9d0026ec:	8e42001c 	lw	v0,28(s2)
    // must follow chain from first cluster
    curCluster_ = firstCluster_;
  } else {
    // advance from curPosition
    nNew -= nCur;
9d0026f0:	02639823 	subu	s3,s3,v1
  }
  while (nNew--) {
    if (!vol_->fatGet(curCluster_, &curCluster_)) return false;
9d0026f4:	0b4009c5 	j	9d002714 <_ZN6SdFile7seekSetEm+0xa4>
9d0026f8:	26500008 	addiu	s0,s2,8
9d0026fc:	8e440020 	lw	a0,32(s2)
9d002700:	8e450008 	lw	a1,8(s2)
9d002704:	0f400cb5 	jal	9d0032d4 <_ZNK8SdVolume6fatGetEmPm>
9d002708:	2673ffff 	addiu	s3,s3,-1
9d00270c:	10400018 	beqz	v0,9d002770 <_ZN6SdFile7seekSetEm+0x100>
9d002710:	8fbf0024 	lw	ra,36(sp)
    curCluster_ = firstCluster_;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
9d002714:	1660fff9 	bnez	s3,9d0026fc <_ZN6SdFile7seekSetEm+0x8c>
9d002718:	02003021 	move	a2,s0
    if (!vol_->fatGet(curCluster_, &curCluster_)) return false;
  }
  curPosition_ = pos;
9d00271c:	ae51000c 	sw	s1,12(s2)
  return true;
9d002720:	24020001 	li	v0,1
}
9d002724:	8fbf0024 	lw	ra,36(sp)
9d002728:	8fb30020 	lw	s3,32(sp)
9d00272c:	8fb2001c 	lw	s2,28(sp)
9d002730:	8fb10018 	lw	s1,24(sp)
9d002734:	8fb00014 	lw	s0,20(sp)
9d002738:	03e00008 	jr	ra
9d00273c:	27bd0028 	addiu	sp,sp,40
  uint32_t nCur = (curPosition_ - 1) >> (vol_->clusterSizeShift_ + 9);
  uint32_t nNew = (pos - 1) >> (vol_->clusterSizeShift_ + 9);

  if (nNew < nCur || curPosition_ == 0) {
    // must follow chain from first cluster
    curCluster_ = firstCluster_;
9d002740:	0b4009bd 	j	9d0026f4 <_ZN6SdFile7seekSetEm+0x84>
9d002744:	ae420008 	sw	v0,8(s2)
  while (nNew--) {
    if (!vol_->fatGet(curCluster_, &curCluster_)) return false;
  }
  curPosition_ = pos;
  return true;
}
9d002748:	8fbf0024 	lw	ra,36(sp)
    curPosition_ = pos;
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    curCluster_ = 0;
9d00274c:	ae400008 	sw	zero,8(s2)
    curPosition_ = 0;
9d002750:	ae40000c 	sw	zero,12(s2)
    return true;
9d002754:	24020001 	li	v0,1
  while (nNew--) {
    if (!vol_->fatGet(curCluster_, &curCluster_)) return false;
  }
  curPosition_ = pos;
  return true;
}
9d002758:	8fb30020 	lw	s3,32(sp)
9d00275c:	8fb2001c 	lw	s2,28(sp)
9d002760:	8fb10018 	lw	s1,24(sp)
9d002764:	8fb00014 	lw	s0,20(sp)
9d002768:	03e00008 	jr	ra
9d00276c:	27bd0028 	addiu	sp,sp,40
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (!vol_->fatGet(curCluster_, &curCluster_)) return false;
9d002770:	00001021 	move	v0,zero
  }
  curPosition_ = pos;
  return true;
}
9d002774:	8fb30020 	lw	s3,32(sp)
9d002778:	8fb2001c 	lw	s2,28(sp)
9d00277c:	8fb10018 	lw	s1,24(sp)
9d002780:	8fb00014 	lw	s0,20(sp)
9d002784:	03e00008 	jr	ra
9d002788:	27bd0028 	addiu	sp,sp,40

9d00278c <_ZN6SdFile4syncEv>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 * Reasons for failure include a call to sync() before a file has been
 * opened or an I/O error.
 */
uint8_t SdFile::sync(void) {
9d00278c:	27bdffe0 	addiu	sp,sp,-32
9d002790:	afb00018 	sw	s0,24(sp)
9d002794:	afbf001c 	sw	ra,28(sp)
  // only allow open files and directories
  if (!isOpen()) return false;
9d002798:	90820005 	lbu	v0,5(a0)
9d00279c:	10400007 	beqz	v0,9d0027bc <_ZN6SdFile4syncEv+0x30>
9d0027a0:	00808021 	move	s0,a0

  if (flags_ & F_FILE_DIR_DIRTY) {
9d0027a4:	80820004 	lb	v0,4(a0)
9d0027a8:	04400009 	bltz	v0,9d0027d0 <_ZN6SdFile4syncEv+0x44>
9d0027ac:	8fbf001c 	lw	ra,28(sp)
    }
    // clear directory dirty
    flags_ &= ~F_FILE_DIR_DIRTY;
  }
  return SdVolume::cacheFlush();
}
9d0027b0:	8fb00018 	lw	s0,24(sp)
      d->lastAccessDate = d->lastWriteDate;
    }
    // clear directory dirty
    flags_ &= ~F_FILE_DIR_DIRTY;
  }
  return SdVolume::cacheFlush();
9d0027b4:	0b400c68 	j	9d0031a0 <_ZN8SdVolume10cacheFlushEv>
9d0027b8:	27bd0020 	addiu	sp,sp,32
}
9d0027bc:	8fbf001c 	lw	ra,28(sp)
9d0027c0:	00001021 	move	v0,zero
9d0027c4:	8fb00018 	lw	s0,24(sp)
9d0027c8:	03e00008 	jr	ra
9d0027cc:	27bd0020 	addiu	sp,sp,32
uint8_t SdFile::sync(void) {
  // only allow open files and directories
  if (!isOpen()) return false;

  if (flags_ & F_FILE_DIR_DIRTY) {
    dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
9d0027d0:	0f400808 	jal	9d002020 <_ZN6SdFile13cacheDirEntryEh>
9d0027d4:	24050001 	li	a1,1
    if (!d) return false;
9d0027d8:	1040fff9 	beqz	v0,9d0027c0 <_ZN6SdFile4syncEv+0x34>
9d0027dc:	8fbf001c 	lw	ra,28(sp)

    // do not set filesize for dir files
    if (!isDir()) d->fileSize = fileSize_;
9d0027e0:	92030005 	lbu	v1,5(s0)
9d0027e4:	2c630002 	sltiu	v1,v1,2
9d0027e8:	5460001f 	bnezl	v1,9d002868 <_ZN6SdFile4syncEv+0xdc>
9d0027ec:	8e030018 	lw	v1,24(s0)

    // update first cluster fields
    d->firstClusterLow = firstCluster_ & 0XFFFF;
9d0027f0:	8e03001c 	lw	v1,28(s0)
9d0027f4:	3064ffff 	andi	a0,v1,0xffff
    d->firstClusterHigh = firstCluster_ >> 16;
9d0027f8:	00031c02 	srl	v1,v1,0x10
9d0027fc:	00032a02 	srl	a1,v1,0x8

    // do not set filesize for dir files
    if (!isDir()) d->fileSize = fileSize_;

    // update first cluster fields
    d->firstClusterLow = firstCluster_ & 0XFFFF;
9d002800:	00043202 	srl	a2,a0,0x8
9d002804:	a044001a 	sb	a0,26(v0)
9d002808:	a046001b 	sb	a2,27(v0)
    d->firstClusterHigh = firstCluster_ >> 16;
9d00280c:	a0430014 	sb	v1,20(v0)
9d002810:	a0450015 	sb	a1,21(v0)

    // set modify time if user supplied a callback date/time function
    if (dateTime_) {
9d002814:	8f83802c 	lw	v1,-32724(gp)
9d002818:	1060000c 	beqz	v1,9d00284c <_ZN6SdFile4syncEv+0xc0>
9d00281c:	24440018 	addiu	a0,v0,24
      dateTime_(&d->lastWriteDate, &d->lastWriteTime);
9d002820:	24450016 	addiu	a1,v0,22
9d002824:	0060f809 	jalr	v1
9d002828:	afa20010 	sw	v0,16(sp)
      d->lastAccessDate = d->lastWriteDate;
9d00282c:	8fa20010 	lw	v0,16(sp)
9d002830:	90430019 	lbu	v1,25(v0)
9d002834:	90440018 	lbu	a0,24(v0)
9d002838:	00031a00 	sll	v1,v1,0x8
9d00283c:	00641825 	or	v1,v1,a0
9d002840:	00032202 	srl	a0,v1,0x8
9d002844:	a0430012 	sb	v1,18(v0)
9d002848:	a0440013 	sb	a0,19(v0)
    }
    // clear directory dirty
    flags_ &= ~F_FILE_DIR_DIRTY;
9d00284c:	92020004 	lbu	v0,4(s0)
9d002850:	3042007f 	andi	v0,v0,0x7f
9d002854:	a2020004 	sb	v0,4(s0)
  }
  return SdVolume::cacheFlush();
}
9d002858:	8fbf001c 	lw	ra,28(sp)
9d00285c:	8fb00018 	lw	s0,24(sp)
      d->lastAccessDate = d->lastWriteDate;
    }
    // clear directory dirty
    flags_ &= ~F_FILE_DIR_DIRTY;
  }
  return SdVolume::cacheFlush();
9d002860:	0b400c68 	j	9d0031a0 <_ZN8SdVolume10cacheFlushEv>
9d002864:	27bd0020 	addiu	sp,sp,32
  if (flags_ & F_FILE_DIR_DIRTY) {
    dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
    if (!d) return false;

    // do not set filesize for dir files
    if (!isDir()) d->fileSize = fileSize_;
9d002868:	a843001f 	swl	v1,31(v0)
9d00286c:	0b4009fc 	j	9d0027f0 <_ZN6SdFile4syncEv+0x64>
9d002870:	b843001c 	swr	v1,28(v0)

9d002874 <_ZN6SdFile8truncateEm>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 * Reasons for failure include file is read only, file is a directory,
 * \a length is greater than the current file size or an I/O error occurs.
 */
uint8_t SdFile::truncate(uint32_t length) {
9d002874:	27bdffd0 	addiu	sp,sp,-48
9d002878:	afb30028 	sw	s3,40(sp)
9d00287c:	afb20024 	sw	s2,36(sp)
9d002880:	afb10020 	sw	s1,32(sp)
9d002884:	afbf002c 	sw	ra,44(sp)
9d002888:	afb0001c 	sw	s0,28(sp)
// error if not a normal file or read-only
  if (!isFile() || !(flags_ & O_WRITE)) return false;
9d00288c:	90830005 	lbu	v1,5(a0)
9d002890:	24020001 	li	v0,1
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 * Reasons for failure include file is read only, file is a directory,
 * \a length is greater than the current file size or an I/O error occurs.
 */
uint8_t SdFile::truncate(uint32_t length) {
9d002894:	00808821 	move	s1,a0
9d002898:	00a09821 	move	s3,a1
// error if not a normal file or read-only
  if (!isFile() || !(flags_ & O_WRITE)) return false;
9d00289c:	10620009 	beq	v1,v0,9d0028c4 <_ZN6SdFile8truncateEm+0x50>
9d0028a0:	00009021 	move	s2,zero

  if (!sync()) return false;

  // set file to correct position
  return seekSet(newPos);
}
9d0028a4:	8fbf002c 	lw	ra,44(sp)
9d0028a8:	02401021 	move	v0,s2
9d0028ac:	8fb30028 	lw	s3,40(sp)
9d0028b0:	8fb20024 	lw	s2,36(sp)
9d0028b4:	8fb10020 	lw	s1,32(sp)
9d0028b8:	8fb0001c 	lw	s0,28(sp)
9d0028bc:	03e00008 	jr	ra
9d0028c0:	27bd0030 	addiu	sp,sp,48
 * Reasons for failure include file is read only, file is a directory,
 * \a length is greater than the current file size or an I/O error occurs.
 */
uint8_t SdFile::truncate(uint32_t length) {
// error if not a normal file or read-only
  if (!isFile() || !(flags_ & O_WRITE)) return false;
9d0028c4:	90820004 	lbu	v0,4(a0)
9d0028c8:	30420002 	andi	v0,v0,0x2
9d0028cc:	1040fff6 	beqz	v0,9d0028a8 <_ZN6SdFile8truncateEm+0x34>
9d0028d0:	8fbf002c 	lw	ra,44(sp)

  // error if length is greater than current size
  if (length > fileSize_) return false;
9d0028d4:	8c820018 	lw	v0,24(a0)
9d0028d8:	0045182b 	sltu	v1,v0,a1
9d0028dc:	5460fff3 	bnezl	v1,9d0028ac <_ZN6SdFile8truncateEm+0x38>
9d0028e0:	02401021 	move	v0,s2

  // fileSize and length are zero - nothing to do
  if (fileSize_ == 0) return true;
9d0028e4:	1040fff0 	beqz	v0,9d0028a8 <_ZN6SdFile8truncateEm+0x34>
9d0028e8:	24120001 	li	s2,1

  // remember position for seek after truncation
  uint32_t newPos = curPosition_ > length ? length : curPosition_;

  // position to last cluster in truncated file
  if (!seekSet(length)) return false;
9d0028ec:	0f40099c 	jal	9d002670 <_ZN6SdFile7seekSetEm>
9d0028f0:	8e30000c 	lw	s0,12(s1)
9d0028f4:	1040ffeb 	beqz	v0,9d0028a4 <_ZN6SdFile8truncateEm+0x30>
9d0028f8:	00009021 	move	s2,zero

  if (length == 0) {
9d0028fc:	16600008 	bnez	s3,9d002920 <_ZN6SdFile8truncateEm+0xac>
9d002900:	8e240020 	lw	a0,32(s1)
    // free all clusters
    if (!vol_->freeChain(firstCluster_)) return false;
9d002904:	8e25001c 	lw	a1,28(s1)
9d002908:	0f400dc2 	jal	9d003708 <_ZN8SdVolume9freeChainEm>
9d00290c:	02609021 	move	s2,s3
9d002910:	1040ffe5 	beqz	v0,9d0028a8 <_ZN6SdFile8truncateEm+0x34>
9d002914:	8fbf002c 	lw	ra,44(sp)
    firstCluster_ = 0;
9d002918:	0b400a56 	j	9d002958 <_ZN6SdFile8truncateEm+0xe4>
9d00291c:	ae20001c 	sw	zero,28(s1)
  } else {
    uint32_t toFree;
    if (!vol_->fatGet(curCluster_, &toFree)) return false;
9d002920:	8e250008 	lw	a1,8(s1)
9d002924:	0f400cb5 	jal	9d0032d4 <_ZNK8SdVolume6fatGetEmPm>
9d002928:	27a60010 	addiu	a2,sp,16
9d00292c:	1040ffdd 	beqz	v0,9d0028a4 <_ZN6SdFile8truncateEm+0x30>
9d002930:	24020010 	li	v0,16

    if (!vol_->isEOC(toFree)) {
9d002934:	8e240020 	lw	a0,32(s1)
  uint8_t fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
  }
  uint8_t freeChain(uint32_t cluster);
  uint8_t isEOC(uint32_t cluster) const {
    return  cluster >= (fatType_ == 16 ? FAT16EOC_MIN : FAT32EOC_MIN);
9d002938:	90830020 	lbu	v1,32(a0)
9d00293c:	10620023 	beq	v1,v0,9d0029cc <_ZN6SdFile8truncateEm+0x158>
9d002940:	8fa50010 	lw	a1,16(sp)
9d002944:	3c020fff 	lui	v0,0xfff
9d002948:	3442fff8 	ori	v0,v0,0xfff8
9d00294c:	00a2102b 	sltu	v0,a1,v0
9d002950:	14400011 	bnez	v0,9d002998 <_ZN6SdFile8truncateEm+0x124>
9d002954:	00000000 	nop
    }
  }
  fileSize_ = length;

  // need to update directory entry
  flags_ |= F_FILE_DIR_DIRTY;
9d002958:	92230004 	lbu	v1,4(s1)
9d00295c:	2402ff80 	li	v0,-128

      // current cluster is end of chain
      if (!vol_->fatPutEOC(curCluster_)) return false;
    }
  }
  fileSize_ = length;
9d002960:	ae330018 	sw	s3,24(s1)

  // need to update directory entry
  flags_ |= F_FILE_DIR_DIRTY;
9d002964:	00621025 	or	v0,v1,v0
9d002968:	a2220004 	sb	v0,4(s1)

  if (!sync()) return false;
9d00296c:	0f4009e3 	jal	9d00278c <_ZN6SdFile4syncEv>
9d002970:	02202021 	move	a0,s1
9d002974:	1040ffcb 	beqz	v0,9d0028a4 <_ZN6SdFile8truncateEm+0x30>
9d002978:	00009021 	move	s2,zero

  // set file to correct position
  return seekSet(newPos);
9d00297c:	0213282b 	sltu	a1,s0,s3
9d002980:	0265800a 	movz	s0,s3,a1
9d002984:	02002821 	move	a1,s0
9d002988:	0f40099c 	jal	9d002670 <_ZN6SdFile7seekSetEm>
9d00298c:	02202021 	move	a0,s1
9d002990:	0b400a29 	j	9d0028a4 <_ZN6SdFile8truncateEm+0x30>
9d002994:	00409021 	move	s2,v0
    uint32_t toFree;
    if (!vol_->fatGet(curCluster_, &toFree)) return false;

    if (!vol_->isEOC(toFree)) {
      // free extra clusters
      if (!vol_->freeChain(toFree)) return false;
9d002998:	0f400dc2 	jal	9d003708 <_ZN8SdVolume9freeChainEm>
9d00299c:	00009021 	move	s2,zero
9d0029a0:	1040ffc1 	beqz	v0,9d0028a8 <_ZN6SdFile8truncateEm+0x34>
9d0029a4:	8fbf002c 	lw	ra,44(sp)
  static uint8_t cacheZeroBlock(uint32_t blockNumber);
  uint8_t chainSize(uint32_t beginCluster, uint32_t* size) const;
  uint8_t fatGet(uint32_t cluster, uint32_t* value) const;
  uint8_t fatPut(uint32_t cluster, uint32_t value);
  uint8_t fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
9d0029a8:	8e240020 	lw	a0,32(s1)
9d0029ac:	8e250008 	lw	a1,8(s1)
9d0029b0:	3c060fff 	lui	a2,0xfff
9d0029b4:	0f400d1e 	jal	9d003478 <_ZN8SdVolume6fatPutEmm>
9d0029b8:	34c6ffff 	ori	a2,a2,0xffff

      // current cluster is end of chain
      if (!vol_->fatPutEOC(curCluster_)) return false;
9d0029bc:	5440ffe7 	bnezl	v0,9d00295c <_ZN6SdFile8truncateEm+0xe8>
9d0029c0:	92230004 	lbu	v1,4(s1)

  if (!sync()) return false;

  // set file to correct position
  return seekSet(newPos);
}
9d0029c4:	0b400a2a 	j	9d0028a8 <_ZN6SdFile8truncateEm+0x34>
9d0029c8:	8fbf002c 	lw	ra,44(sp)
  }
  uint8_t freeChain(uint32_t cluster);
  uint8_t isEOC(uint32_t cluster) const {
    return  cluster >= (fatType_ == 16 ? FAT16EOC_MIN : FAT32EOC_MIN);
9d0029cc:	0b400a53 	j	9d00294c <_ZN6SdFile8truncateEm+0xd8>
9d0029d0:	3402fff8 	li	v0,0xfff8

9d0029d4 <_ZN6SdFile15openCachedEntryEhh>:
  // open cached entry
  return openCachedEntry(index & 0XF, oflag);
}
//------------------------------------------------------------------------------
// open a cached directory entry. Assumes vol_ is initializes
uint8_t SdFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
9d0029d4:	30a500ff 	andi	a1,a1,0xff
  // location of entry in cache
  dir_t* p = SdVolume::cacheBuffer_.dir + dirIndex;

  // write or truncate is an error for a directory or read-only file
  if (p->attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {
9d0029d8:	3c03a000 	lui	v1,0xa000
  // open cached entry
  return openCachedEntry(index & 0XF, oflag);
}
//------------------------------------------------------------------------------
// open a cached directory entry. Assumes vol_ is initializes
uint8_t SdFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
9d0029dc:	27bdffe0 	addiu	sp,sp,-32
  // location of entry in cache
  dir_t* p = SdVolume::cacheBuffer_.dir + dirIndex;

  // write or truncate is an error for a directory or read-only file
  if (p->attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {
9d0029e0:	24630a84 	addiu	v1,v1,2692
9d0029e4:	00051140 	sll	v0,a1,0x5
  // open cached entry
  return openCachedEntry(index & 0XF, oflag);
}
//------------------------------------------------------------------------------
// open a cached directory entry. Assumes vol_ is initializes
uint8_t SdFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
9d0029e8:	afb10014 	sw	s1,20(sp)
9d0029ec:	afb00010 	sw	s0,16(sp)
9d0029f0:	afbf001c 	sw	ra,28(sp)
9d0029f4:	afb20018 	sw	s2,24(sp)
  // location of entry in cache
  dir_t* p = SdVolume::cacheBuffer_.dir + dirIndex;

  // write or truncate is an error for a directory or read-only file
  if (p->attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {
9d0029f8:	00623821 	addu	a3,v1,v0
9d0029fc:	90e7000b 	lbu	a3,11(a3)
  // open cached entry
  return openCachedEntry(index & 0XF, oflag);
}
//------------------------------------------------------------------------------
// open a cached directory entry. Assumes vol_ is initializes
uint8_t SdFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
9d002a00:	00808021 	move	s0,a0
  // location of entry in cache
  dir_t* p = SdVolume::cacheBuffer_.dir + dirIndex;

  // write or truncate is an error for a directory or read-only file
  if (p->attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {
9d002a04:	30e70011 	andi	a3,a3,0x11
9d002a08:	10e00004 	beqz	a3,9d002a1c <_ZN6SdFile15openCachedEntryEhh+0x48>
9d002a0c:	30d100ff 	andi	s1,a2,0xff
    if (oflag & (O_WRITE | O_TRUNC)) return false;
9d002a10:	32240042 	andi	a0,s1,0x42
9d002a14:	14800032 	bnez	a0,9d002ae0 <_ZN6SdFile15openCachedEntryEhh+0x10c>
9d002a18:	8fbf001c 	lw	ra,28(sp)
  }
  // remember location of directory entry on SD
  dirIndex_ = dirIndex;
9d002a1c:	a2050014 	sb	a1,20(s0)
  dirBlock_ = SdVolume::cacheBlockNumber_;

  // copy first cluster number for directory fields
  firstCluster_ = (uint32_t)p->firstClusterHigh << 16;
9d002a20:	00621021 	addu	v0,v1,v0
  if (p->attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {
    if (oflag & (O_WRITE | O_TRUNC)) return false;
  }
  // remember location of directory entry on SD
  dirIndex_ = dirIndex;
  dirBlock_ = SdVolume::cacheBlockNumber_;
9d002a24:	8f838010 	lw	v1,-32752(gp)
9d002a28:	ae030010 	sw	v1,16(s0)

  // copy first cluster number for directory fields
  firstCluster_ = (uint32_t)p->firstClusterHigh << 16;
9d002a2c:	90430015 	lbu	v1,21(v0)
9d002a30:	90440014 	lbu	a0,20(v0)
9d002a34:	00031a00 	sll	v1,v1,0x8
9d002a38:	00641825 	or	v1,v1,a0
9d002a3c:	00031c00 	sll	v1,v1,0x10
9d002a40:	ae03001c 	sw	v1,28(s0)
  firstCluster_ |= p->firstClusterLow;
9d002a44:	9045001b 	lbu	a1,27(v0)
9d002a48:	9044001a 	lbu	a0,26(v0)
9d002a4c:	00052a00 	sll	a1,a1,0x8
9d002a50:	00a42825 	or	a1,a1,a0
9d002a54:	00652825 	or	a1,v1,a1
9d002a58:	ae05001c 	sw	a1,28(s0)
}
/** Mask for file/subdirectory tests */
uint8_t const DIR_ATT_FILE_TYPE_MASK = (DIR_ATT_VOLUME_ID | DIR_ATT_DIRECTORY);
/** Directory entry is for a file */
static inline uint8_t DIR_IS_FILE(const dir_t* dir) {
  return (dir->attributes & DIR_ATT_FILE_TYPE_MASK) == 0;
9d002a5c:	9043000b 	lbu	v1,11(v0)
9d002a60:	30630018 	andi	v1,v1,0x18

  // make sure it is a normal file or subdirectory
  if (DIR_IS_FILE(p)) {
9d002a64:	54600015 	bnezl	v1,9d002abc <_ZN6SdFile15openCachedEntryEhh+0xe8>
9d002a68:	24020010 	li	v0,16
    fileSize_ = p->fileSize;
9d002a6c:	8843001f 	lwl	v1,31(v0)
9d002a70:	9843001c 	lwr	v1,28(v0)
    type_ = FAT_FILE_TYPE_NORMAL;
9d002a74:	24020001 	li	v0,1
9d002a78:	a2020005 	sb	v0,5(s0)
  firstCluster_ = (uint32_t)p->firstClusterHigh << 16;
  firstCluster_ |= p->firstClusterLow;

  // make sure it is a normal file or subdirectory
  if (DIR_IS_FILE(p)) {
    fileSize_ = p->fileSize;
9d002a7c:	ae030018 	sw	v1,24(s0)
    type_ = FAT_FILE_TYPE_SUBDIR;
  } else {
    return false;
  }
  // save open flags for read/write
  flags_ = oflag & (O_ACCMODE | O_SYNC | O_APPEND);
9d002a80:	3222000f 	andi	v0,s1,0xf
  // set to start of file
  curCluster_ = 0;
  curPosition_ = 0;

  // truncate file to zero length if requested
  if (oflag & O_TRUNC) return truncate(0);
9d002a84:	32310040 	andi	s1,s1,0x40
    type_ = FAT_FILE_TYPE_SUBDIR;
  } else {
    return false;
  }
  // save open flags for read/write
  flags_ = oflag & (O_ACCMODE | O_SYNC | O_APPEND);
9d002a88:	a2020004 	sb	v0,4(s0)

  // set to start of file
  curCluster_ = 0;
9d002a8c:	ae000008 	sw	zero,8(s0)
  curPosition_ = 0;
9d002a90:	ae00000c 	sw	zero,12(s0)

  // truncate file to zero length if requested
  if (oflag & O_TRUNC) return truncate(0);
9d002a94:	1220000b 	beqz	s1,9d002ac4 <_ZN6SdFile15openCachedEntryEhh+0xf0>
9d002a98:	24120001 	li	s2,1
9d002a9c:	02002021 	move	a0,s0
  return true;
}
9d002aa0:	8fbf001c 	lw	ra,28(sp)
9d002aa4:	8fb20018 	lw	s2,24(sp)
9d002aa8:	8fb10014 	lw	s1,20(sp)
9d002aac:	8fb00010 	lw	s0,16(sp)
  // set to start of file
  curCluster_ = 0;
  curPosition_ = 0;

  // truncate file to zero length if requested
  if (oflag & O_TRUNC) return truncate(0);
9d002ab0:	00002821 	move	a1,zero
9d002ab4:	0b400a1d 	j	9d002874 <_ZN6SdFile8truncateEm>
9d002ab8:	27bd0020 	addiu	sp,sp,32

  // make sure it is a normal file or subdirectory
  if (DIR_IS_FILE(p)) {
    fileSize_ = p->fileSize;
    type_ = FAT_FILE_TYPE_NORMAL;
  } else if (DIR_IS_SUBDIR(p)) {
9d002abc:	1062000f 	beq	v1,v0,9d002afc <_ZN6SdFile15openCachedEntryEhh+0x128>
9d002ac0:	00009021 	move	s2,zero
  curPosition_ = 0;

  // truncate file to zero length if requested
  if (oflag & O_TRUNC) return truncate(0);
  return true;
}
9d002ac4:	8fbf001c 	lw	ra,28(sp)
9d002ac8:	02401021 	move	v0,s2
9d002acc:	8fb20018 	lw	s2,24(sp)
9d002ad0:	8fb10014 	lw	s1,20(sp)
9d002ad4:	8fb00010 	lw	s0,16(sp)
9d002ad8:	03e00008 	jr	ra
9d002adc:	27bd0020 	addiu	sp,sp,32
  // location of entry in cache
  dir_t* p = SdVolume::cacheBuffer_.dir + dirIndex;

  // write or truncate is an error for a directory or read-only file
  if (p->attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {
    if (oflag & (O_WRITE | O_TRUNC)) return false;
9d002ae0:	00009021 	move	s2,zero
  curPosition_ = 0;

  // truncate file to zero length if requested
  if (oflag & O_TRUNC) return truncate(0);
  return true;
}
9d002ae4:	02401021 	move	v0,s2
9d002ae8:	8fb20018 	lw	s2,24(sp)
9d002aec:	8fb10014 	lw	s1,20(sp)
9d002af0:	8fb00010 	lw	s0,16(sp)
9d002af4:	03e00008 	jr	ra
9d002af8:	27bd0020 	addiu	sp,sp,32
  // make sure it is a normal file or subdirectory
  if (DIR_IS_FILE(p)) {
    fileSize_ = p->fileSize;
    type_ = FAT_FILE_TYPE_NORMAL;
  } else if (DIR_IS_SUBDIR(p)) {
    if (!vol_->chainSize(firstCluster_, &fileSize_)) return false;
9d002afc:	8e040020 	lw	a0,32(s0)
9d002b00:	0f400cea 	jal	9d0033a8 <_ZNK8SdVolume9chainSizeEmPm>
9d002b04:	26060018 	addiu	a2,s0,24
9d002b08:	1040ffee 	beqz	v0,9d002ac4 <_ZN6SdFile15openCachedEntryEhh+0xf0>
9d002b0c:	24020004 	li	v0,4
    type_ = FAT_FILE_TYPE_SUBDIR;
9d002b10:	0b400aa0 	j	9d002a80 <_ZN6SdFile15openCachedEntryEhh+0xac>
9d002b14:	a2020005 	sb	v0,5(s0)

9d002b18 <_ZN6SdFile4openEPS_th>:
 * OR of flags O_READ, O_WRITE, O_TRUNC, and O_SYNC.
 *
 * See open() by fileName for definition of flags and return values.
 *
 */
uint8_t SdFile::open(SdFile* dirFile, uint16_t index, uint8_t oflag) {
9d002b18:	27bdffd8 	addiu	sp,sp,-40
9d002b1c:	afb30020 	sw	s3,32(sp)
9d002b20:	afb2001c 	sw	s2,28(sp)
9d002b24:	afb10018 	sw	s1,24(sp)
9d002b28:	afb00014 	sw	s0,20(sp)
9d002b2c:	afbf0024 	sw	ra,36(sp)
  // error if already open
  if (isOpen())return false;
9d002b30:	90820005 	lbu	v0,5(a0)
 * OR of flags O_READ, O_WRITE, O_TRUNC, and O_SYNC.
 *
 * See open() by fileName for definition of flags and return values.
 *
 */
uint8_t SdFile::open(SdFile* dirFile, uint16_t index, uint8_t oflag) {
9d002b34:	00808021 	move	s0,a0
9d002b38:	00a08821 	move	s1,a1
9d002b3c:	30d2ffff 	andi	s2,a2,0xffff
  // error if already open
  if (isOpen())return false;
9d002b40:	1440000b 	bnez	v0,9d002b70 <_ZN6SdFile4openEPS_th+0x58>
9d002b44:	30f300ff 	andi	s3,a3,0xff

  // don't open existing file if O_CREAT and O_EXCL - user call error
  if ((oflag & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL)) return false;
9d002b48:	32630030 	andi	v1,s3,0x30
9d002b4c:	24020030 	li	v0,48
9d002b50:	10620007 	beq	v1,v0,9d002b70 <_ZN6SdFile4openEPS_th+0x58>
9d002b54:	00a02021 	move	a0,a1

  vol_ = dirFile->vol_;
9d002b58:	8ca20020 	lw	v0,32(a1)

  // seek to location of entry
  if (!dirFile->seekSet(32 * index)) return false;
9d002b5c:	00122940 	sll	a1,s2,0x5
9d002b60:	0f40099c 	jal	9d002670 <_ZN6SdFile7seekSetEm>
9d002b64:	ae020020 	sw	v0,32(s0)
9d002b68:	14400009 	bnez	v0,9d002b90 <_ZN6SdFile4openEPS_th+0x78>
9d002b6c:	00000000 	nop
      p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') {
    return false;
  }
  // open cached entry
  return openCachedEntry(index & 0XF, oflag);
}
9d002b70:	8fbf0024 	lw	ra,36(sp)
9d002b74:	00001021 	move	v0,zero
9d002b78:	8fb30020 	lw	s3,32(sp)
9d002b7c:	8fb2001c 	lw	s2,28(sp)
9d002b80:	8fb10018 	lw	s1,24(sp)
9d002b84:	8fb00014 	lw	s0,20(sp)
9d002b88:	03e00008 	jr	ra
9d002b8c:	27bd0028 	addiu	sp,sp,40

  // seek to location of entry
  if (!dirFile->seekSet(32 * index)) return false;

  // read entry into cache
  dir_t* p = dirFile->readDirCache();
9d002b90:	0f40097c 	jal	9d0025f0 <_ZN6SdFile12readDirCacheEv>
9d002b94:	02202021 	move	a0,s1
  if (p == NULL) return false;
9d002b98:	1040fff6 	beqz	v0,9d002b74 <_ZN6SdFile4openEPS_th+0x5c>
9d002b9c:	8fbf0024 	lw	ra,36(sp)

  // error if empty slot or '.' or '..'
  if (p->name[0] == DIR_NAME_FREE ||
9d002ba0:	90420000 	lbu	v0,0(v0)
9d002ba4:	1040fff3 	beqz	v0,9d002b74 <_ZN6SdFile4openEPS_th+0x5c>
9d002ba8:	240300e5 	li	v1,229
9d002bac:	1043fff1 	beq	v0,v1,9d002b74 <_ZN6SdFile4openEPS_th+0x5c>
9d002bb0:	2403002e 	li	v1,46
9d002bb4:	1043ffef 	beq	v0,v1,9d002b74 <_ZN6SdFile4openEPS_th+0x5c>
9d002bb8:	02002021 	move	a0,s0
      p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') {
    return false;
  }
  // open cached entry
  return openCachedEntry(index & 0XF, oflag);
9d002bbc:	3245000f 	andi	a1,s2,0xf
9d002bc0:	02603021 	move	a2,s3
}
9d002bc4:	8fbf0024 	lw	ra,36(sp)
9d002bc8:	8fb30020 	lw	s3,32(sp)
9d002bcc:	8fb2001c 	lw	s2,28(sp)
9d002bd0:	8fb10018 	lw	s1,24(sp)
9d002bd4:	8fb00014 	lw	s0,20(sp)
  if (p->name[0] == DIR_NAME_FREE ||
      p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') {
    return false;
  }
  // open cached entry
  return openCachedEntry(index & 0XF, oflag);
9d002bd8:	0b400a75 	j	9d0029d4 <_ZN6SdFile15openCachedEntryEhh>
9d002bdc:	27bd0028 	addiu	sp,sp,40

9d002be0 <_ZN6SdFile2lsEhh>:
 * LS_R - Recursive list of subdirectories.
 *
 * \param[in] indent Amount of space before file name. Used for recursive
 * list to indicate subdirectory level.
 */
void SdFile::ls(uint8_t flags, uint8_t indent) {
9d002be0:	27bdffa0 	addiu	sp,sp,-96
9d002be4:	afb20040 	sw	s2,64(sp)
9d002be8:	afb00038 	sw	s0,56(sp)
9d002bec:	30b200ff 	andi	s2,a1,0xff
9d002bf0:	30d000ff 	andi	s0,a2,0xff
9d002bf4:	afb70054 	sw	s7,84(sp)
9d002bf8:	afb60050 	sw	s6,80(sp)
9d002bfc:	afb40048 	sw	s4,72(sp)

    // print any indent spaces
    for (int8_t i = 0; i < indent; i++) Serial.print(' ');

    // print file name with possible blank fill
    printDirName(*p, flags & (LS_DATE | LS_SIZE) ? 14 : 0);
9d002c00:	32420003 	andi	v0,s2,0x3
9d002c04:	2414000e 	li	s4,14

    // list subdirectory content if requested
    if ((flags & LS_R) && DIR_IS_SUBDIR(p)) {
      uint16_t index = curPosition()/32 - 1;
      SdFile s;
      if (s.open(this, index, O_READ)) s.ls(flags, indent + 2);
9d002c08:	26170002 	addiu	s7,s0,2
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
9d002c0c:	3c169d00 	lui	s6,0x9d00
 * LS_R - Recursive list of subdirectories.
 *
 * \param[in] indent Amount of space before file name. Used for recursive
 * list to indicate subdirectory level.
 */
void SdFile::ls(uint8_t flags, uint8_t indent) {
9d002c10:	afb5004c 	sw	s5,76(sp)
9d002c14:	afb1003c 	sw	s1,60(sp)
9d002c18:	afbf005c 	sw	ra,92(sp)
9d002c1c:	afbe0058 	sw	s8,88(sp)
9d002c20:	afb30044 	sw	s3,68(sp)
9d002c24:	00808821 	move	s1,a0
  int8_t readDir(dir_t* dir);
  static uint8_t remove(SdFile* dirFile, const char* fileName);
  uint8_t remove(void);
  /** Set the file's current position to zero. */
  void rewind(void) {
    curPosition_ = curCluster_ = 0;
9d002c28:	ac800008 	sw	zero,8(a0)
9d002c2c:	ac80000c 	sw	zero,12(a0)

    // print any indent spaces
    for (int8_t i = 0; i < indent; i++) Serial.print(' ');

    // print file name with possible blank fill
    printDirName(*p, flags & (LS_DATE | LS_SIZE) ? 14 : 0);
9d002c30:	0002a00a 	movz	s4,zero,v0

    // print modify date/time if requested
    if (flags & LS_DATE) {
9d002c34:	32550001 	andi	s5,s2,0x1
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
9d002c38:	26d67d20 	addiu	s6,s6,32032

    // list subdirectory content if requested
    if ((flags & LS_R) && DIR_IS_SUBDIR(p)) {
      uint16_t index = curPosition()/32 - 1;
      SdFile s;
      if (s.open(this, index, O_READ)) s.ls(flags, indent + 2);
9d002c3c:	32f700ff 	andi	s7,s7,0xff
 */
void SdFile::ls(uint8_t flags, uint8_t indent) {
  dir_t* p;

  rewind();
  while ((p = readDirCache())) {
9d002c40:	0f40097c 	jal	9d0025f0 <_ZN6SdFile12readDirCacheEv>
9d002c44:	02202021 	move	a0,s1
9d002c48:	1040004c 	beqz	v0,9d002d7c <_ZN6SdFile2lsEhh+0x19c>
9d002c4c:	00409821 	move	s3,v0
    // done if past last used entry
    if (p->name[0] == DIR_NAME_FREE) break;
9d002c50:	92620000 	lbu	v0,0(s3)
9d002c54:	10400049 	beqz	v0,9d002d7c <_ZN6SdFile2lsEhh+0x19c>
9d002c58:	240300e5 	li	v1,229

    // skip deleted entry and entries for . and  ..
    if (p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') continue;
9d002c5c:	1043fff8 	beq	v0,v1,9d002c40 <_ZN6SdFile2lsEhh+0x60>
9d002c60:	2403002e 	li	v1,46
9d002c64:	1043fff6 	beq	v0,v1,9d002c40 <_ZN6SdFile2lsEhh+0x60>
9d002c68:	00000000 	nop
static inline uint8_t DIR_IS_SUBDIR(const dir_t* dir) {
  return (dir->attributes & DIR_ATT_FILE_TYPE_MASK) == DIR_ATT_DIRECTORY;
}
/** Directory entry is for a file or subdirectory */
static inline uint8_t DIR_IS_FILE_OR_SUBDIR(const dir_t* dir) {
  return (dir->attributes & DIR_ATT_VOLUME_ID) == 0;
9d002c6c:	9262000b 	lbu	v0,11(s3)
9d002c70:	30420008 	andi	v0,v0,0x8

    // only list subdirectories and files
    if (!DIR_IS_FILE_OR_SUBDIR(p)) continue;
9d002c74:	1440fff2 	bnez	v0,9d002c40 <_ZN6SdFile2lsEhh+0x60>
9d002c78:	00000000 	nop

    // print any indent spaces
    for (int8_t i = 0; i < indent; i++) Serial.print(' ');
9d002c7c:	1200000b 	beqz	s0,9d002cac <_ZN6SdFile2lsEhh+0xcc>
9d002c80:	02602021 	move	a0,s3
9d002c84:	0000f021 	move	s8,zero
9d002c88:	27848060 	addiu	a0,gp,-32672
9d002c8c:	24050020 	li	a1,32
9d002c90:	00003021 	move	a2,zero
9d002c94:	0f401365 	jal	9d004d94 <_ZN5Print5printEci>
9d002c98:	27de0001 	addiu	s8,s8,1
9d002c9c:	03d0102a 	slt	v0,s8,s0
9d002ca0:	1440fffa 	bnez	v0,9d002c8c <_ZN6SdFile2lsEhh+0xac>
9d002ca4:	27848060 	addiu	a0,gp,-32672

    // print file name with possible blank fill
    printDirName(*p, flags & (LS_DATE | LS_SIZE) ? 14 : 0);
9d002ca8:	02602021 	move	a0,s3
9d002cac:	0f400851 	jal	9d002144 <_ZN6SdFile12printDirNameERK14directoryEntryh>
9d002cb0:	02802821 	move	a1,s4

    // print modify date/time if requested
    if (flags & LS_DATE) {
9d002cb4:	56a0003d 	bnezl	s5,9d002dac <_ZN6SdFile2lsEhh+0x1cc>
9d002cb8:	92640019 	lbu	a0,25(s3)
static inline uint8_t DIR_IS_FILE(const dir_t* dir) {
  return (dir->attributes & DIR_ATT_FILE_TYPE_MASK) == 0;
}
/** Directory entry is for a subdirectory */
static inline uint8_t DIR_IS_SUBDIR(const dir_t* dir) {
  return (dir->attributes & DIR_ATT_FILE_TYPE_MASK) == DIR_ATT_DIRECTORY;
9d002cbc:	9263000b 	lbu	v1,11(s3)
       printFatDate(p->lastWriteDate);
       Serial.print(' ');
       printFatTime(p->lastWriteTime);
    }
    // print size if requested
    if (!DIR_IS_SUBDIR(p) && (flags & LS_SIZE)) {
9d002cc0:	24020010 	li	v0,16
9d002cc4:	30630018 	andi	v1,v1,0x18
9d002cc8:	1062000b 	beq	v1,v0,9d002cf8 <_ZN6SdFile2lsEhh+0x118>
9d002ccc:	32420002 	andi	v0,s2,0x2
9d002cd0:	10400009 	beqz	v0,9d002cf8 <_ZN6SdFile2lsEhh+0x118>
9d002cd4:	27848060 	addiu	a0,gp,-32672
      Serial.print(' ');
9d002cd8:	24050020 	li	a1,32
9d002cdc:	0f401365 	jal	9d004d94 <_ZN5Print5printEci>
9d002ce0:	00003021 	move	a2,zero
      Serial.print(p->fileSize);
9d002ce4:	8a65001f 	lwl	a1,31(s3)
9d002ce8:	27848060 	addiu	a0,gp,-32672
9d002cec:	2406000a 	li	a2,10
9d002cf0:	0f401337 	jal	9d004cdc <_ZN5Print5printEmi>
9d002cf4:	9a65001c 	lwr	a1,28(s3)
    }
    Serial.println();
9d002cf8:	0f401367 	jal	9d004d9c <_ZN5Print7printlnEv>
9d002cfc:	27848060 	addiu	a0,gp,-32672

    // list subdirectory content if requested
    if ((flags & LS_R) && DIR_IS_SUBDIR(p)) {
9d002d00:	32420004 	andi	v0,s2,0x4
9d002d04:	1040ffce 	beqz	v0,9d002c40 <_ZN6SdFile2lsEhh+0x60>
9d002d08:	24020010 	li	v0,16
9d002d0c:	9263000b 	lbu	v1,11(s3)
9d002d10:	30630018 	andi	v1,v1,0x18
9d002d14:	1462ffca 	bne	v1,v0,9d002c40 <_ZN6SdFile2lsEhh+0x60>
9d002d18:	27a40010 	addiu	a0,sp,16
      uint16_t index = curPosition()/32 - 1;
9d002d1c:	8e33000c 	lw	s3,12(s1)
      SdFile s;
      if (s.open(this, index, O_READ)) s.ls(flags, indent + 2);
9d002d20:	02202821 	move	a1,s1
    }
    Serial.println();

    // list subdirectory content if requested
    if ((flags & LS_R) && DIR_IS_SUBDIR(p)) {
      uint16_t index = curPosition()/32 - 1;
9d002d24:	00139942 	srl	s3,s3,0x5
9d002d28:	2673ffff 	addiu	s3,s3,-1
9d002d2c:	3273ffff 	andi	s3,s3,0xffff
      SdFile s;
      if (s.open(this, index, O_READ)) s.ls(flags, indent + 2);
9d002d30:	02603021 	move	a2,s3
9d002d34:	24070001 	li	a3,1
9d002d38:	afb60010 	sw	s6,16(sp)
9d002d3c:	0f400ac6 	jal	9d002b18 <_ZN6SdFile4openEPS_th>
9d002d40:	a3a00015 	sb	zero,21(sp)
9d002d44:	50400006 	beqzl	v0,9d002d60 <_ZN6SdFile2lsEhh+0x180>
9d002d48:	26650001 	addiu	a1,s3,1
9d002d4c:	27a40010 	addiu	a0,sp,16
9d002d50:	02402821 	move	a1,s2
9d002d54:	0f400af8 	jal	9d002be0 <_ZN6SdFile2lsEhh>
9d002d58:	02e03021 	move	a2,s7
      seekSet(32 * (index + 1));
9d002d5c:	26650001 	addiu	a1,s3,1
9d002d60:	02202021 	move	a0,s1
9d002d64:	0f40099c 	jal	9d002670 <_ZN6SdFile7seekSetEm>
9d002d68:	00052940 	sll	a1,a1,0x5
 */
void SdFile::ls(uint8_t flags, uint8_t indent) {
  dir_t* p;

  rewind();
  while ((p = readDirCache())) {
9d002d6c:	0f40097c 	jal	9d0025f0 <_ZN6SdFile12readDirCacheEv>
9d002d70:	02202021 	move	a0,s1
9d002d74:	1440ffb6 	bnez	v0,9d002c50 <_ZN6SdFile2lsEhh+0x70>
9d002d78:	00409821 	move	s3,v0
      SdFile s;
      if (s.open(this, index, O_READ)) s.ls(flags, indent + 2);
      seekSet(32 * (index + 1));
    }
  }
}
9d002d7c:	8fbf005c 	lw	ra,92(sp)
9d002d80:	8fbe0058 	lw	s8,88(sp)
9d002d84:	8fb70054 	lw	s7,84(sp)
9d002d88:	8fb60050 	lw	s6,80(sp)
9d002d8c:	8fb5004c 	lw	s5,76(sp)
9d002d90:	8fb40048 	lw	s4,72(sp)
9d002d94:	8fb30044 	lw	s3,68(sp)
9d002d98:	8fb20040 	lw	s2,64(sp)
9d002d9c:	8fb1003c 	lw	s1,60(sp)
9d002da0:	8fb00038 	lw	s0,56(sp)
9d002da4:	03e00008 	jr	ra
9d002da8:	27bd0060 	addiu	sp,sp,96
    // print file name with possible blank fill
    printDirName(*p, flags & (LS_DATE | LS_SIZE) ? 14 : 0);

    // print modify date/time if requested
    if (flags & LS_DATE) {
       printFatDate(p->lastWriteDate);
9d002dac:	92620018 	lbu	v0,24(s3)
9d002db0:	00042200 	sll	a0,a0,0x8
9d002db4:	0f4008c7 	jal	9d00231c <_ZN6SdFile12printFatDateEt>
9d002db8:	00822025 	or	a0,a0,v0
       Serial.print(' ');
9d002dbc:	27848060 	addiu	a0,gp,-32672
9d002dc0:	24050020 	li	a1,32
9d002dc4:	0f401365 	jal	9d004d94 <_ZN5Print5printEci>
9d002dc8:	00003021 	move	a2,zero
       printFatTime(p->lastWriteTime);
9d002dcc:	92640017 	lbu	a0,23(s3)
9d002dd0:	92620016 	lbu	v0,22(s3)
9d002dd4:	00042200 	sll	a0,a0,0x8
9d002dd8:	0f4008b1 	jal	9d0022c4 <_ZN6SdFile12printFatTimeEt>
9d002ddc:	00822025 	or	a0,a0,v0
9d002de0:	0b400b30 	j	9d002cc0 <_ZN6SdFile2lsEhh+0xe0>
9d002de4:	9263000b 	lbu	v1,11(s3)

9d002de8 <_ZN6SdFile5writeEPKvt>:
 * \a nbyte.  If an error occurs, write() returns -1.  Possible errors
 * include write() is called before a file has been opened, write is called
 * for a read-only file, device is full, a corrupt file system or an I/O error.
 *
 */
size_t SdFile::write(const void* buf, uint16_t nbyte) {
9d002de8:	27bdffb8 	addiu	sp,sp,-72
9d002dec:	afbe0040 	sw	s8,64(sp)
9d002df0:	afb3002c 	sw	s3,44(sp)
9d002df4:	afb10024 	sw	s1,36(sp)
9d002df8:	afb00020 	sw	s0,32(sp)
9d002dfc:	afbf0044 	sw	ra,68(sp)
9d002e00:	afb7003c 	sw	s7,60(sp)
9d002e04:	afb60038 	sw	s6,56(sp)
9d002e08:	afb50034 	sw	s5,52(sp)
9d002e0c:	afb40030 	sw	s4,48(sp)
9d002e10:	afb20028 	sw	s2,40(sp)

  // number of bytes left to write  -  must be before goto statements
  uint16_t nToWrite = nbyte;

  // error if not a normal file or is read-only
  if (!isFile() || !(flags_ & O_WRITE)) goto writeErrorReturn;
9d002e14:	90820005 	lbu	v0,5(a0)
9d002e18:	24030001 	li	v1,1
 * \a nbyte.  If an error occurs, write() returns -1.  Possible errors
 * include write() is called before a file has been opened, write is called
 * for a read-only file, device is full, a corrupt file system or an I/O error.
 *
 */
size_t SdFile::write(const void* buf, uint16_t nbyte) {
9d002e1c:	00809821 	move	s3,a0
9d002e20:	00a0f021 	move	s8,a1
9d002e24:	30d1ffff 	andi	s1,a2,0xffff

  // number of bytes left to write  -  must be before goto statements
  uint16_t nToWrite = nbyte;

  // error if not a normal file or is read-only
  if (!isFile() || !(flags_ & O_WRITE)) goto writeErrorReturn;
9d002e28:	1043000e 	beq	v0,v1,9d002e64 <_ZN6SdFile5writeEPKvt+0x7c>
9d002e2c:	00008021 	move	s0,zero
 writeErrorReturn:
  // return for write error
  //writeError = true;
  //setWriteError();
  return 0;
}
9d002e30:	8fbf0044 	lw	ra,68(sp)
9d002e34:	02001021 	move	v0,s0
9d002e38:	8fbe0040 	lw	s8,64(sp)
9d002e3c:	8fb7003c 	lw	s7,60(sp)
9d002e40:	8fb60038 	lw	s6,56(sp)
9d002e44:	8fb50034 	lw	s5,52(sp)
9d002e48:	8fb40030 	lw	s4,48(sp)
9d002e4c:	8fb3002c 	lw	s3,44(sp)
9d002e50:	8fb20028 	lw	s2,40(sp)
9d002e54:	8fb10024 	lw	s1,36(sp)
9d002e58:	8fb00020 	lw	s0,32(sp)
9d002e5c:	03e00008 	jr	ra
9d002e60:	27bd0048 	addiu	sp,sp,72

  // number of bytes left to write  -  must be before goto statements
  uint16_t nToWrite = nbyte;

  // error if not a normal file or is read-only
  if (!isFile() || !(flags_ & O_WRITE)) goto writeErrorReturn;
9d002e64:	90820004 	lbu	v0,4(a0)
9d002e68:	30430002 	andi	v1,v0,0x2
9d002e6c:	1060fff1 	beqz	v1,9d002e34 <_ZN6SdFile5writeEPKvt+0x4c>
9d002e70:	8fbf0044 	lw	ra,68(sp)

  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
9d002e74:	30420004 	andi	v0,v0,0x4
9d002e78:	10400009 	beqz	v0,9d002ea0 <_ZN6SdFile5writeEPKvt+0xb8>
9d002e7c:	8e76000c 	lw	s6,12(s3)
9d002e80:	8e650018 	lw	a1,24(s3)
9d002e84:	12c50006 	beq	s6,a1,9d002ea0 <_ZN6SdFile5writeEPKvt+0xb8>
9d002e88:	00000000 	nop
  }
  /**
   *  Set the files current position to end of file.  Useful to position
   *  a file for append. See seekSet().
   */
  uint8_t seekEnd(void) {return seekSet(fileSize_);}
9d002e8c:	0f40099c 	jal	9d002670 <_ZN6SdFile7seekSetEm>
9d002e90:	00000000 	nop
    if (!seekEnd()) goto writeErrorReturn;
9d002e94:	1040ffe7 	beqz	v0,9d002e34 <_ZN6SdFile5writeEPKvt+0x4c>
9d002e98:	8fbf0044 	lw	ra,68(sp)
9d002e9c:	8e76000c 	lw	s6,12(s3)
  }

  while (nToWrite > 0) {
9d002ea0:	52200032 	beqzl	s1,9d002f6c <_ZN6SdFile5writeEPKvt+0x184>
9d002ea4:	8e620018 	lw	v0,24(s3)
  uint8_t fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
  }
  uint8_t freeChain(uint32_t cluster);
  uint8_t isEOC(uint32_t cluster) const {
    return  cluster >= (fatType_ == 16 ? FAT16EOC_MIN : FAT32EOC_MIN);
9d002ea8:	3c120fff 	lui	s2,0xfff
        // rewrite part of block
        if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) {
          goto writeErrorReturn;
        }
      }
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
9d002eac:	3c10a000 	lui	s0,0xa000
 * for a read-only file, device is full, a corrupt file system or an I/O error.
 *
 */
size_t SdFile::write(const void* buf, uint16_t nbyte) {
  // convert void* to uint8_t*  -  must be before goto statements
  const uint8_t* src = reinterpret_cast<const uint8_t*>(buf);
9d002eb0:	0220a821 	move	s5,s1
9d002eb4:	3652fff8 	ori	s2,s2,0xfff8
        // rewrite part of block
        if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) {
          goto writeErrorReturn;
        }
      }
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
9d002eb8:	26100a84 	addiu	s0,s0,2692
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    if (!seekEnd()) goto writeErrorReturn;
  }

  while (nToWrite > 0) {
    uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
9d002ebc:	8e640020 	lw	a0,32(s3)
  uint16_t rootDirEntryCount_;  // number of entries in FAT16 root dir
  uint32_t rootDirStart_;       // root start block for FAT16, cluster for FAT32
  //----------------------------------------------------------------------------
  uint8_t allocContiguous(uint32_t count, uint32_t* curCluster);
  uint8_t blockOfCluster(uint32_t position) const {
          return (position >> 9) & (blocksPerCluster_ - 1);}
9d002ec0:	00161242 	srl	v0,s6,0x9
9d002ec4:	90970004 	lbu	s7,4(a0)
9d002ec8:	26f7ffff 	addiu	s7,s7,-1
9d002ecc:	0057b824 	and	s7,v0,s7
9d002ed0:	32f700ff 	andi	s7,s7,0xff
    uint16_t blockOffset = curPosition_ & 0X1FF;
    if (blockOfCluster == 0 && blockOffset == 0) {
9d002ed4:	16e0004e 	bnez	s7,9d003010 <_ZN6SdFile5writeEPKvt+0x228>
9d002ed8:	32d601ff 	andi	s6,s6,0x1ff
9d002edc:	56c0004d 	bnezl	s6,9d003014 <_ZN6SdFile5writeEPKvt+0x22c>
9d002ee0:	24020200 	li	v0,512
      // start of new cluster
      if (curCluster_ == 0) {
9d002ee4:	8e650008 	lw	a1,8(s3)
9d002ee8:	14a00038 	bnez	a1,9d002fcc <_ZN6SdFile5writeEPKvt+0x1e4>
9d002eec:	00000000 	nop
        if (firstCluster_ == 0) {
9d002ef0:	8e63001c 	lw	v1,28(s3)
9d002ef4:	10600041 	beqz	v1,9d002ffc <_ZN6SdFile5writeEPKvt+0x214>
9d002ef8:	24020200 	li	v0,512
          curCluster_ = next;
        }
      }
    }
    // max space in block
    uint16_t n = 512 - blockOffset;
9d002efc:	0056a023 	subu	s4,v0,s6
9d002f00:	3294ffff 	andi	s4,s4,0xffff

    // lesser of space and amount to write
    if (n > nToWrite) n = nToWrite;
9d002f04:	02b4282b 	sltu	a1,s5,s4
9d002f08:	14a00047 	bnez	a1,9d003028 <_ZN6SdFile5writeEPKvt+0x240>
9d002f0c:	ae630008 	sw	v1,8(s3)
  uint32_t clusterStartBlock(uint32_t cluster) const {
           return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);}
9d002f10:	8c850014 	lw	a1,20(a0)
9d002f14:	90840010 	lbu	a0,16(a0)
9d002f18:	2463fffe 	addiu	v1,v1,-2
9d002f1c:	02e5b821 	addu	s7,s7,a1
9d002f20:	00831804 	sllv	v1,v1,a0

    // block for data write
    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
    if (n == 512) {
9d002f24:	16820047 	bne	s4,v0,9d003044 <_ZN6SdFile5writeEPKvt+0x25c>
9d002f28:	02e32821 	addu	a1,s7,v1
      // full block - don't need to use cache
      // invalidate cache if block is in cache
      if (SdVolume::cacheBlockNumber_ == block) {
9d002f2c:	8f828010 	lw	v0,-32752(gp)
9d002f30:	1045006c 	beq	v0,a1,9d0030e4 <_ZN6SdFile5writeEPKvt+0x2fc>
9d002f34:	2402ffff 	li	v0,-1
  uint8_t readData(uint32_t block, uint16_t offset,
    uint16_t count, uint8_t* dst) {
      return sdCard_->readData(block, offset, count, dst);
  }
  uint8_t writeBlock(uint32_t block, const uint8_t* dst) {
    return sdCard_->writeBlock(block, dst);
9d002f38:	8f848030 	lw	a0,-32720(gp)
9d002f3c:	0f4007b7 	jal	9d001edc <_ZN7Sd2Card10writeBlockEmPKh>
9d002f40:	03c03021 	move	a2,s8
        SdVolume::cacheBlockNumber_ = 0XFFFFFFFF;
      }
      if (!vol_->writeBlock(block, src)) goto writeErrorReturn;
9d002f44:	10400069 	beqz	v0,9d0030ec <_ZN6SdFile5writeEPKvt+0x304>
9d002f48:	27de0200 	addiu	s8,s8,512
      src += 512;
9d002f4c:	24160200 	li	s6,512
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
      uint8_t* end = dst + n;
      while (dst != end) *dst++ = *src++;
    }
    nToWrite -= n;
    curPosition_ += n;
9d002f50:	8e62000c 	lw	v0,12(s3)
      }
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
      uint8_t* end = dst + n;
      while (dst != end) *dst++ = *src++;
    }
    nToWrite -= n;
9d002f54:	02b4a823 	subu	s5,s5,s4
9d002f58:	32b5ffff 	andi	s5,s5,0xffff
    curPosition_ += n;
9d002f5c:	02c2b021 	addu	s6,s6,v0
  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    if (!seekEnd()) goto writeErrorReturn;
  }

  while (nToWrite > 0) {
9d002f60:	16a0ffd6 	bnez	s5,9d002ebc <_ZN6SdFile5writeEPKvt+0xd4>
9d002f64:	ae76000c 	sw	s6,12(s3)
      while (dst != end) *dst++ = *src++;
    }
    nToWrite -= n;
    curPosition_ += n;
  }
  if (curPosition_ > fileSize_) {
9d002f68:	8e620018 	lw	v0,24(s3)
9d002f6c:	0056102b 	sltu	v0,v0,s6
9d002f70:	1040006c 	beqz	v0,9d003124 <_ZN6SdFile5writeEPKvt+0x33c>
9d002f74:	8f82802c 	lw	v0,-32724(gp)
    // update fileSize and insure sync will update dir entry
    fileSize_ = curPosition_;
    flags_ |= F_FILE_DIR_DIRTY;
9d002f78:	92620004 	lbu	v0,4(s3)
    nToWrite -= n;
    curPosition_ += n;
  }
  if (curPosition_ > fileSize_) {
    // update fileSize and insure sync will update dir entry
    fileSize_ = curPosition_;
9d002f7c:	ae760018 	sw	s6,24(s3)
    flags_ |= F_FILE_DIR_DIRTY;
9d002f80:	3042007f 	andi	v0,v0,0x7f
9d002f84:	34420080 	ori	v0,v0,0x80
9d002f88:	a2620004 	sb	v0,4(s3)
  } else if (dateTime_ && nbyte) {
    // insure sync will update modified date and time
    flags_ |= F_FILE_DIR_DIRTY;
  }

  if (flags_ & O_SYNC) {
9d002f8c:	30420008 	andi	v0,v0,0x8
9d002f90:	14400045 	bnez	v0,9d0030a8 <_ZN6SdFile5writeEPKvt+0x2c0>
9d002f94:	02208021 	move	s0,s1
 writeErrorReturn:
  // return for write error
  //writeError = true;
  //setWriteError();
  return 0;
}
9d002f98:	8fbf0044 	lw	ra,68(sp)
9d002f9c:	02001021 	move	v0,s0
9d002fa0:	8fbe0040 	lw	s8,64(sp)
9d002fa4:	8fb7003c 	lw	s7,60(sp)
9d002fa8:	8fb60038 	lw	s6,56(sp)
9d002fac:	8fb50034 	lw	s5,52(sp)
9d002fb0:	8fb40030 	lw	s4,48(sp)
9d002fb4:	8fb3002c 	lw	s3,44(sp)
9d002fb8:	8fb20028 	lw	s2,40(sp)
9d002fbc:	8fb10024 	lw	s1,36(sp)
9d002fc0:	8fb00020 	lw	s0,32(sp)
9d002fc4:	03e00008 	jr	ra
9d002fc8:	27bd0048 	addiu	sp,sp,72
        } else {
          curCluster_ = firstCluster_;
        }
      } else {
        uint32_t next;
        if (!vol_->fatGet(curCluster_, &next)) return false;
9d002fcc:	0f400cb5 	jal	9d0032d4 <_ZNK8SdVolume6fatGetEmPm>
9d002fd0:	27a60010 	addiu	a2,sp,16
9d002fd4:	10400045 	beqz	v0,9d0030ec <_ZN6SdFile5writeEPKvt+0x304>
9d002fd8:	8fa30010 	lw	v1,16(sp)
        if (vol_->isEOC(next)) {
9d002fdc:	8e640020 	lw	a0,32(s3)
  uint8_t fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
  }
  uint8_t freeChain(uint32_t cluster);
  uint8_t isEOC(uint32_t cluster) const {
    return  cluster >= (fatType_ == 16 ? FAT16EOC_MIN : FAT32EOC_MIN);
9d002fe0:	3402fff8 	li	v0,0xfff8
9d002fe4:	90850020 	lbu	a1,32(a0)
9d002fe8:	38a50010 	xori	a1,a1,0x10
9d002fec:	0245100b 	movn	v0,s2,a1
9d002ff0:	0062102b 	sltu	v0,v1,v0
9d002ff4:	1440ffc1 	bnez	v0,9d002efc <_ZN6SdFile5writeEPKvt+0x114>
9d002ff8:	24020200 	li	v0,512
          // add cluster if at end of chain
          if (!addCluster()) goto writeErrorReturn;
9d002ffc:	0f4007f0 	jal	9d001fc0 <_ZN6SdFile10addClusterEv>
9d003000:	02602021 	move	a0,s3
9d003004:	1040003a 	beqz	v0,9d0030f0 <_ZN6SdFile5writeEPKvt+0x308>
9d003008:	8fbf0044 	lw	ra,68(sp)
9d00300c:	8e640020 	lw	a0,32(s3)
          curCluster_ = next;
        }
      }
    }
    // max space in block
    uint16_t n = 512 - blockOffset;
9d003010:	24020200 	li	v0,512
9d003014:	0056a023 	subu	s4,v0,s6
9d003018:	3294ffff 	andi	s4,s4,0xffff

    // lesser of space and amount to write
    if (n > nToWrite) n = nToWrite;
9d00301c:	02b4282b 	sltu	a1,s5,s4
9d003020:	10a0ffbb 	beqz	a1,9d002f10 <_ZN6SdFile5writeEPKvt+0x128>
9d003024:	8e630008 	lw	v1,8(s3)
  //----------------------------------------------------------------------------
  uint8_t allocContiguous(uint32_t count, uint32_t* curCluster);
  uint8_t blockOfCluster(uint32_t position) const {
          return (position >> 9) & (blocksPerCluster_ - 1);}
  uint32_t clusterStartBlock(uint32_t cluster) const {
           return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);}
9d003028:	8c850014 	lw	a1,20(a0)
9d00302c:	90820010 	lbu	v0,16(a0)
9d003030:	2463fffe 	addiu	v1,v1,-2
9d003034:	02e5b821 	addu	s7,s7,a1
9d003038:	00431804 	sllv	v1,v1,v0

    // block for data write
    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
9d00303c:	02e32821 	addu	a1,s7,v1
9d003040:	02a0a021 	move	s4,s5
        SdVolume::cacheBlockNumber_ = 0XFFFFFFFF;
      }
      if (!vol_->writeBlock(block, src)) goto writeErrorReturn;
      src += 512;
    } else {
      if (blockOffset == 0 && curPosition_ >= fileSize_) {
9d003044:	16c00006 	bnez	s6,9d003060 <_ZN6SdFile5writeEPKvt+0x278>
9d003048:	00a02021 	move	a0,a1
9d00304c:	8e63000c 	lw	v1,12(s3)
9d003050:	8e620018 	lw	v0,24(s3)
9d003054:	0062102b 	sltu	v0,v1,v0
9d003058:	10400019 	beqz	v0,9d0030c0 <_ZN6SdFile5writeEPKvt+0x2d8>
9d00305c:	00000000 	nop
        if (!SdVolume::cacheFlush()) goto writeErrorReturn;
        SdVolume::cacheBlockNumber_ = block;
        SdVolume::cacheSetDirty();
      } else {
        // rewrite part of block
        if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) {
9d003060:	0f400c8f 	jal	9d00323c <_ZN8SdVolume13cacheRawBlockEmh>
9d003064:	24050001 	li	a1,1
9d003068:	10400021 	beqz	v0,9d0030f0 <_ZN6SdFile5writeEPKvt+0x308>
9d00306c:	8fbf0044 	lw	ra,68(sp)
          goto writeErrorReturn;
        }
      }
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
9d003070:	02163021 	addu	a2,s0,s6
      uint8_t* end = dst + n;
9d003074:	00d42821 	addu	a1,a2,s4
      while (dst != end) *dst++ = *src++;
9d003078:	10c5ffb5 	beq	a2,a1,9d002f50 <_ZN6SdFile5writeEPKvt+0x168>
9d00307c:	0280b021 	move	s6,s4
9d003080:	00c01021 	move	v0,a2
9d003084:	03c01821 	move	v1,s8
9d003088:	90640000 	lbu	a0,0(v1)
9d00308c:	a0440000 	sb	a0,0(v0)
9d003090:	24420001 	addiu	v0,v0,1
9d003094:	14a2fffc 	bne	a1,v0,9d003088 <_ZN6SdFile5writeEPKvt+0x2a0>
9d003098:	24630001 	addiu	v1,v1,1
 * \a nbyte.  If an error occurs, write() returns -1.  Possible errors
 * include write() is called before a file has been opened, write is called
 * for a read-only file, device is full, a corrupt file system or an I/O error.
 *
 */
size_t SdFile::write(const void* buf, uint16_t nbyte) {
9d00309c:	00a62823 	subu	a1,a1,a2
          goto writeErrorReturn;
        }
      }
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
      uint8_t* end = dst + n;
      while (dst != end) *dst++ = *src++;
9d0030a0:	0b400bd4 	j	9d002f50 <_ZN6SdFile5writeEPKvt+0x168>
9d0030a4:	03c5f021 	addu	s8,s8,a1
    // insure sync will update modified date and time
    flags_ |= F_FILE_DIR_DIRTY;
  }

  if (flags_ & O_SYNC) {
    if (!sync()) goto writeErrorReturn;
9d0030a8:	0f4009e3 	jal	9d00278c <_ZN6SdFile4syncEv>
9d0030ac:	02602021 	move	a0,s3
9d0030b0:	1040ff5f 	beqz	v0,9d002e30 <_ZN6SdFile5writeEPKvt+0x48>
9d0030b4:	00008021 	move	s0,zero
  }
  return nbyte;
9d0030b8:	0b400be6 	j	9d002f98 <_ZN6SdFile5writeEPKvt+0x1b0>
9d0030bc:	02208021 	move	s0,s1
      if (!vol_->writeBlock(block, src)) goto writeErrorReturn;
      src += 512;
    } else {
      if (blockOffset == 0 && curPosition_ >= fileSize_) {
        // start of new block don't need to read into cache
        if (!SdVolume::cacheFlush()) goto writeErrorReturn;
9d0030c0:	0f400c68 	jal	9d0031a0 <_ZN8SdVolume10cacheFlushEv>
9d0030c4:	afa50018 	sw	a1,24(sp)
9d0030c8:	10400008 	beqz	v0,9d0030ec <_ZN6SdFile5writeEPKvt+0x304>
9d0030cc:	8fa50018 	lw	a1,24(sp)
  uint32_t blockNumber(uint32_t cluster, uint32_t position) const {
           return clusterStartBlock(cluster) + blockOfCluster(position);}
  static uint8_t cacheFlush(void);
  static uint8_t cacheRawBlock(uint32_t blockNumber, uint8_t action);
  static void cacheSetDirty(void) {cacheDirty_ |= CACHE_FOR_WRITE;}
9d0030d0:	93828034 	lbu	v0,-32716(gp)
        SdVolume::cacheBlockNumber_ = block;
9d0030d4:	af858010 	sw	a1,-32752(gp)
9d0030d8:	34420001 	ori	v0,v0,0x1
9d0030dc:	0b400c1c 	j	9d003070 <_ZN6SdFile5writeEPKvt+0x288>
9d0030e0:	a3828034 	sb	v0,-32716(gp)
    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
    if (n == 512) {
      // full block - don't need to use cache
      // invalidate cache if block is in cache
      if (SdVolume::cacheBlockNumber_ == block) {
        SdVolume::cacheBlockNumber_ = 0XFFFFFFFF;
9d0030e4:	0b400bce 	j	9d002f38 <_ZN6SdFile5writeEPKvt+0x150>
9d0030e8:	af828010 	sw	v0,-32752(gp)
 writeErrorReturn:
  // return for write error
  //writeError = true;
  //setWriteError();
  return 0;
}
9d0030ec:	8fbf0044 	lw	ra,68(sp)

 writeErrorReturn:
  // return for write error
  //writeError = true;
  //setWriteError();
  return 0;
9d0030f0:	00008021 	move	s0,zero
}
9d0030f4:	02001021 	move	v0,s0
9d0030f8:	8fbe0040 	lw	s8,64(sp)
9d0030fc:	8fb7003c 	lw	s7,60(sp)
9d003100:	8fb60038 	lw	s6,56(sp)
9d003104:	8fb50034 	lw	s5,52(sp)
9d003108:	8fb40030 	lw	s4,48(sp)
9d00310c:	8fb3002c 	lw	s3,44(sp)
9d003110:	8fb20028 	lw	s2,40(sp)
9d003114:	8fb10024 	lw	s1,36(sp)
9d003118:	8fb00020 	lw	s0,32(sp)
9d00311c:	03e00008 	jr	ra
9d003120:	27bd0048 	addiu	sp,sp,72
  }
  if (curPosition_ > fileSize_) {
    // update fileSize and insure sync will update dir entry
    fileSize_ = curPosition_;
    flags_ |= F_FILE_DIR_DIRTY;
  } else if (dateTime_ && nbyte) {
9d003124:	1040ff99 	beqz	v0,9d002f8c <_ZN6SdFile5writeEPKvt+0x1a4>
9d003128:	92620004 	lbu	v0,4(s3)
9d00312c:	1220ff97 	beqz	s1,9d002f8c <_ZN6SdFile5writeEPKvt+0x1a4>
9d003130:	00000000 	nop
    // insure sync will update modified date and time
    flags_ |= F_FILE_DIR_DIRTY;
9d003134:	3042007f 	andi	v0,v0,0x7f
9d003138:	34420080 	ori	v0,v0,0x80
9d00313c:	0b400be3 	j	9d002f8c <_ZN6SdFile5writeEPKvt+0x1a4>
9d003140:	a2620004 	sb	v0,4(s3)

9d003144 <_ZN6SdFile5writeEPKc>:
/**
 * Write a string to a file. Used by the Arduino Print class.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::write(const char* str) {
9d003144:	27bdffe0 	addiu	sp,sp,-32
9d003148:	afb00018 	sw	s0,24(sp)
9d00314c:	00808021 	move	s0,a0
  //return 
  write(str, strlen(str));
9d003150:	00a02021 	move	a0,a1
/**
 * Write a string to a file. Used by the Arduino Print class.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::write(const char* str) {
9d003154:	afbf001c 	sw	ra,28(sp)
  //return 
  write(str, strlen(str));
9d003158:	0f401c2e 	jal	9d0070b8 <strlen>
9d00315c:	afa50010 	sw	a1,16(sp)
9d003160:	8fa50010 	lw	a1,16(sp)
9d003164:	02002021 	move	a0,s0
}
9d003168:	8fbf001c 	lw	ra,28(sp)
9d00316c:	8fb00018 	lw	s0,24(sp)
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::write(const char* str) {
  //return 
  write(str, strlen(str));
9d003170:	3046ffff 	andi	a2,v0,0xffff
9d003174:	0b400b7a 	j	9d002de8 <_ZN6SdFile5writeEPKvt>
9d003178:	27bd0020 	addiu	sp,sp,32

9d00317c <_ZN6SdFile5writeEh>:
/**
 * Write a byte to a file. Required by the Arduino Print class.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::write(uint8_t b) {
9d00317c:	27bdffe8 	addiu	sp,sp,-24
9d003180:	a3a5001c 	sb	a1,28(sp)
  //return 
  write(&b, 1);
9d003184:	24060001 	li	a2,1
/**
 * Write a byte to a file. Required by the Arduino Print class.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::write(uint8_t b) {
9d003188:	afbf0014 	sw	ra,20(sp)
  //return 
  write(&b, 1);
9d00318c:	0f400b7a 	jal	9d002de8 <_ZN6SdFile5writeEPKvt>
9d003190:	27a5001c 	addiu	a1,sp,28
}
9d003194:	8fbf0014 	lw	ra,20(sp)
9d003198:	03e00008 	jr	ra
9d00319c:	27bd0018 	addiu	sp,sp,24

9d0031a0 <_ZN8SdVolume10cacheFlushEv>:

  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheFlush(void) {
  if (cacheDirty_) {
9d0031a0:	93828034 	lbu	v0,-32716(gp)
  if (setStart) allocSearchStart_ = bgnCluster + 1;

  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheFlush(void) {
9d0031a4:	27bdffe0 	addiu	sp,sp,-32
9d0031a8:	afb00014 	sw	s0,20(sp)
9d0031ac:	afbf001c 	sw	ra,28(sp)
9d0031b0:	afb10018 	sw	s1,24(sp)
  if (cacheDirty_) {
9d0031b4:	14400007 	bnez	v0,9d0031d4 <_ZN8SdVolume10cacheFlushEv+0x34>
9d0031b8:	24100001 	li	s0,1
      cacheMirrorBlock_ = 0;
    }
    cacheDirty_ = 0;
  }
  return true;
}
9d0031bc:	8fbf001c 	lw	ra,28(sp)
9d0031c0:	02001021 	move	v0,s0
9d0031c4:	8fb10018 	lw	s1,24(sp)
9d0031c8:	8fb00014 	lw	s0,20(sp)
9d0031cc:	03e00008 	jr	ra
9d0031d0:	27bd0020 	addiu	sp,sp,32
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheFlush(void) {
  if (cacheDirty_) {
    if (!sdCard_->writeBlock(cacheBlockNumber_, cacheBuffer_.data)) {
9d0031d4:	8f848030 	lw	a0,-32720(gp)
9d0031d8:	8f858010 	lw	a1,-32752(gp)
9d0031dc:	3c11a000 	lui	s1,0xa000
9d0031e0:	0f4007b7 	jal	9d001edc <_ZN7Sd2Card10writeBlockEmPKh>
9d0031e4:	26260a84 	addiu	a2,s1,2692
9d0031e8:	1040fff4 	beqz	v0,9d0031bc <_ZN8SdVolume10cacheFlushEv+0x1c>
9d0031ec:	00008021 	move	s0,zero
      return false;
    }
    // mirror FAT tables
    if (cacheMirrorBlock_) {
9d0031f0:	8f858038 	lw	a1,-32712(gp)
9d0031f4:	14a00009 	bnez	a1,9d00321c <_ZN8SdVolume10cacheFlushEv+0x7c>
9d0031f8:	8f848030 	lw	a0,-32720(gp)
      if (!sdCard_->writeBlock(cacheMirrorBlock_, cacheBuffer_.data)) {
        return false;
      }
      cacheMirrorBlock_ = 0;
    }
    cacheDirty_ = 0;
9d0031fc:	a3808034 	sb	zero,-32716(gp)
  }
  return true;
9d003200:	24100001 	li	s0,1
}
9d003204:	8fbf001c 	lw	ra,28(sp)
9d003208:	02001021 	move	v0,s0
9d00320c:	8fb10018 	lw	s1,24(sp)
9d003210:	8fb00014 	lw	s0,20(sp)
9d003214:	03e00008 	jr	ra
9d003218:	27bd0020 	addiu	sp,sp,32
    if (!sdCard_->writeBlock(cacheBlockNumber_, cacheBuffer_.data)) {
      return false;
    }
    // mirror FAT tables
    if (cacheMirrorBlock_) {
      if (!sdCard_->writeBlock(cacheMirrorBlock_, cacheBuffer_.data)) {
9d00321c:	0f4007b7 	jal	9d001edc <_ZN7Sd2Card10writeBlockEmPKh>
9d003220:	26260a84 	addiu	a2,s1,2692
9d003224:	1040ffe6 	beqz	v0,9d0031c0 <_ZN8SdVolume10cacheFlushEv+0x20>
9d003228:	8fbf001c 	lw	ra,28(sp)
        return false;
      }
      cacheMirrorBlock_ = 0;
9d00322c:	af808038 	sw	zero,-32712(gp)
    }
    cacheDirty_ = 0;
9d003230:	a3808034 	sb	zero,-32716(gp)
  }
  return true;
9d003234:	0b400c81 	j	9d003204 <_ZN8SdVolume10cacheFlushEv+0x64>
9d003238:	24100001 	li	s0,1

9d00323c <_ZN8SdVolume13cacheRawBlockEmh>:
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheRawBlock(uint32_t blockNumber, uint8_t action) {
  if (cacheBlockNumber_ != blockNumber) {
9d00323c:	8f828010 	lw	v0,-32752(gp)
    cacheDirty_ = 0;
  }
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheRawBlock(uint32_t blockNumber, uint8_t action) {
9d003240:	27bdffe0 	addiu	sp,sp,-32
9d003244:	afb20018 	sw	s2,24(sp)
9d003248:	afb00010 	sw	s0,16(sp)
9d00324c:	afbf001c 	sw	ra,28(sp)
9d003250:	afb10014 	sw	s1,20(sp)
9d003254:	00808021 	move	s0,a0
  if (cacheBlockNumber_ != blockNumber) {
9d003258:	10440013 	beq	v0,a0,9d0032a8 <_ZN8SdVolume13cacheRawBlockEmh+0x6c>
9d00325c:	30b200ff 	andi	s2,a1,0xff
    if (!cacheFlush()) return false;
9d003260:	0f400c68 	jal	9d0031a0 <_ZN8SdVolume10cacheFlushEv>
9d003264:	00008821 	move	s1,zero
9d003268:	14400008 	bnez	v0,9d00328c <_ZN8SdVolume13cacheRawBlockEmh+0x50>
9d00326c:	8f848030 	lw	a0,-32720(gp)
    }
    cacheBlockNumber_ = blockNumber;
  }
  cacheDirty_ |= action;
  return true;
}
9d003270:	8fbf001c 	lw	ra,28(sp)
9d003274:	02201021 	move	v0,s1
9d003278:	8fb20018 	lw	s2,24(sp)
9d00327c:	8fb10014 	lw	s1,20(sp)
9d003280:	8fb00010 	lw	s0,16(sp)
9d003284:	03e00008 	jr	ra
9d003288:	27bd0020 	addiu	sp,sp,32
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheRawBlock(uint32_t blockNumber, uint8_t action) {
  if (cacheBlockNumber_ != blockNumber) {
    if (!cacheFlush()) return false;
    if (!sdCard_->readBlock(blockNumber, cacheBuffer_.data)) {
9d00328c:	3c06a000 	lui	a2,0xa000
9d003290:	02002821 	move	a1,s0
9d003294:	0f40077e 	jal	9d001df8 <_ZN7Sd2Card9readBlockEmPh>
9d003298:	24c60a84 	addiu	a2,a2,2692
9d00329c:	1040fff5 	beqz	v0,9d003274 <_ZN8SdVolume13cacheRawBlockEmh+0x38>
9d0032a0:	8fbf001c 	lw	ra,28(sp)
        return false;
    }
    cacheBlockNumber_ = blockNumber;
9d0032a4:	af908010 	sw	s0,-32752(gp)
  }
  cacheDirty_ |= action;
9d0032a8:	93828034 	lbu	v0,-32716(gp)
  return true;
}
9d0032ac:	8fbf001c 	lw	ra,28(sp)
        return false;
    }
    cacheBlockNumber_ = blockNumber;
  }
  cacheDirty_ |= action;
  return true;
9d0032b0:	24110001 	li	s1,1
    if (!sdCard_->readBlock(blockNumber, cacheBuffer_.data)) {
        return false;
    }
    cacheBlockNumber_ = blockNumber;
  }
  cacheDirty_ |= action;
9d0032b4:	02429025 	or	s2,s2,v0
9d0032b8:	a3928034 	sb	s2,-32716(gp)
  return true;
}
9d0032bc:	02201021 	move	v0,s1
9d0032c0:	8fb20018 	lw	s2,24(sp)
9d0032c4:	8fb10014 	lw	s1,20(sp)
9d0032c8:	8fb00010 	lw	s0,16(sp)
9d0032cc:	03e00008 	jr	ra
9d0032d0:	27bd0020 	addiu	sp,sp,32

9d0032d4 <_ZNK8SdVolume6fatGetEmPm>:
  return true;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
  if (cluster > (clusterCount_ + 1)) return false;
9d0032d4:	8c82000c 	lw	v0,12(a0)
  *size = s;
  return true;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
9d0032d8:	27bdffd8 	addiu	sp,sp,-40
9d0032dc:	afb20020 	sw	s2,32(sp)
  if (cluster > (clusterCount_ + 1)) return false;
9d0032e0:	24420001 	addiu	v0,v0,1
9d0032e4:	0045102b 	sltu	v0,v0,a1
  *size = s;
  return true;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
9d0032e8:	afb1001c 	sw	s1,28(sp)
9d0032ec:	afb00018 	sw	s0,24(sp)
9d0032f0:	afbf0024 	sw	ra,36(sp)
9d0032f4:	00808821 	move	s1,a0
9d0032f8:	00a08021 	move	s0,a1
  if (cluster > (clusterCount_ + 1)) return false;
9d0032fc:	1440001b 	bnez	v0,9d00336c <_ZNK8SdVolume6fatGetEmPm+0x98>
9d003300:	00009021 	move	s2,zero
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
9d003304:	90830020 	lbu	v1,32(a0)
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
  if (cluster > (clusterCount_ + 1)) return false;
  uint32_t lba = fatStartBlock_;
9d003308:	8c84001c 	lw	a0,28(a0)
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
9d00330c:	00051202 	srl	v0,a1,0x8
9d003310:	38670010 	xori	a3,v1,0x10
9d003314:	000529c2 	srl	a1,a1,0x7
9d003318:	00a7100b 	movn	v0,a1,a3
9d00331c:	00442021 	addu	a0,v0,a0
  if (lba != cacheBlockNumber_) {
9d003320:	8f828010 	lw	v0,-32752(gp)
9d003324:	10820006 	beq	a0,v0,9d003340 <_ZNK8SdVolume6fatGetEmPm+0x6c>
9d003328:	00002821 	move	a1,zero
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
9d00332c:	0f400c8f 	jal	9d00323c <_ZN8SdVolume13cacheRawBlockEmh>
9d003330:	afa60010 	sw	a2,16(sp)
9d003334:	1040000d 	beqz	v0,9d00336c <_ZNK8SdVolume6fatGetEmPm+0x98>
9d003338:	8fa60010 	lw	a2,16(sp)
9d00333c:	92230020 	lbu	v1,32(s1)
  }
  if (fatType_ == 16) {
9d003340:	24020010 	li	v0,16
9d003344:	10620010 	beq	v1,v0,9d003388 <_ZNK8SdVolume6fatGetEmPm+0xb4>
9d003348:	3c02a000 	lui	v0,0xa000
    *value = cacheBuffer_.fat16[cluster & 0XFF];
  } else {
    *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;
9d00334c:	3210007f 	andi	s0,s0,0x7f
9d003350:	24420a84 	addiu	v0,v0,2692
9d003354:	00108080 	sll	s0,s0,0x2
9d003358:	02028021 	addu	s0,s0,v0
9d00335c:	8e020000 	lw	v0,0(s0)
  }
  return true;
9d003360:	24120001 	li	s2,1
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
  }
  if (fatType_ == 16) {
    *value = cacheBuffer_.fat16[cluster & 0XFF];
  } else {
    *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;
9d003364:	7c42d800 	ext	v0,v0,0x0,0x1c
9d003368:	acc20000 	sw	v0,0(a2)
  }
  return true;
}
9d00336c:	8fbf0024 	lw	ra,36(sp)
9d003370:	02401021 	move	v0,s2
9d003374:	8fb20020 	lw	s2,32(sp)
9d003378:	8fb1001c 	lw	s1,28(sp)
9d00337c:	8fb00018 	lw	s0,24(sp)
9d003380:	03e00008 	jr	ra
9d003384:	27bd0028 	addiu	sp,sp,40
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
  if (lba != cacheBlockNumber_) {
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
  }
  if (fatType_ == 16) {
    *value = cacheBuffer_.fat16[cluster & 0XFF];
9d003388:	321000ff 	andi	s0,s0,0xff
9d00338c:	24420a84 	addiu	v0,v0,2692
9d003390:	00108040 	sll	s0,s0,0x1
9d003394:	02028021 	addu	s0,s0,v0
9d003398:	96020000 	lhu	v0,0(s0)
  } else {
    *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;
  }
  return true;
9d00339c:	24120001 	li	s2,1
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
  if (lba != cacheBlockNumber_) {
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
  }
  if (fatType_ == 16) {
    *value = cacheBuffer_.fat16[cluster & 0XFF];
9d0033a0:	0b400cdb 	j	9d00336c <_ZNK8SdVolume6fatGetEmPm+0x98>
9d0033a4:	acc20000 	sw	v0,0(a2)

9d0033a8 <_ZNK8SdVolume9chainSizeEmPm>:
  cacheSetDirty();
  return true;
}
//------------------------------------------------------------------------------
// return the size in bytes of a cluster chain
uint8_t SdVolume::chainSize(uint32_t cluster, uint32_t* size) const {
9d0033a8:	27bdffd0 	addiu	sp,sp,-48
9d0033ac:	afb2001c 	sw	s2,28(sp)
  uint8_t fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
  }
  uint8_t freeChain(uint32_t cluster);
  uint8_t isEOC(uint32_t cluster) const {
    return  cluster >= (fatType_ == 16 ? FAT16EOC_MIN : FAT32EOC_MIN);
9d0033b0:	3c120fff 	lui	s2,0xfff
9d0033b4:	afb50028 	sw	s5,40(sp)
9d0033b8:	afb40024 	sw	s4,36(sp)
9d0033bc:	afb30020 	sw	s3,32(sp)
9d0033c0:	afb10018 	sw	s1,24(sp)
9d0033c4:	afb00014 	sw	s0,20(sp)
9d0033c8:	afbf002c 	sw	ra,44(sp)
9d0033cc:	0080a021 	move	s4,a0
9d0033d0:	afa50034 	sw	a1,52(sp)
9d0033d4:	00c09821 	move	s3,a2
  uint32_t s = 0;
9d0033d8:	0000a821 	move	s5,zero
  do {
    if (!fatGet(cluster, &cluster)) return false;
    s += 512UL << clusterSizeShift_;
9d0033dc:	24110200 	li	s1,512
9d0033e0:	24100010 	li	s0,16
9d0033e4:	0b400d04 	j	9d003410 <_ZNK8SdVolume9chainSizeEmPm+0x68>
9d0033e8:	3652fff8 	ori	s2,s2,0xfff8
9d0033ec:	92840020 	lbu	a0,32(s4)
9d0033f0:	92820010 	lbu	v0,16(s4)
  } while (!isEOC(cluster));
9d0033f4:	8fa50034 	lw	a1,52(sp)
9d0033f8:	00902026 	xor	a0,a0,s0
9d0033fc:	0244180b 	movn	v1,s2,a0
// return the size in bytes of a cluster chain
uint8_t SdVolume::chainSize(uint32_t cluster, uint32_t* size) const {
  uint32_t s = 0;
  do {
    if (!fatGet(cluster, &cluster)) return false;
    s += 512UL << clusterSizeShift_;
9d003400:	00511004 	sllv	v0,s1,v0
}
//------------------------------------------------------------------------------
// return the size in bytes of a cluster chain
uint8_t SdVolume::chainSize(uint32_t cluster, uint32_t* size) const {
  uint32_t s = 0;
  do {
9d003404:	00a3182b 	sltu	v1,a1,v1
9d003408:	10600010 	beqz	v1,9d00344c <_ZNK8SdVolume9chainSizeEmPm+0xa4>
9d00340c:	02a2a821 	addu	s5,s5,v0
    if (!fatGet(cluster, &cluster)) return false;
9d003410:	02802021 	move	a0,s4
9d003414:	0f400cb5 	jal	9d0032d4 <_ZNK8SdVolume6fatGetEmPm>
9d003418:	27a60034 	addiu	a2,sp,52
9d00341c:	1440fff3 	bnez	v0,9d0033ec <_ZNK8SdVolume9chainSizeEmPm+0x44>
9d003420:	3403fff8 	li	v1,0xfff8
    s += 512UL << clusterSizeShift_;
  } while (!isEOC(cluster));
  *size = s;
  return true;
}
9d003424:	8fbf002c 	lw	ra,44(sp)
//------------------------------------------------------------------------------
// return the size in bytes of a cluster chain
uint8_t SdVolume::chainSize(uint32_t cluster, uint32_t* size) const {
  uint32_t s = 0;
  do {
    if (!fatGet(cluster, &cluster)) return false;
9d003428:	00001021 	move	v0,zero
    s += 512UL << clusterSizeShift_;
  } while (!isEOC(cluster));
  *size = s;
  return true;
}
9d00342c:	8fb50028 	lw	s5,40(sp)
9d003430:	8fb40024 	lw	s4,36(sp)
9d003434:	8fb30020 	lw	s3,32(sp)
9d003438:	8fb2001c 	lw	s2,28(sp)
9d00343c:	8fb10018 	lw	s1,24(sp)
9d003440:	8fb00014 	lw	s0,20(sp)
9d003444:	03e00008 	jr	ra
9d003448:	27bd0030 	addiu	sp,sp,48
9d00344c:	8fbf002c 	lw	ra,44(sp)
  uint32_t s = 0;
  do {
    if (!fatGet(cluster, &cluster)) return false;
    s += 512UL << clusterSizeShift_;
  } while (!isEOC(cluster));
  *size = s;
9d003450:	ae750000 	sw	s5,0(s3)
  return true;
9d003454:	24020001 	li	v0,1
}
9d003458:	8fb50028 	lw	s5,40(sp)
9d00345c:	8fb40024 	lw	s4,36(sp)
9d003460:	8fb30020 	lw	s3,32(sp)
9d003464:	8fb2001c 	lw	s2,28(sp)
9d003468:	8fb10018 	lw	s1,24(sp)
9d00346c:	8fb00014 	lw	s0,20(sp)
9d003470:	03e00008 	jr	ra
9d003474:	27bd0030 	addiu	sp,sp,48

9d003478 <_ZN8SdVolume6fatPutEmm>:
  }
  return true;
}
//------------------------------------------------------------------------------
// Store a FAT entry
uint8_t SdVolume::fatPut(uint32_t cluster, uint32_t value) {
9d003478:	27bdffd0 	addiu	sp,sp,-48
  // error if reserved cluster
  if (cluster < 2) return false;
9d00347c:	2ca20002 	sltiu	v0,a1,2
  }
  return true;
}
//------------------------------------------------------------------------------
// Store a FAT entry
uint8_t SdVolume::fatPut(uint32_t cluster, uint32_t value) {
9d003480:	afb20024 	sw	s2,36(sp)
9d003484:	afb10020 	sw	s1,32(sp)
9d003488:	afb0001c 	sw	s0,28(sp)
9d00348c:	afbf002c 	sw	ra,44(sp)
9d003490:	afb30028 	sw	s3,40(sp)
9d003494:	00a08021 	move	s0,a1
9d003498:	00808821 	move	s1,a0
  // error if reserved cluster
  if (cluster < 2) return false;
9d00349c:	14400027 	bnez	v0,9d00353c <_ZN8SdVolume6fatPutEmm+0xc4>
9d0034a0:	00009021 	move	s2,zero

  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) return false;
9d0034a4:	8c82000c 	lw	v0,12(a0)
9d0034a8:	24420001 	addiu	v0,v0,1
9d0034ac:	0045102b 	sltu	v0,v0,a1
9d0034b0:	14400022 	bnez	v0,9d00353c <_ZN8SdVolume6fatPutEmm+0xc4>
9d0034b4:	00051202 	srl	v0,a1,0x8

  // calculate block address for entry
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
9d0034b8:	90830020 	lbu	v1,32(a0)

  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) return false;

  // calculate block address for entry
  uint32_t lba = fatStartBlock_;
9d0034bc:	8c93001c 	lw	s3,28(a0)
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
9d0034c0:	000521c2 	srl	a0,a1,0x7
9d0034c4:	38650010 	xori	a1,v1,0x10
9d0034c8:	0085100b 	movn	v0,a0,a1
9d0034cc:	00539821 	addu	s3,v0,s3

  if (lba != cacheBlockNumber_) {
9d0034d0:	8f828010 	lw	v0,-32752(gp)
9d0034d4:	12620007 	beq	s3,v0,9d0034f4 <_ZN8SdVolume6fatPutEmm+0x7c>
9d0034d8:	02602021 	move	a0,s3
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
9d0034dc:	00002821 	move	a1,zero
9d0034e0:	0f400c8f 	jal	9d00323c <_ZN8SdVolume13cacheRawBlockEmh>
9d0034e4:	afa60010 	sw	a2,16(sp)
9d0034e8:	10400014 	beqz	v0,9d00353c <_ZN8SdVolume6fatPutEmm+0xc4>
9d0034ec:	8fa60010 	lw	a2,16(sp)
9d0034f0:	92230020 	lbu	v1,32(s1)
  }
  // store entry
  if (fatType_ == 16) {
9d0034f4:	24020010 	li	v0,16
9d0034f8:	10620018 	beq	v1,v0,9d00355c <_ZN8SdVolume6fatPutEmm+0xe4>
9d0034fc:	3c02a000 	lui	v0,0xa000
    cacheBuffer_.fat16[cluster & 0XFF] = value;
  } else {
    cacheBuffer_.fat32[cluster & 0X7F] = value;
9d003500:	3210007f 	andi	s0,s0,0x7f
9d003504:	00108080 	sll	s0,s0,0x2
9d003508:	24420a84 	addiu	v0,v0,2692
9d00350c:	02028021 	addu	s0,s0,v0
9d003510:	ae060000 	sw	a2,0(s0)
           return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);}
  uint32_t blockNumber(uint32_t cluster, uint32_t position) const {
           return clusterStartBlock(cluster) + blockOfCluster(position);}
  static uint8_t cacheFlush(void);
  static uint8_t cacheRawBlock(uint32_t blockNumber, uint8_t action);
  static void cacheSetDirty(void) {cacheDirty_ |= CACHE_FOR_WRITE;}
9d003514:	93828034 	lbu	v0,-32716(gp)
9d003518:	34420001 	ori	v0,v0,0x1
9d00351c:	a3828034 	sb	v0,-32716(gp)
  }
  cacheSetDirty();

  // mirror second FAT
  if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
9d003520:	92220018 	lbu	v0,24(s1)
9d003524:	2c420002 	sltiu	v0,v0,2
9d003528:	14400004 	bnez	v0,9d00353c <_ZN8SdVolume6fatPutEmm+0xc4>
9d00352c:	24120001 	li	s2,1
9d003530:	8e220008 	lw	v0,8(s1)
9d003534:	02629821 	addu	s3,s3,v0
9d003538:	af938038 	sw	s3,-32712(gp)
  return true;
}
9d00353c:	8fbf002c 	lw	ra,44(sp)
9d003540:	02401021 	move	v0,s2
9d003544:	8fb30028 	lw	s3,40(sp)
9d003548:	8fb20024 	lw	s2,36(sp)
9d00354c:	8fb10020 	lw	s1,32(sp)
9d003550:	8fb0001c 	lw	s0,28(sp)
9d003554:	03e00008 	jr	ra
9d003558:	27bd0030 	addiu	sp,sp,48
  if (lba != cacheBlockNumber_) {
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
  }
  // store entry
  if (fatType_ == 16) {
    cacheBuffer_.fat16[cluster & 0XFF] = value;
9d00355c:	321000ff 	andi	s0,s0,0xff
9d003560:	00108040 	sll	s0,s0,0x1
9d003564:	24420a84 	addiu	v0,v0,2692
9d003568:	02028021 	addu	s0,s0,v0
9d00356c:	0b400d45 	j	9d003514 <_ZN8SdVolume6fatPutEmm+0x9c>
9d003570:	a6060000 	sh	a2,0(s0)

9d003574 <_ZN8SdVolume15allocContiguousEmPm>:
Sd2Card* SdVolume::sdCard_;          // pointer to SD card object
uint8_t  SdVolume::cacheDirty_ = 0;  // cacheFlush() will write block if true
uint32_t SdVolume::cacheMirrorBlock_ = 0;  // mirror  block for second FAT
//------------------------------------------------------------------------------
// find a contiguous group of clusters
uint8_t SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
9d003574:	27bdffc0 	addiu	sp,sp,-64
9d003578:	afb40028 	sw	s4,40(sp)

  // flag to save place to start next search
  uint8_t setStart;

  // set search start cluster
  if (*curCluster) {
9d00357c:	8cd40000 	lw	s4,0(a2)
Sd2Card* SdVolume::sdCard_;          // pointer to SD card object
uint8_t  SdVolume::cacheDirty_ = 0;  // cacheFlush() will write block if true
uint32_t SdVolume::cacheMirrorBlock_ = 0;  // mirror  block for second FAT
//------------------------------------------------------------------------------
// find a contiguous group of clusters
uint8_t SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
9d003580:	afb70034 	sw	s7,52(sp)
9d003584:	afb20020 	sw	s2,32(sp)
9d003588:	afb1001c 	sw	s1,28(sp)
9d00358c:	afbf003c 	sw	ra,60(sp)
9d003590:	afbe0038 	sw	s8,56(sp)
9d003594:	afb60030 	sw	s6,48(sp)
9d003598:	afb5002c 	sw	s5,44(sp)
9d00359c:	afb30024 	sw	s3,36(sp)
9d0035a0:	afb00018 	sw	s0,24(sp)
9d0035a4:	00c09021 	move	s2,a2
9d0035a8:	0080b821 	move	s7,a0

  // flag to save place to start next search
  uint8_t setStart;

  // set search start cluster
  if (*curCluster) {
9d0035ac:	12800043 	beqz	s4,9d0036bc <_ZN8SdVolume15allocContiguousEmPm+0x148>
9d0035b0:	00a08821 	move	s1,a1
    // try to make file contiguous
    bgnCluster = *curCluster + 1;
9d0035b4:	26940001 	addiu	s4,s4,1

    // don't save new start location
    setStart = false;
9d0035b8:	00009821 	move	s3,zero
  }
  // end of group
  uint32_t endCluster = bgnCluster;

  // last cluster of FAT
  uint32_t fatEnd = clusterCount_ + 1;
9d0035bc:	8ee2000c 	lw	v0,12(s7)

  // search the FAT for free clusters
  for (uint32_t n = 0;; n++, endCluster++) {
    // can't find space checked all clusters
    if (n >= clusterCount_) return false;
9d0035c0:	00001821 	move	v1,zero
9d0035c4:	10400030 	beqz	v0,9d003688 <_ZN8SdVolume15allocContiguousEmPm+0x114>
9d0035c8:	24500001 	addiu	s0,v0,1
9d0035cc:	02801821 	move	v1,s4
9d0035d0:	0000b021 	move	s6,zero

    // past end - start from beginning of FAT
    if (endCluster > fatEnd) {
9d0035d4:	0b400d7c 	j	9d0035f0 <_ZN8SdVolume15allocContiguousEmPm+0x7c>
9d0035d8:	241e0002 	li	s8,2
  uint32_t fatEnd = clusterCount_ + 1;

  // search the FAT for free clusters
  for (uint32_t n = 0;; n++, endCluster++) {
    // can't find space checked all clusters
    if (n >= clusterCount_) return false;
9d0035dc:	8ee2000c 	lw	v0,12(s7)

  // last cluster of FAT
  uint32_t fatEnd = clusterCount_ + 1;

  // search the FAT for free clusters
  for (uint32_t n = 0;; n++, endCluster++) {
9d0035e0:	26d60001 	addiu	s6,s6,1
    // can't find space checked all clusters
    if (n >= clusterCount_) return false;
9d0035e4:	02c2102b 	sltu	v0,s6,v0
9d0035e8:	50400027 	beqzl	v0,9d003688 <_ZN8SdVolume15allocContiguousEmPm+0x114>
9d0035ec:	00001821 	move	v1,zero

    // past end - start from beginning of FAT
    if (endCluster > fatEnd) {
9d0035f0:	0203102b 	sltu	v0,s0,v1
9d0035f4:	03c0a821 	move	s5,s8
9d0035f8:	0062a80a 	movz	s5,v1,v0
      bgnCluster = endCluster = 2;
    }
    uint32_t f;
    if (!fatGet(endCluster, &f)) return false;
9d0035fc:	02e02021 	move	a0,s7
9d003600:	02a02821 	move	a1,s5
9d003604:	27a60010 	addiu	a2,sp,16
9d003608:	0f400cb5 	jal	9d0032d4 <_ZNK8SdVolume6fatGetEmPm>
9d00360c:	03c2a00b 	movn	s4,s8,v0

    if (f != 0) {
      // cluster in use try next cluster as bgnCluster
      bgnCluster = endCluster + 1;
    } else if ((endCluster - bgnCluster + 1) == count) {
9d003610:	26a30001 	addiu	v1,s5,1
    // past end - start from beginning of FAT
    if (endCluster > fatEnd) {
      bgnCluster = endCluster = 2;
    }
    uint32_t f;
    if (!fatGet(endCluster, &f)) return false;
9d003614:	1040001b 	beqz	v0,9d003684 <_ZN8SdVolume15allocContiguousEmPm+0x110>
9d003618:	00742023 	subu	a0,v1,s4

    if (f != 0) {
9d00361c:	8fa20010 	lw	v0,16(sp)
9d003620:	5440ffee 	bnezl	v0,9d0035dc <_ZN8SdVolume15allocContiguousEmPm+0x68>
9d003624:	0060a021 	move	s4,v1
      // cluster in use try next cluster as bgnCluster
      bgnCluster = endCluster + 1;
    } else if ((endCluster - bgnCluster + 1) == count) {
9d003628:	5491ffed 	bnel	a0,s1,9d0035e0 <_ZN8SdVolume15allocContiguousEmPm+0x6c>
9d00362c:	8ee2000c 	lw	v0,12(s7)
  static uint8_t cacheZeroBlock(uint32_t blockNumber);
  uint8_t chainSize(uint32_t beginCluster, uint32_t* size) const;
  uint8_t fatGet(uint32_t cluster, uint32_t* value) const;
  uint8_t fatPut(uint32_t cluster, uint32_t value);
  uint8_t fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
9d003630:	3c060fff 	lui	a2,0xfff
9d003634:	02e02021 	move	a0,s7
9d003638:	02a02821 	move	a1,s5
9d00363c:	0f400d1e 	jal	9d003478 <_ZN8SdVolume6fatPutEmm>
9d003640:	34c6ffff 	ori	a2,a2,0xffff
      // done - found space
      break;
    }
  }
  // mark end of chain
  if (!fatPutEOC(endCluster)) return false;
9d003644:	10400010 	beqz	v0,9d003688 <_ZN8SdVolume15allocContiguousEmPm+0x114>
9d003648:	00001821 	move	v1,zero

  // link clusters
  while (endCluster > bgnCluster) {
9d00364c:	0295102b 	sltu	v0,s4,s5
9d003650:	14400005 	bnez	v0,9d003668 <_ZN8SdVolume15allocContiguousEmPm+0xf4>
9d003654:	26a2ffff 	addiu	v0,s5,-1
    if (!fatPut(endCluster - 1, endCluster)) return false;
    endCluster--;
  }
  if (*curCluster != 0) {
9d003658:	0b400db4 	j	9d0036d0 <_ZN8SdVolume15allocContiguousEmPm+0x15c>
9d00365c:	8e450000 	lw	a1,0(s2)
  }
  // mark end of chain
  if (!fatPutEOC(endCluster)) return false;

  // link clusters
  while (endCluster > bgnCluster) {
9d003660:	1060001a 	beqz	v1,9d0036cc <_ZN8SdVolume15allocContiguousEmPm+0x158>
9d003664:	26a2ffff 	addiu	v0,s5,-1
    if (!fatPut(endCluster - 1, endCluster)) return false;
9d003668:	02a03021 	move	a2,s5
9d00366c:	02e02021 	move	a0,s7
9d003670:	00402821 	move	a1,v0
9d003674:	0f400d1e 	jal	9d003478 <_ZN8SdVolume6fatPutEmm>
9d003678:	0040a821 	move	s5,v0
9d00367c:	1440fff8 	bnez	v0,9d003660 <_ZN8SdVolume15allocContiguousEmPm+0xec>
9d003680:	0295182b 	sltu	v1,s4,s5
9d003684:	00001821 	move	v1,zero

  // remember possible next free cluster
  if (setStart) allocSearchStart_ = bgnCluster + 1;

  return true;
}
9d003688:	8fbf003c 	lw	ra,60(sp)
9d00368c:	00601021 	move	v0,v1
9d003690:	8fbe0038 	lw	s8,56(sp)
9d003694:	8fb70034 	lw	s7,52(sp)
9d003698:	8fb60030 	lw	s6,48(sp)
9d00369c:	8fb5002c 	lw	s5,44(sp)
9d0036a0:	8fb40028 	lw	s4,40(sp)
9d0036a4:	8fb30024 	lw	s3,36(sp)
9d0036a8:	8fb20020 	lw	s2,32(sp)
9d0036ac:	8fb1001c 	lw	s1,28(sp)
9d0036b0:	8fb00018 	lw	s0,24(sp)
9d0036b4:	03e00008 	jr	ra
9d0036b8:	27bd0040 	addiu	sp,sp,64
  } else {
    // start at likely place for free cluster
    bgnCluster = allocSearchStart_;

    // save next search start if one cluster
    setStart = 1 == count;
9d0036bc:	38b30001 	xori	s3,a1,0x1

    // don't save new start location
    setStart = false;
  } else {
    // start at likely place for free cluster
    bgnCluster = allocSearchStart_;
9d0036c0:	8c940000 	lw	s4,0(a0)

    // save next search start if one cluster
    setStart = 1 == count;
9d0036c4:	0b400d6f 	j	9d0035bc <_ZN8SdVolume15allocContiguousEmPm+0x48>
9d0036c8:	2e730001 	sltiu	s3,s3,1
  // link clusters
  while (endCluster > bgnCluster) {
    if (!fatPut(endCluster - 1, endCluster)) return false;
    endCluster--;
  }
  if (*curCluster != 0) {
9d0036cc:	8e450000 	lw	a1,0(s2)
9d0036d0:	14a00007 	bnez	a1,9d0036f0 <_ZN8SdVolume15allocContiguousEmPm+0x17c>
9d0036d4:	02e02021 	move	a0,s7
    // connect chains
    if (!fatPut(*curCluster, bgnCluster)) return false;
  }
  // return first cluster number to caller
  *curCluster = bgnCluster;
9d0036d8:	ae540000 	sw	s4,0(s2)

  // remember possible next free cluster
  if (setStart) allocSearchStart_ = bgnCluster + 1;
9d0036dc:	1260ffea 	beqz	s3,9d003688 <_ZN8SdVolume15allocContiguousEmPm+0x114>
9d0036e0:	24030001 	li	v1,1
9d0036e4:	26940001 	addiu	s4,s4,1
9d0036e8:	0b400da2 	j	9d003688 <_ZN8SdVolume15allocContiguousEmPm+0x114>
9d0036ec:	aef40000 	sw	s4,0(s7)
    if (!fatPut(endCluster - 1, endCluster)) return false;
    endCluster--;
  }
  if (*curCluster != 0) {
    // connect chains
    if (!fatPut(*curCluster, bgnCluster)) return false;
9d0036f0:	0f400d1e 	jal	9d003478 <_ZN8SdVolume6fatPutEmm>
9d0036f4:	02803021 	move	a2,s4
9d0036f8:	1440fff7 	bnez	v0,9d0036d8 <_ZN8SdVolume15allocContiguousEmPm+0x164>
9d0036fc:	00001821 	move	v1,zero

  // remember possible next free cluster
  if (setStart) allocSearchStart_ = bgnCluster + 1;

  return true;
}
9d003700:	0b400da3 	j	9d00368c <_ZN8SdVolume15allocContiguousEmPm+0x118>
9d003704:	8fbf003c 	lw	ra,60(sp)

9d003708 <_ZN8SdVolume9freeChainEm>:
  if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
  return true;
}
//------------------------------------------------------------------------------
// free a cluster chain
uint8_t SdVolume::freeChain(uint32_t cluster) {
9d003708:	27bdffd0 	addiu	sp,sp,-48
9d00370c:	afb20024 	sw	s2,36(sp)
  // clear free cluster location
  allocSearchStart_ = 2;
9d003710:	24020002 	li	v0,2
  }
  uint8_t freeChain(uint32_t cluster);
  uint8_t isEOC(uint32_t cluster) const {
    return  cluster >= (fatType_ == 16 ? FAT16EOC_MIN : FAT32EOC_MIN);
9d003714:	3c120fff 	lui	s2,0xfff
  if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
  return true;
}
//------------------------------------------------------------------------------
// free a cluster chain
uint8_t SdVolume::freeChain(uint32_t cluster) {
9d003718:	afb30028 	sw	s3,40(sp)
9d00371c:	afb10020 	sw	s1,32(sp)
9d003720:	afb0001c 	sw	s0,28(sp)
9d003724:	afbf002c 	sw	ra,44(sp)
9d003728:	00808021 	move	s0,a0
9d00372c:	00a09821 	move	s3,a1
  // clear free cluster location
  allocSearchStart_ = 2;
9d003730:	ac820000 	sw	v0,0(a0)
9d003734:	24110010 	li	s1,16
9d003738:	0b400ddb 	j	9d00376c <_ZN8SdVolume9freeChainEm+0x64>
9d00373c:	3652fff8 	ori	s2,s2,0xfff8
  do {
    uint32_t next;
    if (!fatGet(cluster, &next)) return false;

    // free cluster
    if (!fatPut(cluster, 0)) return false;
9d003740:	0f400d1e 	jal	9d003478 <_ZN8SdVolume6fatPutEmm>
9d003744:	00000000 	nop
9d003748:	10400010 	beqz	v0,9d00378c <_ZN8SdVolume9freeChainEm+0x84>
9d00374c:	3403fff8 	li	v1,0xfff8
9d003750:	92020020 	lbu	v0,32(s0)

    cluster = next;
9d003754:	8fb30010 	lw	s3,16(sp)
9d003758:	00511026 	xor	v0,v0,s1
9d00375c:	0242180b 	movn	v1,s2,v0
// free a cluster chain
uint8_t SdVolume::freeChain(uint32_t cluster) {
  // clear free cluster location
  allocSearchStart_ = 2;

  do {
9d003760:	0263182b 	sltu	v1,s3,v1
9d003764:	10600011 	beqz	v1,9d0037ac <_ZN8SdVolume9freeChainEm+0xa4>
9d003768:	8fbf002c 	lw	ra,44(sp)
    uint32_t next;
    if (!fatGet(cluster, &next)) return false;
9d00376c:	02602821 	move	a1,s3
9d003770:	02002021 	move	a0,s0
9d003774:	0f400cb5 	jal	9d0032d4 <_ZNK8SdVolume6fatGetEmPm>
9d003778:	27a60010 	addiu	a2,sp,16

    // free cluster
    if (!fatPut(cluster, 0)) return false;
9d00377c:	02602821 	move	a1,s3
9d003780:	02002021 	move	a0,s0
  // clear free cluster location
  allocSearchStart_ = 2;

  do {
    uint32_t next;
    if (!fatGet(cluster, &next)) return false;
9d003784:	1440ffee 	bnez	v0,9d003740 <_ZN8SdVolume9freeChainEm+0x38>
9d003788:	00003021 	move	a2,zero

    cluster = next;
  } while (!isEOC(cluster));

  return true;
}
9d00378c:	8fbf002c 	lw	ra,44(sp)
  do {
    uint32_t next;
    if (!fatGet(cluster, &next)) return false;

    // free cluster
    if (!fatPut(cluster, 0)) return false;
9d003790:	00001021 	move	v0,zero

    cluster = next;
  } while (!isEOC(cluster));

  return true;
}
9d003794:	8fb30028 	lw	s3,40(sp)
9d003798:	8fb20024 	lw	s2,36(sp)
9d00379c:	8fb10020 	lw	s1,32(sp)
9d0037a0:	8fb0001c 	lw	s0,28(sp)
9d0037a4:	03e00008 	jr	ra
9d0037a8:	27bd0030 	addiu	sp,sp,48
    if (!fatPut(cluster, 0)) return false;

    cluster = next;
  } while (!isEOC(cluster));

  return true;
9d0037ac:	24020001 	li	v0,1
}
9d0037b0:	8fb30028 	lw	s3,40(sp)
9d0037b4:	8fb20024 	lw	s2,36(sp)
9d0037b8:	8fb10020 	lw	s1,32(sp)
9d0037bc:	8fb0001c 	lw	s0,28(sp)
9d0037c0:	03e00008 	jr	ra
9d0037c4:	27bd0030 	addiu	sp,sp,48

9d0037c8 <_ZN8SdVolume4initEP7Sd2Cardh>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.  Reasons for
 * failure include not finding a valid partition, not finding a valid
 * FAT file system in the specified partition or an I/O error.
 */
uint8_t SdVolume::init(Sd2Card* dev, uint8_t part) {
9d0037c8:	27bdffe0 	addiu	sp,sp,-32
9d0037cc:	afb00010 	sw	s0,16(sp)
9d0037d0:	30d000ff 	andi	s0,a2,0xff
9d0037d4:	afb20018 	sw	s2,24(sp)
9d0037d8:	afbf001c 	sw	ra,28(sp)
9d0037dc:	afb10014 	sw	s1,20(sp)
9d0037e0:	00809021 	move	s2,a0
  uint32_t volumeStartBlock = 0;
  sdCard_ = dev;
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
9d0037e4:	12000025 	beqz	s0,9d00387c <_ZN8SdVolume4initEP7Sd2Cardh+0xb4>
9d0037e8:	af858030 	sw	a1,-32720(gp)
    if (part > 4)return false;
9d0037ec:	2e020005 	sltiu	v0,s0,5
9d0037f0:	14400008 	bnez	v0,9d003814 <_ZN8SdVolume4initEP7Sd2Cardh+0x4c>
9d0037f4:	00008821 	move	s1,zero
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
    fatType_ = 32;
  }
  return true;
}
9d0037f8:	8fbf001c 	lw	ra,28(sp)
9d0037fc:	02201021 	move	v0,s1
9d003800:	8fb20018 	lw	s2,24(sp)
9d003804:	8fb10014 	lw	s1,20(sp)
9d003808:	8fb00010 	lw	s0,16(sp)
9d00380c:	03e00008 	jr	ra
9d003810:	27bd0020 	addiu	sp,sp,32
  sdCard_ = dev;
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
9d003814:	00002021 	move	a0,zero
9d003818:	0f400c8f 	jal	9d00323c <_ZN8SdVolume13cacheRawBlockEmh>
9d00381c:	00002821 	move	a1,zero
9d003820:	1040fff5 	beqz	v0,9d0037f8 <_ZN8SdVolume4initEP7Sd2Cardh+0x30>
9d003824:	2602ffff 	addiu	v0,s0,-1
    part_t* p = &cacheBuffer_.mbr.part[part-1];
    if ((p->boot & 0X7F) !=0  ||
9d003828:	3c03a000 	lui	v1,0xa000
9d00382c:	00021100 	sll	v0,v0,0x4
9d003830:	24630a84 	addiu	v1,v1,2692
9d003834:	00431021 	addu	v0,v0,v1
9d003838:	904201be 	lbu	v0,446(v0)
9d00383c:	3042007f 	andi	v0,v0,0x7f
9d003840:	1440ffed 	bnez	v0,9d0037f8 <_ZN8SdVolume4initEP7Sd2Cardh+0x30>
9d003844:	2602001b 	addiu	v0,s0,27
9d003848:	00021100 	sll	v0,v0,0x4
9d00384c:	00431021 	addu	v0,v0,v1
9d003850:	8843000d 	lwl	v1,13(v0)
9d003854:	9843000a 	lwr	v1,10(v0)
9d003858:	2c630064 	sltiu	v1,v1,100
9d00385c:	1460ffe7 	bnez	v1,9d0037fc <_ZN8SdVolume4initEP7Sd2Cardh+0x34>
9d003860:	8fbf001c 	lw	ra,28(sp)
9d003864:	88500009 	lwl	s0,9(v0)
9d003868:	98500006 	lwr	s0,6(v0)
9d00386c:	16000005 	bnez	s0,9d003884 <_ZN8SdVolume4initEP7Sd2Cardh+0xbc>
9d003870:	02002021 	move	a0,s0
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
    fatType_ = 32;
  }
  return true;
}
9d003874:	0b400e00 	j	9d003800 <_ZN8SdVolume4initEP7Sd2Cardh+0x38>
9d003878:	02201021 	move	v0,s1
 * the value zero, false, is returned for failure.  Reasons for
 * failure include not finding a valid partition, not finding a valid
 * FAT file system in the specified partition or an I/O error.
 */
uint8_t SdVolume::init(Sd2Card* dev, uint8_t part) {
  uint32_t volumeStartBlock = 0;
9d00387c:	00008021 	move	s0,zero
      // not a valid partition
      return false;
    }
    volumeStartBlock = p->firstSector;
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
9d003880:	02002021 	move	a0,s0
9d003884:	0f400c8f 	jal	9d00323c <_ZN8SdVolume13cacheRawBlockEmh>
9d003888:	00002821 	move	a1,zero
9d00388c:	1040ffda 	beqz	v0,9d0037f8 <_ZN8SdVolume4initEP7Sd2Cardh+0x30>
9d003890:	00008821 	move	s1,zero
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
9d003894:	3c02a000 	lui	v0,0xa000
9d003898:	24420a84 	addiu	v0,v0,2692
9d00389c:	9044000c 	lbu	a0,12(v0)
9d0038a0:	9043000b 	lbu	v1,11(v0)
9d0038a4:	00042200 	sll	a0,a0,0x8
9d0038a8:	00832025 	or	a0,a0,v1
9d0038ac:	24030200 	li	v1,512
9d0038b0:	1483ffd2 	bne	a0,v1,9d0037fc <_ZN8SdVolume4initEP7Sd2Cardh+0x34>
9d0038b4:	8fbf001c 	lw	ra,28(sp)
9d0038b8:	90430010 	lbu	v1,16(v0)
9d0038bc:	5060ffd0 	beqzl	v1,9d003800 <_ZN8SdVolume4initEP7Sd2Cardh+0x38>
9d0038c0:	02201021 	move	v0,s1
9d0038c4:	9444000e 	lhu	a0,14(v0)
9d0038c8:	5080ffcd 	beqzl	a0,9d003800 <_ZN8SdVolume4initEP7Sd2Cardh+0x38>
9d0038cc:	02201021 	move	v0,s1
9d0038d0:	9046000d 	lbu	a2,13(v0)
9d0038d4:	10c0ffc9 	beqz	a2,9d0037fc <_ZN8SdVolume4initEP7Sd2Cardh+0x34>
9d0038d8:	00002021 	move	a0,zero
    bpb->reservedSectorCount == 0 ||
    bpb->sectorsPerCluster == 0) {
       // not valid FAT volume
      return false;
  }
  fatCount_ = bpb->fatCount;
9d0038dc:	a2430018 	sb	v1,24(s2)
  blocksPerCluster_ = bpb->sectorsPerCluster;
9d0038e0:	a2460004 	sb	a2,4(s2)

  // determine shift that is same as multiply by blocksPerCluster_
  clusterSizeShift_ = 0;
9d0038e4:	a2400010 	sb	zero,16(s2)
  while (blocksPerCluster_ != (1 << clusterSizeShift_)) {
9d0038e8:	00001821 	move	v1,zero
9d0038ec:	24070001 	li	a3,1
9d0038f0:	0b400e41 	j	9d003904 <_ZN8SdVolume4initEP7Sd2Cardh+0x13c>
9d0038f4:	24080009 	li	t0,9
    // error if not power of 2
    if (clusterSizeShift_++ > 7) return false;
9d0038f8:	24630001 	addiu	v1,v1,1
9d0038fc:	1068002e 	beq	v1,t0,9d0039b8 <_ZN8SdVolume4initEP7Sd2Cardh+0x1f0>
9d003900:	a2440010 	sb	a0,16(s2)
9d003904:	24840001 	addiu	a0,a0,1
  fatCount_ = bpb->fatCount;
  blocksPerCluster_ = bpb->sectorsPerCluster;

  // determine shift that is same as multiply by blocksPerCluster_
  clusterSizeShift_ = 0;
  while (blocksPerCluster_ != (1 << clusterSizeShift_)) {
9d003908:	00672804 	sllv	a1,a3,v1
9d00390c:	14a6fffa 	bne	a1,a2,9d0038f8 <_ZN8SdVolume4initEP7Sd2Cardh+0x130>
9d003910:	308400ff 	andi	a0,a0,0xff
    // error if not power of 2
    if (clusterSizeShift_++ > 7) return false;
  }
  blocksPerFat_ = bpb->sectorsPerFat16 ?
                    bpb->sectorsPerFat16 : bpb->sectorsPerFat32;
9d003914:	94450016 	lhu	a1,22(v0)
9d003918:	50a00001 	beqzl	a1,9d003920 <_ZN8SdVolume4initEP7Sd2Cardh+0x158>
9d00391c:	8c450024 	lw	a1,36(v0)
9d003920:	ae450008 	sw	a1,8(s2)

  // count for FAT16 zero for FAT32
  rootDirEntryCount_ = bpb->rootDirEntryCount;

  // directory start for FAT16 dataStart for FAT32
  rootDirStart_ = fatStartBlock_ + bpb->fatCount * blocksPerFat_;
9d003924:	90460010 	lbu	a2,16(v0)
    if (clusterSizeShift_++ > 7) return false;
  }
  blocksPerFat_ = bpb->sectorsPerFat16 ?
                    bpb->sectorsPerFat16 : bpb->sectorsPerFat32;

  fatStartBlock_ = volumeStartBlock + bpb->reservedSectorCount;
9d003928:	9444000e 	lhu	a0,14(v0)

  // count for FAT16 zero for FAT32
  rootDirEntryCount_ = bpb->rootDirEntryCount;

  // directory start for FAT16 dataStart for FAT32
  rootDirStart_ = fatStartBlock_ + bpb->fatCount * blocksPerFat_;
9d00392c:	70a63802 	mul	a3,a1,a2
    if (clusterSizeShift_++ > 7) return false;
  }
  blocksPerFat_ = bpb->sectorsPerFat16 ?
                    bpb->sectorsPerFat16 : bpb->sectorsPerFat32;

  fatStartBlock_ = volumeStartBlock + bpb->reservedSectorCount;
9d003930:	02042021 	addu	a0,s0,a0
9d003934:	ae44001c 	sw	a0,28(s2)

  // count for FAT16 zero for FAT32
  rootDirEntryCount_ = bpb->rootDirEntryCount;
9d003938:	8c460010 	lw	a2,16(v0)
9d00393c:	7cc67a00 	ext	a2,a2,0x8,0x10
9d003940:	a6460022 	sh	a2,34(s2)

  // directory start for FAT16 dataStart for FAT32
  rootDirStart_ = fatStartBlock_ + bpb->fatCount * blocksPerFat_;
9d003944:	00e42821 	addu	a1,a3,a0
                    bpb->sectorsPerFat16 : bpb->sectorsPerFat32;

  fatStartBlock_ = volumeStartBlock + bpb->reservedSectorCount;

  // count for FAT16 zero for FAT32
  rootDirEntryCount_ = bpb->rootDirEntryCount;
9d003948:	30c4ffff 	andi	a0,a2,0xffff

  // directory start for FAT16 dataStart for FAT32
  rootDirStart_ = fatStartBlock_ + bpb->fatCount * blocksPerFat_;

  // data start for FAT16 and FAT32
  dataStartBlock_ = rootDirStart_ + ((32 * bpb->rootDirEntryCount + 511)/512);
9d00394c:	00042140 	sll	a0,a0,0x5
9d003950:	248401ff 	addiu	a0,a0,511
9d003954:	00042243 	sra	a0,a0,0x9
9d003958:	00a42021 	addu	a0,a1,a0

  // count for FAT16 zero for FAT32
  rootDirEntryCount_ = bpb->rootDirEntryCount;

  // directory start for FAT16 dataStart for FAT32
  rootDirStart_ = fatStartBlock_ + bpb->fatCount * blocksPerFat_;
9d00395c:	ae450024 	sw	a1,36(s2)

  // data start for FAT16 and FAT32
  dataStartBlock_ = rootDirStart_ + ((32 * bpb->rootDirEntryCount + 511)/512);
9d003960:	ae440014 	sw	a0,20(s2)

  // total blocks for FAT16 or FAT32
  uint32_t totalBlocks = bpb->totalSectors16 ?
                           bpb->totalSectors16 : bpb->totalSectors32;
9d003964:	90450014 	lbu	a1,20(v0)
9d003968:	90460013 	lbu	a2,19(v0)
9d00396c:	00052a00 	sll	a1,a1,0x8
9d003970:	00a62825 	or	a1,a1,a2
9d003974:	50a00001 	beqzl	a1,9d00397c <_ZN8SdVolume4initEP7Sd2Cardh+0x1b4>
9d003978:	8c450020 	lw	a1,32(v0)
  // total data blocks
  clusterCount_ = totalBlocks - (dataStartBlock_ - volumeStartBlock);
9d00397c:	02042023 	subu	a0,s0,a0
9d003980:	00852021 	addu	a0,a0,a1

  // divide by cluster size to get cluster count
  clusterCount_ >>= clusterSizeShift_;
9d003984:	00641806 	srlv	v1,a0,v1

  // FAT type is determined by cluster count
  if (clusterCount_ < 4085) {
9d003988:	2c640ff5 	sltiu	a0,v1,4085
9d00398c:	1480000c 	bnez	a0,9d0039c0 <_ZN8SdVolume4initEP7Sd2Cardh+0x1f8>
9d003990:	ae43000c 	sw	v1,12(s2)
    fatType_ = 12;
  } else if (clusterCount_ < 65525) {
9d003994:	3404fff5 	li	a0,0xfff5
9d003998:	0064182b 	sltu	v1,v1,a0
9d00399c:	1460000c 	bnez	v1,9d0039d0 <_ZN8SdVolume4initEP7Sd2Cardh+0x208>
9d0039a0:	24030020 	li	v1,32
    fatType_ = 16;
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
9d0039a4:	8c42002c 	lw	v0,44(v0)
    fatType_ = 32;
9d0039a8:	a2430020 	sb	v1,32(s2)
  if (clusterCount_ < 4085) {
    fatType_ = 12;
  } else if (clusterCount_ < 65525) {
    fatType_ = 16;
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
9d0039ac:	ae420024 	sw	v0,36(s2)
    fatType_ = 32;
  }
  return true;
9d0039b0:	0b400dfe 	j	9d0037f8 <_ZN8SdVolume4initEP7Sd2Cardh+0x30>
9d0039b4:	24110001 	li	s1,1

  // determine shift that is same as multiply by blocksPerCluster_
  clusterSizeShift_ = 0;
  while (blocksPerCluster_ != (1 << clusterSizeShift_)) {
    // error if not power of 2
    if (clusterSizeShift_++ > 7) return false;
9d0039b8:	0b400dfe 	j	9d0037f8 <_ZN8SdVolume4initEP7Sd2Cardh+0x30>
9d0039bc:	00008821 	move	s1,zero
  // divide by cluster size to get cluster count
  clusterCount_ >>= clusterSizeShift_;

  // FAT type is determined by cluster count
  if (clusterCount_ < 4085) {
    fatType_ = 12;
9d0039c0:	2402000c 	li	v0,12
9d0039c4:	a2420020 	sb	v0,32(s2)
    fatType_ = 16;
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
    fatType_ = 32;
  }
  return true;
9d0039c8:	0b400dfe 	j	9d0037f8 <_ZN8SdVolume4initEP7Sd2Cardh+0x30>
9d0039cc:	24110001 	li	s1,1

  // FAT type is determined by cluster count
  if (clusterCount_ < 4085) {
    fatType_ = 12;
  } else if (clusterCount_ < 65525) {
    fatType_ = 16;
9d0039d0:	24020010 	li	v0,16
9d0039d4:	a2420020 	sb	v0,32(s2)
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
    fatType_ = 32;
  }
  return true;
9d0039d8:	0b400dfe 	j	9d0037f8 <_ZN8SdVolume4initEP7Sd2Cardh+0x30>
9d0039dc:	24110001 	li	s1,1

9d0039e0 <_ZN4DSPI8setSpeedEm>:

	uint16_t	brg;

	/* Compute the baud rate divider for this frequency.
	*/
	brg = (uint16_t)((F_CPU / (2 * spd)) - 1);
9d0039e0:	3c0204c4 	lui	v0,0x4c4
9d0039e4:	3442b400 	ori	v0,v0,0xb400
9d0039e8:	00052840 	sll	a1,a1,0x1
9d0039ec:	0045001b 	divu	zero,v0,a1
9d0039f0:	00a001f4 	teq	a1,zero,0x7

	/* That the baud rate value is in the correct range.
	*/
	if (brg == 0xFFFF) {
9d0039f4:	3403ffff 	li	v1,0xffff

	uint16_t	brg;

	/* Compute the baud rate divider for this frequency.
	*/
	brg = (uint16_t)((F_CPU / (2 * spd)) - 1);
9d0039f8:	00001012 	mflo	v0
9d0039fc:	2442ffff 	addiu	v0,v0,-1
9d003a00:	3042ffff 	andi	v0,v0,0xffff

	/* That the baud rate value is in the correct range.
	*/
	if (brg == 0xFFFF) {
9d003a04:	1043000a 	beq	v0,v1,9d003a30 <_ZN4DSPI8setSpeedEm+0x50>
9d003a08:	2c430200 	sltiu	v1,v0,512
		** Set it to the highest supported frequency.
		*/
		brg = 0;
	}

	if (brg > 0x1FF) {
9d003a0c:	14600009 	bnez	v1,9d003a34 <_ZN4DSPI8setSpeedEm+0x54>
9d003a10:	240501ff 	li	a1,511

	/* Write the value to the SPI baud rate register. Section 23. SPI
	** of the PIC32 Family Reference Manual says to disable the SPI
	** controller before writing to the baud register
	*/
	pspi->sxCon.clr = (1 << _SPICON_ON);	// disable SPI
9d003a14:	8c820020 	lw	v0,32(a0)
9d003a18:	34038000 	li	v1,0x8000
9d003a1c:	ac430004 	sw	v1,4(v0)
	pspi->sxBrg.reg = brg;
9d003a20:	ac450030 	sw	a1,48(v0)
	pspi->sxCon.set = (1 << _SPICON_ON);	// enable SPI
9d003a24:	ac430008 	sw	v1,8(v0)

}
9d003a28:	03e00008 	jr	ra
9d003a2c:	00000000 	nop
	*/
	if (brg == 0xFFFF) {
		/* The user tried to set a frequency that is too high to support.
		** Set it to the highest supported frequency.
		*/
		brg = 0;
9d003a30:	00001021 	move	v0,zero
	}

	if (brg > 0x1FF) {
9d003a34:	00402821 	move	a1,v0

	/* Write the value to the SPI baud rate register. Section 23. SPI
	** of the PIC32 Family Reference Manual says to disable the SPI
	** controller before writing to the baud register
	*/
	pspi->sxCon.clr = (1 << _SPICON_ON);	// disable SPI
9d003a38:	8c820020 	lw	v0,32(a0)
9d003a3c:	34038000 	li	v1,0x8000
9d003a40:	ac430004 	sw	v1,4(v0)
	pspi->sxBrg.reg = brg;
9d003a44:	ac450030 	sw	a1,48(v0)
	pspi->sxCon.set = (1 << _SPICON_ON);	// enable SPI
9d003a48:	ac430008 	sw	v1,8(v0)

}
9d003a4c:	03e00008 	jr	ra
9d003a50:	00000000 	nop

9d003a54 <_ZN4DSPI12setPinSelectEh>:
**		pin be an output driving high. This pin will then be use
**		by the setSelect method.
*/

void
DSPI::setPinSelect(uint8_t pin) {
9d003a54:	27bdffe8 	addiu	sp,sp,-24
9d003a58:	afb00010 	sw	s0,16(sp)
9d003a5c:	30a200ff 	andi	v0,a1,0xff
9d003a60:	00808021 	move	s0,a0
9d003a64:	afbf0014 	sw	ra,20(sp)

	pinSS = pin;

	pinMode(pinSS, OUTPUT);
9d003a68:	00402021 	move	a0,v0
9d003a6c:	24050001 	li	a1,1
9d003a70:	0f4010b3 	jal	9d0042cc <pinMode>
9d003a74:	a202002a 	sb	v0,42(s0)
	digitalWrite(pinSS, HIGH);
9d003a78:	9204002a 	lbu	a0,42(s0)

}
9d003a7c:	8fbf0014 	lw	ra,20(sp)
9d003a80:	8fb00010 	lw	s0,16(sp)
DSPI::setPinSelect(uint8_t pin) {

	pinSS = pin;

	pinMode(pinSS, OUTPUT);
	digitalWrite(pinSS, HIGH);
9d003a84:	24050001 	li	a1,1
9d003a88:	0b4010fb 	j	9d0043ec <digitalWrite>
9d003a8c:	27bd0018 	addiu	sp,sp,24

9d003a90 <_ZN4DSPI5beginEh>:
**		will set the clock rate to the default speed and the
**		pin for SS to the specified pin.
*/

void
DSPI::begin(uint8_t pinT) {
9d003a90:	27bdffe0 	addiu	sp,sp,-32
9d003a94:	afbf001c 	sw	ra,28(sp)
9d003a98:	afb10018 	sw	s1,24(sp)
9d003a9c:	afb00014 	sw	s0,20(sp)
9d003aa0:	00808021 	move	s0,a0
9d003aa4:	30b100ff 	andi	s1,a1,0xff
	*/
    mapPps(pinMOSI, ppsMOSI);
#endif

    // set up the interrupt handler 
    setIntVector(vec, isr);
9d003aa8:	90840028 	lbu	a0,40(a0)
9d003aac:	0f400feb 	jal	9d003fac <setIntVector>
9d003ab0:	8e050024 	lw	a1,36(s0)
/* Initialize the pins. The pin directions for SDO, SDI and SCK
	** are set automatically when the SPI controller is enabled. The
	** SS pin isn't explicitly used by the SPI controller when in
	** master mode, so we need to initialize it ourselves.
	*/
	setPinSelect(pinT);
9d003ab4:	02002021 	move	a0,s0
9d003ab8:	0f400e95 	jal	9d003a54 <_ZN4DSPI12setPinSelectEh>
9d003abc:	02202821 	move	a1,s1

	/* Disable interrupts on this SPI controller.
	*/
	pregIec->clr = bitErr + bitRx + bitTx;
9d003ac0:	8e07000c 	lw	a3,12(s0)
9d003ac4:	8e030008 	lw	v1,8(s0)
9d003ac8:	8e060010 	lw	a2,16(s0)
9d003acc:	8e050004 	lw	a1,4(s0)

	/* Disable and reset the SPI controller.
	*/
	pspi->sxCon.reg = 0;
9d003ad0:	8e020020 	lw	v0,32(s0)
	*/
	bTmp = pspi->sxBuf.reg;

	/* Clear all SPI interrupt flags.
	*/
	pregIfs->clr = bitErr + bitRx + bitTx;
9d003ad4:	8e040000 	lw	a0,0(s0)
	*/
	setPinSelect(pinT);

	/* Disable interrupts on this SPI controller.
	*/
	pregIec->clr = bitErr + bitRx + bitTx;
9d003ad8:	00e31821 	addu	v1,a3,v1
9d003adc:	00661821 	addu	v1,v1,a2
9d003ae0:	aca30004 	sw	v1,4(a1)

	/* Disable and reset the SPI controller.
	*/
	pspi->sxCon.reg = 0;
9d003ae4:	ac400000 	sw	zero,0(v0)

	/* Clear the receive buffer.
	*/
	bTmp = pspi->sxBuf.reg;
9d003ae8:	8c450020 	lw	a1,32(v0)

	/* Clear all SPI interrupt flags.
	*/
	pregIfs->clr = bitErr + bitRx + bitTx;
9d003aec:	ac830004 	sw	v1,4(a0)

	/* Compute the address of the interrupt priority control register
	** used by this SPI controller.
	*/
	pregIpc = ((p32_regset *)&IPC0) + (vec / 4);	// interrupt priority control register
9d003af0:	92040028 	lbu	a0,40(s0)
9d003af4:	3c03bf88 	lui	v1,0xbf88
9d003af8:	24631090 	addiu	v1,v1,4240
9d003afc:	00042882 	srl	a1,a0,0x2
9d003b00:	00052900 	sll	a1,a1,0x4

	/* Compute the bit position of the interrupt priority bits for
	** this interrupt vector.
	*/
	bnVec = 8 * (vec % 4);
9d003b04:	30840003 	andi	a0,a0,0x3
	pregIfs->clr = bitErr + bitRx + bitTx;

	/* Compute the address of the interrupt priority control register
	** used by this SPI controller.
	*/
	pregIpc = ((p32_regset *)&IPC0) + (vec / 4);	// interrupt priority control register
9d003b08:	00651821 	addu	v1,v1,a1

	/* Compute the bit position of the interrupt priority bits for
	** this interrupt vector.
	*/
	bnVec = 8 * (vec % 4);
9d003b0c:	000420c0 	sll	a0,a0,0x3
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	pregIpc->clr = (0x1F << bnVec);
9d003b10:	2405001f 	li	a1,31
9d003b14:	00852804 	sllv	a1,a1,a0
9d003b18:	ac650004 	sw	a1,4(v1)
	pregIpc->set = ipl << bnVec;
9d003b1c:	92050029 	lbu	a1,41(s0)
9d003b20:	00852004 	sllv	a0,a1,a0
9d003b24:	ac640008 	sw	a0,8(v1)

	/* Set the default baud rate.
	*/
	brg = (uint16_t)((F_CPU / (2 * _DSPI_SPD_DEFAULT)) - 1);
	pspi->sxBrg.reg = brg;
9d003b28:	24030027 	li	v1,39
9d003b2c:	ac430030 	sw	v1,48(v0)

	/* Clear the receive overflow bit and receive overflow error flag
	*/
	pspi->sxStat.clr = (1 << _SPISTAT_SPIROV);
9d003b30:	24030040 	li	v1,64
9d003b34:	ac430014 	sw	v1,20(v0)
	fRov = 0;
9d003b38:	a200001f 	sb	zero,31(s0)
	** the SS pin MUST be kept as OUTPUT.
	*/
	pspi->sxCon.reg = 0;
	pspi->sxCon.set = (1 << _SPICON_ON) + (1 << _SPICON_MSTEN) + DSPI_MODE0;

}	
9d003b3c:	8fbf001c 	lw	ra,28(sp)
	** Warning: if the SS pin ever becomes a LOW INPUT then SPI 
	** automatically switches to Slave, so the data direction of 
	** the SS pin MUST be kept as OUTPUT.
	*/
	pspi->sxCon.reg = 0;
	pspi->sxCon.set = (1 << _SPICON_ON) + (1 << _SPICON_MSTEN) + DSPI_MODE0;
9d003b40:	34038120 	li	v1,0x8120
	/* Enable the SPI controller.
	** Warning: if the SS pin ever becomes a LOW INPUT then SPI 
	** automatically switches to Slave, so the data direction of 
	** the SS pin MUST be kept as OUTPUT.
	*/
	pspi->sxCon.reg = 0;
9d003b44:	ac400000 	sw	zero,0(v0)
	pspi->sxCon.set = (1 << _SPICON_ON) + (1 << _SPICON_MSTEN) + DSPI_MODE0;

}	
9d003b48:	8fb10018 	lw	s1,24(sp)
9d003b4c:	8fb00014 	lw	s0,20(sp)
	** Warning: if the SS pin ever becomes a LOW INPUT then SPI 
	** automatically switches to Slave, so the data direction of 
	** the SS pin MUST be kept as OUTPUT.
	*/
	pspi->sxCon.reg = 0;
	pspi->sxCon.set = (1 << _SPICON_ON) + (1 << _SPICON_MSTEN) + DSPI_MODE0;
9d003b50:	ac430008 	sw	v1,8(v0)

}	
9d003b54:	03e00008 	jr	ra
9d003b58:	27bd0020 	addiu	sp,sp,32

9d003b5c <_ZN4DSPI5beginEv>:
void
DSPI::begin() {

	/* Use the default pin specified in the constructor.
	*/
	begin(pinSS);
9d003b5c:	0b400ea4 	j	9d003a90 <_ZN4DSPI5beginEh>
9d003b60:	9085002a 	lbu	a1,42(a0)

9d003b64 <_ZN4DSPI8transferEm>:
**		Send the specified byte to the SPI slave device, returning
**		the byte received from the slave device.
*/

uint32_t
DSPI::transfer(uint32_t bVal) {
9d003b64:	8c820020 	lw	v0,32(a0)

	while ((pspi->sxStat.reg & (1 << _SPISTAT_SPITBE)) == 0) {
9d003b68:	8c430010 	lw	v1,16(v0)
9d003b6c:	30630008 	andi	v1,v1,0x8
9d003b70:	1060fffd 	beqz	v1,9d003b68 <_ZN4DSPI8transferEm+0x4>
9d003b74:	00000000 	nop
	}
	pspi->sxBuf.reg = bVal;
9d003b78:	ac450020 	sw	a1,32(v0)

	while ((pspi->sxStat.reg & (1 << _SPISTAT_SPIRBF)) == 0) {
9d003b7c:	8c430010 	lw	v1,16(v0)
9d003b80:	30630001 	andi	v1,v1,0x1
9d003b84:	1060fffd 	beqz	v1,9d003b7c <_ZN4DSPI8transferEm+0x18>
9d003b88:	00000000 	nop
	}

	return pspi->sxBuf.reg;
9d003b8c:	8c420020 	lw	v0,32(v0)

}
9d003b90:	03e00008 	jr	ra
9d003b94:	00000000 	nop

9d003b98 <_ZN4DSPI8transferEtPh>:
*/

void
DSPI::transfer(uint16_t cbReq, uint8_t * pbSnd) {
#ifdef _SPI1ACON_ENHBUF_POSITION
    pspi->sxCon.clr = 1<<_SPI1ACON_ON_POSITION;
9d003b98:	8c820020 	lw	v0,32(a0)
9d003b9c:	34038000 	li	v1,0x8000
    pspi->sxCon.set = 1<<_SPI1ACON_ENHBUF_POSITION;
9d003ba0:	3c040001 	lui	a0,0x1
**		slave device, discarding the bytes received from the
**		slave.
*/

void
DSPI::transfer(uint16_t cbReq, uint8_t * pbSnd) {
9d003ba4:	30a5ffff 	andi	a1,a1,0xffff
#ifdef _SPI1ACON_ENHBUF_POSITION
    pspi->sxCon.clr = 1<<_SPI1ACON_ON_POSITION;
9d003ba8:	ac430004 	sw	v1,4(v0)
    pspi->sxCon.set = 1<<_SPI1ACON_ENHBUF_POSITION;
9d003bac:	ac440008 	sw	a0,8(v0)
    pspi->sxCon.set = 1<<_SPI1ACON_ON_POSITION;
9d003bb0:	ac430008 	sw	v1,8(v0)
    uint16_t toWrite = cbReq;
    uint16_t toRead = cbReq;
    uint16_t wPos = 0;

    while (toWrite > 0 && toRead > 0) {
9d003bb4:	10a0001c 	beqz	a1,9d003c28 <_ZN4DSPI8transferEtPh+0x90>
9d003bb8:	34038000 	li	v1,0x8000
9d003bbc:	00a01821 	move	v1,a1
9d003bc0:	00002021 	move	a0,zero
        if (toWrite > 0) {
9d003bc4:	1060000b 	beqz	v1,9d003bf4 <_ZN4DSPI8transferEtPh+0x5c>
9d003bc8:	00000000 	nop
            if ((pspi->sxStat.reg & 1<<_SPI1ASTAT_SPITBF_POSITION) == 0) {
9d003bcc:	8c470010 	lw	a3,16(v0)
                pspi->sxBuf.reg = pbSnd[wPos++];
9d003bd0:	00c45021 	addu	t2,a2,a0
9d003bd4:	24880001 	addiu	t0,a0,1
    uint16_t toRead = cbReq;
    uint16_t wPos = 0;

    while (toWrite > 0 && toRead > 0) {
        if (toWrite > 0) {
            if ((pspi->sxStat.reg & 1<<_SPI1ASTAT_SPITBF_POSITION) == 0) {
9d003bd8:	30e70002 	andi	a3,a3,0x2
9d003bdc:	14e00005 	bnez	a3,9d003bf4 <_ZN4DSPI8transferEtPh+0x5c>
9d003be0:	2469ffff 	addiu	t1,v1,-1
                pspi->sxBuf.reg = pbSnd[wPos++];
9d003be4:	91470000 	lbu	a3,0(t2)
                toWrite--;
9d003be8:	3123ffff 	andi	v1,t1,0xffff
    uint16_t wPos = 0;

    while (toWrite > 0 && toRead > 0) {
        if (toWrite > 0) {
            if ((pspi->sxStat.reg & 1<<_SPI1ASTAT_SPITBF_POSITION) == 0) {
                pspi->sxBuf.reg = pbSnd[wPos++];
9d003bec:	3104ffff 	andi	a0,t0,0xffff
9d003bf0:	ac470020 	sw	a3,32(v0)
                toWrite--;
            }
        }
        if (toRead > 0) {
9d003bf4:	10a00007 	beqz	a1,9d003c14 <_ZN4DSPI8transferEtPh+0x7c>
9d003bf8:	00000000 	nop
            if ((pspi->sxStat.reg & 1<<_SPI1ASTAT_SPIRBE_POSITION) == 0) {
9d003bfc:	8c470010 	lw	a3,16(v0)
9d003c00:	30e70020 	andi	a3,a3,0x20
9d003c04:	14e00003 	bnez	a3,9d003c14 <_ZN4DSPI8transferEtPh+0x7c>
9d003c08:	24a8ffff 	addiu	t0,a1,-1
                (void) pspi->sxBuf.reg;
9d003c0c:	8c450020 	lw	a1,32(v0)
                toRead--;
9d003c10:	3105ffff 	andi	a1,t0,0xffff
    pspi->sxCon.set = 1<<_SPI1ACON_ON_POSITION;
    uint16_t toWrite = cbReq;
    uint16_t toRead = cbReq;
    uint16_t wPos = 0;

    while (toWrite > 0 && toRead > 0) {
9d003c14:	50600004 	beqzl	v1,9d003c28 <_ZN4DSPI8transferEtPh+0x90>
9d003c18:	34038000 	li	v1,0x8000
9d003c1c:	14a0ffe9 	bnez	a1,9d003bc4 <_ZN4DSPI8transferEtPh+0x2c>
9d003c20:	00000000 	nop
                (void) pspi->sxBuf.reg;
                toRead--;
            }
        }
    }
    pspi->sxCon.clr = 1<<_SPI1ACON_ON_POSITION;
9d003c24:	34038000 	li	v1,0x8000
    pspi->sxCon.clr = 1<<_SPI1ACON_ENHBUF_POSITION;
9d003c28:	3c040001 	lui	a0,0x1
                (void) pspi->sxBuf.reg;
                toRead--;
            }
        }
    }
    pspi->sxCon.clr = 1<<_SPI1ACON_ON_POSITION;
9d003c2c:	ac430004 	sw	v1,4(v0)
    pspi->sxCon.clr = 1<<_SPI1ACON_ENHBUF_POSITION;
9d003c30:	ac440004 	sw	a0,4(v0)
    pspi->sxCon.set = 1<<_SPI1ACON_ON_POSITION;
9d003c34:	ac430008 	sw	v1,8(v0)

	for (cbCur = cbReq; cbCur > 0; cbCur--) {
		transfer(*pbSnd++);
	}
#endif
}
9d003c38:	03e00008 	jr	ra
9d003c3c:	00000000 	nop

9d003c40 <_ZN4DSPI8transferEthPh>:
*/

void
DSPI::transfer(uint16_t cbReq, uint8_t bPad, uint8_t * pbRcv) {
#ifdef _SPI1ACON_ENHBUF_POSITION
    pspi->sxCon.clr = 1<<_SPI1ACON_ON_POSITION;
9d003c40:	8c820020 	lw	v0,32(a0)
9d003c44:	34038000 	li	v1,0x8000
    pspi->sxCon.set = 1<<_SPI1ACON_ENHBUF_POSITION;
9d003c48:	3c080001 	lui	t0,0x1
**		from the slave. The given pad byte will be sent to the
**		slave to cause the received bytes to be sent.
*/

void
DSPI::transfer(uint16_t cbReq, uint8_t bPad, uint8_t * pbRcv) {
9d003c4c:	30a5ffff 	andi	a1,a1,0xffff
#ifdef _SPI1ACON_ENHBUF_POSITION
    pspi->sxCon.clr = 1<<_SPI1ACON_ON_POSITION;
9d003c50:	ac430004 	sw	v1,4(v0)
**		from the slave. The given pad byte will be sent to the
**		slave to cause the received bytes to be sent.
*/

void
DSPI::transfer(uint16_t cbReq, uint8_t bPad, uint8_t * pbRcv) {
9d003c54:	30c600ff 	andi	a2,a2,0xff
#ifdef _SPI1ACON_ENHBUF_POSITION
    pspi->sxCon.clr = 1<<_SPI1ACON_ON_POSITION;
    pspi->sxCon.set = 1<<_SPI1ACON_ENHBUF_POSITION;
9d003c58:	ac480008 	sw	t0,8(v0)
    pspi->sxCon.set = 1<<_SPI1ACON_ON_POSITION;
9d003c5c:	ac430008 	sw	v1,8(v0)
    uint16_t toWrite = cbReq;
    uint16_t toRead = cbReq;
    uint16_t rPos = 0;

    while (toWrite > 0 && toRead > 0) {
9d003c60:	10a0001d 	beqz	a1,9d003cd8 <_ZN4DSPI8transferEthPh+0x98>
9d003c64:	34038000 	li	v1,0x8000
9d003c68:	00a01821 	move	v1,a1
9d003c6c:	00004021 	move	t0,zero
        if (toWrite > 0) {
9d003c70:	10600007 	beqz	v1,9d003c90 <_ZN4DSPI8transferEthPh+0x50>
9d003c74:	00000000 	nop
            if ((pspi->sxStat.reg & 1<<_SPI1ASTAT_SPITBF_POSITION) == 0) {
9d003c78:	8c490010 	lw	t1,16(v0)
9d003c7c:	31290002 	andi	t1,t1,0x2
9d003c80:	15200003 	bnez	t1,9d003c90 <_ZN4DSPI8transferEthPh+0x50>
9d003c84:	246affff 	addiu	t2,v1,-1
                pspi->sxBuf.reg = bPad;
9d003c88:	ac460020 	sw	a2,32(v0)
                toWrite--;
9d003c8c:	3143ffff 	andi	v1,t2,0xffff
            }
        }
        if (toRead > 0) {
9d003c90:	10a0000c 	beqz	a1,9d003cc4 <_ZN4DSPI8transferEthPh+0x84>
9d003c94:	00000000 	nop
            if ((pspi->sxStat.reg & 1<<_SPI1ASTAT_SPIRBE_POSITION) == 0) {
9d003c98:	8c490010 	lw	t1,16(v0)
                pbRcv[rPos++] = pspi->sxBuf.reg;
9d003c9c:	00e85021 	addu	t2,a3,t0
9d003ca0:	250b0001 	addiu	t3,t0,1
                pspi->sxBuf.reg = bPad;
                toWrite--;
            }
        }
        if (toRead > 0) {
            if ((pspi->sxStat.reg & 1<<_SPI1ASTAT_SPIRBE_POSITION) == 0) {
9d003ca4:	31290020 	andi	t1,t1,0x20
9d003ca8:	15200006 	bnez	t1,9d003cc4 <_ZN4DSPI8transferEthPh+0x84>
9d003cac:	24acffff 	addiu	t4,a1,-1
                pbRcv[rPos++] = pspi->sxBuf.reg;
9d003cb0:	8c420020 	lw	v0,32(v0)
                toRead--;
9d003cb4:	3185ffff 	andi	a1,t4,0xffff
                toWrite--;
            }
        }
        if (toRead > 0) {
            if ((pspi->sxStat.reg & 1<<_SPI1ASTAT_SPIRBE_POSITION) == 0) {
                pbRcv[rPos++] = pspi->sxBuf.reg;
9d003cb8:	3168ffff 	andi	t0,t3,0xffff
9d003cbc:	a1420000 	sb	v0,0(t2)
                toRead--;
9d003cc0:	8c820020 	lw	v0,32(a0)
    pspi->sxCon.set = 1<<_SPI1ACON_ON_POSITION;
    uint16_t toWrite = cbReq;
    uint16_t toRead = cbReq;
    uint16_t rPos = 0;

    while (toWrite > 0 && toRead > 0) {
9d003cc4:	50600004 	beqzl	v1,9d003cd8 <_ZN4DSPI8transferEthPh+0x98>
9d003cc8:	34038000 	li	v1,0x8000
9d003ccc:	14a0ffe8 	bnez	a1,9d003c70 <_ZN4DSPI8transferEthPh+0x30>
9d003cd0:	00000000 	nop
                pbRcv[rPos++] = pspi->sxBuf.reg;
                toRead--;
            }
        }
    }
    pspi->sxCon.clr = 1<<_SPI1ACON_ON_POSITION;
9d003cd4:	34038000 	li	v1,0x8000
    pspi->sxCon.clr = 1<<_SPI1ACON_ENHBUF_POSITION;
9d003cd8:	3c040001 	lui	a0,0x1
                pbRcv[rPos++] = pspi->sxBuf.reg;
                toRead--;
            }
        }
    }
    pspi->sxCon.clr = 1<<_SPI1ACON_ON_POSITION;
9d003cdc:	ac430004 	sw	v1,4(v0)
    pspi->sxCon.clr = 1<<_SPI1ACON_ENHBUF_POSITION;
9d003ce0:	ac440004 	sw	a0,4(v0)
    pspi->sxCon.set = 1<<_SPI1ACON_ON_POSITION;
9d003ce4:	ac430008 	sw	v1,8(v0)

	for (cbCur = cbReq; cbCur > 0; cbCur--) {
		*pbRcv++ = transfer(bPad);
	}
#endif
}
9d003ce8:	03e00008 	jr	ra
9d003cec:	00000000 	nop

9d003cf0 <_ZN4DSPI15doDspiInterruptEv>:
	uint8_t		bTmp;
	uint32_t	regIfs;

	/* Get the interrupt flag status.
	*/
	regIfs = pregIfs->reg;
9d003cf0:	8c820000 	lw	v0,0(a0)

	/* Check for and handle overrun error interrupt.
	*/
	if ((regIfs & bitErr) != 0) {
9d003cf4:	8c830008 	lw	v1,8(a0)
	uint8_t		bTmp;
	uint32_t	regIfs;

	/* Get the interrupt flag status.
	*/
	regIfs = pregIfs->reg;
9d003cf8:	8c450000 	lw	a1,0(v0)

	/* Check for and handle overrun error interrupt.
	*/
	if ((regIfs & bitErr) != 0) {
9d003cfc:	00653024 	and	a2,v1,a1
9d003d00:	50c00008 	beqzl	a2,9d003d24 <_ZN4DSPI15doDspiInterruptEv+0x34>
9d003d04:	8c83000c 	lw	v1,12(a0)
		fRov = 1;				// set the receive overflow error flag;
		pspi->sxStat.clr = (1 << _SPISTAT_SPIROV);	//clear status bit
9d003d08:	8c860020 	lw	a2,32(a0)
	regIfs = pregIfs->reg;

	/* Check for and handle overrun error interrupt.
	*/
	if ((regIfs & bitErr) != 0) {
		fRov = 1;				// set the receive overflow error flag;
9d003d0c:	24070001 	li	a3,1
9d003d10:	a087001f 	sb	a3,31(a0)
		pspi->sxStat.clr = (1 << _SPISTAT_SPIROV);	//clear status bit
9d003d14:	24070040 	li	a3,64
9d003d18:	acc70014 	sw	a3,20(a2)
		pregIfs->clr = bitErr;
9d003d1c:	ac430004 	sw	v1,4(v0)
	}

	/* Check for and handle receive interrupt.
	*/
	if ((regIfs & bitRx) != 0) {
9d003d20:	8c83000c 	lw	v1,12(a0)
9d003d24:	00a32824 	and	a1,a1,v1
9d003d28:	10a0001d 	beqz	a1,9d003da0 <_ZN4DSPI15doDspiInterruptEv+0xb0>
9d003d2c:	00000000 	nop

		/* Get the received character.
		*/
		bTmp = pspi->sxBuf.reg;		//read next byte from SPI controller
9d003d30:	8c860020 	lw	a2,32(a0)
		cbCur -= 1;					//count this byte as received

		/* Are we storing it? pbRcvCur is 0 if we are sending only
		** and ignoring the received data.
		*/
		if (pbRcvCur != 0) {
9d003d34:	8c850018 	lw	a1,24(a0)
	*/
	if ((regIfs & bitRx) != 0) {

		/* Get the received character.
		*/
		bTmp = pspi->sxBuf.reg;		//read next byte from SPI controller
9d003d38:	8cc70020 	lw	a3,32(a2)
		cbCur -= 1;					//count this byte as received
9d003d3c:	9486001c 	lhu	a2,28(a0)
9d003d40:	24c6ffff 	addiu	a2,a2,-1
9d003d44:	30c6ffff 	andi	a2,a2,0xffff
9d003d48:	a486001c 	sh	a2,28(a0)

		/* Are we storing it? pbRcvCur is 0 if we are sending only
		** and ignoring the received data.
		*/
		if (pbRcvCur != 0) {
9d003d4c:	10a00006 	beqz	a1,9d003d68 <_ZN4DSPI15doDspiInterruptEv+0x78>
9d003d50:	30e700ff 	andi	a3,a3,0xff
			*pbRcvCur++ = bTmp;		//store the received byte into output buffer
9d003d54:	a0a70000 	sb	a3,0(a1)
9d003d58:	8c820000 	lw	v0,0(a0)
9d003d5c:	8c83000c 	lw	v1,12(a0)
9d003d60:	24a50001 	addiu	a1,a1,1
9d003d64:	ac850018 	sw	a1,24(a0)
		}

		/* Send the next byte to the slave. pbSndCur is 0 if we are
		** receiving only. In this case send the pad byte.
		*/
		if (cbCur > 0) {
9d003d68:	9485001c 	lhu	a1,28(a0)
9d003d6c:	30a5ffff 	andi	a1,a1,0xffff
9d003d70:	10a0000a 	beqz	a1,9d003d9c <_ZN4DSPI15doDspiInterruptEv+0xac>
9d003d74:	00000000 	nop
			bTmp = (pbSndCur != 0) ? *pbSndCur++ : bPad;
9d003d78:	8c850014 	lw	a1,20(a0)
9d003d7c:	50a0000a 	beqzl	a1,9d003da8 <_ZN4DSPI15doDspiInterruptEv+0xb8>
9d003d80:	9085001e 	lbu	a1,30(a0)
9d003d84:	90a60000 	lbu	a2,0(a1)
9d003d88:	24a50001 	addiu	a1,a1,1
9d003d8c:	ac850014 	sw	a1,20(a0)
			pspi->sxBuf.reg = bTmp;
9d003d90:	8c840020 	lw	a0,32(a0)

		/* Send the next byte to the slave. pbSndCur is 0 if we are
		** receiving only. In this case send the pad byte.
		*/
		if (cbCur > 0) {
			bTmp = (pbSndCur != 0) ? *pbSndCur++ : bPad;
9d003d94:	30c500ff 	andi	a1,a2,0xff
			pspi->sxBuf.reg = bTmp;
9d003d98:	ac850020 	sw	a1,32(a0)
		}

		pregIfs->clr = bitRx;		//clear the receive interrupt flag
9d003d9c:	ac430004 	sw	v1,4(v0)
9d003da0:	03e00008 	jr	ra
9d003da4:	00000000 	nop
		/* Send the next byte to the slave. pbSndCur is 0 if we are
		** receiving only. In this case send the pad byte.
		*/
		if (cbCur > 0) {
			bTmp = (pbSndCur != 0) ? *pbSndCur++ : bPad;
			pspi->sxBuf.reg = bTmp;
9d003da8:	8c840020 	lw	a0,32(a0)
9d003dac:	ac850020 	sw	a1,32(a0)
9d003db0:	0b400f67 	j	9d003d9c <_ZN4DSPI15doDspiInterruptEv+0xac>
9d003db4:	00000000 	nop

9d003db8 <IntDspi0Handler>:
**		logical SPI port DSPI0
*/
#if defined(_DSPI0_VECTOR)

void __attribute__((interrupt(), nomips16)) IntDspi0Handler(void)
{
9d003db8:	415de800 	rdpgpr	sp,sp
9d003dbc:	401b7000 	mfc0	k1,c0_epc
9d003dc0:	401a6002 	mfc0	k0,c0_srsctl
9d003dc4:	27bdff90 	addiu	sp,sp,-112
9d003dc8:	afbb006c 	sw	k1,108(sp)
9d003dcc:	401b6000 	mfc0	k1,c0_status
9d003dd0:	afba0068 	sw	k0,104(sp)
9d003dd4:	401a6800 	mfc0	k0,c0_cause
9d003dd8:	001ad282 	srl	k0,k0,0xa
9d003ddc:	afbb0064 	sw	k1,100(sp)
9d003de0:	7f5b7a84 	ins	k1,k0,0xa,0x6
9d003de4:	7c1b2044 	ins	k1,zero,0x1,0x4
9d003de8:	409b6000 	mtc0	k1,c0_status
9d003dec:	afa30018 	sw	v1,24(sp)
9d003df0:	8fa30068 	lw	v1,104(sp)
9d003df4:	3063000f 	andi	v1,v1,0xf
9d003df8:	14600011 	bnez	v1,9d003e40 <IntDspi0Handler+0x88>
9d003dfc:	afa20014 	sw	v0,20(sp)
9d003e00:	afbf0054 	sw	ra,84(sp)
9d003e04:	afb90050 	sw	t9,80(sp)
9d003e08:	afb8004c 	sw	t8,76(sp)
9d003e0c:	afaf0048 	sw	t7,72(sp)
9d003e10:	afae0044 	sw	t6,68(sp)
9d003e14:	afad0040 	sw	t5,64(sp)
9d003e18:	afac003c 	sw	t4,60(sp)
9d003e1c:	afab0038 	sw	t3,56(sp)
9d003e20:	afaa0034 	sw	t2,52(sp)
9d003e24:	afa90030 	sw	t1,48(sp)
9d003e28:	afa8002c 	sw	t0,44(sp)
9d003e2c:	afa70028 	sw	a3,40(sp)
9d003e30:	afa60024 	sw	a2,36(sp)
9d003e34:	afa50020 	sw	a1,32(sp)
9d003e38:	afa4001c 	sw	a0,28(sp)
9d003e3c:	afa10010 	sw	at,16(sp)
	if (pdspi0 != 0) {
9d003e40:	8f84803c 	lw	a0,-32708(gp)
**		logical SPI port DSPI0
*/
#if defined(_DSPI0_VECTOR)

void __attribute__((interrupt(), nomips16)) IntDspi0Handler(void)
{
9d003e44:	00001012 	mflo	v0
9d003e48:	afa2005c 	sw	v0,92(sp)
9d003e4c:	00001810 	mfhi	v1
	if (pdspi0 != 0) {
9d003e50:	10800003 	beqz	a0,9d003e60 <IntDspi0Handler+0xa8>
9d003e54:	afa30058 	sw	v1,88(sp)
		pdspi0->doDspiInterrupt();
9d003e58:	0f400f3c 	jal	9d003cf0 <_ZN4DSPI15doDspiInterruptEv>
9d003e5c:	00000000 	nop
	}
}
9d003e60:	8fa2005c 	lw	v0,92(sp)
9d003e64:	8fa30058 	lw	v1,88(sp)
9d003e68:	00400013 	mtlo	v0
9d003e6c:	8fa20068 	lw	v0,104(sp)
9d003e70:	3042000f 	andi	v0,v0,0xf
9d003e74:	14400013 	bnez	v0,9d003ec4 <IntDspi0Handler+0x10c>
9d003e78:	00600011 	mthi	v1
9d003e7c:	8fbf0054 	lw	ra,84(sp)
9d003e80:	8fb90050 	lw	t9,80(sp)
9d003e84:	8fb8004c 	lw	t8,76(sp)
9d003e88:	8faf0048 	lw	t7,72(sp)
9d003e8c:	8fae0044 	lw	t6,68(sp)
9d003e90:	8fad0040 	lw	t5,64(sp)
9d003e94:	8fac003c 	lw	t4,60(sp)
9d003e98:	8fab0038 	lw	t3,56(sp)
9d003e9c:	8faa0034 	lw	t2,52(sp)
9d003ea0:	8fa90030 	lw	t1,48(sp)
9d003ea4:	8fa8002c 	lw	t0,44(sp)
9d003ea8:	8fa70028 	lw	a3,40(sp)
9d003eac:	8fa60024 	lw	a2,36(sp)
9d003eb0:	8fa50020 	lw	a1,32(sp)
9d003eb4:	8fa4001c 	lw	a0,28(sp)
9d003eb8:	8fa30018 	lw	v1,24(sp)
9d003ebc:	8fa20014 	lw	v0,20(sp)
9d003ec0:	8fa10010 	lw	at,16(sp)
9d003ec4:	41606000 	di
9d003ec8:	000000c0 	ehb
9d003ecc:	8fba006c 	lw	k0,108(sp)
9d003ed0:	8fbb0064 	lw	k1,100(sp)
9d003ed4:	409a7000 	mtc0	k0,c0_epc
9d003ed8:	8fba0068 	lw	k0,104(sp)
9d003edc:	27bd0070 	addiu	sp,sp,112
9d003ee0:	409a6002 	mtc0	k0,c0_srsctl
9d003ee4:	41dde800 	wrpgpr	sp,sp
9d003ee8:	409b6000 	mtc0	k1,c0_status
9d003eec:	42000018 	eret

9d003ef0 <_ZN5DSPI0C1Ev>:
#else
DSPI0::DSPI0() 
#endif
{

	pspi = (p32_spi *) _DSPI0_BASE;
9d003ef0:	3c02bf80 	lui	v0,0xbf80
9d003ef4:	24425a00 	addiu	v0,v0,23040
9d003ef8:	ac820020 	sw	v0,32(a0)
	vec = _DSPI0_VECTOR;
9d003efc:	2402001f 	li	v0,31
9d003f00:	a0820028 	sb	v0,40(a0)
	ipl = ((_DSPI0_IPL & 0x07) << 2) + (_DSPI0_SPL & 0x03);
9d003f04:	24020008 	li	v0,8
9d003f08:	a0820029 	sb	v0,41(a0)
	pinSS = PIN_DSPI0_SS;
9d003f0c:	24020069 	li	v0,105
9d003f10:	a082002a 	sb	v0,42(a0)
	** and IEC register. For each IFS register, there is a SET, CLR,
	** and INV register, so the distance (in dwords) from IFS0 to IFS1
	** is 4. This code assumes that all of the enable control and flag
	** bits for an SPI controller are in the same IEC and IFS registers.
	*/
	pregIec = ((p32_regset *)&IEC0) + (irqErr / 32);	// interrupt enable control register
9d003f14:	3c02bf88 	lui	v0,0xbf88
9d003f18:	24421070 	addiu	v0,v0,4208
9d003f1c:	ac820004 	sw	v0,4(a0)
	pregIfs = ((p32_regset *)&IFS0) + (irqErr / 32);	// interrupt flag register
9d003f20:	3c02bf88 	lui	v0,0xbf88
9d003f24:	24421040 	addiu	v0,v0,4160
9d003f28:	ac820000 	sw	v0,0(a0)

	bitErr = 1 << (irqErr % 32);	// error interrupt flag/enable bit
9d003f2c:	24020020 	li	v0,32
9d003f30:	ac820008 	sw	v0,8(a0)
	bitRx  = 1 << (irqRx % 32);		// rx interrupt flag/enable bit
9d003f34:	24020040 	li	v0,64
9d003f38:	ac82000c 	sw	v0,12(a0)
	bitTx  = 1 << (irqTx % 32);		// tx interrupt flag/enable bit
9d003f3c:	24020080 	li	v0,128
9d003f40:	ac820010 	sw	v0,16(a0)

    isr = isrHandler;
9d003f44:	3c029d00 	lui	v0,0x9d00
9d003f48:	24423db8 	addiu	v0,v0,15800
DSPI::DSPI()
#endif
 {

	pspi = 0;
	cbCur = 0;
9d003f4c:	a480001c 	sh	zero,28(a0)
	vec = _DSPI0_VECTOR;
	ipl = ((_DSPI0_IPL & 0x07) << 2) + (_DSPI0_SPL & 0x03);
	pinSS = PIN_DSPI0_SS;

	init(_DSPI0_ERR_IRQ, _DSPI0_RX_IRQ, _DSPI0_TX_IRQ, IntDspi0Handler);
}
9d003f50:	03e00008 	jr	ra
9d003f54:	ac820024 	sw	v0,36(a0)

9d003f58 <initIntVector>:
*/
void initIntVector(void)
{
    const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    int i = 0;
    void * pvOrgIntVec = (void *)pImageHeader->pOrgVector0;
9d003f58:	3c029d00 	lui	v0,0x9d00
9d003f5c:	24427ad4 	addiu	v0,v0,31444
9d003f60:	88430043 	lwl	v1,67(v0)
9d003f64:	8846004b 	lwl	a2,75(v0)
    {
        // If a compiler installed interrupt handler exits, pre-load it
        // and don't fool with the priority
        if(*((uint32_t *) pvOrgIntVec) != 0xFFFFFFFF)
        {
            _isr_primary_install[i] = (isrFunc) pvOrgIntVec;
9d003f68:	3c08a000 	lui	t0,0xa000
*/
void initIntVector(void)
{
    const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    int i = 0;
    void * pvOrgIntVec = (void *)pImageHeader->pOrgVector0;
9d003f6c:	98430040 	lwr	v1,64(v0)
9d003f70:	98460048 	lwr	a2,72(v0)

    for(i=0; i<NUM_INT_VECTOR; i++)
    {
        // If a compiler installed interrupt handler exits, pre-load it
        // and don't fool with the priority
        if(*((uint32_t *) pvOrgIntVec) != 0xFFFFFFFF)
9d003f74:	2409ffff 	li	t1,-1
{
    const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    int i = 0;
    void * pvOrgIntVec = (void *)pImageHeader->pOrgVector0;

    for(i=0; i<NUM_INT_VECTOR; i++)
9d003f78:	00001021 	move	v0,zero
    {
        // If a compiler installed interrupt handler exits, pre-load it
        // and don't fool with the priority
        if(*((uint32_t *) pvOrgIntVec) != 0xFFFFFFFF)
        {
            _isr_primary_install[i] = (isrFunc) pvOrgIntVec;
9d003f7c:	25080008 	addiu	t0,t0,8
{
    const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    int i = 0;
    void * pvOrgIntVec = (void *)pImageHeader->pOrgVector0;

    for(i=0; i<NUM_INT_VECTOR; i++)
9d003f80:	24070034 	li	a3,52
    {
        // If a compiler installed interrupt handler exits, pre-load it
        // and don't fool with the priority
        if(*((uint32_t *) pvOrgIntVec) != 0xFFFFFFFF)
9d003f84:	8c640000 	lw	a0,0(v1)
        {
            _isr_primary_install[i] = (isrFunc) pvOrgIntVec;
9d003f88:	00022880 	sll	a1,v0,0x2
9d003f8c:	00a82821 	addu	a1,a1,t0

    for(i=0; i<NUM_INT_VECTOR; i++)
    {
        // If a compiler installed interrupt handler exits, pre-load it
        // and don't fool with the priority
        if(*((uint32_t *) pvOrgIntVec) != 0xFFFFFFFF)
9d003f90:	10890002 	beq	a0,t1,9d003f9c <initIntVector+0x44>
9d003f94:	24420001 	addiu	v0,v0,1
        {
            _isr_primary_install[i] = (isrFunc) pvOrgIntVec;
9d003f98:	aca30000 	sw	v1,0(a1)
{
    const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    int i = 0;
    void * pvOrgIntVec = (void *)pImageHeader->pOrgVector0;

    for(i=0; i<NUM_INT_VECTOR; i++)
9d003f9c:	1447fff9 	bne	v0,a3,9d003f84 <initIntVector+0x2c>
9d003fa0:	00661821 	addu	v1,v1,a2
9d003fa4:	03e00008 	jr	ra
9d003fa8:	00000000 	nop

9d003fac <setIntVector>:
isrFunc setIntVector(int vec, isrFunc func)
{
 //   const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    isrFunc t = 0;

    if (vec < NUM_INT_VECTOR)
9d003fac:	28830034 	slti	v1,a0,52
9d003fb0:	10600007 	beqz	v1,9d003fd0 <setIntVector+0x24>
9d003fb4:	00001021 	move	v0,zero
    {
        t = _isr_primary_install[vec];
9d003fb8:	3c02a000 	lui	v0,0xa000
9d003fbc:	24420008 	addiu	v0,v0,8
9d003fc0:	00042080 	sll	a0,a0,0x2
9d003fc4:	00822021 	addu	a0,a0,v0
9d003fc8:	8c820000 	lw	v0,0(a0)
        _isr_primary_install[vec] = func;       
9d003fcc:	ac850000 	sw	a1,0(a0)
    }

    return t;
}
9d003fd0:	03e00008 	jr	ra
9d003fd4:	00000000 	nop

9d003fd8 <setIntEnable>:
uint32_t setIntEnable(int irq)
{
	p32_regset *	iec;
	uint32_t		st;

	iec = ((p32_regset *)&IEC0) + (irq / 32);
9d003fd8:	28830000 	slti	v1,a0,0
9d003fdc:	2482001f 	addiu	v0,a0,31
9d003fe0:	0083100a 	movz	v0,a0,v1
9d003fe4:	00021143 	sra	v0,v0,0x5
9d003fe8:	3c03bf88 	lui	v1,0xbf88
9d003fec:	00021100 	sll	v0,v0,0x4
	st = iec->reg;
	iec->set = 1 << (irq % 32);
9d003ff0:	24050001 	li	a1,1
uint32_t setIntEnable(int irq)
{
	p32_regset *	iec;
	uint32_t		st;

	iec = ((p32_regset *)&IEC0) + (irq / 32);
9d003ff4:	24631060 	addiu	v1,v1,4192
9d003ff8:	00621821 	addu	v1,v1,v0
	st = iec->reg;
	iec->set = 1 << (irq % 32);
9d003ffc:	00852004 	sllv	a0,a1,a0
{
	p32_regset *	iec;
	uint32_t		st;

	iec = ((p32_regset *)&IEC0) + (irq / 32);
	st = iec->reg;
9d004000:	8c620000 	lw	v0,0(v1)
	iec->set = 1 << (irq % 32);
9d004004:	ac640008 	sw	a0,8(v1)
	return st;
}
9d004008:	03e00008 	jr	ra
9d00400c:	00000000 	nop

9d004010 <setIntPriority>:
	ipc = ((p32_regset *)&IPC0) + (vec / 4);

	/* Compute the number of bit positions to shift to get to the
	** correct position for the priority bits for this vector.
	*/
	bn = 8 * (vec % 4);
9d004010:	000417c3 	sra	v0,a0,0x1f
9d004014:	00021782 	srl	v0,v0,0x1e
9d004018:	00821821 	addu	v1,a0,v0
	int				bn;

	/* Compute the address of the interrupt priority control register used
	** by this interrupt vector
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);
9d00401c:	24870003 	addiu	a3,a0,3
9d004020:	28880000 	slti	t0,a0,0

	/* Compute the number of bit positions to shift to get to the
	** correct position for the priority bits for this vector.
	*/
	bn = 8 * (vec % 4);
9d004024:	30630003 	andi	v1,v1,0x3
	int				bn;

	/* Compute the address of the interrupt priority control register used
	** by this interrupt vector
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);
9d004028:	00e8200b 	movn	a0,a3,t0

	/* Compute the number of bit positions to shift to get to the
	** correct position for the priority bits for this vector.
	*/
	bn = 8 * (vec % 4);
9d00402c:	00621023 	subu	v0,v1,v0
	int				bn;

	/* Compute the address of the interrupt priority control register used
	** by this interrupt vector
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);
9d004030:	00042083 	sra	a0,a0,0x2
9d004034:	3c03bf88 	lui	v1,0xbf88
9d004038:	24631090 	addiu	v1,v1,4240
	bn = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = (0x1F << bn);
	ipc->set = ((ipl << 2) + spl) << bn;
9d00403c:	00052880 	sll	a1,a1,0x2
	int				bn;

	/* Compute the address of the interrupt priority control register used
	** by this interrupt vector
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);
9d004040:	00042100 	sll	a0,a0,0x4
9d004044:	00642021 	addu	a0,v1,a0

	/* Compute the number of bit positions to shift to get to the
	** correct position for the priority bits for this vector.
	*/
	bn = 8 * (vec % 4);
9d004048:	000210c0 	sll	v0,v0,0x3

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = (0x1F << bn);
	ipc->set = ((ipl << 2) + spl) << bn;
9d00404c:	00c52821 	addu	a1,a2,a1
	*/
	bn = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = (0x1F << bn);
9d004050:	2403001f 	li	v1,31
9d004054:	00431804 	sllv	v1,v1,v0
	ipc->set = ((ipl << 2) + spl) << bn;
9d004058:	00451004 	sllv	v0,a1,v0
	*/
	bn = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = (0x1F << bn);
9d00405c:	ac830004 	sw	v1,4(a0)
	ipc->set = ((ipl << 2) + spl) << bn;
9d004060:	ac820008 	sw	v0,8(a0)
}
9d004064:	03e00008 	jr	ra
9d004068:	00000000 	nop

9d00406c <getPeripheralClock>:
uint32_t getPeripheralClock()
{
	uint32_t	clkPb;

    clkPb = F_CPU;
    clkPb >>= OSCCONbits.PBDIV;
9d00406c:	3c02bf81 	lui	v0,0xbf81
9d004070:	8c43f000 	lw	v1,-4096(v0)

    return clkPb;

}
9d004074:	3c0204c4 	lui	v0,0x4c4
9d004078:	3442b400 	ori	v0,v0,0xb400
uint32_t getPeripheralClock()
{
	uint32_t	clkPb;

    clkPb = F_CPU;
    clkPb >>= OSCCONbits.PBDIV;
9d00407c:	7c630cc0 	ext	v1,v1,0x13,0x2

    return clkPb;

}
9d004080:	03e00008 	jr	ra
9d004084:	00621006 	srlv	v0,v0,v1

9d004088 <_configSystem>:

uint32_t __attribute__((nomips16)) disableInterrupts(void)
{
    uint32_t status = 0;

    asm volatile("di    %0" : "=r"(status));
9d004088:	41686000 	di	t0

	stInt = disableInterrupts();

	/* Disable wait states in data ram.
	*/
	BMXCONCLR = (1 << _BMXCON_BMXWSDRM_POSITION);
9d00408c:	24030040 	li	v1,64
9d004090:	3c02bf88 	lui	v0,0xbf88
9d004094:	ac432004 	sw	v1,8196(v0)

#ifdef _PCACHE

	stCache = CHECON;
9d004098:	3c07bf88 	lui	a3,0xbf88
9d00409c:	8ce94000 	lw	t1,16384(a3)
    stCache |= (3 << _CHECON_PREFEN_POSITION);

	/* Turn on caching for KSEG0
	*/
	asm("mfc0 %0,$16,0" :  "=r"(tmp));
	tmp = (tmp & ~7) | 3;
9d0040a0:	2402fff8 	li	v0,-8
	*/
    stCache |= (3 << _CHECON_PREFEN_POSITION);

	/* Turn on caching for KSEG0
	*/
	asm("mfc0 %0,$16,0" :  "=r"(tmp));
9d0040a4:	40038000 	mfc0	v1,c0_config
	tmp = (tmp & ~7) | 3;
9d0040a8:	00621024 	and	v0,v1,v0
	stCache = CHECON;

	/* Configure predictive prefetch caching for both cached and
	** non-cached memory regions.
	*/
    stCache |= (3 << _CHECON_PREFEN_POSITION);
9d0040ac:	35290030 	ori	t1,t1,0x30

	/* Turn on caching for KSEG0
	*/
	asm("mfc0 %0,$16,0" :  "=r"(tmp));
	tmp = (tmp & ~7) | 3;
9d0040b0:	34420003 	ori	v0,v0,0x3
	asm("mtc0 %0,$16,0" :: "r" (tmp));
9d0040b4:	40828000 	mtc0	v0,c0_config

	/* Configure the number of wait states in the program flash
	*/
    wait = 0;

    while(clk > FLASH_SPEED_HZ)
9d0040b8:	3c0501c9 	lui	a1,0x1c9
9d0040bc:	34a5c381 	ori	a1,a1,0xc381
9d0040c0:	0085182b 	sltu	v1,a0,a1
9d0040c4:	14600007 	bnez	v1,9d0040e4 <_configSystem+0x5c>
9d0040c8:	00001021 	move	v0,zero
    {
        wait += 1;
        clk -= FLASH_SPEED_HZ;
9d0040cc:	3c06fe36 	lui	a2,0xfe36
9d0040d0:	24c63c80 	addiu	a2,a2,15488
9d0040d4:	00862021 	addu	a0,a0,a2

	/* Configure the number of wait states in the program flash
	*/
    wait = 0;

    while(clk > FLASH_SPEED_HZ)
9d0040d8:	0085182b 	sltu	v1,a0,a1
9d0040dc:	1060fffd 	beqz	v1,9d0040d4 <_configSystem+0x4c>
9d0040e0:	24420001 	addiu	v0,v0,1
    {
        wait += 1;
        clk -= FLASH_SPEED_HZ;
    }

    stCache &= ~_CHECON_PFMWS_MASK;
9d0040e4:	2404fff8 	li	a0,-8
9d0040e8:	01241824 	and	v1,t1,a0
	stCache |= (wait << _CHECON_PFMWS_POSITION);
9d0040ec:	00431025 	or	v0,v0,v1
**		enableInterrupts() or disableInterrupts().
*/

void __attribute__((nomips16))  restoreInterrupts(uint32_t st)
{
    if (st & 0x00000001)
9d0040f0:	31030001 	andi	v1,t0,0x1
    }

    stCache &= ~_CHECON_PFMWS_MASK;
	stCache |= (wait << _CHECON_PFMWS_POSITION);

	CHECON = stCache;
9d0040f4:	14600003 	bnez	v1,9d004104 <_configSystem+0x7c>
**		enableInterrupts() or disableInterrupts().
*/

void __attribute__((nomips16))  restoreInterrupts(uint32_t st)
{
    if (st & 0x00000001)
9d0040f8:	ace24000 	sw	v0,16384(a3)
	{
        asm volatile("ei");
	}
    else
	{
        asm volatile("di");
9d0040fc:	03e00008 	jr	ra
9d004100:	41606000 	di

void __attribute__((nomips16))  restoreInterrupts(uint32_t st)
{
    if (st & 0x00000001)
	{
        asm volatile("ei");
9d004104:	03e00008 	jr	ra
9d004108:	41606020 	ei

9d00410c <_enableMultiVectorInterrupts>:
    unsigned int val;

    /* Set the CP0 bit so that interrupt exceptions use the
	** special interrupt vector and not the general exception vector.
	*/
    asm volatile("mfc0   %0,$13" : "=r"(val));
9d00410c:	40036800 	mfc0	v1,c0_cause
    val |= 0x00800000;
9d004110:	3c020080 	lui	v0,0x80
9d004114:	00621025 	or	v0,v1,v0
    asm volatile("mtc0   %0,$13" : "+r"(val));
9d004118:	40826800 	mtc0	v0,c0_cause

	/* Turn on multi-vectored interrupts.
	*/
    INTCONSET = _INTCON_MVEC_MASK;
9d00411c:	24031000 	li	v1,4096
9d004120:	3c02bf88 	lui	v0,0xbf88
9d004124:	ac431008 	sw	v1,4104(v0)

uint32_t __attribute__((nomips16))  enableInterrupts(void)
{
    uint32_t status = 0;

    asm volatile("ei    %0" : "=r"(status));
9d004128:	03e00008 	jr	ra

    /* Enable interrupts.
	*/
    enableInterrupts();

}
9d00412c:	41626020 	ei	v0

9d004130 <_initCoreTimer>:

void __attribute__((nomips16)) _initCoreTimer(uint32_t prd)
{
	/* Clear the core timer counter
	*/
    asm volatile("mtc0   $0,$9");
9d004130:	40804800 	mtc0	zero,c0_count

    /* Store the requested value in the compare register
	*/
    asm volatile("mtc0   %0,$11" : "+r"(prd));
9d004134:	03e00008 	jr	ra
}
9d004138:	40845800 	mtc0	a0,c0_compare

9d00413c <shiftIn>:
  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
*/

#include "wiring_private.h"

uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
9d00413c:	27bdffd0 	addiu	sp,sp,-48
9d004140:	afb60028 	sw	s6,40(sp)
9d004144:	afb50024 	sw	s5,36(sp)
9d004148:	afb40020 	sw	s4,32(sp)
9d00414c:	afb3001c 	sw	s3,28(sp)
9d004150:	afb20018 	sw	s2,24(sp)
9d004154:	afb10014 	sw	s1,20(sp)
9d004158:	afb00010 	sw	s0,16(sp)
9d00415c:	afbf002c 	sw	ra,44(sp)
9d004160:	309300ff 	andi	s3,a0,0xff
9d004164:	30b100ff 	andi	s1,a1,0xff
9d004168:	30d400ff 	andi	s4,a2,0xff
9d00416c:	24100007 	li	s0,7
	uint8_t value = 0;
9d004170:	00009021 	move	s2,zero
  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
*/

#include "wiring_private.h"

uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
9d004174:	24160007 	li	s6,7
	uint8_t value = 0;
	uint8_t i;

	for (i = 0; i < 8; ++i) {
9d004178:	0b40106c 	j	9d0041b0 <shiftIn+0x74>
9d00417c:	2415ffff 	li	s5,-1
		digitalWrite(clockPin, HIGH);
		if (bitOrder == LSBFIRST)
			value |= digitalRead(dataPin) << i;
9d004180:	0f40112e 	jal	9d0044b8 <digitalRead>
9d004184:	00000000 	nop
  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
*/

#include "wiring_private.h"

uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
9d004188:	02d01823 	subu	v1,s6,s0
	uint8_t i;

	for (i = 0; i < 8; ++i) {
		digitalWrite(clockPin, HIGH);
		if (bitOrder == LSBFIRST)
			value |= digitalRead(dataPin) << i;
9d00418c:	00621804 	sllv	v1,v0,v1
9d004190:	00729025 	or	s2,v1,s2
		else
			value |= digitalRead(dataPin) << (7 - i);
		digitalWrite(clockPin, LOW);
9d004194:	2610ffff 	addiu	s0,s0,-1
9d004198:	02202021 	move	a0,s1
9d00419c:	00002821 	move	a1,zero
9d0041a0:	0f4010fb 	jal	9d0043ec <digitalWrite>
9d0041a4:	325200ff 	andi	s2,s2,0xff

uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
	uint8_t value = 0;
	uint8_t i;

	for (i = 0; i < 8; ++i) {
9d0041a8:	12150012 	beq	s0,s5,9d0041f4 <shiftIn+0xb8>
9d0041ac:	8fbf002c 	lw	ra,44(sp)
		digitalWrite(clockPin, HIGH);
9d0041b0:	02202021 	move	a0,s1
9d0041b4:	0f4010fb 	jal	9d0043ec <digitalWrite>
9d0041b8:	24050001 	li	a1,1
		if (bitOrder == LSBFIRST)
9d0041bc:	1280fff0 	beqz	s4,9d004180 <shiftIn+0x44>
9d0041c0:	02602021 	move	a0,s3
			value |= digitalRead(dataPin) << i;
		else
			value |= digitalRead(dataPin) << (7 - i);
9d0041c4:	0f40112e 	jal	9d0044b8 <digitalRead>
9d0041c8:	02602021 	move	a0,s3
9d0041cc:	02021004 	sllv	v0,v0,s0
9d0041d0:	00529025 	or	s2,v0,s2
		digitalWrite(clockPin, LOW);
9d0041d4:	2610ffff 	addiu	s0,s0,-1
9d0041d8:	02202021 	move	a0,s1
9d0041dc:	00002821 	move	a1,zero
9d0041e0:	0f4010fb 	jal	9d0043ec <digitalWrite>
9d0041e4:	325200ff 	andi	s2,s2,0xff

uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
	uint8_t value = 0;
	uint8_t i;

	for (i = 0; i < 8; ++i) {
9d0041e8:	1615fff2 	bne	s0,s5,9d0041b4 <shiftIn+0x78>
9d0041ec:	02202021 	move	a0,s1
		else
			value |= digitalRead(dataPin) << (7 - i);
		digitalWrite(clockPin, LOW);
	}
	return value;
}
9d0041f0:	8fbf002c 	lw	ra,44(sp)
9d0041f4:	02401021 	move	v0,s2
9d0041f8:	8fb60028 	lw	s6,40(sp)
9d0041fc:	8fb50024 	lw	s5,36(sp)
9d004200:	8fb40020 	lw	s4,32(sp)
9d004204:	8fb3001c 	lw	s3,28(sp)
9d004208:	8fb20018 	lw	s2,24(sp)
9d00420c:	8fb10014 	lw	s1,20(sp)
9d004210:	8fb00010 	lw	s0,16(sp)
9d004214:	03e00008 	jr	ra
9d004218:	27bd0030 	addiu	sp,sp,48

9d00421c <shiftOut>:

void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
{
9d00421c:	27bdffd0 	addiu	sp,sp,-48
9d004220:	afb60028 	sw	s6,40(sp)
9d004224:	afb50024 	sw	s5,36(sp)
9d004228:	afb40020 	sw	s4,32(sp)
9d00422c:	afb3001c 	sw	s3,28(sp)
9d004230:	afb20018 	sw	s2,24(sp)
9d004234:	afb10014 	sw	s1,20(sp)
9d004238:	afb00010 	sw	s0,16(sp)
9d00423c:	afbf002c 	sw	ra,44(sp)
9d004240:	309100ff 	andi	s1,a0,0xff
9d004244:	30b000ff 	andi	s0,a1,0xff
9d004248:	30d600ff 	andi	s6,a2,0xff
9d00424c:	30f300ff 	andi	s3,a3,0xff
9d004250:	24120007 	li	s2,7
		digitalWrite(clockPin, LOW);
	}
	return value;
}

void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
9d004254:	24140007 	li	s4,7
{
	uint8_t i;

	for (i = 0; i < 8; i++)  {
9d004258:	2415ffff 	li	s5,-1
		digitalWrite(clockPin, LOW);
	}
	return value;
}

void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
9d00425c:	02922823 	subu	a1,s4,s2
{
	uint8_t i;

	for (i = 0; i < 8; i++)  {
		if (bitOrder == LSBFIRST)
			digitalWrite(dataPin, !!(val & (1 << i)));
9d004260:	00b32807 	srav	a1,s3,a1
		else	
			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
9d004264:	02531007 	srav	v0,s3,s2
{
	uint8_t i;

	for (i = 0; i < 8; i++)  {
		if (bitOrder == LSBFIRST)
			digitalWrite(dataPin, !!(val & (1 << i)));
9d004268:	02202021 	move	a0,s1
void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
{
	uint8_t i;

	for (i = 0; i < 8; i++)  {
		if (bitOrder == LSBFIRST)
9d00426c:	12c00003 	beqz	s6,9d00427c <shiftOut+0x60>
9d004270:	30a50001 	andi	a1,a1,0x1
			digitalWrite(dataPin, !!(val & (1 << i)));
		else	
			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
9d004274:	02202021 	move	a0,s1
9d004278:	30450001 	andi	a1,v0,0x1
9d00427c:	0f4010fb 	jal	9d0043ec <digitalWrite>
9d004280:	2652ffff 	addiu	s2,s2,-1
			
		digitalWrite(clockPin, HIGH);
9d004284:	24050001 	li	a1,1
9d004288:	0f4010fb 	jal	9d0043ec <digitalWrite>
9d00428c:	02002021 	move	a0,s0
		digitalWrite(clockPin, LOW);		
9d004290:	02002021 	move	a0,s0
9d004294:	0f4010fb 	jal	9d0043ec <digitalWrite>
9d004298:	00002821 	move	a1,zero

void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
{
	uint8_t i;

	for (i = 0; i < 8; i++)  {
9d00429c:	5655fff0 	bnel	s2,s5,9d004260 <shiftOut+0x44>
9d0042a0:	02922823 	subu	a1,s4,s2
			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
			
		digitalWrite(clockPin, HIGH);
		digitalWrite(clockPin, LOW);		
	}
}
9d0042a4:	8fbf002c 	lw	ra,44(sp)
9d0042a8:	8fb60028 	lw	s6,40(sp)
9d0042ac:	8fb50024 	lw	s5,36(sp)
9d0042b0:	8fb40020 	lw	s4,32(sp)
9d0042b4:	8fb3001c 	lw	s3,28(sp)
9d0042b8:	8fb20018 	lw	s2,24(sp)
9d0042bc:	8fb10014 	lw	s1,20(sp)
9d0042c0:	8fb00010 	lw	s0,16(sp)
9d0042c4:	03e00008 	jr	ra
9d0042c8:	27bd0030 	addiu	sp,sp,48

9d0042cc <pinMode>:
#include "wiring_private.h"
#include "pins_arduino.h"

//************************************************************************
void pinMode(uint8_t pin, uint8_t mode)
{
9d0042cc:	308400ff 	andi	a0,a0,0xff
9d0042d0:	27bdffe0 	addiu	sp,sp,-32
uint32_t                cn;
#endif

	/* Check if pin number is in valid range.
	*/
	if (pin >= NUM_DIGITAL_PINS_EXTENDED)
9d0042d4:	2c82002d 	sltiu	v0,a0,45
#include "wiring_private.h"
#include "pins_arduino.h"

//************************************************************************
void pinMode(uint8_t pin, uint8_t mode)
{
9d0042d8:	afbf001c 	sw	ra,28(sp)
9d0042dc:	afb10018 	sw	s1,24(sp)
9d0042e0:	afb00014 	sw	s0,20(sp)
uint32_t                cn;
#endif

	/* Check if pin number is in valid range.
	*/
	if (pin >= NUM_DIGITAL_PINS_EXTENDED)
9d0042e4:	10400022 	beqz	v0,9d004370 <pinMode+0xa4>
9d0042e8:	30a500ff 	andi	a1,a1,0xff
		return;
	}
#endif	// OPT_BOARD_DIGITAL_IO

	//* Get the port number for this pin.
	if ((port = digitalPinToPort(pin)) == NOT_A_PIN)
9d0042ec:	3c029d00 	lui	v0,0x9d00
9d0042f0:	24427d54 	addiu	v0,v0,32084
9d0042f4:	00441021 	addu	v0,v0,a0
9d0042f8:	90420000 	lbu	v0,0(v0)
9d0042fc:	1040001c 	beqz	v0,9d004370 <pinMode+0xa4>
9d004300:	00021880 	sll	v1,v0,0x2
	{
		return;
	}

	//* Obtain pointer to the registers for this io port.
	iop = (p32_ioport *)portRegisters(port);
9d004304:	3c069d00 	lui	a2,0x9d00
9d004308:	24c67d30 	addiu	a2,a2,32048
9d00430c:	00663021 	addu	a2,v1,a2

	//* Obtain bit mask for the specific bit for this pin.
	bit = digitalPinToBitMask(pin);
9d004310:	3c039d00 	lui	v1,0x9d00
9d004314:	00042040 	sll	a0,a0,0x1
9d004318:	24637d84 	addiu	v1,v1,32132
9d00431c:	00641821 	addu	v1,v1,a0
9d004320:	94700000 	lhu	s0,0(v1)
	// analog input capable pins.
	// Clear the bit in the ANSELx register to ensure that the pin is in
	// digital input mode.
	iop->ansel.clr = bit;
#else
	if (port == _IOPORT_PB)
9d004324:	24030002 	li	v1,2
9d004328:	10430026 	beq	v0,v1,9d0043c4 <pinMode+0xf8>
9d00432c:	8cd10000 	lw	s1,0(a2)

	}
#endif	// defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)

	// Set the pin to the requested mode.
    switch (mode) {
9d004330:	24020002 	li	v0,2
9d004334:	10a2001c 	beq	a1,v0,9d0043a8 <pinMode+0xdc>
9d004338:	2ca20003 	sltiu	v0,a1,3
9d00433c:	50400011 	beqzl	v0,9d004384 <pinMode+0xb8>
9d004340:	2ca50006 	sltiu	a1,a1,6
9d004344:	14a00012 	bnez	a1,9d004390 <pinMode+0xc4>
9d004348:	8fbf001c 	lw	ra,28(sp)
            }
#endif
            // continue into INPUT case
            //* Determine if this is an output compare pin. If so,
            //* we need to make sure PWM output is off.
            timer = digitalPinToTimerOC(pin) >> _BN_TIMER_OC;
9d00434c:	3c029d00 	lui	v0,0x9d00
9d004350:	24427de0 	addiu	v0,v0,32224
9d004354:	00442021 	addu	a0,v0,a0
9d004358:	90840000 	lbu	a0,0(a0)
9d00435c:	3084000f 	andi	a0,a0,0xf
            if (timer != NOT_ON_TIMER)
9d004360:	1480001c 	bnez	a0,9d0043d4 <pinMode+0x108>
9d004364:	00000000 	nop
            }

            //*	May  1,	2011
            //*	according to item #26 in PIC32MX5XX-6XX-7XX Errata.pdf 
            //*	if we are setting to input, set the data bit to zero first
            iop->lat.clr  = bit;	//clear to output bit		
9d004368:	ae300024 	sw	s0,36(s1)
            iop->tris.set = bit;	//make the pin an input
9d00436c:	ae300008 	sw	s0,8(s1)
            } 
#endif
            iop->tris.clr = bit;	//make the pin an output
            iop->odc.clr  = bit;	//make sure it isn't open drain
	}
}
9d004370:	8fbf001c 	lw	ra,28(sp)
9d004374:	8fb10018 	lw	s1,24(sp)
9d004378:	8fb00014 	lw	s0,20(sp)
9d00437c:	03e00008 	jr	ra
9d004380:	27bd0020 	addiu	sp,sp,32

	}
#endif	// defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)

	// Set the pin to the requested mode.
    switch (mode) {
9d004384:	14a0fff2 	bnez	a1,9d004350 <pinMode+0x84>
9d004388:	3c029d00 	lui	v0,0x9d00
            } 
#endif
            iop->tris.clr = bit;	//make the pin an output
            iop->odc.clr  = bit;	//make sure it isn't open drain
	}
}
9d00438c:	8fbf001c 	lw	ra,28(sp)
            cn = digitalPinToCN(pin);
            if (cn != NOT_CN_PIN) {
                CNPUECLR = cn;
            } 
#endif
            iop->tris.clr = bit;	//make the pin an output
9d004390:	ae300004 	sw	s0,4(s1)
            iop->odc.clr  = bit;	//make sure it isn't open drain
9d004394:	ae300034 	sw	s0,52(s1)
	}
}
9d004398:	8fb10018 	lw	s1,24(sp)
9d00439c:	8fb00014 	lw	s0,20(sp)
9d0043a0:	03e00008 	jr	ra
9d0043a4:	27bd0020 	addiu	sp,sp,32
9d0043a8:	8fbf001c 	lw	ra,28(sp)
            //*	if we are setting to input, set the data bit to zero first
            iop->lat.clr  = bit;	//clear to output bit		
            iop->tris.set = bit;	//make the pin an input
            break;
        case OPEN:
            iop->tris.clr = bit;	//OPEN implies output, make the pin an output
9d0043ac:	ae300004 	sw	s0,4(s1)
            iop->odc.set  = bit;	//make the pin open drain
9d0043b0:	ae300038 	sw	s0,56(s1)
            } 
#endif
            iop->tris.clr = bit;	//make the pin an output
            iop->odc.clr  = bit;	//make sure it isn't open drain
	}
}
9d0043b4:	8fb10018 	lw	s1,24(sp)
9d0043b8:	8fb00014 	lw	s0,20(sp)
9d0043bc:	03e00008 	jr	ra
9d0043c0:	27bd0020 	addiu	sp,sp,32
		//	You have to set the bit in the AD1PCFG for an analog pin to be used as a 
		//	digital input. They come up after reset as analog input with the digital 
		//	input disabled. For the PORTB pins you switch between analog input and 
		//	digital input using AD1PCFG.

		AD1PCFGSET = bit;
9d0043c4:	3c02bf81 	lui	v0,0xbf81
9d0043c8:	ac509068 	sw	s0,-28568(v0)

	}
#endif	// defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)

	// Set the pin to the requested mode.
    switch (mode) {
9d0043cc:	0b4010cd 	j	9d004334 <pinMode+0x68>
9d0043d0:	24020002 	li	v0,2
            //* Determine if this is an output compare pin. If so,
            //* we need to make sure PWM output is off.
            timer = digitalPinToTimerOC(pin) >> _BN_TIMER_OC;
            if (timer != NOT_ON_TIMER)
            {
                turnOffPWM(timer);
9d0043d4:	0f40114d 	jal	9d004534 <turnOffPWM>
9d0043d8:	00000000 	nop
            }

            //*	May  1,	2011
            //*	according to item #26 in PIC32MX5XX-6XX-7XX Errata.pdf 
            //*	if we are setting to input, set the data bit to zero first
            iop->lat.clr  = bit;	//clear to output bit		
9d0043dc:	ae300024 	sw	s0,36(s1)
            iop->tris.set = bit;	//make the pin an input
9d0043e0:	ae300008 	sw	s0,8(s1)
            } 
#endif
            iop->tris.clr = bit;	//make the pin an output
            iop->odc.clr  = bit;	//make sure it isn't open drain
	}
}
9d0043e4:	0b4010dd 	j	9d004374 <pinMode+0xa8>
9d0043e8:	8fbf001c 	lw	ra,28(sp)

9d0043ec <digitalWrite>:
//*	Reading from PORT gives you a snapshot of the actual pins state regardless of how, 
//*	if at all, the PIC is trying to drive them.  
//*	Reading from LAT gives you the values last written to the pins, whether thru LAT or PORT.
//************************************************************************
void digitalWrite(uint8_t pin, uint8_t val)
{
9d0043ec:	308400ff 	andi	a0,a0,0xff
9d0043f0:	27bdffd8 	addiu	sp,sp,-40
uint32_t                cn;
#endif

	/* Check if pin number is in valid range.
	*/
	if (pin >= NUM_DIGITAL_PINS_EXTENDED)
9d0043f4:	2c82002d 	sltiu	v0,a0,45
//*	Reading from PORT gives you a snapshot of the actual pins state regardless of how, 
//*	if at all, the PIC is trying to drive them.  
//*	Reading from LAT gives you the values last written to the pins, whether thru LAT or PORT.
//************************************************************************
void digitalWrite(uint8_t pin, uint8_t val)
{
9d0043f8:	afbf0024 	sw	ra,36(sp)
9d0043fc:	afb10020 	sw	s1,32(sp)
9d004400:	afb0001c 	sw	s0,28(sp)
uint32_t                cn;
#endif

	/* Check if pin number is in valid range.
	*/
	if (pin >= NUM_DIGITAL_PINS_EXTENDED)
9d004404:	1040001d 	beqz	v0,9d00447c <digitalWrite+0x90>
9d004408:	30a500ff 	andi	a1,a1,0xff
		return;
	}
#endif		// OPT_BOARD_DIGITAL_IO

	//* Get the port number for this pin.
	if ((port = digitalPinToPort(pin)) == NOT_A_PIN)
9d00440c:	3c029d00 	lui	v0,0x9d00
9d004410:	24427d54 	addiu	v0,v0,32084
9d004414:	00821021 	addu	v0,a0,v0
9d004418:	90420000 	lbu	v0,0(v0)
9d00441c:	10400017 	beqz	v0,9d00447c <digitalWrite+0x90>
9d004420:	3c039d00 	lui	v1,0x9d00
	{
		return;
	}

	//* Obtain pointer to the registers for this io port.
	iop = (p32_ioport *)portRegisters(port);
9d004424:	24637d30 	addiu	v1,v1,32048
9d004428:	00021080 	sll	v0,v0,0x2
9d00442c:	00431021 	addu	v0,v0,v1
9d004430:	8c500000 	lw	s0,0(v0)

	//* Obtain bit mask for the specific bit for this pin.
	bit = digitalPinToBitMask(pin);
9d004434:	3c039d00 	lui	v1,0x9d00
9d004438:	00042040 	sll	a0,a0,0x1
9d00443c:	24637d84 	addiu	v1,v1,32132
9d004440:	00831821 	addu	v1,a0,v1

    //* If the port is in input mode and we write a value to it
    //* we must be enabling or disabling the internal pull-up
    //* resistor.  Only works for pins that have an associated
    //* change notification pin.
    if (iop->tris.reg & bit) {
9d004444:	8e020000 	lw	v0,0(s0)
9d004448:	94710000 	lhu	s1,0(v1)
9d00444c:	02221024 	and	v0,s1,v0
9d004450:	1440000a 	bnez	v0,9d00447c <digitalWrite+0x90>
9d004454:	3c029d00 	lui	v0,0x9d00
#endif

    } else {
        //* Determine if this is an output compare pin. If so,
        //* we need to make sure PWM output is off.
        timer = digitalPinToTimerOC(pin);
9d004458:	24427de0 	addiu	v0,v0,32224
9d00445c:	00822021 	addu	a0,a0,v0
9d004460:	90840000 	lbu	a0,0(a0)
9d004464:	3084000f 	andi	a0,a0,0xf
        if (timer != NOT_ON_TIMER)
9d004468:	1480000c 	bnez	a0,9d00449c <digitalWrite+0xb0>
9d00446c:	00000000 	nop
        {
            turnOffPWM(timer);
        }

        //* Set the pin state
        if (val == LOW)
9d004470:	10a00007 	beqz	a1,9d004490 <digitalWrite+0xa4>
9d004474:	00000000 	nop
        {
            iop->lat.clr = bit;
        }
        else
        {
            iop->lat.set = bit;
9d004478:	ae110028 	sw	s1,40(s0)
        }
    }
}
9d00447c:	8fbf0024 	lw	ra,36(sp)
9d004480:	8fb10020 	lw	s1,32(sp)
9d004484:	8fb0001c 	lw	s0,28(sp)
9d004488:	03e00008 	jr	ra
9d00448c:	27bd0028 	addiu	sp,sp,40
        }

        //* Set the pin state
        if (val == LOW)
        {
            iop->lat.clr = bit;
9d004490:	ae110024 	sw	s1,36(s0)
        else
        {
            iop->lat.set = bit;
        }
    }
}
9d004494:	0b401120 	j	9d004480 <digitalWrite+0x94>
9d004498:	8fbf0024 	lw	ra,36(sp)
        //* Determine if this is an output compare pin. If so,
        //* we need to make sure PWM output is off.
        timer = digitalPinToTimerOC(pin);
        if (timer != NOT_ON_TIMER)
        {
            turnOffPWM(timer);
9d00449c:	0f40114d 	jal	9d004534 <turnOffPWM>
9d0044a0:	afa50010 	sw	a1,16(sp)
9d0044a4:	8fa50010 	lw	a1,16(sp)
        }

        //* Set the pin state
        if (val == LOW)
9d0044a8:	14a0fff3 	bnez	a1,9d004478 <digitalWrite+0x8c>
9d0044ac:	00000000 	nop
9d0044b0:	0b401124 	j	9d004490 <digitalWrite+0xa4>
9d0044b4:	00000000 	nop

9d0044b8 <digitalRead>:
    }
}

//************************************************************************
int digitalRead(uint8_t pin)
{
9d0044b8:	308400ff 	andi	a0,a0,0xff
uint8_t					port;
int						highLow;

	/* Check if pin number is in valid range.
	*/
	if (pin >= NUM_DIGITAL_PINS_EXTENDED)
9d0044bc:	2c83002d 	sltiu	v1,a0,45
9d0044c0:	10600017 	beqz	v1,9d004520 <digitalRead+0x68>
9d0044c4:	00001021 	move	v0,zero
		return tmp;
	}
#endif		// OPT_BOARD_DIGITAL_IO

	//* Get the port number for this pin.
	if ((port = digitalPinToPort(pin)) == NOT_A_PIN)
9d0044c8:	3c039d00 	lui	v1,0x9d00
9d0044cc:	24637d54 	addiu	v1,v1,32084
9d0044d0:	00831821 	addu	v1,a0,v1
9d0044d4:	90630000 	lbu	v1,0(v1)
9d0044d8:	10600011 	beqz	v1,9d004520 <digitalRead+0x68>
9d0044dc:	00000000 	nop
	{
		return LOW;
	}

	//* Obtain pointer to the registers for this io port.
	iop = (p32_ioport *)portRegisters(port);
9d0044e0:	3c029d00 	lui	v0,0x9d00
9d0044e4:	00032880 	sll	a1,v1,0x2
9d0044e8:	24427d30 	addiu	v0,v0,32048
9d0044ec:	00a21021 	addu	v0,a1,v0

	//* Obtain bit mask for the specific bit for this pin.
	bit = digitalPinToBitMask(pin);
9d0044f0:	3c059d00 	lui	a1,0x9d00
9d0044f4:	24a57d84 	addiu	a1,a1,32132
9d0044f8:	00042040 	sll	a0,a0,0x1
9d0044fc:	00852021 	addu	a0,a0,a1
	{
		return LOW;
	}

	//* Obtain pointer to the registers for this io port.
	iop = (p32_ioport *)portRegisters(port);
9d004500:	8c450000 	lw	a1,0(v0)

	//* Obtain bit mask for the specific bit for this pin.
	bit = digitalPinToBitMask(pin);
9d004504:	94820000 	lhu	v0,0(a0)
	// analog input capable pins.
	// Clear the bit in the ANSELx register to ensure that the pin is in
	// digital input mode.
	iop->ansel.clr = bit;
#else
	if (port == _IOPORT_PB)
9d004508:	24040002 	li	a0,2
9d00450c:	10640006 	beq	v1,a0,9d004528 <digitalRead+0x70>
9d004510:	3c03bf81 	lui	v1,0xbf81

	}
#endif	// defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)

	//* Get the pin state.
	if ((iop->port.reg & bit) != 0) 
9d004514:	8ca30010 	lw	v1,16(a1)
9d004518:	00431024 	and	v0,v0,v1

	/* Check if pin number is in valid range.
	*/
	if (pin >= NUM_DIGITAL_PINS_EXTENDED)
	{
		return 0;
9d00451c:	0002102b 	sltu	v0,zero,v0
	{
		highLow	=	LOW;
	}

	return(highLow);
}
9d004520:	03e00008 	jr	ra
9d004524:	00000000 	nop
		//	You have to set the bit in the AD1PCFG for an analog pin to be used as a 
		//	digital input. They come up after reset as analog input with the digital 
		//	input disabled. For the PORTB pins you switch between analog input and 
		//	digital input using AD1PCFG.

		AD1PCFGSET = bit;
9d004528:	ac629068 	sw	v0,-28568(v1)
9d00452c:	0b401145 	j	9d004514 <digitalRead+0x5c>
9d004530:	00000000 	nop

9d004534 <turnOffPWM>:
}


//************************************************************************
void turnOffPWM(uint8_t timer)
{
9d004534:	308400ff 	andi	a0,a0,0xff
	*/
	ocp = (p32_oc *)(_OCMP1_BASE_ADDRESS + (0x200 * (timer - (_TIMER_OC1 >> _BN_TIMER_OC))));
	ocp->ocxCon.clr = OCCON_ON;

	// Turn off the bit saying that this PWM is active.
	pwm_active &= ~(1 << (timer - (_TIMER_OC1 >> _BN_TIMER_OC)));
9d004538:	2482ffff 	addiu	v0,a0,-1
9d00453c:	24030001 	li	v1,1
9d004540:	93858040 	lbu	a1,-32704(gp)
9d004544:	00431004 	sllv	v0,v1,v0
{
	p32_oc *	ocp;

	/* Disable the output compare.
	*/
	ocp = (p32_oc *)(_OCMP1_BASE_ADDRESS + (0x200 * (timer - (_TIMER_OC1 >> _BN_TIMER_OC))));
9d004548:	3c03005f 	lui	v1,0x5f
9d00454c:	3463c017 	ori	v1,v1,0xc017
9d004550:	00832021 	addu	a0,a0,v1
	ocp->ocxCon.clr = OCCON_ON;

	// Turn off the bit saying that this PWM is active.
	pwm_active &= ~(1 << (timer - (_TIMER_OC1 >> _BN_TIMER_OC)));
9d004554:	00021027 	nor	v0,zero,v0
{
	p32_oc *	ocp;

	/* Disable the output compare.
	*/
	ocp = (p32_oc *)(_OCMP1_BASE_ADDRESS + (0x200 * (timer - (_TIMER_OC1 >> _BN_TIMER_OC))));
9d004558:	00042240 	sll	a0,a0,0x9
	ocp->ocxCon.clr = OCCON_ON;
9d00455c:	34038000 	li	v1,0x8000

	// Turn off the bit saying that this PWM is active.
	pwm_active &= ~(1 << (timer - (_TIMER_OC1 >> _BN_TIMER_OC)));
9d004560:	00451024 	and	v0,v0,a1
	p32_oc *	ocp;

	/* Disable the output compare.
	*/
	ocp = (p32_oc *)(_OCMP1_BASE_ADDRESS + (0x200 * (timer - (_TIMER_OC1 >> _BN_TIMER_OC))));
	ocp->ocxCon.clr = OCCON_ON;
9d004564:	ac830004 	sw	v1,4(a0)

	// Turn off the bit saying that this PWM is active.
	pwm_active &= ~(1 << (timer - (_TIMER_OC1 >> _BN_TIMER_OC)));

	// If no PWM are active, turn off the timer.
	if (pwm_active == 0)
9d004568:	14400003 	bnez	v0,9d004578 <turnOffPWM+0x44>
9d00456c:	a3828040 	sb	v0,-32704(gp)
	{
    	T2CONCLR = TBCON_ON;
9d004570:	3c02bf80 	lui	v0,0xbf80
9d004574:	ac430804 	sw	v1,2052(v0)
9d004578:	03e00008 	jr	ra
9d00457c:	00000000 	nop

9d004580 <millisecondCoreTimerService>:
*/
uint32_t millisecondCoreTimerService(uint32_t curTime)
{
    static int nextInt = 0;
    uint32_t relWait = 0;
    uint32_t relTime = curTime - nextInt;
9d004580:	8f858050 	lw	a1,-32688(gp)
    uint32_t millisLocal = gTimer0_millis;  // defeat volatility
9d004584:	8f838044 	lw	v1,-32700(gp)
**
*/
uint32_t millisecondCoreTimerService(uint32_t curTime)
{
    static int nextInt = 0;
    uint32_t relWait = 0;
9d004588:	00001021 	move	v0,zero
    uint32_t relTime = curTime - nextInt;
9d00458c:	00852023 	subu	a0,a0,a1

    // catch-up up to current time; we may have fallen behind due to interrupts being diabled.
    while(relWait <= relTime)
    {
        millisLocal++;                      // add a ms to our time
        relWait += CORE_TICK_RATE;          // add a ms to our next ISR time
9d004590:	34079c40 	li	a3,0x9c40
9d004594:	00471021 	addu	v0,v0,a3
    uint32_t relWait = 0;
    uint32_t relTime = curTime - nextInt;
    uint32_t millisLocal = gTimer0_millis;  // defeat volatility

    // catch-up up to current time; we may have fallen behind due to interrupts being diabled.
    while(relWait <= relTime)
9d004598:	0082302b 	sltu	a2,a0,v0
9d00459c:	10c0fffd 	beqz	a2,9d004594 <millisecondCoreTimerService+0x14>
9d0045a0:	24630001 	addiu	v1,v1,1
        millisLocal++;                      // add a ms to our time
        relWait += CORE_TICK_RATE;          // add a ms to our next ISR time
     }

    // set when we want to be called again
    nextInt += relWait;                     // calculate the absolute interrupt time we want.
9d0045a4:	00451021 	addu	v0,v0,a1

    // we want to sync gCore_timer_last_val with the last millisecond "count" value
    // curTime may not be exactly on a millisecond boundary, but we know where that is
    // we know nextInt is our next millisecond boundary, so less 1 CORE_TICK_RATE will be our last one
    // gCore_timer_last_val = curTime;         // This is the original bogus code
    gCore_timer_last_val =  nextInt - CORE_TICK_RATE;
9d0045a8:	34049c40 	li	a0,0x9c40
9d0045ac:	00442023 	subu	a0,v0,a0
9d0045b0:	af848048 	sw	a0,-32696(gp)
        millisLocal++;                      // add a ms to our time
        relWait += CORE_TICK_RATE;          // add a ms to our next ISR time
     }

    // set when we want to be called again
    nextInt += relWait;                     // calculate the absolute interrupt time we want.
9d0045b4:	af828050 	sw	v0,-32688(gp)
    // we know nextInt is our next millisecond boundary, so less 1 CORE_TICK_RATE will be our last one
    // gCore_timer_last_val = curTime;         // This is the original bogus code
    gCore_timer_last_val =  nextInt - CORE_TICK_RATE;

    // update the global millisecond counter.
    gTimer0_millis = millisLocal;           // Total number of ms
9d0045b8:	af838044 	sw	v1,-32700(gp)

    return(nextInt);
}
9d0045bc:	03e00008 	jr	ra
9d0045c0:	00000000 	nop

9d0045c4 <CoreTimerHandler>:
**      each service's logical compare values. And then the next and soonest logical compare value is searched for and set as
**      the real compare value to be interrupted to notify the Serivces when count hits that value.
**
*/
void __attribute__((interrupt(),nomips16)) CoreTimerHandler(void)
{
9d0045c4:	415de800 	rdpgpr	sp,sp
9d0045c8:	401b7000 	mfc0	k1,c0_epc
9d0045cc:	401a6002 	mfc0	k0,c0_srsctl
9d0045d0:	27bdff58 	addiu	sp,sp,-168
9d0045d4:	afbb00a4 	sw	k1,164(sp)
9d0045d8:	401b6000 	mfc0	k1,c0_status
9d0045dc:	afba00a0 	sw	k0,160(sp)
9d0045e0:	401a6800 	mfc0	k0,c0_cause
9d0045e4:	001ad282 	srl	k0,k0,0xa
9d0045e8:	afbb009c 	sw	k1,156(sp)
9d0045ec:	7f5b7a84 	ins	k1,k0,0xa,0x6
9d0045f0:	7c1b2044 	ins	k1,zero,0x1,0x4
9d0045f4:	409b6000 	mtc0	k1,c0_status
9d0045f8:	afa3002c 	sw	v1,44(sp)
9d0045fc:	8fa300a0 	lw	v1,160(sp)
9d004600:	3063000f 	andi	v1,v1,0xf
9d004604:	1460001a 	bnez	v1,9d004670 <CoreTimerHandler+0xac>
9d004608:	afa20028 	sw	v0,40(sp)
9d00460c:	afbf008c 	sw	ra,140(sp)
9d004610:	afbe0088 	sw	s8,136(sp)
9d004614:	afb90084 	sw	t9,132(sp)
9d004618:	afb80080 	sw	t8,128(sp)
9d00461c:	afb7007c 	sw	s7,124(sp)
9d004620:	afb60078 	sw	s6,120(sp)
9d004624:	afb50074 	sw	s5,116(sp)
9d004628:	afb40070 	sw	s4,112(sp)
9d00462c:	afb3006c 	sw	s3,108(sp)
9d004630:	afb20068 	sw	s2,104(sp)
9d004634:	afb10064 	sw	s1,100(sp)
9d004638:	afb00060 	sw	s0,96(sp)
9d00463c:	afaf005c 	sw	t7,92(sp)
9d004640:	afae0058 	sw	t6,88(sp)
9d004644:	afad0054 	sw	t5,84(sp)
9d004648:	afac0050 	sw	t4,80(sp)
9d00464c:	afab004c 	sw	t3,76(sp)
9d004650:	afaa0048 	sw	t2,72(sp)
9d004654:	afa90044 	sw	t1,68(sp)
9d004658:	afa80040 	sw	t0,64(sp)
9d00465c:	afa7003c 	sw	a3,60(sp)
9d004660:	afa60038 	sw	a2,56(sp)
9d004664:	afa50034 	sw	a1,52(sp)
9d004668:	afa40030 	sw	a0,48(sp)
9d00466c:	afa10024 	sw	at,36(sp)
9d004670:	00001012 	mflo	v0
9d004674:	afa20094 	sw	v0,148(sp)
9d004678:	00001810 	mfhi	v1
9d00467c:	afa30090 	sw	v1,144(sp)

    // we know that count >= compare, otherwise we would not have been interrupted
    // we also know that count and compare >= gLastBaseCount as this was our last count value.

    // get our current time; this will establish our next base
    read_count(curTime); 
9d004680:	40134800 	mfc0	s3,c0_count
    relCurTime = curTime - gLastBaseCount;
9d004684:	8f9e804c 	lw	s8,-32692(gp)
9d004688:	3c10a000 	lui	s0,0xa000
        {
            // if the serivce exists
            if(gCoreTimerInfo[i].serivce != NULL)
            {
                // if their time has come up
                relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d00468c:	3c05a000 	lui	a1,0xa000
    // we know that count >= compare, otherwise we would not have been interrupted
    // we also know that count and compare >= gLastBaseCount as this was our last count value.

    // get our current time; this will establish our next base
    read_count(curTime); 
    relCurTime = curTime - gLastBaseCount;
9d004690:	027ef023 	subu	s8,s3,s8

    // we know that count >= compare, otherwise we would not have been interrupted
    // we also know that count and compare >= gLastBaseCount as this was our last count value.

    // get our current time; this will establish our next base
    read_count(curTime); 
9d004694:	02603021 	move	a2,s3
9d004698:	261000dc 	addiu	s0,s0,220
9d00469c:	3c12bf88 	lui	s2,0xbf88
        {
            // if the serivce exists
            if(gCoreTimerInfo[i].serivce != NULL)
            {
                // if their time has come up
                relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d0046a0:	24a500d8 	addiu	a1,a1,216
    {
        // make sure we find the lowest int to set
        relNextInt = 0xFFFFFFFF;

        // check to see who all we need to call
        for(i=0; i<MaxNbrOfCoreTimerServices; i++)
9d0046a4:	24030003 	li	v1,3
        // we need to apply our base to convert from relative values to an absolute time.
        compare = relNextInt + gLastBaseCount;
        write_comp(compare); 

        // clear the CT flag
        mCTClearIntFlag();
9d0046a8:	24110001 	li	s1,1
    // we know that count >= compare, otherwise we would not have been interrupted
    // we also know that count and compare >= gLastBaseCount as this was our last count value.

    // get our current time; this will establish our next base
    read_count(curTime); 
    relCurTime = curTime - gLastBaseCount;
9d0046ac:	0200b021 	move	s6,s0
    {
        // make sure we find the lowest int to set
        relNextInt = 0xFFFFFFFF;

        // check to see who all we need to call
        for(i=0; i<MaxNbrOfCoreTimerServices; i++)
9d0046b0:	0000a021 	move	s4,zero
    nextBase = curTime;

    do
    {
        // make sure we find the lowest int to set
        relNextInt = 0xFFFFFFFF;
9d0046b4:	2415ffff 	li	s5,-1

        // check to see who all we need to call
        for(i=0; i<MaxNbrOfCoreTimerServices; i++)
        {
            // if the serivce exists
            if(gCoreTimerInfo[i].serivce != NULL)
9d0046b8:	8ec20000 	lw	v0,0(s6)
            {
                // if their time has come up
                relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d0046bc:	0014b8c0 	sll	s7,s4,0x3
9d0046c0:	02e5b821 	addu	s7,s7,a1
    {
        // make sure we find the lowest int to set
        relNextInt = 0xFFFFFFFF;

        // check to see who all we need to call
        for(i=0; i<MaxNbrOfCoreTimerServices; i++)
9d0046c4:	26940001 	addiu	s4,s4,1
        {
            // if the serivce exists
            if(gCoreTimerInfo[i].serivce != NULL)
9d0046c8:	10400009 	beqz	v0,9d0046f0 <CoreTimerHandler+0x12c>
9d0046cc:	26d60008 	addiu	s6,s6,8
            {
                // if their time has come up
                relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d0046d0:	8ee70000 	lw	a3,0(s7)
9d0046d4:	8f84804c 	lw	a0,-32692(gp)
9d0046d8:	00e42023 	subu	a0,a3,a0
                if(relInt <= relCurTime)
9d0046dc:	03c4382b 	sltu	a3,s8,a0
9d0046e0:	50e0003d 	beqzl	a3,9d0047d8 <CoreTimerHandler+0x214>
9d0046e4:	00c02021 	move	a0,a2
                    relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
                }

                // see if this is the next interrupt we want to set
                // we are looking for the closest/lowest int to set.
                if(relInt < relNextInt)
9d0046e8:	0095102b 	sltu	v0,a0,s5
9d0046ec:	0082a80b 	movn	s5,a0,v0
    {
        // make sure we find the lowest int to set
        relNextInt = 0xFFFFFFFF;

        // check to see who all we need to call
        for(i=0; i<MaxNbrOfCoreTimerServices; i++)
9d0046f0:	5683fff2 	bnel	s4,v1,9d0046bc <CoreTimerHandler+0xf8>
9d0046f4:	8ec20000 	lw	v0,0(s6)
        // other service may cause the compare value to be set for an earlier time; but we always know there will be a compare time
        // to set, so we know that relNextInt has a value other than 0xFFFFFFFF in it.

        // Go ahead and set the compare register to the next interrupt we want.
        // we need to apply our base to convert from relative values to an absolute time.
        compare = relNextInt + gLastBaseCount;
9d0046f8:	8f82804c 	lw	v0,-32692(gp)
9d0046fc:	02a21021 	addu	v0,s5,v0
        write_comp(compare); 
9d004700:	40825800 	mtc0	v0,c0_compare

        // clear the CT flag
        mCTClearIntFlag();
9d004704:	ae511034 	sw	s1,4148(s2)

        // read the count after the CT flag has been set so we can make sure count has not passed compare
        // during our processing of this int
        read_count(curTime); 
9d004708:	40064800 	mfc0	a2,c0_count

        // get the relative time so we can operate in the linear portion of our uint32.
        relCurTime = curTime - gLastBaseCount;
9d00470c:	8f9e804c 	lw	s8,-32692(gp)
9d004710:	00def023 	subu	s8,a2,s8

        // if the current time has passed our interrupt time, then we basically hit the interrupt again
        // so we probabaly missed the CT flag being set and we need to reprocess this interrupt and find the next one to set.
    } while(relNextInt <= relCurTime);
9d004714:	03d5a82b 	sltu	s5,s8,s5
9d004718:	52a0ffe5 	beqzl	s5,9d0046b0 <CoreTimerHandler+0xec>
9d00471c:	0200b021 	move	s6,s0
    // otherwise the next interrupt time (compare time) is after the current time and CT will catch it when count == compare.
    // we can safely exit the ISR.

    // but first we must set our new base so the next time we come into this routine we
    // have a valid lower base to shift our times to for comparisons.
    gLastBaseCount = nextBase;
9d004720:	af93804c 	sw	s3,-32692(gp)
}
9d004724:	8fa20094 	lw	v0,148(sp)
9d004728:	8fa30090 	lw	v1,144(sp)
9d00472c:	00400013 	mtlo	v0
9d004730:	8fa200a0 	lw	v0,160(sp)
9d004734:	3042000f 	andi	v0,v0,0xf
9d004738:	1440001c 	bnez	v0,9d0047ac <CoreTimerHandler+0x1e8>
9d00473c:	00600011 	mthi	v1
9d004740:	8fbf008c 	lw	ra,140(sp)
9d004744:	8fbe0088 	lw	s8,136(sp)
9d004748:	8fb90084 	lw	t9,132(sp)
9d00474c:	8fb80080 	lw	t8,128(sp)
9d004750:	8fb7007c 	lw	s7,124(sp)
9d004754:	8fb60078 	lw	s6,120(sp)
9d004758:	8fb50074 	lw	s5,116(sp)
9d00475c:	8fb40070 	lw	s4,112(sp)
9d004760:	8fb3006c 	lw	s3,108(sp)
9d004764:	8fb20068 	lw	s2,104(sp)
9d004768:	8fb10064 	lw	s1,100(sp)
9d00476c:	8fb00060 	lw	s0,96(sp)
9d004770:	8faf005c 	lw	t7,92(sp)
9d004774:	8fae0058 	lw	t6,88(sp)
9d004778:	8fad0054 	lw	t5,84(sp)
9d00477c:	8fac0050 	lw	t4,80(sp)
9d004780:	8fab004c 	lw	t3,76(sp)
9d004784:	8faa0048 	lw	t2,72(sp)
9d004788:	8fa90044 	lw	t1,68(sp)
9d00478c:	8fa80040 	lw	t0,64(sp)
9d004790:	8fa7003c 	lw	a3,60(sp)
9d004794:	8fa60038 	lw	a2,56(sp)
9d004798:	8fa50034 	lw	a1,52(sp)
9d00479c:	8fa40030 	lw	a0,48(sp)
9d0047a0:	8fa3002c 	lw	v1,44(sp)
9d0047a4:	8fa20028 	lw	v0,40(sp)
9d0047a8:	8fa10024 	lw	at,36(sp)
9d0047ac:	41606000 	di
9d0047b0:	000000c0 	ehb
9d0047b4:	8fba00a4 	lw	k0,164(sp)
9d0047b8:	8fbb009c 	lw	k1,156(sp)
9d0047bc:	409a7000 	mtc0	k0,c0_epc
9d0047c0:	8fba00a0 	lw	k0,160(sp)
9d0047c4:	27bd00a8 	addiu	sp,sp,168
9d0047c8:	409a6002 	mtc0	k0,c0_srsctl
9d0047cc:	41dde800 	wrpgpr	sp,sp
9d0047d0:	409b6000 	mtc0	k1,c0_status
9d0047d4:	42000018 	eret
                // if their time has come up
                relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
                if(relInt <= relCurTime)
                {
                    // call their routine to get their next interrupt time
                    gCoreTimerInfo[i].nextInt = gCoreTimerInfo[i].serivce(curTime);
9d0047d8:	afa30018 	sw	v1,24(sp)
9d0047dc:	afa50014 	sw	a1,20(sp)
9d0047e0:	0040f809 	jalr	v0
9d0047e4:	afa60010 	sw	a2,16(sp)
9d0047e8:	aee20000 	sw	v0,0(s7)

                    // recalculate the relative time of thier next int
                    // so we can see if this is the next int we need to set
                    relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d0047ec:	8ee40000 	lw	a0,0(s7)
9d0047f0:	8f82804c 	lw	v0,-32692(gp)
9d0047f4:	8fa60010 	lw	a2,16(sp)
9d0047f8:	8fa50014 	lw	a1,20(sp)
9d0047fc:	00822023 	subu	a0,a0,v0
                }

                // see if this is the next interrupt we want to set
                // we are looking for the closest/lowest int to set.
                if(relInt < relNextInt)
9d004800:	0095102b 	sltu	v0,a0,s5
                    // call their routine to get their next interrupt time
                    gCoreTimerInfo[i].nextInt = gCoreTimerInfo[i].serivce(curTime);

                    // recalculate the relative time of thier next int
                    // so we can see if this is the next int we need to set
                    relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d004804:	8fa30018 	lw	v1,24(sp)
                }

                // see if this is the next interrupt we want to set
                // we are looking for the closest/lowest int to set.
                if(relInt < relNextInt)
9d004808:	0b4011bc 	j	9d0046f0 <CoreTimerHandler+0x12c>
9d00480c:	0082a80b 	movn	s5,a0,v0

9d004810 <millis>:
uint8_t ppsGlobalLock = false;

//************************************************************************
unsigned long millis()
{
	return(gTimer0_millis);
9d004810:	8f828044 	lw	v0,-32700(gp)
}
9d004814:	03e00008 	jr	ra
9d004818:	00000000 	nop

9d00481c <delay>:
}

//************************************************************************
// Delay for a given number of milliseconds.
void delay(unsigned long ms)
{
9d00481c:	27bdffe0 	addiu	sp,sp,-32
9d004820:	afb10018 	sw	s1,24(sp)
unsigned long	startMillis;

	startMillis	=	gTimer0_millis;
9d004824:	8f918044 	lw	s1,-32700(gp)
	while ((gTimer0_millis - startMillis) < ms)
9d004828:	8f828044 	lw	v0,-32700(gp)
}

//************************************************************************
// Delay for a given number of milliseconds.
void delay(unsigned long ms)
{
9d00482c:	afb00014 	sw	s0,20(sp)
9d004830:	afbf001c 	sw	ra,28(sp)
unsigned long	startMillis;

	startMillis	=	gTimer0_millis;
	while ((gTimer0_millis - startMillis) < ms)
9d004834:	00511023 	subu	v0,v0,s1
9d004838:	0044102b 	sltu	v0,v0,a0
9d00483c:	10400008 	beqz	v0,9d004860 <delay+0x44>
9d004840:	00808021 	move	s0,a0
	{
		_scheduleTask();
9d004844:	0f401258 	jal	9d004960 <_scheduleTask>
9d004848:	00000000 	nop
void delay(unsigned long ms)
{
unsigned long	startMillis;

	startMillis	=	gTimer0_millis;
	while ((gTimer0_millis - startMillis) < ms)
9d00484c:	8f828044 	lw	v0,-32700(gp)
9d004850:	00511023 	subu	v0,v0,s1
9d004854:	0050102b 	sltu	v0,v0,s0
9d004858:	1440fffa 	bnez	v0,9d004844 <delay+0x28>
9d00485c:	00000000 	nop
	{
		_scheduleTask();
	}
}
9d004860:	8fbf001c 	lw	ra,28(sp)
9d004864:	8fb10018 	lw	s1,24(sp)
9d004868:	8fb00014 	lw	s0,20(sp)
9d00486c:	03e00008 	jr	ra
9d004870:	27bd0020 	addiu	sp,sp,32

9d004874 <init>:
	__PIC32_pbClk	=	SYSTEMConfigPerformance(F_CPU);
#endif
#endif

	// Configure the processor for the proper number of wait states and caching.
	_configSystem(F_CPU);
9d004874:	3c0404c4 	lui	a0,0x4c4
}


//************************************************************************
void init()
{
9d004878:	27bdffe8 	addiu	sp,sp,-24
9d00487c:	afbf0014 	sw	ra,20(sp)
	__PIC32_pbClk	=	SYSTEMConfigPerformance(F_CPU);
#endif
#endif

	// Configure the processor for the proper number of wait states and caching.
	_configSystem(F_CPU);
9d004880:	0f401022 	jal	9d004088 <_configSystem>
9d004884:	3484b400 	ori	a0,a0,0xb400

	// Enable multi-vector interrupts
	_enableMultiVectorInterrupts();
9d004888:	0f401043 	jal	9d00410c <_enableMultiVectorInterrupts>
9d00488c:	00000000 	nop

	// Initialize the core timer for use to maintain the system timer tick.
	_initCoreTimer(CORE_TICK_RATE);
9d004890:	0f40104c 	jal	9d004130 <_initCoreTimer>
9d004894:	34049c40 	li	a0,0x9c40

    initIntVector();
9d004898:	0f400fd6 	jal	9d003f58 <initIntVector>
9d00489c:	00000000 	nop

	setIntPriority(_CORE_TIMER_VECTOR, _CT_IPL_IPC, _CT_SPL_IPC);
9d0048a0:	00003021 	move	a2,zero
9d0048a4:	00002021 	move	a0,zero
9d0048a8:	0f401004 	jal	9d004010 <setIntPriority>
9d0048ac:	24050007 	li	a1,7
	setIntVector(_CORE_TIMER_VECTOR, CoreTimerHandler);
9d0048b0:	3c059d00 	lui	a1,0x9d00
9d0048b4:	24a545c4 	addiu	a1,a1,17860
9d0048b8:	0f400feb 	jal	9d003fac <setIntVector>
9d0048bc:	00002021 	move	a0,zero
	setIntEnable(_CORE_TIMER_IRQ);
9d0048c0:	0f400ff6 	jal	9d003fd8 <setIntEnable>
9d0048c4:	00002021 	move	a0,zero

	// Save the peripheral bus frequency for later use.
	__PIC32_pbClk = getPeripheralClock();
9d0048c8:	0f40101b 	jal	9d00406c <getPeripheralClock>
9d0048cc:	00000000 	nop

   // allow for debugging, this will stop the core timer when the debugger takes control
    _CP0_BIC_DEBUG(_CP0_DEBUG_COUNTDM_MASK); 
9d0048d0:	3c030200 	lui	v1,0x200
	setIntPriority(_CORE_TIMER_VECTOR, _CT_IPL_IPC, _CT_SPL_IPC);
	setIntVector(_CORE_TIMER_VECTOR, CoreTimerHandler);
	setIntEnable(_CORE_TIMER_IRQ);

	// Save the peripheral bus frequency for later use.
	__PIC32_pbClk = getPeripheralClock();
9d0048d4:	af8280c8 	sw	v0,-32568(gp)

   // allow for debugging, this will stop the core timer when the debugger takes control
    _CP0_BIC_DEBUG(_CP0_DEBUG_COUNTDM_MASK); 
9d0048d8:	4002b800 	mfc0	v0,c0_debug
9d0048dc:	00031827 	nor	v1,zero,v1
9d0048e0:	00431824 	and	v1,v0,v1
9d0048e4:	4083b800 	mtc0	v1,c0_debug
9d0048e8:	000000c0 	ehb
	RtccSetTimeDate(0x10073000, 0x10101701);
	// please note that the rsvd field has to be 0 in the time field!
#endif
#endif

	delay(50);
9d0048ec:	0f401207 	jal	9d00481c <delay>
9d0048f0:	24040032 	li	a0,50
#if defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)
	CFGCONbits.JTAGEN = 0;
	//CFGCONbits.TDOEN = 0;
	//OSCCONbits.SOSCEN = 0;
#else
	DDPCONbits.JTAGEN	=	0;
9d0048f4:	3c02bf81 	lui	v0,0xbf81
9d0048f8:	8c43f200 	lw	v1,-3584(v0)
9d0048fc:	7c0318c4 	ins	v1,zero,0x3,0x1
9d004900:	ac43f200 	sw	v1,-3584(v0)
#endif


#if (OPT_BOARD_INIT != 0)
void	_board_init(void);
	_board_init();
9d004904:	0f4012c6 	jal	9d004b18 <_board_init>
9d004908:	00000000 	nop
#endif

	//* Initialize the periodic task manager
	_initTaskManager();
9d00490c:	0f40124b 	jal	9d00492c <_initTaskManager>
9d004910:	00000000 	nop
#if defined(_SER0_BASE)
	p32_uart *	uart;
	uart = (p32_uart *)_SER0_BASE;
	uart->uxMode.clr = (1 << _UARTMODE_ON);
#endif
}
9d004914:	8fbf0014 	lw	ra,20(sp)
	//*	Issue #84
	//*	disable the uart so that the pins can be used as general purpose I/O
#if defined(_SER0_BASE)
	p32_uart *	uart;
	uart = (p32_uart *)_SER0_BASE;
	uart->uxMode.clr = (1 << _UARTMODE_ON);
9d004918:	34038000 	li	v1,0x8000
9d00491c:	3c02bf80 	lui	v0,0xbf80
9d004920:	ac436004 	sw	v1,24580(v0)
#endif
}
9d004924:	03e00008 	jr	ra
9d004928:	27bd0018 	addiu	sp,sp,24

9d00492c <_initTaskManager>:
void
_initTaskManager() {
	int		id;

	for (id = 0; id < NUM_TASKS; id++) {
		rgtaskTable[id].pfnTask = 0;
9d00492c:	3c03a000 	lui	v1,0xa000
9d004930:	24620c84 	addiu	v0,v1,3204
9d004934:	ac600c84 	sw	zero,3204(v1)
9d004938:	ac400014 	sw	zero,20(v0)
9d00493c:	ac400028 	sw	zero,40(v0)
9d004940:	ac40003c 	sw	zero,60(v0)
9d004944:	ac400050 	sw	zero,80(v0)
9d004948:	ac400064 	sw	zero,100(v0)
9d00494c:	ac400078 	sw	zero,120(v0)
9d004950:	ac40008c 	sw	zero,140(v0)
	}

	tmsLastEvent = 0;
9d004954:	af80805c 	sw	zero,-32676(gp)
	tmsNextEvent = 0;

}
9d004958:	03e00008 	jr	ra
9d00495c:	af808058 	sw	zero,-32680(gp)

9d004960 <_scheduleTask>:
	unsigned long	tmsCur;		//current system time
	unsigned long	tmsNxt;		//time for next event for this task
	unsigned long	dtmsNext;
	unsigned long	dtms;

	if (cntActiveTask == 0) {
9d004960:	8f828054 	lw	v0,-32684(gp)
**	xxxN..C..........................................Lxx
**		current time and next time have wrapped: (N < L) && (C >= N)
*/

void
_scheduleTask() {
9d004964:	27bdffc8 	addiu	sp,sp,-56
9d004968:	afbf0034 	sw	ra,52(sp)
9d00496c:	afb50030 	sw	s5,48(sp)
9d004970:	afb4002c 	sw	s4,44(sp)
9d004974:	afb30028 	sw	s3,40(sp)
9d004978:	afb20024 	sw	s2,36(sp)
9d00497c:	afb10020 	sw	s1,32(sp)
	unsigned long	tmsCur;		//current system time
	unsigned long	tmsNxt;		//time for next event for this task
	unsigned long	dtmsNext;
	unsigned long	dtms;

	if (cntActiveTask == 0) {
9d004980:	1440000a 	bnez	v0,9d0049ac <_scheduleTask+0x4c>
9d004984:	afb0001c 	sw	s0,28(sp)

	/* Compute when the next event time will be by adding the event
	** time delta to the current time.
	*/
	tmsNextEvent = tmsCur + dtmsNext;
}
9d004988:	8fbf0034 	lw	ra,52(sp)
9d00498c:	8fb50030 	lw	s5,48(sp)
9d004990:	8fb4002c 	lw	s4,44(sp)
9d004994:	8fb30028 	lw	s3,40(sp)
9d004998:	8fb20024 	lw	s2,36(sp)
9d00499c:	8fb10020 	lw	s1,32(sp)
9d0049a0:	8fb0001c 	lw	s0,28(sp)
9d0049a4:	03e00008 	jr	ra
9d0049a8:	27bd0038 	addiu	sp,sp,56

	if (cntActiveTask == 0) {
		return;
	}

	tmsCur = millis();
9d0049ac:	0f401204 	jal	9d004810 <millis>
9d0049b0:	00000000 	nop

	/* The system millisecond timer will overflow every 49.71 days. The complexity of
	** this conditional is to account for the cases where either the next event time has
	** wrapped around or the current time has wrapped around.
	*/
	if ( ((tmsNextEvent >= tmsLastEvent) &&
9d0049b4:	8f848058 	lw	a0,-32680(gp)
9d0049b8:	8f83805c 	lw	v1,-32676(gp)
9d0049bc:	0083282b 	sltu	a1,a0,v1
9d0049c0:	14a00048 	bnez	a1,9d004ae4 <_scheduleTask+0x184>
9d0049c4:	0043182b 	sltu	v1,v0,v1
9d0049c8:	14600004 	bnez	v1,9d0049dc <_scheduleTask+0x7c>
9d0049cc:	3c10a000 	lui	s0,0xa000
				((tmsCur >= tmsLastEvent) && (tmsCur < tmsNextEvent))) ||
9d0049d0:	0044202b 	sltu	a0,v0,a0
9d0049d4:	1480ffec 	bnez	a0,9d004988 <_scheduleTask+0x28>
9d0049d8:	3c10a000 	lui	s0,0xa000
9d0049dc:	26100c94 	addiu	s0,s0,3220
**	xxxN..C..........................................Lxx
**		current time and next time have wrapped: (N < L) && (C >= N)
*/

void
_scheduleTask() {
9d0049e0:	2413ffff 	li	s3,-1
9d0049e4:	00008821 	move	s1,zero

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
			(*rgtaskTable[id].pfnTask)(id, rgtaskTable[id].varTask);
			rgtaskTable[id].fsFlags &= ~fsBusy;
9d0049e8:	2415fffe 	li	s5,-2

			/* Decrement the repeat count.
			*/
			if ((rgtaskTable[id].stTask > 0) &&
9d0049ec:	3414fffe 	li	s4,0xfffe
	** the table for all events that have elapsed and call their
	** associated functions, update their next event timers, and then
	** figure out when the next event time is.
	*/
	dtmsNext = 0xFFFFFFFF;
	for (id = 0; id < NUM_TASKS; id++) {
9d0049f0:	24120008 	li	s2,8
		/* If this isn't an active task, go to the next one.
		*/
		if ((rgtaskTable[id].pfnTask == 0) || 
9d0049f4:	8e03fff0 	lw	v1,-16(s0)
9d0049f8:	5060002c 	beqzl	v1,9d004aac <_scheduleTask+0x14c>
9d0049fc:	26310001 	addiu	s1,s1,1
9d004a00:	96040000 	lhu	a0,0(s0)
9d004a04:	50800029 	beqzl	a0,9d004aac <_scheduleTask+0x14c>
9d004a08:	26310001 	addiu	s1,s1,1
		** occur if a user task function calls delay() or any other
		** function that causes _scheduleTask to be called recursively.
		** This prevents the task function from being called recursively
		** until the system crashes.
		*/
		if ((rgtaskTable[id].fsFlags & fsBusy) != 0) {
9d004a0c:	96040002 	lhu	a0,2(s0)
9d004a10:	30840001 	andi	a0,a0,0x1
9d004a14:	54800025 	bnezl	a0,9d004aac <_scheduleTask+0x14c>
9d004a18:	26310001 	addiu	s1,s1,1
			continue;
		}

		/* Check if this task's period has timed out.
		*/
		tmsNxt = rgtaskTable[id].tmsNext;
9d004a1c:	8e04fff8 	lw	a0,-8(s0)
		if ( ((tmsNxt >= tmsLastEvent) && 
9d004a20:	8f85805c 	lw	a1,-32676(gp)
9d004a24:	0085302b 	sltu	a2,a0,a1
9d004a28:	10c00032 	beqz	a2,9d004af4 <_scheduleTask+0x194>
9d004a2c:	0044302b 	sltu	a2,v0,a0
						((tmsCur >= tmsNxt) || (tmsCur < tmsLastEvent))) ||
			 ((tmsNxt <  tmsLastEvent) && 
9d004a30:	54c0001b 	bnezl	a2,9d004aa0 <_scheduleTask+0x140>
9d004a34:	00822023 	subu	a0,a0,v0
						((tmsCur >= tmsNxt) && (tmsCur < tmsLastEvent))) ) {
9d004a38:	0045282b 	sltu	a1,v0,a1
9d004a3c:	50a00018 	beqzl	a1,9d004aa0 <_scheduleTask+0x140>
9d004a40:	00822023 	subu	a0,a0,v0
			*/
			rgtaskTable[id].tmsNext += rgtaskTable[id].tmsPeriod;

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
9d004a44:	96060002 	lhu	a2,2(s0)
						((tmsCur >= tmsNxt) && (tmsCur < tmsLastEvent))) ) {

			/* This task event has timed out. Update the event time for the
			** next event on this task.
			*/
			rgtaskTable[id].tmsNext += rgtaskTable[id].tmsPeriod;
9d004a48:	8e07fff4 	lw	a3,-12(s0)

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
			(*rgtaskTable[id].pfnTask)(id, rgtaskTable[id].varTask);
9d004a4c:	8e05fffc 	lw	a1,-4(s0)
			*/
			rgtaskTable[id].tmsNext += rgtaskTable[id].tmsPeriod;

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
9d004a50:	34c60001 	ori	a2,a2,0x1
						((tmsCur >= tmsNxt) && (tmsCur < tmsLastEvent))) ) {

			/* This task event has timed out. Update the event time for the
			** next event on this task.
			*/
			rgtaskTable[id].tmsNext += rgtaskTable[id].tmsPeriod;
9d004a54:	00e42021 	addu	a0,a3,a0
9d004a58:	ae04fff8 	sw	a0,-8(s0)

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
			(*rgtaskTable[id].pfnTask)(id, rgtaskTable[id].varTask);
9d004a5c:	afa20010 	sw	v0,16(sp)
9d004a60:	02202021 	move	a0,s1
9d004a64:	0060f809 	jalr	v1
9d004a68:	a6060002 	sh	a2,2(s0)
			rgtaskTable[id].fsFlags &= ~fsBusy;

			/* Decrement the repeat count.
			*/
			if ((rgtaskTable[id].stTask > 0) &&
9d004a6c:	96030000 	lhu	v1,0(s0)

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
			(*rgtaskTable[id].pfnTask)(id, rgtaskTable[id].varTask);
			rgtaskTable[id].fsFlags &= ~fsBusy;
9d004a70:	96050002 	lhu	a1,2(s0)

			/* Decrement the repeat count.
			*/
			if ((rgtaskTable[id].stTask > 0) &&
9d004a74:	8fa20010 	lw	v0,16(sp)
9d004a78:	2463ffff 	addiu	v1,v1,-1
9d004a7c:	3063ffff 	andi	v1,v1,0xffff

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
			(*rgtaskTable[id].pfnTask)(id, rgtaskTable[id].varTask);
			rgtaskTable[id].fsFlags &= ~fsBusy;
9d004a80:	00b52824 	and	a1,a1,s5

			/* Decrement the repeat count.
			*/
			if ((rgtaskTable[id].stTask > 0) &&
9d004a84:	0074202b 	sltu	a0,v1,s4
9d004a88:	10800003 	beqz	a0,9d004a98 <_scheduleTask+0x138>
9d004a8c:	a6050002 	sh	a1,2(s0)
				rgtaskTable[id].stTask -= 1;

				/* The task state counter has gone to 0. This task is now
				** disabled.
				*/
				if (rgtaskTable[id].stTask == 0) {
9d004a90:	1060001c 	beqz	v1,9d004b04 <_scheduleTask+0x1a4>
9d004a94:	a6030000 	sh	v1,0(s0)
9d004a98:	8e04fff8 	lw	a0,-8(s0)
		}

		/* Compute delta of this event time from the current time and
		** remember it if it is less than the current delta.
		*/
		dtms = rgtaskTable[id].tmsNext - tmsCur;
9d004a9c:	00822023 	subu	a0,a0,v0
		if (dtms < dtmsNext) {
9d004aa0:	0093182b 	sltu	v1,a0,s3
9d004aa4:	0083980b 	movn	s3,a0,v1
	** the table for all events that have elapsed and call their
	** associated functions, update their next event timers, and then
	** figure out when the next event time is.
	*/
	dtmsNext = 0xFFFFFFFF;
	for (id = 0; id < NUM_TASKS; id++) {
9d004aa8:	26310001 	addiu	s1,s1,1
9d004aac:	1632ffd1 	bne	s1,s2,9d0049f4 <_scheduleTask+0x94>
9d004ab0:	26100014 	addiu	s0,s0,20

	/* Compute when the next event time will be by adding the event
	** time delta to the current time.
	*/
	tmsNextEvent = tmsCur + dtmsNext;
}
9d004ab4:	8fbf0034 	lw	ra,52(sp)
	tmsLastEvent = tmsCur;

	/* Compute when the next event time will be by adding the event
	** time delta to the current time.
	*/
	tmsNextEvent = tmsCur + dtmsNext;
9d004ab8:	02629821 	addu	s3,s3,v0
9d004abc:	af938058 	sw	s3,-32680(gp)
}
9d004ac0:	8fb50030 	lw	s5,48(sp)
9d004ac4:	8fb4002c 	lw	s4,44(sp)
9d004ac8:	8fb30028 	lw	s3,40(sp)
9d004acc:	8fb20024 	lw	s2,36(sp)
9d004ad0:	8fb10020 	lw	s1,32(sp)
9d004ad4:	8fb0001c 	lw	s0,28(sp)
	}

	/* All done with event tasks. Update the last event time with
	** the current time.
	*/
	tmsLastEvent = tmsCur;
9d004ad8:	af82805c 	sw	v0,-32676(gp)

	/* Compute when the next event time will be by adding the event
	** time delta to the current time.
	*/
	tmsNextEvent = tmsCur + dtmsNext;
}
9d004adc:	03e00008 	jr	ra
9d004ae0:	27bd0038 	addiu	sp,sp,56
	** this conditional is to account for the cases where either the next event time has
	** wrapped around or the current time has wrapped around.
	*/
	if ( ((tmsNextEvent >= tmsLastEvent) &&
				((tmsCur >= tmsLastEvent) && (tmsCur < tmsNextEvent))) ||
		 ((tmsNextEvent < tmsLastEvent) &&
9d004ae4:	5460ffbb 	bnezl	v1,9d0049d4 <_scheduleTask+0x74>
9d004ae8:	0044202b 	sltu	a0,v0,a0

	/* Compute when the next event time will be by adding the event
	** time delta to the current time.
	*/
	tmsNextEvent = tmsCur + dtmsNext;
}
9d004aec:	0b401263 	j	9d00498c <_scheduleTask+0x2c>
9d004af0:	8fbf0034 	lw	ra,52(sp)
		}

		/* Check if this task's period has timed out.
		*/
		tmsNxt = rgtaskTable[id].tmsNext;
		if ( ((tmsNxt >= tmsLastEvent) && 
9d004af4:	50c0ffd4 	beqzl	a2,9d004a48 <_scheduleTask+0xe8>
9d004af8:	96060002 	lhu	a2,2(s0)
						((tmsCur >= tmsNxt) || (tmsCur < tmsLastEvent))) ||
			 ((tmsNxt <  tmsLastEvent) && 
						((tmsCur >= tmsNxt) && (tmsCur < tmsLastEvent))) ) {
9d004afc:	0b40128f 	j	9d004a3c <_scheduleTask+0xdc>
9d004b00:	0045282b 	sltu	a1,v0,a1
				/* The task state counter has gone to 0. This task is now
				** disabled.
				*/
				if (rgtaskTable[id].stTask == 0) {
					rgtaskTable[id].tmsNext = 0;
					cntActiveTask -= 1;
9d004b04:	8f838054 	lw	v1,-32684(gp)

				/* The task state counter has gone to 0. This task is now
				** disabled.
				*/
				if (rgtaskTable[id].stTask == 0) {
					rgtaskTable[id].tmsNext = 0;
9d004b08:	ae00fff8 	sw	zero,-8(s0)
					cntActiveTask -= 1;
9d004b0c:	2463ffff 	addiu	v1,v1,-1
					continue;
9d004b10:	0b4012aa 	j	9d004aa8 <_scheduleTask+0x148>
9d004b14:	af838054 	sw	v1,-32684(gp)

9d004b18 <_board_init>:

void _board_init(void) {

	/*	Turn off Secondary oscillator so pins can be used as GPIO
	*/
	OSCCONCLR	=	_OSCCON_SOSCEN_MASK;
9d004b18:	24030002 	li	v1,2
9d004b1c:	3c02bf81 	lui	v0,0xbf81
9d004b20:	ac43f004 	sw	v1,-4092(v0)

}
9d004b24:	03e00008 	jr	ra
9d004b28:	00000000 	nop

9d004b2c <main>:
__attribute__((section(".comment"))) void (*__use_force_isr_install)(void) = &__use_isr_install;
}

//************************************************************************
int main(void)
{
9d004b2c:	27bdffe8 	addiu	sp,sp,-24
9d004b30:	afbf0014 	sw	ra,20(sp)
	init();
9d004b34:	0f40121d 	jal	9d004874 <init>
9d004b38:	00000000 	nop

	setup();
9d004b3c:	0f4004ca 	jal	9d001328 <setup>
9d004b40:	00000000 	nop

	while (1)
	{
		_scheduleTask();
9d004b44:	0f401258 	jal	9d004960 <_scheduleTask>
9d004b48:	00000000 	nop
		loop();
9d004b4c:	0f40057f 	jal	9d0015fc <loop>
9d004b50:	00000000 	nop
9d004b54:	0b4012d1 	j	9d004b44 <main+0x18>
9d004b58:	00000000 	nop

9d004b5c <_ZN5Print5writeEPKc>:

//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const char *str)
{
9d004b5c:	27bdffe0 	addiu	sp,sp,-32
9d004b60:	afb10018 	sw	s1,24(sp)
9d004b64:	afb00014 	sw	s0,20(sp)
9d004b68:	afbf001c 	sw	ra,28(sp)
9d004b6c:	00a08021 	move	s0,a1
	while (*str)
9d004b70:	80a50000 	lb	a1,0(a1)
9d004b74:	10a0000a 	beqz	a1,9d004ba0 <_ZN5Print5writeEPKc+0x44>
9d004b78:	00808821 	move	s1,a0
	{
		write(*str++);
9d004b7c:	8e220000 	lw	v0,0(s1)
9d004b80:	30a500ff 	andi	a1,a1,0xff
9d004b84:	26100001 	addiu	s0,s0,1
9d004b88:	8c420000 	lw	v0,0(v0)
9d004b8c:	0040f809 	jalr	v0
9d004b90:	02202021 	move	a0,s1
//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const char *str)
{
	while (*str)
9d004b94:	82050000 	lb	a1,0(s0)
9d004b98:	54a0fff9 	bnezl	a1,9d004b80 <_ZN5Print5writeEPKc+0x24>
9d004b9c:	8e220000 	lw	v0,0(s1)
	{
		write(*str++);
	}
}
9d004ba0:	8fbf001c 	lw	ra,28(sp)
9d004ba4:	8fb10018 	lw	s1,24(sp)
9d004ba8:	8fb00014 	lw	s0,20(sp)
9d004bac:	03e00008 	jr	ra
9d004bb0:	27bd0020 	addiu	sp,sp,32

9d004bb4 <_ZN5Print5writeEPKhm>:

//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const uint8_t *buffer, size_t size)
{
9d004bb4:	27bdffe0 	addiu	sp,sp,-32
9d004bb8:	afb20018 	sw	s2,24(sp)
9d004bbc:	afb10014 	sw	s1,20(sp)
9d004bc0:	afb00010 	sw	s0,16(sp)
9d004bc4:	afbf001c 	sw	ra,28(sp)
9d004bc8:	00c08021 	move	s0,a2
9d004bcc:	00809021 	move	s2,a0
	while (size--)
9d004bd0:	10c0000a 	beqz	a2,9d004bfc <_ZN5Print5writeEPKhm+0x48>
9d004bd4:	00a08821 	move	s1,a1
	{
		write(*buffer++);
9d004bd8:	8e420000 	lw	v0,0(s2)
9d004bdc:	92250000 	lbu	a1,0(s1)
9d004be0:	2610ffff 	addiu	s0,s0,-1
9d004be4:	8c420000 	lw	v0,0(v0)
9d004be8:	02402021 	move	a0,s2
9d004bec:	0040f809 	jalr	v0
9d004bf0:	26310001 	addiu	s1,s1,1
//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const uint8_t *buffer, size_t size)
{
	while (size--)
9d004bf4:	5600fff9 	bnezl	s0,9d004bdc <_ZN5Print5writeEPKhm+0x28>
9d004bf8:	8e420000 	lw	v0,0(s2)
	{
		write(*buffer++);
	}
}
9d004bfc:	8fbf001c 	lw	ra,28(sp)
9d004c00:	8fb20018 	lw	s2,24(sp)
9d004c04:	8fb10014 	lw	s1,20(sp)
9d004c08:	8fb00010 	lw	s0,16(sp)
9d004c0c:	03e00008 	jr	ra
9d004c10:	27bd0020 	addiu	sp,sp,32

9d004c14 <_ZN5Print5printEPKc>:
	}
}
//************************************************************************
void Print::print(const char str[])
{
	write(str);
9d004c14:	8c820000 	lw	v0,0(a0)
9d004c18:	8c590004 	lw	t9,4(v0)
9d004c1c:	03200008 	jr	t9
9d004c20:	00000000 	nop

9d004c24 <_ZN5Print11printNumberEmh>:

// Private Methods /////////////////////////////////////////////////////////////

//************************************************************************
void Print::printNumber(unsigned long n, uint8_t base)
{
9d004c24:	27bdffc0 	addiu	sp,sp,-64
9d004c28:	afb10038 	sw	s1,56(sp)
9d004c2c:	afb00034 	sw	s0,52(sp)
9d004c30:	afbf003c 	sw	ra,60(sp)
9d004c34:	00808021 	move	s0,a0
9d004c38:	30c600ff 	andi	a2,a2,0xff
unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars.
unsigned long i = 0;

	if (n == 0)
9d004c3c:	10a00020 	beqz	a1,9d004cc0 <_ZN5Print11printNumberEmh+0x9c>
9d004c40:	00008821 	move	s1,zero
		return;
	}

	while (n > 0)
	{
		buf[i++] = n % base;
9d004c44:	00a6001b 	divu	zero,a1,a2
9d004c48:	00c001f4 	teq	a2,zero,0x7
}

// Private Methods /////////////////////////////////////////////////////////////

//************************************************************************
void Print::printNumber(unsigned long n, uint8_t base)
9d004c4c:	27a40010 	addiu	a0,sp,16
9d004c50:	00911021 	addu	v0,a0,s1
		return;
	}

	while (n > 0)
	{
		buf[i++] = n % base;
9d004c54:	26310001 	addiu	s1,s1,1
9d004c58:	00001810 	mfhi	v1
9d004c5c:	00002812 	mflo	a1
	{
		print('0');
		return;
	}

	while (n > 0)
9d004c60:	14a0fff8 	bnez	a1,9d004c44 <_ZN5Print11printNumberEmh+0x20>
9d004c64:	a0430000 	sb	v1,0(v0)
	{
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
9d004c68:	12200011 	beqz	s1,9d004cb0 <_ZN5Print11printNumberEmh+0x8c>
9d004c6c:	8fbf003c 	lw	ra,60(sp)
}

// Private Methods /////////////////////////////////////////////////////////////

//************************************************************************
void Print::printNumber(unsigned long n, uint8_t base)
9d004c70:	27a30010 	addiu	v1,sp,16
9d004c74:	00711021 	addu	v0,v1,s1
		n /= base;
	}

	for (; i > 0; i--)
	{
		print((char) (buf[i - 1] < 10 ?
9d004c78:	9042ffff 	lbu	v0,-1(v0)
					'0' + buf[i - 1] :
					'A' + buf[i - 1] - 10));
9d004c7c:	24450030 	addiu	a1,v0,48
9d004c80:	2c43000a 	sltiu	v1,v0,10
9d004c84:	7c052c20 	seb	a1,a1
9d004c88:	14600002 	bnez	v1,9d004c94 <_ZN5Print11printNumberEmh+0x70>
9d004c8c:	24420037 	addiu	v0,v0,55
9d004c90:	7c022c20 	seb	a1,v0
	{
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
9d004c94:	2631ffff 	addiu	s1,s1,-1
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d004c98:	02002021 	move	a0,s0
9d004c9c:	0f40133e 	jal	9d004cf8 <_ZN5Print5printEli>
9d004ca0:	00003021 	move	a2,zero
	{
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
9d004ca4:	1620fff3 	bnez	s1,9d004c74 <_ZN5Print11printNumberEmh+0x50>
9d004ca8:	27a30010 	addiu	v1,sp,16
	{
		print((char) (buf[i - 1] < 10 ?
					'0' + buf[i - 1] :
					'A' + buf[i - 1] - 10));
	}
}
9d004cac:	8fbf003c 	lw	ra,60(sp)
9d004cb0:	8fb10038 	lw	s1,56(sp)
9d004cb4:	8fb00034 	lw	s0,52(sp)
9d004cb8:	03e00008 	jr	ra
9d004cbc:	27bd0040 	addiu	sp,sp,64
9d004cc0:	8fbf003c 	lw	ra,60(sp)
9d004cc4:	8fb10038 	lw	s1,56(sp)
9d004cc8:	8fb00034 	lw	s0,52(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d004ccc:	24050030 	li	a1,48
9d004cd0:	00003021 	move	a2,zero
9d004cd4:	0b40133e 	j	9d004cf8 <_ZN5Print5printEli>
9d004cd8:	27bd0040 	addiu	sp,sp,64

9d004cdc <_ZN5Print5printEmi>:
}

//************************************************************************
void Print::print(unsigned long n, int base)
{
	if (base == 0)
9d004cdc:	50c00003 	beqzl	a2,9d004cec <_ZN5Print5printEmi+0x10>
9d004ce0:	8c830000 	lw	v1,0(a0)
	{
		write(n);
	}
	else
	{
		printNumber(n, base);
9d004ce4:	0b401309 	j	9d004c24 <_ZN5Print11printNumberEmh>
9d004ce8:	30c600ff 	andi	a2,a2,0xff
//************************************************************************
void Print::print(unsigned long n, int base)
{
	if (base == 0)
	{
		write(n);
9d004cec:	8c790000 	lw	t9,0(v1)
9d004cf0:	03200008 	jr	t9
9d004cf4:	30a500ff 	andi	a1,a1,0xff

9d004cf8 <_ZN5Print5printEli>:
	print((unsigned long) n, base);
}

//************************************************************************
void Print::print(long n, int base)
{
9d004cf8:	27bdffe0 	addiu	sp,sp,-32
9d004cfc:	afb10018 	sw	s1,24(sp)
9d004d00:	afb00014 	sw	s0,20(sp)
9d004d04:	afbf001c 	sw	ra,28(sp)
9d004d08:	00808821 	move	s1,a0
	if (base == 0)
9d004d0c:	10c00013 	beqz	a2,9d004d5c <_ZN5Print5printEli+0x64>
9d004d10:	00a08021 	move	s0,a1
	{
		write(n);
	}
	else if (base == 10)
9d004d14:	2402000a 	li	v0,10
9d004d18:	10c20006 	beq	a2,v0,9d004d34 <_ZN5Print5printEli+0x3c>
9d004d1c:	8fbf001c 	lw	ra,28(sp)
	}
	else
	{
		printNumber(n, base);
	}
}
9d004d20:	8fb10018 	lw	s1,24(sp)
9d004d24:	8fb00014 	lw	s0,20(sp)
		}
		printNumber(n, 10);
	}
	else
	{
		printNumber(n, base);
9d004d28:	30c600ff 	andi	a2,a2,0xff
9d004d2c:	0b401309 	j	9d004c24 <_ZN5Print11printNumberEmh>
9d004d30:	27bd0020 	addiu	sp,sp,32
	{
		write(n);
	}
	else if (base == 10)
	{
		if (n < 0)
9d004d34:	04a00011 	bltz	a1,9d004d7c <_ZN5Print5printEli+0x84>
9d004d38:	2405002d 	li	a1,45
		{
			print('-');
			n = -n;
		}
		printNumber(n, 10);
9d004d3c:	02202021 	move	a0,s1
9d004d40:	02002821 	move	a1,s0
	}
	else
	{
		printNumber(n, base);
	}
}
9d004d44:	8fbf001c 	lw	ra,28(sp)
9d004d48:	8fb10018 	lw	s1,24(sp)
9d004d4c:	8fb00014 	lw	s0,20(sp)
		if (n < 0)
		{
			print('-');
			n = -n;
		}
		printNumber(n, 10);
9d004d50:	2406000a 	li	a2,10
	}
	else
	{
		printNumber(n, base);
9d004d54:	0b401309 	j	9d004c24 <_ZN5Print11printNumberEmh>
9d004d58:	27bd0020 	addiu	sp,sp,32
//************************************************************************
void Print::print(long n, int base)
{
	if (base == 0)
	{
		write(n);
9d004d5c:	8c820000 	lw	v0,0(a0)
	}
	else
	{
		printNumber(n, base);
	}
}
9d004d60:	8fbf001c 	lw	ra,28(sp)
9d004d64:	8fb10018 	lw	s1,24(sp)
//************************************************************************
void Print::print(long n, int base)
{
	if (base == 0)
	{
		write(n);
9d004d68:	8c590000 	lw	t9,0(v0)
	}
	else
	{
		printNumber(n, base);
	}
}
9d004d6c:	8fb00014 	lw	s0,20(sp)
//************************************************************************
void Print::print(long n, int base)
{
	if (base == 0)
	{
		write(n);
9d004d70:	30a500ff 	andi	a1,a1,0xff
9d004d74:	03200008 	jr	t9
9d004d78:	27bd0020 	addiu	sp,sp,32
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d004d7c:	0f40133e 	jal	9d004cf8 <_ZN5Print5printEli>
9d004d80:	00003021 	move	a2,zero
	else if (base == 10)
	{
		if (n < 0)
		{
			print('-');
			n = -n;
9d004d84:	0b40134f 	j	9d004d3c <_ZN5Print5printEli+0x44>
9d004d88:	00108023 	negu	s0,s0

9d004d8c <_ZN5Print5printEii>:
}

//************************************************************************
void Print::print(int n, int base)
{
	print((long) n, base);
9d004d8c:	0b40133e 	j	9d004cf8 <_ZN5Print5printEli>
9d004d90:	00000000 	nop

9d004d94 <_ZN5Print5printEci>:
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d004d94:	0b40133e 	j	9d004cf8 <_ZN5Print5printEli>
9d004d98:	7c052c20 	seb	a1,a1

9d004d9c <_ZN5Print7printlnEv>:
	printFloat(n, digits);
}

//************************************************************************
void Print::println(void)
{
9d004d9c:	27bdffe8 	addiu	sp,sp,-24
9d004da0:	afb00010 	sw	s0,16(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d004da4:	2405000d 	li	a1,13
	printFloat(n, digits);
}

//************************************************************************
void Print::println(void)
{
9d004da8:	00808021 	move	s0,a0
9d004dac:	afbf0014 	sw	ra,20(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d004db0:	0f40133e 	jal	9d004cf8 <_ZN5Print5printEli>
9d004db4:	00003021 	move	a2,zero
9d004db8:	02002021 	move	a0,s0
//************************************************************************
void Print::println(void)
{
	print('\r');
	print('\n');
}
9d004dbc:	8fbf0014 	lw	ra,20(sp)
9d004dc0:	8fb00010 	lw	s0,16(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d004dc4:	2405000a 	li	a1,10
9d004dc8:	00003021 	move	a2,zero
9d004dcc:	0b40133e 	j	9d004cf8 <_ZN5Print5printEli>
9d004dd0:	27bd0018 	addiu	sp,sp,24

9d004dd4 <_ZN5Print7printlnEhi>:
	println();
}

//************************************************************************
void Print::println(unsigned char b, int base)
{
9d004dd4:	27bdffe8 	addiu	sp,sp,-24
9d004dd8:	afb00010 	sw	s0,16(sp)
}

//************************************************************************
void Print::print(unsigned char b, int base)
{
	print((unsigned long) b, base);
9d004ddc:	30a500ff 	andi	a1,a1,0xff
	println();
}

//************************************************************************
void Print::println(unsigned char b, int base)
{
9d004de0:	afbf0014 	sw	ra,20(sp)
}

//************************************************************************
void Print::print(unsigned char b, int base)
{
	print((unsigned long) b, base);
9d004de4:	0f401337 	jal	9d004cdc <_ZN5Print5printEmi>
9d004de8:	00808021 	move	s0,a0

//************************************************************************
void Print::println(unsigned char b, int base)
{
	print(b, base);
	println();
9d004dec:	02002021 	move	a0,s0
}
9d004df0:	8fbf0014 	lw	ra,20(sp)
9d004df4:	8fb00010 	lw	s0,16(sp)

//************************************************************************
void Print::println(unsigned char b, int base)
{
	print(b, base);
	println();
9d004df8:	0b401367 	j	9d004d9c <_ZN5Print7printlnEv>
9d004dfc:	27bd0018 	addiu	sp,sp,24

9d004e00 <_ZN5Print7printlnEPKc>:
	}
}
//************************************************************************
void Print::print(const char str[])
{
	write(str);
9d004e00:	8c820000 	lw	v0,0(a0)
	print(argString);
	println();
}
//************************************************************************
void Print::println(const char c[])
{
9d004e04:	27bdffe8 	addiu	sp,sp,-24
9d004e08:	afbf0014 	sw	ra,20(sp)
	}
}
//************************************************************************
void Print::print(const char str[])
{
	write(str);
9d004e0c:	8c420004 	lw	v0,4(v0)
	print(argString);
	println();
}
//************************************************************************
void Print::println(const char c[])
{
9d004e10:	afb00010 	sw	s0,16(sp)
	}
}
//************************************************************************
void Print::print(const char str[])
{
	write(str);
9d004e14:	0040f809 	jalr	v0
9d004e18:	00808021 	move	s0,a0
}
//************************************************************************
void Print::println(const char c[])
{
	print(c);
	println();
9d004e1c:	02002021 	move	a0,s0
}
9d004e20:	8fbf0014 	lw	ra,20(sp)
9d004e24:	8fb00010 	lw	s0,16(sp)
}
//************************************************************************
void Print::println(const char c[])
{
	print(c);
	println();
9d004e28:	0b401367 	j	9d004d9c <_ZN5Print7printlnEv>
9d004e2c:	27bd0018 	addiu	sp,sp,24

9d004e30 <_ZN5Print7printlnEli>:
	println();
}

//************************************************************************
void Print::println(long n, int base)
{
9d004e30:	27bdffe8 	addiu	sp,sp,-24
9d004e34:	afb00010 	sw	s0,16(sp)
9d004e38:	afbf0014 	sw	ra,20(sp)
	print(n, base);
9d004e3c:	0f40133e 	jal	9d004cf8 <_ZN5Print5printEli>
9d004e40:	00808021 	move	s0,a0
	println();
9d004e44:	02002021 	move	a0,s0
}
9d004e48:	8fbf0014 	lw	ra,20(sp)
9d004e4c:	8fb00010 	lw	s0,16(sp)

//************************************************************************
void Print::println(long n, int base)
{
	print(n, base);
	println();
9d004e50:	0b401367 	j	9d004d9c <_ZN5Print7printlnEv>
9d004e54:	27bd0018 	addiu	sp,sp,24

9d004e58 <_ZN14HardwareSerial9availableEv>:
**		receive buffer.
*/

int HardwareSerial::available(void)
{
	return (RX_BUFFER_SIZE + rx_buffer.head - rx_buffer.tail) % RX_BUFFER_SIZE;
9d004e58:	8c820224 	lw	v0,548(a0)
9d004e5c:	8c830228 	lw	v1,552(a0)
9d004e60:	24420200 	addiu	v0,v0,512
9d004e64:	00431023 	subu	v0,v0,v1
9d004e68:	00021fc3 	sra	v1,v0,0x1f
9d004e6c:	00031dc2 	srl	v1,v1,0x17
9d004e70:	00431021 	addu	v0,v0,v1
9d004e74:	304201ff 	andi	v0,v0,0x1ff
}
9d004e78:	03e00008 	jr	ra
9d004e7c:	00431023 	subu	v0,v0,v1

9d004e80 <_ZN14HardwareSerial4peekEv>:
**		removing it from the buffer, or -1 if no characters are in the buffer.
*/

int HardwareSerial::peek()
{
	if (rx_buffer.head == rx_buffer.tail)
9d004e80:	8c830228 	lw	v1,552(a0)
9d004e84:	8c850224 	lw	a1,548(a0)
9d004e88:	10a30003 	beq	a1,v1,9d004e98 <_ZN14HardwareSerial4peekEv+0x18>
9d004e8c:	2402ffff 	li	v0,-1
	{
		return -1;
	}
	else
	{
		return rx_buffer.buffer[rx_buffer.tail];
9d004e90:	00832021 	addu	a0,a0,v1
9d004e94:	90820024 	lbu	v0,36(a0)
	}
}
9d004e98:	03e00008 	jr	ra
9d004e9c:	00000000 	nop

9d004ea0 <_ZN14HardwareSerial4readEv>:
int HardwareSerial::read(void)
{
	unsigned char theChar;

	// if the head isn't ahead of the tail, we don't have any characters
	if (rx_buffer.head == rx_buffer.tail)
9d004ea0:	8c830228 	lw	v1,552(a0)
9d004ea4:	8c850224 	lw	a1,548(a0)
9d004ea8:	10a3000a 	beq	a1,v1,9d004ed4 <_ZN14HardwareSerial4readEv+0x34>
9d004eac:	2402ffff 	li	v0,-1
		return -1;
	}
	else
	{
		theChar			= rx_buffer.buffer[rx_buffer.tail];
		rx_buffer.tail	= (rx_buffer.tail + 1) % RX_BUFFER_SIZE;
9d004eb0:	24660001 	addiu	a2,v1,1
9d004eb4:	00062fc3 	sra	a1,a2,0x1f
9d004eb8:	00052dc2 	srl	a1,a1,0x17
9d004ebc:	00c53021 	addu	a2,a2,a1
	{
		return -1;
	}
	else
	{
		theChar			= rx_buffer.buffer[rx_buffer.tail];
9d004ec0:	00831821 	addu	v1,a0,v1
		rx_buffer.tail	= (rx_buffer.tail + 1) % RX_BUFFER_SIZE;
9d004ec4:	30c601ff 	andi	a2,a2,0x1ff
	{
		return -1;
	}
	else
	{
		theChar			= rx_buffer.buffer[rx_buffer.tail];
9d004ec8:	90620024 	lbu	v0,36(v1)
		rx_buffer.tail	= (rx_buffer.tail + 1) % RX_BUFFER_SIZE;
9d004ecc:	00c52823 	subu	a1,a2,a1
9d004ed0:	ac850228 	sw	a1,552(a0)
		return (theChar);
	}
}
9d004ed4:	03e00008 	jr	ra
9d004ed8:	00000000 	nop

9d004edc <_ZN14HardwareSerial5flushEv>:
**	Description:
**		Empty the send buffer by waiting for the
**		fifo to empty and the transmitter to become idle
*/
void HardwareSerial::flush()
{
9d004edc:	8c830004 	lw	v1,4(a0)
	while ((uart->uxSta.reg & (1 << _UARTSTA_TMRT)) == 0)	//check the TRMT bit
9d004ee0:	8c620010 	lw	v0,16(v1)
9d004ee4:	30420100 	andi	v0,v0,0x100
9d004ee8:	1040fffd 	beqz	v0,9d004ee0 <_ZN14HardwareSerial5flushEv+0x4>
9d004eec:	00000000 	nop
	{
		//* wait for the transmitter to be clear
	}
}
9d004ef0:	03e00008 	jr	ra
9d004ef4:	00000000 	nop

9d004ef8 <_ZN14HardwareSerial5purgeEv>:
	// don't reverse this or there may be problems if the RX interrupt
	// occurs after reading the value of rx_buffer_head but before writing
	// the value to rx_buffer_tail; the previous value of rx_buffer_head
	// may be written to rx_buffer_tail, making it appear as if the buffer
	// were full, not empty.
	rx_buffer.head = rx_buffer.tail;
9d004ef8:	8c820228 	lw	v0,552(a0)
}
9d004efc:	03e00008 	jr	ra
9d004f00:	ac820224 	sw	v0,548(a0)

9d004f04 <_ZN14HardwareSerial5writeEh>:
**		Wait until the transmitter is idle, and then transmit the
**		specified character.
*/

void HardwareSerial::write(uint8_t theChar)
{
9d004f04:	8c820004 	lw	v0,4(a0)
9d004f08:	30a500ff 	andi	a1,a1,0xff

	while ((uart->uxSta.reg & (1 << _UARTSTA_UTXBF)) != 0)	//check the UTXBF bit
9d004f0c:	8c430010 	lw	v1,16(v0)
9d004f10:	30630200 	andi	v1,v1,0x200
9d004f14:	1460fffd 	bnez	v1,9d004f0c <_ZN14HardwareSerial5writeEh+0x8>
9d004f18:	00000000 	nop
  {
		//* wait for the transmitter buffer to have room
	}

	uart->uxTx.reg = theChar;
9d004f1c:	ac450020 	sw	a1,32(v0)
}
9d004f20:	03e00008 	jr	ra
9d004f24:	00000000 	nop

9d004f28 <_Z15USBresetRoutinev>:

//****************************************************************
void	USBresetRoutine(void)
{
	
}
9d004f28:	03e00008 	jr	ra
9d004f2c:	00000000 	nop

9d004f30 <_Z19USBstoreDataRoutinePKhi>:
boolean	USBstoreDataRoutine(const byte *buffer, int length)
{
    int	i;

    // Put each byte into the serial recieve buffer
    for (i=0; i<length; i++)
9d004f30:	18a00020 	blez	a1,9d004fb4 <_Z19USBstoreDataRoutinePKhi+0x84>
9d004f34:	3c02a000 	lui	v0,0xa000
9d004f38:	3c0aa000 	lui	t2,0xa000
9d004f3c:	254a0d24 	addiu	t2,t2,3364
9d004f40:	8d4b0204 	lw	t3,516(t2)
9d004f44:	8d480200 	lw	t0,512(t2)
9d004f48:	00001021 	move	v0,zero
inline boolean store_char(unsigned char theChar, ring_buffer *rx_buffer)
{
int	bufIndex;

    // Compute the place where we want to store this byte - one beyond the head
	bufIndex	= (rx_buffer->head + 1) % RX_BUFFER_SIZE;
9d004f4c:	25070001 	addiu	a3,t0,1
9d004f50:	000737c3 	sra	a2,a3,0x1f
9d004f54:	000635c2 	srl	a2,a2,0x17
9d004f58:	00e61821 	addu	v1,a3,a2
9d004f5c:	306301ff 	andi	v1,v1,0x1ff
	
}

//****************************************************************
// Need to return FALSE if we need USB to hold off for awhile
boolean	USBstoreDataRoutine(const byte *buffer, int length)
9d004f60:	00824821 	addu	t1,a0,v0
inline boolean store_char(unsigned char theChar, ring_buffer *rx_buffer)
{
int	bufIndex;

    // Compute the place where we want to store this byte - one beyond the head
	bufIndex	= (rx_buffer->head + 1) % RX_BUFFER_SIZE;
9d004f64:	00661823 	subu	v1,v1,a2
boolean	USBstoreDataRoutine(const byte *buffer, int length)
{
    int	i;

    // Put each byte into the serial recieve buffer
    for (i=0; i<length; i++)
9d004f68:	24420001 	addiu	v0,v0,1
    // we would overflow the buffer if we put our character there. This is because
    // if head = tail, the buffer is empty. If head = tail-1, then the buffer
    // is full. So only write into the buffer if we are not writing at the tail.
	if (bufIndex != rx_buffer->tail)
	{
		rx_buffer->buffer[rx_buffer->head]	=	theChar;
9d004f6c:	01483021 	addu	a2,t2,t0

    // If the place where we are about to store the character is the tail, then
    // we would overflow the buffer if we put our character there. This is because
    // if head = tail, the buffer is empty. If head = tail-1, then the buffer
    // is full. So only write into the buffer if we are not writing at the tail.
	if (bufIndex != rx_buffer->tail)
9d004f70:	106b0004 	beq	v1,t3,9d004f84 <_Z19USBstoreDataRoutinePKhi+0x54>
9d004f74:	91270000 	lbu	a3,0(t1)
	{
		rx_buffer->buffer[rx_buffer->head]	=	theChar;
		rx_buffer->head	=	bufIndex;
9d004f78:	ad430200 	sw	v1,512(t2)
    // we would overflow the buffer if we put our character there. This is because
    // if head = tail, the buffer is empty. If head = tail-1, then the buffer
    // is full. So only write into the buffer if we are not writing at the tail.
	if (bufIndex != rx_buffer->tail)
	{
		rx_buffer->buffer[rx_buffer->head]	=	theChar;
9d004f7c:	a0c70000 	sb	a3,0(a2)
		rx_buffer->head	=	bufIndex;
9d004f80:	00604021 	move	t0,v1
boolean	USBstoreDataRoutine(const byte *buffer, int length)
{
    int	i;

    // Put each byte into the serial recieve buffer
    for (i=0; i<length; i++)
9d004f84:	1445fff2 	bne	v0,a1,9d004f50 <_Z19USBstoreDataRoutinePKhi+0x20>
9d004f88:	25070001 	addiu	a3,t0,1
	{
        store_char(buffer[i], &rx_bufferUSB);
	}
    // If there isn't going to be enough space for a whole nother buffer, then return
    // false so USB will NAK and we won't get any more data.
    if (USBSerialBufferFree() < USB_SERIAL_MIN_BUFFER_FREE)
9d004f8c:	256b01ff 	addiu	t3,t3,511
9d004f90:	01684023 	subu	t0,t3,t0
9d004f94:	000817c3 	sra	v0,t0,0x1f
9d004f98:	000215c2 	srl	v0,v0,0x17
9d004f9c:	01024021 	addu	t0,t0,v0
9d004fa0:	310801ff 	andi	t0,t0,0x1ff
9d004fa4:	01021023 	subu	v0,t0,v0
    {
        return(false);
9d004fa8:	28420080 	slti	v0,v0,128
    }
    else
    {
        return(true);
    }
}
9d004fac:	03e00008 	jr	ra
9d004fb0:	38420001 	xori	v0,v0,0x1
boolean	USBstoreDataRoutine(const byte *buffer, int length)
{
    int	i;

    // Put each byte into the serial recieve buffer
    for (i=0; i<length; i++)
9d004fb4:	24420d24 	addiu	v0,v0,3364
9d004fb8:	8c4b0204 	lw	t3,516(v0)
9d004fbc:	0b4013e3 	j	9d004f8c <_Z19USBstoreDataRoutinePKhi+0x5c>
9d004fc0:	8c480200 	lw	t0,512(v0)

9d004fc4 <_ZN9USBSerial9availableEv>:
}

//*******************************************************************************************
int USBSerial::available(void)
{
	return (RX_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) % RX_BUFFER_SIZE;
9d004fc4:	8c830004 	lw	v1,4(a0)
9d004fc8:	8c620200 	lw	v0,512(v1)
9d004fcc:	8c630204 	lw	v1,516(v1)
9d004fd0:	24420200 	addiu	v0,v0,512
9d004fd4:	00431023 	subu	v0,v0,v1
9d004fd8:	00021fc3 	sra	v1,v0,0x1f
9d004fdc:	00031dc2 	srl	v1,v1,0x17
9d004fe0:	00431021 	addu	v0,v0,v1
9d004fe4:	304201ff 	andi	v0,v0,0x1ff
}
9d004fe8:	03e00008 	jr	ra
9d004fec:	00431023 	subu	v0,v0,v1

9d004ff0 <_ZN9USBSerial4peekEv>:

//*******************************************************************************************
int USBSerial::peek()
{
	if (_rx_buffer->head == _rx_buffer->tail)
9d004ff0:	8c830004 	lw	v1,4(a0)
9d004ff4:	8c640204 	lw	a0,516(v1)
9d004ff8:	8c650200 	lw	a1,512(v1)
9d004ffc:	10a40003 	beq	a1,a0,9d00500c <_ZN9USBSerial4peekEv+0x1c>
9d005000:	2402ffff 	li	v0,-1
	{
		return -1;
	}
	else
	{
		return _rx_buffer->buffer[_rx_buffer->tail];
9d005004:	00641821 	addu	v1,v1,a0
9d005008:	90620000 	lbu	v0,0(v1)
	}
}
9d00500c:	03e00008 	jr	ra
9d005010:	00000000 	nop

9d005014 <_ZN9USBSerial5flushEv>:
	// don't reverse this or there may be problems if the RX interrupt
	// occurs after reading the value of rx_buffer_head but before writing
	// the value to rx_buffer_tail; the previous value of rx_buffer_head
	// may be written to rx_buffer_tail, making it appear as if the buffer
	// were full, not empty.
	_rx_buffer->head	=	_rx_buffer->tail;
9d005014:	8c820004 	lw	v0,4(a0)
9d005018:	8c430204 	lw	v1,516(v0)
}
9d00501c:	03e00008 	jr	ra
9d005020:	ac430200 	sw	v1,512(v0)

9d005024 <_ZN9USBSerial5writeEPKc>:
	}
}

//*******************************************************************************************
void USBSerial::write(const char *str)
{
9d005024:	27bdffe0 	addiu	sp,sp,-32
9d005028:	afb00018 	sw	s0,24(sp)
9d00502c:	00808021 	move	s0,a0
size_t size;

	size	=	strlen(str);
9d005030:	00a02021 	move	a0,a1
	}
}

//*******************************************************************************************
void USBSerial::write(const char *str)
{
9d005034:	afbf001c 	sw	ra,28(sp)
size_t size;

	size	=	strlen(str);
9d005038:	0f401c2e 	jal	9d0070b8 <strlen>
9d00503c:	afa50010 	sw	a1,16(sp)
	write((const uint8_t *)str, size);
9d005040:	8e030000 	lw	v1,0(s0)
9d005044:	8fa50010 	lw	a1,16(sp)
9d005048:	02002021 	move	a0,s0
9d00504c:	8c790008 	lw	t9,8(v1)
}
9d005050:	8fbf001c 	lw	ra,28(sp)
9d005054:	8fb00018 	lw	s0,24(sp)
void USBSerial::write(const char *str)
{
size_t size;

	size	=	strlen(str);
	write((const uint8_t *)str, size);
9d005058:	00403021 	move	a2,v0
9d00505c:	03200008 	jr	t9
9d005060:	27bd0020 	addiu	sp,sp,32

9d005064 <_ZN9USBSerial5writeEPKhm>:
//*	testing showed 63 gave better speed results than 64

#define	kMaxUSBxmitPkt	63
//*******************************************************************************************
void USBSerial::write(const uint8_t *buffer, size_t size)
{
9d005064:	27bdff98 	addiu	sp,sp,-104

	if (size < kMaxUSBxmitPkt)
9d005068:	2cc2003f 	sltiu	v0,a2,63
//*	testing showed 63 gave better speed results than 64

#define	kMaxUSBxmitPkt	63
//*******************************************************************************************
void USBSerial::write(const uint8_t *buffer, size_t size)
{
9d00506c:	afb20060 	sw	s2,96(sp)
9d005070:	afb1005c 	sw	s1,92(sp)
9d005074:	afbf0064 	sw	ra,100(sp)
9d005078:	afb00058 	sw	s0,88(sp)
9d00507c:	00c08821 	move	s1,a2

	if (size < kMaxUSBxmitPkt)
9d005080:	1440002a 	bnez	v0,9d00512c <_ZN9USBSerial5writeEPKhm+0xc8>
9d005084:	00a09021 	move	s2,a1
	size_t 			packetSize;
	
		packetSize	=	0;
		for (ii=0; ii<size; ii++)
		{
			usbBuffer[packetSize++]	=	buffer[ii];
9d005088:	90a20000 	lbu	v0,0(a1)
9d00508c:	00008021 	move	s0,zero
9d005090:	24050001 	li	a1,1
9d005094:	a3a20010 	sb	v0,16(sp)
	unsigned char	usbBuffer[kMaxUSBxmitPkt + 2];
	unsigned short	ii;
	size_t 			packetSize;
	
		packetSize	=	0;
		for (ii=0; ii<size; ii++)
9d005098:	26100001 	addiu	s0,s0,1
9d00509c:	3210ffff 	andi	s0,s0,0xffff
		{
			usbBuffer[packetSize++]	=	buffer[ii];
9d0050a0:	27a20010 	addiu	v0,sp,16
9d0050a4:	00451821 	addu	v1,v0,a1
	unsigned char	usbBuffer[kMaxUSBxmitPkt + 2];
	unsigned short	ii;
	size_t 			packetSize;
	
		packetSize	=	0;
		for (ii=0; ii<size; ii++)
9d0050a8:	0211102b 	sltu	v0,s0,s1
9d0050ac:	10400010 	beqz	v0,9d0050f0 <_ZN9USBSerial5writeEPKhm+0x8c>
9d0050b0:	02502021 	addu	a0,s2,s0
		{
			usbBuffer[packetSize++]	=	buffer[ii];
9d0050b4:	90840000 	lbu	a0,0(a0)
9d0050b8:	24a50001 	addiu	a1,a1,1
			if (packetSize >= kMaxUSBxmitPkt)
9d0050bc:	2ca2003f 	sltiu	v0,a1,63
9d0050c0:	1440fff5 	bnez	v0,9d005098 <_ZN9USBSerial5writeEPKhm+0x34>
9d0050c4:	a0640000 	sb	a0,0(v1)
			{
				cdcacm_print(usbBuffer, packetSize);
9d0050c8:	27a40010 	addiu	a0,sp,16
9d0050cc:	0f401972 	jal	9d0065c8 <cdcacm_print>
9d0050d0:	26100001 	addiu	s0,s0,1
	unsigned char	usbBuffer[kMaxUSBxmitPkt + 2];
	unsigned short	ii;
	size_t 			packetSize;
	
		packetSize	=	0;
		for (ii=0; ii<size; ii++)
9d0050d4:	3210ffff 	andi	s0,s0,0xffff
		{
			usbBuffer[packetSize++]	=	buffer[ii];
9d0050d8:	27a20010 	addiu	v0,sp,16
			if (packetSize >= kMaxUSBxmitPkt)
			{
				cdcacm_print(usbBuffer, packetSize);
				packetSize	=	0;
9d0050dc:	00002821 	move	a1,zero
	size_t 			packetSize;
	
		packetSize	=	0;
		for (ii=0; ii<size; ii++)
		{
			usbBuffer[packetSize++]	=	buffer[ii];
9d0050e0:	00451821 	addu	v1,v0,a1
	unsigned char	usbBuffer[kMaxUSBxmitPkt + 2];
	unsigned short	ii;
	size_t 			packetSize;
	
		packetSize	=	0;
		for (ii=0; ii<size; ii++)
9d0050e4:	0211102b 	sltu	v0,s0,s1
9d0050e8:	1440fff2 	bnez	v0,9d0050b4 <_ZN9USBSerial5writeEPKhm+0x50>
9d0050ec:	02502021 	addu	a0,s2,s0
			{
				cdcacm_print(usbBuffer, packetSize);
				packetSize	=	0;
			}
		}
		if (packetSize > 0)
9d0050f0:	14a00006 	bnez	a1,9d00510c <_ZN9USBSerial5writeEPKhm+0xa8>
9d0050f4:	8fbf0064 	lw	ra,100(sp)
		{
			cdcacm_print(usbBuffer, packetSize);
		}
	}
}
9d0050f8:	8fb20060 	lw	s2,96(sp)
9d0050fc:	8fb1005c 	lw	s1,92(sp)
9d005100:	8fb00058 	lw	s0,88(sp)
9d005104:	03e00008 	jr	ra
9d005108:	27bd0068 	addiu	sp,sp,104
				packetSize	=	0;
			}
		}
		if (packetSize > 0)
		{
			cdcacm_print(usbBuffer, packetSize);
9d00510c:	0f401972 	jal	9d0065c8 <cdcacm_print>
9d005110:	27a40010 	addiu	a0,sp,16
		}
	}
}
9d005114:	8fbf0064 	lw	ra,100(sp)
9d005118:	8fb20060 	lw	s2,96(sp)
9d00511c:	8fb1005c 	lw	s1,92(sp)
9d005120:	8fb00058 	lw	s0,88(sp)
9d005124:	03e00008 	jr	ra
9d005128:	27bd0068 	addiu	sp,sp,104
{

	if (size < kMaxUSBxmitPkt)
	{
		//*	it will fit in one transmit packet
		cdcacm_print(buffer, size);
9d00512c:	00a02021 	move	a0,a1
9d005130:	0f401972 	jal	9d0065c8 <cdcacm_print>
9d005134:	00c02821 	move	a1,a2
		if (packetSize > 0)
		{
			cdcacm_print(usbBuffer, packetSize);
		}
	}
}
9d005138:	8fbf0064 	lw	ra,100(sp)
9d00513c:	8fb20060 	lw	s2,96(sp)
9d005140:	8fb1005c 	lw	s1,92(sp)
9d005144:	8fb00058 	lw	s0,88(sp)
9d005148:	03e00008 	jr	ra
9d00514c:	27bd0068 	addiu	sp,sp,104

9d005150 <_ZN9USBSerial5writeEh>:
	_rx_buffer->head	=	_rx_buffer->tail;
}

//*******************************************************************************************
void USBSerial::write(uint8_t theChar)
{
9d005150:	27bdffe0 	addiu	sp,sp,-32
unsigned char	usbBuf[4];

	usbBuf[0]	=	theChar;
9d005154:	a3a50010 	sb	a1,16(sp)
	
	cdcacm_print(usbBuf, 1);
9d005158:	27a40010 	addiu	a0,sp,16
	_rx_buffer->head	=	_rx_buffer->tail;
}

//*******************************************************************************************
void USBSerial::write(uint8_t theChar)
{
9d00515c:	afbf001c 	sw	ra,28(sp)
unsigned char	usbBuf[4];

	usbBuf[0]	=	theChar;
	
	cdcacm_print(usbBuf, 1);
9d005160:	0f401972 	jal	9d0065c8 <cdcacm_print>
9d005164:	24050001 	li	a1,1
}
9d005168:	8fbf001c 	lw	ra,28(sp)
9d00516c:	03e00008 	jr	ra
9d005170:	27bd0020 	addiu	sp,sp,32

9d005174 <_ZN9USBSerial4readEv>:
int USBSerial::read(void)
{
	unsigned char theChar;

	// If the head = tail, then the buffer is empty, so nothing to read
	if (_rx_buffer->head == _rx_buffer->tail)
9d005174:	8c830004 	lw	v1,4(a0)
	}
}

//*******************************************************************************************
int USBSerial::read(void)
{
9d005178:	27bdffe0 	addiu	sp,sp,-32
9d00517c:	afbf001c 	sw	ra,28(sp)
	unsigned char theChar;

	// If the head = tail, then the buffer is empty, so nothing to read
	if (_rx_buffer->head == _rx_buffer->tail)
9d005180:	8c640204 	lw	a0,516(v1)
9d005184:	8c650200 	lw	a1,512(v1)
9d005188:	10a40017 	beq	a1,a0,9d0051e8 <_ZN9USBSerial4readEv+0x74>
9d00518c:	2402ffff 	li	v0,-1
		return -1;
	}
	else
	{
		theChar				=	_rx_buffer->buffer[_rx_buffer->tail];
		_rx_buffer->tail	=	(_rx_buffer->tail + 1) % RX_BUFFER_SIZE;
9d005190:	24850001 	addiu	a1,a0,1
9d005194:	000517c3 	sra	v0,a1,0x1f
9d005198:	000215c2 	srl	v0,v0,0x17
9d00519c:	00a22821 	addu	a1,a1,v0
9d0051a0:	30a501ff 	andi	a1,a1,0x1ff
9d0051a4:	00a22823 	subu	a1,a1,v0
        
        // If we just made enough room for the next packet to fit into our buffer,
        // start the packets flowing from the PC again
        if (USBSerialBufferFree() >= USB_SERIAL_MIN_BUFFER_FREE)
9d0051a8:	3c02a000 	lui	v0,0xa000
9d0051ac:	24420d24 	addiu	v0,v0,3364
		return -1;
	}
	else
	{
		theChar				=	_rx_buffer->buffer[_rx_buffer->tail];
		_rx_buffer->tail	=	(_rx_buffer->tail + 1) % RX_BUFFER_SIZE;
9d0051b0:	ac650204 	sw	a1,516(v1)
        
        // If we just made enough room for the next packet to fit into our buffer,
        // start the packets flowing from the PC again
        if (USBSerialBufferFree() >= USB_SERIAL_MIN_BUFFER_FREE)
9d0051b4:	8c450204 	lw	a1,516(v0)
9d0051b8:	8c420200 	lw	v0,512(v0)
	{
		return -1;
	}
	else
	{
		theChar				=	_rx_buffer->buffer[_rx_buffer->tail];
9d0051bc:	00641821 	addu	v1,v1,a0
		_rx_buffer->tail	=	(_rx_buffer->tail + 1) % RX_BUFFER_SIZE;
        
        // If we just made enough room for the next packet to fit into our buffer,
        // start the packets flowing from the PC again
        if (USBSerialBufferFree() >= USB_SERIAL_MIN_BUFFER_FREE)
9d0051c0:	24a501ff 	addiu	a1,a1,511
9d0051c4:	00a22823 	subu	a1,a1,v0
9d0051c8:	000517c3 	sra	v0,a1,0x1f
9d0051cc:	000215c2 	srl	v0,v0,0x17
9d0051d0:	00a22821 	addu	a1,a1,v0
9d0051d4:	30a501ff 	andi	a1,a1,0x1ff
9d0051d8:	00a22823 	subu	a1,a1,v0
9d0051dc:	28a50080 	slti	a1,a1,128
9d0051e0:	10a00004 	beqz	a1,9d0051f4 <_ZN9USBSerial4readEv+0x80>
9d0051e4:	90620000 	lbu	v0,0(v1)
            cdcacm_command_ack();
        }
        
		return (theChar);
	}
}
9d0051e8:	8fbf001c 	lw	ra,28(sp)
9d0051ec:	03e00008 	jr	ra
9d0051f0:	27bd0020 	addiu	sp,sp,32
        
        // If we just made enough room for the next packet to fit into our buffer,
        // start the packets flowing from the PC again
        if (USBSerialBufferFree() >= USB_SERIAL_MIN_BUFFER_FREE)
        {
            cdcacm_command_ack();
9d0051f4:	0f401a18 	jal	9d006860 <cdcacm_command_ack>
9d0051f8:	afa20010 	sw	v0,16(sp)
        }
        
		return (theChar);
	}
}
9d0051fc:	8fbf001c 	lw	ra,28(sp)
        
        // If we just made enough room for the next packet to fit into our buffer,
        // start the packets flowing from the PC again
        if (USBSerialBufferFree() >= USB_SERIAL_MIN_BUFFER_FREE)
        {
            cdcacm_command_ack();
9d005200:	8fa20010 	lw	v0,16(sp)
        }
        
		return (theChar);
	}
}
9d005204:	03e00008 	jr	ra
9d005208:	27bd0020 	addiu	sp,sp,32

9d00520c <_ZN14HardwareSerial11doSerialIntEv>:
	uint8_t	ch;

	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
9d00520c:	8c820010 	lw	v0,16(a0)
9d005210:	8c83001c 	lw	v1,28(a0)
9d005214:	8c450000 	lw	a1,0(v0)
9d005218:	00652824 	and	a1,v1,a1
9d00521c:	10a00010 	beqz	a1,9d005260 <_ZN14HardwareSerial11doSerialIntEv+0x54>
9d005220:	00000000 	nop
	{
		ch = uart->uxRx.reg;
		bufIndex	= (rx_buffer.head + 1) % RX_BUFFER_SIZE;
9d005224:	8c870224 	lw	a3,548(a0)
	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
9d005228:	8c890004 	lw	t1,4(a0)
		/* If we should be storing the received character into the location
		** just before the tail (meaning that the head would advance to the
		** current location of the tail), we're about to overflow the buffer
		** and so we don't write the character or advance the head.
		*/
		if (bufIndex != rx_buffer.tail)
9d00522c:	8c880228 	lw	t0,552(a0)
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
		bufIndex	= (rx_buffer.head + 1) % RX_BUFFER_SIZE;
9d005230:	24e60001 	addiu	a2,a3,1
9d005234:	00062fc3 	sra	a1,a2,0x1f
9d005238:	00052dc2 	srl	a1,a1,0x17
9d00523c:	00c53021 	addu	a2,a2,a1
9d005240:	30c601ff 	andi	a2,a2,0x1ff
9d005244:	00c52823 	subu	a1,a2,a1
	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
9d005248:	8d260030 	lw	a2,48(t1)
		/* If we should be storing the received character into the location
		** just before the tail (meaning that the head would advance to the
		** current location of the tail), we're about to overflow the buffer
		** and so we don't write the character or advance the head.
		*/
		if (bufIndex != rx_buffer.tail)
9d00524c:	11050003 	beq	t0,a1,9d00525c <_ZN14HardwareSerial11doSerialIntEv+0x50>
9d005250:	00873821 	addu	a3,a0,a3
	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
9d005254:	a0e60024 	sb	a2,36(a3)
		** and so we don't write the character or advance the head.
		*/
		if (bufIndex != rx_buffer.tail)
		{
			rx_buffer.buffer[rx_buffer.head] = ch;
			rx_buffer.head = bufIndex;
9d005258:	ac850224 	sw	a1,548(a0)
		}

		/* Clear the interrupt flag.
		*/
		ifs->clr = bit_rx;
9d00525c:	ac430004 	sw	v1,4(v0)
	}

	/* If it's a transmit interrupt, ignore it, as we don't current
	** have interrupt driven i/o on the transmit side.
	*/
	if ((ifs->reg & bit_tx) != 0)
9d005260:	8c450000 	lw	a1,0(v0)
9d005264:	8c830020 	lw	v1,32(a0)
9d005268:	00652024 	and	a0,v1,a1
9d00526c:	54800001 	bnezl	a0,9d005274 <_ZN14HardwareSerial11doSerialIntEv+0x68>
9d005270:	ac430004 	sw	v1,4(v0)
9d005274:	03e00008 	jr	ra
9d005278:	00000000 	nop

9d00527c <IntSer1Handler>:
**		serial port 1.
*/
#if defined(_SER1_VECTOR)

void __attribute__((interrupt(), nomips16)) IntSer1Handler(void)
{
9d00527c:	415de800 	rdpgpr	sp,sp
9d005280:	401b7000 	mfc0	k1,c0_epc
9d005284:	401a6002 	mfc0	k0,c0_srsctl
9d005288:	27bdff90 	addiu	sp,sp,-112
9d00528c:	afbb006c 	sw	k1,108(sp)
9d005290:	401b6000 	mfc0	k1,c0_status
9d005294:	afba0068 	sw	k0,104(sp)
9d005298:	401a6800 	mfc0	k0,c0_cause
9d00529c:	001ad282 	srl	k0,k0,0xa
9d0052a0:	afbb0064 	sw	k1,100(sp)
9d0052a4:	7f5b7a84 	ins	k1,k0,0xa,0x6
9d0052a8:	7c1b2044 	ins	k1,zero,0x1,0x4
9d0052ac:	409b6000 	mtc0	k1,c0_status
9d0052b0:	afa30018 	sw	v1,24(sp)
9d0052b4:	8fa30068 	lw	v1,104(sp)
9d0052b8:	3063000f 	andi	v1,v1,0xf
9d0052bc:	14600011 	bnez	v1,9d005304 <IntSer1Handler+0x88>
9d0052c0:	afa20014 	sw	v0,20(sp)
9d0052c4:	afbf0054 	sw	ra,84(sp)
9d0052c8:	afb90050 	sw	t9,80(sp)
9d0052cc:	afb8004c 	sw	t8,76(sp)
9d0052d0:	afaf0048 	sw	t7,72(sp)
9d0052d4:	afae0044 	sw	t6,68(sp)
9d0052d8:	afad0040 	sw	t5,64(sp)
9d0052dc:	afac003c 	sw	t4,60(sp)
9d0052e0:	afab0038 	sw	t3,56(sp)
9d0052e4:	afaa0034 	sw	t2,52(sp)
9d0052e8:	afa90030 	sw	t1,48(sp)
9d0052ec:	afa8002c 	sw	t0,44(sp)
9d0052f0:	afa70028 	sw	a3,40(sp)
9d0052f4:	afa60024 	sw	a2,36(sp)
9d0052f8:	afa50020 	sw	a1,32(sp)
9d0052fc:	afa4001c 	sw	a0,28(sp)
9d005300:	afa10010 	sw	at,16(sp)
	Serial1.doSerialInt();
9d005304:	3c04a000 	lui	a0,0xa000
**		serial port 1.
*/
#if defined(_SER1_VECTOR)

void __attribute__((interrupt(), nomips16)) IntSer1Handler(void)
{
9d005308:	00001012 	mflo	v0
	Serial1.doSerialInt();
9d00530c:	24841158 	addiu	a0,a0,4440
**		serial port 1.
*/
#if defined(_SER1_VECTOR)

void __attribute__((interrupt(), nomips16)) IntSer1Handler(void)
{
9d005310:	afa2005c 	sw	v0,92(sp)
9d005314:	00001810 	mfhi	v1
	Serial1.doSerialInt();
9d005318:	0f401483 	jal	9d00520c <_ZN14HardwareSerial11doSerialIntEv>
9d00531c:	afa30058 	sw	v1,88(sp)
}
9d005320:	8fa2005c 	lw	v0,92(sp)
9d005324:	8fa30058 	lw	v1,88(sp)
9d005328:	00400013 	mtlo	v0
9d00532c:	8fa20068 	lw	v0,104(sp)
9d005330:	3042000f 	andi	v0,v0,0xf
9d005334:	14400013 	bnez	v0,9d005384 <IntSer1Handler+0x108>
9d005338:	00600011 	mthi	v1
9d00533c:	8fbf0054 	lw	ra,84(sp)
9d005340:	8fb90050 	lw	t9,80(sp)
9d005344:	8fb8004c 	lw	t8,76(sp)
9d005348:	8faf0048 	lw	t7,72(sp)
9d00534c:	8fae0044 	lw	t6,68(sp)
9d005350:	8fad0040 	lw	t5,64(sp)
9d005354:	8fac003c 	lw	t4,60(sp)
9d005358:	8fab0038 	lw	t3,56(sp)
9d00535c:	8faa0034 	lw	t2,52(sp)
9d005360:	8fa90030 	lw	t1,48(sp)
9d005364:	8fa8002c 	lw	t0,44(sp)
9d005368:	8fa70028 	lw	a3,40(sp)
9d00536c:	8fa60024 	lw	a2,36(sp)
9d005370:	8fa50020 	lw	a1,32(sp)
9d005374:	8fa4001c 	lw	a0,28(sp)
9d005378:	8fa30018 	lw	v1,24(sp)
9d00537c:	8fa20014 	lw	v0,20(sp)
9d005380:	8fa10010 	lw	at,16(sp)
9d005384:	41606000 	di
9d005388:	000000c0 	ehb
9d00538c:	8fba006c 	lw	k0,108(sp)
9d005390:	8fbb0064 	lw	k1,100(sp)
9d005394:	409a7000 	mtc0	k0,c0_epc
9d005398:	8fba0068 	lw	k0,104(sp)
9d00539c:	27bd0070 	addiu	sp,sp,112
9d0053a0:	409a6002 	mtc0	k0,c0_srsctl
9d0053a4:	41dde800 	wrpgpr	sp,sp
9d0053a8:	409b6000 	mtc0	k1,c0_status
9d0053ac:	42000018 	eret

9d0053b0 <IntSer0Handler>:
**		serial port 0.
*/
#if defined(_SER0_VECTOR)

void __attribute__((interrupt(), nomips16)) IntSer0Handler(void)
{
9d0053b0:	415de800 	rdpgpr	sp,sp
9d0053b4:	401b7000 	mfc0	k1,c0_epc
9d0053b8:	401a6002 	mfc0	k0,c0_srsctl
9d0053bc:	27bdff90 	addiu	sp,sp,-112
9d0053c0:	afbb006c 	sw	k1,108(sp)
9d0053c4:	401b6000 	mfc0	k1,c0_status
9d0053c8:	afba0068 	sw	k0,104(sp)
9d0053cc:	401a6800 	mfc0	k0,c0_cause
9d0053d0:	001ad282 	srl	k0,k0,0xa
9d0053d4:	afbb0064 	sw	k1,100(sp)
9d0053d8:	7f5b7a84 	ins	k1,k0,0xa,0x6
9d0053dc:	7c1b2044 	ins	k1,zero,0x1,0x4
9d0053e0:	409b6000 	mtc0	k1,c0_status
9d0053e4:	afa30018 	sw	v1,24(sp)
9d0053e8:	8fa30068 	lw	v1,104(sp)
9d0053ec:	3063000f 	andi	v1,v1,0xf
9d0053f0:	14600011 	bnez	v1,9d005438 <IntSer0Handler+0x88>
9d0053f4:	afa20014 	sw	v0,20(sp)
9d0053f8:	afbf0054 	sw	ra,84(sp)
9d0053fc:	afb90050 	sw	t9,80(sp)
9d005400:	afb8004c 	sw	t8,76(sp)
9d005404:	afaf0048 	sw	t7,72(sp)
9d005408:	afae0044 	sw	t6,68(sp)
9d00540c:	afad0040 	sw	t5,64(sp)
9d005410:	afac003c 	sw	t4,60(sp)
9d005414:	afab0038 	sw	t3,56(sp)
9d005418:	afaa0034 	sw	t2,52(sp)
9d00541c:	afa90030 	sw	t1,48(sp)
9d005420:	afa8002c 	sw	t0,44(sp)
9d005424:	afa70028 	sw	a3,40(sp)
9d005428:	afa60024 	sw	a2,36(sp)
9d00542c:	afa50020 	sw	a1,32(sp)
9d005430:	afa4001c 	sw	a0,28(sp)
9d005434:	afa10010 	sw	at,16(sp)
#if defined(_USB) && defined(_USE_USB_FOR_SERIAL_)
	Serial0.doSerialInt();
9d005438:	3c04a000 	lui	a0,0xa000
**		serial port 0.
*/
#if defined(_SER0_VECTOR)

void __attribute__((interrupt(), nomips16)) IntSer0Handler(void)
{
9d00543c:	00001012 	mflo	v0
#if defined(_USB) && defined(_USE_USB_FOR_SERIAL_)
	Serial0.doSerialInt();
9d005440:	24840f2c 	addiu	a0,a0,3884
**		serial port 0.
*/
#if defined(_SER0_VECTOR)

void __attribute__((interrupt(), nomips16)) IntSer0Handler(void)
{
9d005444:	afa2005c 	sw	v0,92(sp)
9d005448:	00001810 	mfhi	v1
#if defined(_USB) && defined(_USE_USB_FOR_SERIAL_)
	Serial0.doSerialInt();
9d00544c:	0f401483 	jal	9d00520c <_ZN14HardwareSerial11doSerialIntEv>
9d005450:	afa30058 	sw	v1,88(sp)
#else
	Serial.doSerialInt();
#endif
}
9d005454:	8fa2005c 	lw	v0,92(sp)
9d005458:	8fa30058 	lw	v1,88(sp)
9d00545c:	00400013 	mtlo	v0
9d005460:	8fa20068 	lw	v0,104(sp)
9d005464:	3042000f 	andi	v0,v0,0xf
9d005468:	14400013 	bnez	v0,9d0054b8 <IntSer0Handler+0x108>
9d00546c:	00600011 	mthi	v1
9d005470:	8fbf0054 	lw	ra,84(sp)
9d005474:	8fb90050 	lw	t9,80(sp)
9d005478:	8fb8004c 	lw	t8,76(sp)
9d00547c:	8faf0048 	lw	t7,72(sp)
9d005480:	8fae0044 	lw	t6,68(sp)
9d005484:	8fad0040 	lw	t5,64(sp)
9d005488:	8fac003c 	lw	t4,60(sp)
9d00548c:	8fab0038 	lw	t3,56(sp)
9d005490:	8faa0034 	lw	t2,52(sp)
9d005494:	8fa90030 	lw	t1,48(sp)
9d005498:	8fa8002c 	lw	t0,44(sp)
9d00549c:	8fa70028 	lw	a3,40(sp)
9d0054a0:	8fa60024 	lw	a2,36(sp)
9d0054a4:	8fa50020 	lw	a1,32(sp)
9d0054a8:	8fa4001c 	lw	a0,28(sp)
9d0054ac:	8fa30018 	lw	v1,24(sp)
9d0054b0:	8fa20014 	lw	v0,20(sp)
9d0054b4:	8fa10010 	lw	at,16(sp)
9d0054b8:	41606000 	di
9d0054bc:	000000c0 	ehb
9d0054c0:	8fba006c 	lw	k0,108(sp)
9d0054c4:	8fbb0064 	lw	k1,100(sp)
9d0054c8:	409a7000 	mtc0	k0,c0_epc
9d0054cc:	8fba0068 	lw	k0,104(sp)
9d0054d0:	27bd0070 	addiu	sp,sp,112
9d0054d4:	409a6002 	mtc0	k0,c0_srsctl
9d0054d8:	41dde800 	wrpgpr	sp,sp
9d0054dc:	409b6000 	mtc0	k1,c0_status
9d0054e0:	42000018 	eret

9d0054e4 <_ZN9USBSerialcviEv>:
	_rx_buffer->head	=	0;
	_rx_buffer->tail	=	0;
}

USBSerial::operator int() {
    return gConnected ? 1 : 0;
9d0054e4:	9382809c 	lbu	v0,-32612(gp)
}
9d0054e8:	03e00008 	jr	ra
9d0054ec:	0002102b 	sltu	v0,zero,v0

9d0054f0 <_ZN9USBSerial5beginEm>:
#endif


//*******************************************************************************************
void USBSerial::begin(unsigned long baudRate)
{
9d0054f0:	27bdffe8 	addiu	sp,sp,-24
9d0054f4:	afbf0014 	sw	ra,20(sp)
	DebugViaSerial0("USBSerial::begin");

	DebugViaSerial0("calling usb_initialize");
	usb_initialize();
9d0054f8:	0f401806 	jal	9d006018 <usb_initialize>
9d0054fc:	00000000 	nop
	DebugViaSerial0("returned from usb_initialize");

	cdcacm_register(USBresetRoutine, USBstoreDataRoutine);
9d005500:	3c049d00 	lui	a0,0x9d00
9d005504:	3c059d00 	lui	a1,0x9d00

	// Must enable glocal interrupts - in this case, we are using multi-vector mode
	//INTEnableSystemMultiVectoredInt();
	DebugViaSerial0("INTEnableSystemMultiVectoredInt");

}
9d005508:	8fbf0014 	lw	ra,20(sp)

	DebugViaSerial0("calling usb_initialize");
	usb_initialize();
	DebugViaSerial0("returned from usb_initialize");

	cdcacm_register(USBresetRoutine, USBstoreDataRoutine);
9d00550c:	24844f28 	addiu	a0,a0,20264
9d005510:	24a54f30 	addiu	a1,a1,20272
9d005514:	0b401a2c 	j	9d0068b0 <cdcacm_register>
9d005518:	27bd0018 	addiu	sp,sp,24

9d00551c <_GLOBAL__I__ZN14HardwareSerialC2EP8p32_uartiiiiPFvvE>:


//*******************************************************************************************
USBSerial::USBSerial(ring_buffer	*rx_buffer)
{
	_rx_buffer			=	rx_buffer;
9d00551c:	3c04a000 	lui	a0,0xa000
9d005520:	24840d24 	addiu	a0,a0,3364
*/

#if defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
9d005524:	3c0aa000 	lui	t2,0xa000
#endif
{
	uart = uartT;
9d005528:	25430f2c 	addiu	v1,t2,3884


//*******************************************************************************************
USBSerial::USBSerial(ring_buffer	*rx_buffer)
{
	_rx_buffer			=	rx_buffer;
9d00552c:	af848064 	sw	a0,-32668(gp)
	_rx_buffer->head	=	0;
9d005530:	ac800200 	sw	zero,512(a0)
	_rx_buffer->tail	=	0;
9d005534:	ac800204 	sw	zero,516(a0)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
#endif
{
	uart = uartT;
	irq  = irqT;
9d005538:	2404001a 	li	a0,26
9d00553c:	a064000c 	sb	a0,12(v1)
	vec  = vecT;
9d005540:	24040018 	li	a0,24
9d005544:	a064000d 	sb	a0,13(v1)
	irq  = (uint8_t)irqT;
	vec  = (uint8_t)vecT;
	ipl  = (uint8_t)iplT;
	spl  = (uint8_t)splT;
    isr  = isrHandler;
9d005548:	3c049d00 	lui	a0,0x9d00
9d00554c:	248453b0 	addiu	a0,a0,21424
9d005550:	ac640008 	sw	a0,8(v1)
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
9d005554:	3c040400 	lui	a0,0x400
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
#endif
{
	uart = uartT;
9d005558:	3c0bbf80 	lui	t3,0xbf80
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
9d00555c:	ac640018 	sw	a0,24(v1)
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d005560:	3c09bf88 	lui	t1,0xbf88
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d005564:	3c040800 	lui	a0,0x800
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d005568:	3c08bf88 	lui	t0,0xbf88
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d00556c:	25291030 	addiu	t1,t1,4144
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d005570:	25081060 	addiu	t0,t0,4192
*/

#if defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
9d005574:	3c06a000 	lui	a2,0xa000
	uart = uartT;
	irq  = irqT;
	vec  = vecT;
	irq  = (uint8_t)irqT;
	vec  = (uint8_t)vecT;
	ipl  = (uint8_t)iplT;
9d005578:	24050002 	li	a1,2
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
#endif
{
	uart = uartT;
9d00557c:	256e6000 	addiu	t6,t3,24576
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d005580:	ac64001c 	sw	a0,28(v1)
	bit_tx  = 1 << ((irq+2) % 32);	//tx interrupt flag/enable bit
9d005584:	3c041000 	lui	a0,0x1000
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
#endif
{
	uart = uartT;
9d005588:	24c21158 	addiu	v0,a2,4440
9d00558c:	ac6e0004 	sw	t6,4(v1)
	irq  = irqT;
	vec  = vecT;
	irq  = (uint8_t)irqT;
	vec  = (uint8_t)vecT;
	ipl  = (uint8_t)iplT;
9d005590:	a065000e 	sb	a1,14(v1)
	spl  = (uint8_t)splT;
9d005594:	a060000f 	sb	zero,15(v1)
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d005598:	ac690010 	sw	t1,16(v1)
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d00559c:	ac680014 	sw	t0,20(v1)

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
	bit_tx  = 1 << ((irq+2) % 32);	//tx interrupt flag/enable bit
9d0055a0:	ac640020 	sw	a0,32(v1)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
#endif
{
	uart = uartT;
	irq  = irqT;
9d0055a4:	24030028 	li	v1,40
9d0055a8:	a043000c 	sb	v1,12(v0)
	vec  = vecT;
9d0055ac:	24030020 	li	v1,32
9d0055b0:	a043000d 	sb	v1,13(v0)
	irq  = (uint8_t)irqT;
	vec  = (uint8_t)vecT;
	ipl  = (uint8_t)iplT;
	spl  = (uint8_t)splT;
    isr  = isrHandler;
9d0055b4:	3c039d00 	lui	v1,0x9d00
9d0055b8:	2463527c 	addiu	v1,v1,21116
9d0055bc:	ac430008 	sw	v1,8(v0)
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
9d0055c0:	24030100 	li	v1,256
*/

#if defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
9d0055c4:	3c079d00 	lui	a3,0x9d00
    }
}


//*******************************************************************************************
USBSerial::USBSerial(ring_buffer	*rx_buffer)
9d0055c8:	3c0f9d00 	lui	t7,0x9d00
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
9d0055cc:	ac430018 	sw	v1,24(v0)
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d0055d0:	24030200 	li	v1,512
*/

#if defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
9d0055d4:	24e77e70 	addiu	a3,a3,32368
#endif
{
	uart = uartT;
9d0055d8:	256b6800 	addiu	t3,t3,26624
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d0055dc:	252d0010 	addiu	t5,t1,16
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d0055e0:	250c0010 	addiu	t4,t0,16
    }
}


//*******************************************************************************************
USBSerial::USBSerial(ring_buffer	*rx_buffer)
9d0055e4:	25ef7e48 	addiu	t7,t7,32328
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d0055e8:	ac43001c 	sw	v1,28(v0)
	bit_tx  = 1 << ((irq+2) % 32);	//tx interrupt flag/enable bit
9d0055ec:	24030400 	li	v1,1024
    }
}


//*******************************************************************************************
USBSerial::USBSerial(ring_buffer	*rx_buffer)
9d0055f0:	af8f8060 	sw	t7,-32672(gp)
*/

#if defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
9d0055f4:	ad470f2c 	sw	a3,3884(t2)
9d0055f8:	acc71158 	sw	a3,4440(a2)
#endif
{
	uart = uartT;
9d0055fc:	ac4b0004 	sw	t3,4(v0)
	irq  = irqT;
	vec  = vecT;
	irq  = (uint8_t)irqT;
	vec  = (uint8_t)vecT;
	ipl  = (uint8_t)iplT;
9d005600:	a045000e 	sb	a1,14(v0)
	spl  = (uint8_t)splT;
9d005604:	a040000f 	sb	zero,15(v0)
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d005608:	ac4d0010 	sw	t5,16(v0)
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d00560c:	ac4c0014 	sw	t4,20(v0)

extern "C" {
    void __attribute__((weak,used)) _mon_putc(char c) {
        Serial.write(c);
    }
}
9d005610:	03e00008 	jr	ra
9d005614:	ac430020 	sw	v1,32(v0)

9d005618 <usb_device_enqueue>:

//************************************************************************
// enqueue a packet to the usb engine for transfer to/from the host
//************************************************************************
void	usb_device_enqueue(int endpoint, boolean tx, byte *buffer, int length)
{
9d005618:	30a500ff 	andi	a1,a1,0xff
	int			flags;
	struct bdt	*bdt;

	assert(endpoint < LENGTHOF(endpoints));

	if (tx != (boolean)-1)
9d00561c:	240200ff 	li	v0,255
9d005620:	10a2001d 	beq	a1,v0,9d005698 <usb_device_enqueue+0x80>
9d005624:	00041140 	sll	v0,a0,0x5
	{
		// transfer up to one packet at a time
		assert(endpoints[endpoint].packetsize);
		length	=	MIN(length, endpoints[endpoint].packetsize);
9d005628:	000441c0 	sll	t0,a0,0x7
9d00562c:	01024023 	subu	t0,t0,v0
9d005630:	3c02a000 	lui	v0,0xa000

		// find the next bdt entry to use
		odd	=	endpoints[endpoint].bdtodd[tx];
9d005634:	01051821 	addu	v1,t0,a1

	if (tx != (boolean)-1)
	{
		// transfer up to one packet at a time
		assert(endpoints[endpoint].packetsize);
		length	=	MIN(length, endpoints[endpoint].packetsize);
9d005638:	24421790 	addiu	v0,v0,6032

		// find the next bdt entry to use
		odd	=	endpoints[endpoint].bdtodd[tx];
9d00563c:	00621821 	addu	v1,v1,v0

		// initialize the bdt entry
		bdt	=	MYBDT(endpoint, tx, odd);
9d005640:	90690002 	lbu	t1,2(v1)
9d005644:	00045040 	sll	t2,a0,0x1
9d005648:	00aa2821 	addu	a1,a1,t2

	if (tx != (boolean)-1)
	{
		// transfer up to one packet at a time
		assert(endpoints[endpoint].packetsize);
		length	=	MIN(length, endpoints[endpoint].packetsize);
9d00564c:	01021021 	addu	v0,t0,v0

		// find the next bdt entry to use
		odd	=	endpoints[endpoint].bdtodd[tx];

		// initialize the bdt entry
		bdt	=	MYBDT(endpoint, tx, odd);
9d005650:	00052840 	sll	a1,a1,0x1
9d005654:	8f888068 	lw	t0,-32664(gp)
9d005658:	01252821 	addu	a1,t1,a1
9d00565c:	000528c0 	sll	a1,a1,0x3

	if (tx != (boolean)-1)
	{
		// transfer up to one packet at a time
		assert(endpoints[endpoint].packetsize);
		length	=	MIN(length, endpoints[endpoint].packetsize);
9d005660:	90420004 	lbu	v0,4(v0)

		// find the next bdt entry to use
		odd	=	endpoints[endpoint].bdtodd[tx];

		// initialize the bdt entry
		bdt	=	MYBDT(endpoint, tx, odd);
9d005664:	01052821 	addu	a1,t0,a1
		bdt->buffer	=	(byte *)TF_LITTLE(KVA_TO_PA((int)buffer));
9d005668:	7cc6e000 	ext	a2,a2,0x0,0x1d
9d00566c:	a8a60007 	swl	a2,7(a1)
9d005670:	b8a60004 	swr	a2,4(a1)
		flags	=	TF_LITTLE(bdt->flags);
		assert(! (flags & BD_FLAGS_OWN));
		assert(length <= endpoints[endpoint].packetsize);
		bdt->flags	=	TF_LITTLE(BD_FLAGS_BC_ENC(length)|BD_FLAGS_OWN|endpoints[endpoint].toggle[tx]|BD_FLAGS_DTS);
9d005674:	90630000 	lbu	v1,0(v1)

	if (tx != (boolean)-1)
	{
		// transfer up to one packet at a time
		assert(endpoints[endpoint].packetsize);
		length	=	MIN(length, endpoints[endpoint].packetsize);
9d005678:	0047302a 	slt	a2,v0,a3
9d00567c:	00e6100a 	movz	v0,a3,a2
		bdt	=	MYBDT(endpoint, tx, odd);
		bdt->buffer	=	(byte *)TF_LITTLE(KVA_TO_PA((int)buffer));
		flags	=	TF_LITTLE(bdt->flags);
		assert(! (flags & BD_FLAGS_OWN));
		assert(length <= endpoints[endpoint].packetsize);
		bdt->flags	=	TF_LITTLE(BD_FLAGS_BC_ENC(length)|BD_FLAGS_OWN|endpoints[endpoint].toggle[tx]|BD_FLAGS_DTS);
9d005680:	304203ff 	andi	v0,v0,0x3ff
9d005684:	34670088 	ori	a3,v1,0x88
9d005688:	00021400 	sll	v0,v0,0x10
9d00568c:	00e23825 	or	a3,a3,v0
9d005690:	a8a70003 	swl	a3,3(a1)
9d005694:	b8a70000 	swr	a3,0(a1)
	}

	ep	=	MCF_USB_OTG_ENDPT_EP_HSHK|MCF_USB_OTG_ENDPT_EP_TX_EN|MCF_USB_OTG_ENDPT_EP_RX_EN;
	ep |= endpoint?MCF_USB_OTG_ENDPT_EP_CTL_DIS:0;
9d005698:	14800004 	bnez	a0,9d0056ac <usb_device_enqueue+0x94>
9d00569c:	2402000d 	li	v0,13
	// enable the packet transfer
	switch (endpoint)
	{
		case 0:
			U1EP0	=	(uint8)(ep);
9d0056a0:	3c03bf88 	lui	v1,0xbf88
9d0056a4:	03e00008 	jr	ra
			break;
9d0056a8:	ac625300 	sw	v0,21248(v1)
	}

	ep	=	MCF_USB_OTG_ENDPT_EP_HSHK|MCF_USB_OTG_ENDPT_EP_TX_EN|MCF_USB_OTG_ENDPT_EP_RX_EN;
	ep |= endpoint?MCF_USB_OTG_ENDPT_EP_CTL_DIS:0;
	// enable the packet transfer
	switch (endpoint)
9d0056ac:	24020001 	li	v0,1
9d0056b0:	1082000a 	beq	a0,v0,9d0056dc <usb_device_enqueue+0xc4>
9d0056b4:	28820002 	slti	v0,a0,2
9d0056b8:	14400013 	bnez	v0,9d005708 <usb_device_enqueue+0xf0>
9d0056bc:	24020002 	li	v0,2
9d0056c0:	1082000a 	beq	a0,v0,9d0056ec <usb_device_enqueue+0xd4>
9d0056c4:	24020003 	li	v0,3
9d0056c8:	1082000c 	beq	a0,v0,9d0056fc <usb_device_enqueue+0xe4>
9d0056cc:	2403001d 	li	v1,29
			break;
		case 3:
			U1EP3	=	(uint8)(ep);
			break;
		default:
			ASSERT(0);
9d0056d0:	7000003f 	sdbbp
9d0056d4:	03e00008 	jr	ra
9d0056d8:	00000000 	nop
	{
		case 0:
			U1EP0	=	(uint8)(ep);
			break;
		case 1:
			U1EP1	=	(uint8)(ep);
9d0056dc:	2403001d 	li	v1,29
9d0056e0:	3c02bf88 	lui	v0,0xbf88
9d0056e4:	03e00008 	jr	ra
			break;
9d0056e8:	ac435310 	sw	v1,21264(v0)
		case 2:
			U1EP2	=	(uint8)(ep);
9d0056ec:	2403001d 	li	v1,29
9d0056f0:	3c02bf88 	lui	v0,0xbf88
9d0056f4:	03e00008 	jr	ra
			break;
9d0056f8:	ac435320 	sw	v1,21280(v0)
		case 3:
			U1EP3	=	(uint8)(ep);
9d0056fc:	3c02bf88 	lui	v0,0xbf88
9d005700:	03e00008 	jr	ra
			break;
9d005704:	ac435330 	sw	v1,21296(v0)
	}

	ep	=	MCF_USB_OTG_ENDPT_EP_HSHK|MCF_USB_OTG_ENDPT_EP_TX_EN|MCF_USB_OTG_ENDPT_EP_RX_EN;
	ep |= endpoint?MCF_USB_OTG_ENDPT_EP_CTL_DIS:0;
	// enable the packet transfer
	switch (endpoint)
9d005708:	1080ffe5 	beqz	a0,9d0056a0 <usb_device_enqueue+0x88>
9d00570c:	2402001d 	li	v0,29
9d005710:	0b4015b4 	j	9d0056d0 <usb_device_enqueue+0xb8>
9d005714:	00000000 	nop

9d005718 <IntUSB1Handler>:
#ifdef _USE_USB_IRQ_
	void __attribute__((interrupt(),nomips16)) IntUSB1Handler(void)
#else
	void	usb_isr(void)
#endif
{
9d005718:	415de800 	rdpgpr	sp,sp
9d00571c:	401b7000 	mfc0	k1,c0_epc
9d005720:	401a6002 	mfc0	k0,c0_srsctl
9d005724:	27bdff78 	addiu	sp,sp,-136
9d005728:	afbb0084 	sw	k1,132(sp)
9d00572c:	401b6000 	mfc0	k1,c0_status
9d005730:	afba0080 	sw	k0,128(sp)
9d005734:	401a6800 	mfc0	k0,c0_cause
9d005738:	001ad282 	srl	k0,k0,0xa
9d00573c:	afbb007c 	sw	k1,124(sp)
9d005740:	7f5b7a84 	ins	k1,k0,0xa,0x6
9d005744:	7c1b2044 	ins	k1,zero,0x1,0x4
9d005748:	409b6000 	mtc0	k1,c0_status
9d00574c:	afa3001c 	sw	v1,28(sp)
9d005750:	8fa30080 	lw	v1,128(sp)
9d005754:	3063000f 	andi	v1,v1,0xf
9d005758:	14600016 	bnez	v1,9d0057b4 <IntUSB1Handler+0x9c>
9d00575c:	afa20018 	sw	v0,24(sp)
9d005760:	afbf006c 	sw	ra,108(sp)
9d005764:	afb90068 	sw	t9,104(sp)
9d005768:	afb80064 	sw	t8,100(sp)
9d00576c:	afb40060 	sw	s4,96(sp)
9d005770:	afb3005c 	sw	s3,92(sp)
9d005774:	afb20058 	sw	s2,88(sp)
9d005778:	afb10054 	sw	s1,84(sp)
9d00577c:	afb00050 	sw	s0,80(sp)
9d005780:	afaf004c 	sw	t7,76(sp)
9d005784:	afae0048 	sw	t6,72(sp)
9d005788:	afad0044 	sw	t5,68(sp)
9d00578c:	afac0040 	sw	t4,64(sp)
9d005790:	afab003c 	sw	t3,60(sp)
9d005794:	afaa0038 	sw	t2,56(sp)
9d005798:	afa90034 	sw	t1,52(sp)
9d00579c:	afa80030 	sw	t0,48(sp)
9d0057a0:	afa7002c 	sw	a3,44(sp)
9d0057a4:	afa60028 	sw	a2,40(sp)
9d0057a8:	afa50024 	sw	a1,36(sp)
9d0057ac:	afa40020 	sw	a0,32(sp)
9d0057b0:	afa10014 	sw	at,20(sp)
9d0057b4:	00001810 	mfhi	v1
9d0057b8:	afa30070 	sw	v1,112(sp)
	int rv __attribute__((aligned));

	if (! bdts)
9d0057bc:	8f838068 	lw	v1,-32664(gp)
#ifdef _USE_USB_IRQ_
	void __attribute__((interrupt(),nomips16)) IntUSB1Handler(void)
#else
	void	usb_isr(void)
#endif
{
9d0057c0:	00001012 	mflo	v0
	int rv __attribute__((aligned));

	if (! bdts)
9d0057c4:	1060001a 	beqz	v1,9d005830 <IntUSB1Handler+0x118>
9d0057c8:	afa20074 	sw	v0,116(sp)
#ifdef _USE_USB_IRQ_
#if defined(__PIC32MX2XX__)
    /// TODO: Plib replacement function should go here
    IFS1CLR	=	0x00000008; // USBIF
#else
	IFS1CLR	=	0x02000000; // USBIF
9d0057cc:	3c02bf88 	lui	v0,0xbf88
9d0057d0:	3c040200 	lui	a0,0x200
9d0057d4:	ac441044 	sw	a0,4164(v0)
#endif
#endif	
	// *** device ***
	
	// if we just transferred a token...
	if (MCF_USB_OTG_INT_STAT & MCF_USB_OTG_INT_STAT_TOK_DNE)
9d0057d8:	3c10bf88 	lui	s0,0xbf88
9d0057dc:	8e025200 	lw	v0,20992(s0)
9d0057e0:	30420008 	andi	v0,v0,0x8
9d0057e4:	1440003b 	bnez	v0,9d0058d4 <IntUSB1Handler+0x1bc>
9d0057e8:	3c02bf88 	lui	v0,0xbf88

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_TOK_DNE;
	}

	// if we just got reset by the host...
	if (MCF_USB_OTG_INT_STAT & MCF_USB_OTG_INT_STAT_USB_RST)
9d0057ec:	8e025200 	lw	v0,20992(s0)
9d0057f0:	30420001 	andi	v0,v0,0x1
9d0057f4:	14400083 	bnez	v0,9d005a04 <IntUSB1Handler+0x2ec>
9d0057f8:	3c02bf88 	lui	v0,0xbf88

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_USB_RST;
	}

	// if we just went idle...
	if (MCF_USB_OTG_INT_STAT & MCF_USB_OTG_INT_STAT_SLEEP)
9d0057fc:	8e025200 	lw	v0,20992(s0)
9d005800:	30420010 	andi	v0,v0,0x10
9d005804:	1040000a 	beqz	v0,9d005830 <IntUSB1Handler+0x118>
9d005808:	3c02bf88 	lui	v0,0xbf88
	{
		gCdcacm_active		=	0;
		gCdcacm_attached	=	0;

		// disable usb sleep interrupts
		MCF_USB_OTG_INT_ENB		&=	~MCF_USB_OTG_INT_ENB_SLEEP_EN;
9d00580c:	8c445210 	lw	a0,21008(v0)
9d005810:	2403ffef 	li	v1,-17
	}

	// if we just went idle...
	if (MCF_USB_OTG_INT_STAT & MCF_USB_OTG_INT_STAT_SLEEP)
	{
		gCdcacm_active		=	0;
9d005814:	a38080de 	sb	zero,-32546(gp)
		gCdcacm_attached	=	0;

		// disable usb sleep interrupts
		MCF_USB_OTG_INT_ENB		&=	~MCF_USB_OTG_INT_ENB_SLEEP_EN;
9d005818:	00831824 	and	v1,a0,v1
9d00581c:	ac435210 	sw	v1,21008(v0)
		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_SLEEP;
9d005820:	24030010 	li	v1,16
9d005824:	3c02bf88 	lui	v0,0xbf88

	// if we just went idle...
	if (MCF_USB_OTG_INT_STAT & MCF_USB_OTG_INT_STAT_SLEEP)
	{
		gCdcacm_active		=	0;
		gCdcacm_attached	=	0;
9d005828:	a38080cc 	sb	zero,-32564(gp)

		// disable usb sleep interrupts
		MCF_USB_OTG_INT_ENB		&=	~MCF_USB_OTG_INT_ENB_SLEEP_EN;
		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_SLEEP;
9d00582c:	ac435200 	sw	v1,20992(v0)
	}
	
//XXX_SKIP_XXX:
	assert(usb_in_isr);
	assert((usb_in_isr = false) ? true : true);
}
9d005830:	8fa20074 	lw	v0,116(sp)
9d005834:	8fa30070 	lw	v1,112(sp)
9d005838:	00400013 	mtlo	v0
9d00583c:	8fa20080 	lw	v0,128(sp)
9d005840:	3042000f 	andi	v0,v0,0xf
9d005844:	14400018 	bnez	v0,9d0058a8 <IntUSB1Handler+0x190>
9d005848:	00600011 	mthi	v1
9d00584c:	8fbf006c 	lw	ra,108(sp)
9d005850:	8fb90068 	lw	t9,104(sp)
9d005854:	8fb80064 	lw	t8,100(sp)
9d005858:	8fb40060 	lw	s4,96(sp)
9d00585c:	8fb3005c 	lw	s3,92(sp)
9d005860:	8fb20058 	lw	s2,88(sp)
9d005864:	8fb10054 	lw	s1,84(sp)
9d005868:	8fb00050 	lw	s0,80(sp)
9d00586c:	8faf004c 	lw	t7,76(sp)
9d005870:	8fae0048 	lw	t6,72(sp)
9d005874:	8fad0044 	lw	t5,68(sp)
9d005878:	8fac0040 	lw	t4,64(sp)
9d00587c:	8fab003c 	lw	t3,60(sp)
9d005880:	8faa0038 	lw	t2,56(sp)
9d005884:	8fa90034 	lw	t1,52(sp)
9d005888:	8fa80030 	lw	t0,48(sp)
9d00588c:	8fa7002c 	lw	a3,44(sp)
9d005890:	8fa60028 	lw	a2,40(sp)
9d005894:	8fa50024 	lw	a1,36(sp)
9d005898:	8fa40020 	lw	a0,32(sp)
9d00589c:	8fa3001c 	lw	v1,28(sp)
9d0058a0:	8fa20018 	lw	v0,24(sp)
9d0058a4:	8fa10014 	lw	at,20(sp)
9d0058a8:	41606000 	di
9d0058ac:	000000c0 	ehb
9d0058b0:	8fba0084 	lw	k0,132(sp)
9d0058b4:	8fbb007c 	lw	k1,124(sp)
9d0058b8:	409a7000 	mtc0	k0,c0_epc
9d0058bc:	8fba0080 	lw	k0,128(sp)
9d0058c0:	27bd0088 	addiu	sp,sp,136
9d0058c4:	409a6002 	mtc0	k0,c0_srsctl
9d0058c8:	41dde800 	wrpgpr	sp,sp
9d0058cc:	409b6000 	mtc0	k1,c0_status
9d0058d0:	42000018 	eret
		short value;
		volatile struct bdt *bdt;
		struct setup *setup;
		
		// we just completed a packet transfer
		stat		=	MCF_USB_OTG_STAT;
9d0058d4:	8c425240 	lw	v0,21056(v0)
		tx			=	!! (stat & MCF_USB_OTG_STAT_TX);
		odd			=	!! (stat & MCF_USB_OTG_STAT_ODD);
		endpoint	=	(stat & 0xf0) >> 4;

		// toggle the data toggle flag
		endpoints[endpoint].toggle[tx]	=	endpoints[endpoint].toggle[tx] ? 0 : BD_FLAGS_DATA;
9d0058d8:	3c12a000 	lui	s2,0xa000
9d0058dc:	26511790 	addiu	s1,s2,6032
		
		// we just completed a packet transfer
		stat		=	MCF_USB_OTG_STAT;
		tx			=	!! (stat & MCF_USB_OTG_STAT_TX);
		odd			=	!! (stat & MCF_USB_OTG_STAT_ODD);
		endpoint	=	(stat & 0xf0) >> 4;
9d0058e0:	7c471900 	ext	a3,v0,0x4,0x4

		// toggle the data toggle flag
		endpoints[endpoint].toggle[tx]	=	endpoints[endpoint].toggle[tx] ? 0 : BD_FLAGS_DATA;
9d0058e4:	00079940 	sll	s3,a3,0x5
9d0058e8:	0007a1c0 	sll	s4,a3,0x7
		volatile struct bdt *bdt;
		struct setup *setup;
		
		// we just completed a packet transfer
		stat		=	MCF_USB_OTG_STAT;
		tx			=	!! (stat & MCF_USB_OTG_STAT_TX);
9d0058ec:	7c4400c0 	ext	a0,v0,0x3,0x1
		odd			=	!! (stat & MCF_USB_OTG_STAT_ODD);
		endpoint	=	(stat & 0xf0) >> 4;

		// toggle the data toggle flag
		endpoints[endpoint].toggle[tx]	=	endpoints[endpoint].toggle[tx] ? 0 : BD_FLAGS_DATA;
9d0058f0:	02932823 	subu	a1,s4,s3
9d0058f4:	00a42821 	addu	a1,a1,a0
9d0058f8:	02252821 	addu	a1,s1,a1
9d0058fc:	90a90000 	lbu	t1,0(a1)
		
		// toggle the next bdt entry to use
		ASSERT(odd == endpoints[endpoint].bdtodd[tx]);
9d005900:	90a60002 	lbu	a2,2(a1)
		tx			=	!! (stat & MCF_USB_OTG_STAT_TX);
		odd			=	!! (stat & MCF_USB_OTG_STAT_ODD);
		endpoint	=	(stat & 0xf0) >> 4;

		// toggle the data toggle flag
		endpoints[endpoint].toggle[tx]	=	endpoints[endpoint].toggle[tx] ? 0 : BD_FLAGS_DATA;
9d005904:	24080040 	li	t0,64
9d005908:	0009400b 	movn	t0,zero,t1
		struct setup *setup;
		
		// we just completed a packet transfer
		stat		=	MCF_USB_OTG_STAT;
		tx			=	!! (stat & MCF_USB_OTG_STAT_TX);
		odd			=	!! (stat & MCF_USB_OTG_STAT_ODD);
9d00590c:	7c420080 	ext	v0,v0,0x2,0x1

		// toggle the data toggle flag
		endpoints[endpoint].toggle[tx]	=	endpoints[endpoint].toggle[tx] ? 0 : BD_FLAGS_DATA;
		
		// toggle the next bdt entry to use
		ASSERT(odd == endpoints[endpoint].bdtodd[tx]);
9d005910:	10c20002 	beq	a2,v0,9d00591c <IntUSB1Handler+0x204>
9d005914:	a0a80000 	sb	t0,0(a1)
9d005918:	7000003f 	sdbbp
		endpoints[endpoint].bdtodd[tx]	=	! endpoints[endpoint].bdtodd[tx];

		bdt	=	MYBDT(endpoint, tx, odd);
9d00591c:	00072840 	sll	a1,a3,0x1
9d005920:	00a42821 	addu	a1,a1,a0
9d005924:	00052840 	sll	a1,a1,0x1
		// toggle the data toggle flag
		endpoints[endpoint].toggle[tx]	=	endpoints[endpoint].toggle[tx] ? 0 : BD_FLAGS_DATA;
		
		// toggle the next bdt entry to use
		ASSERT(odd == endpoints[endpoint].bdtodd[tx]);
		endpoints[endpoint].bdtodd[tx]	=	! endpoints[endpoint].bdtodd[tx];
9d005928:	02934023 	subu	t0,s4,s3

		bdt	=	MYBDT(endpoint, tx, odd);
9d00592c:	00a21021 	addu	v0,a1,v0
		// toggle the data toggle flag
		endpoints[endpoint].toggle[tx]	=	endpoints[endpoint].toggle[tx] ? 0 : BD_FLAGS_DATA;
		
		// toggle the next bdt entry to use
		ASSERT(odd == endpoints[endpoint].bdtodd[tx]);
		endpoints[endpoint].bdtodd[tx]	=	! endpoints[endpoint].bdtodd[tx];
9d005930:	01042021 	addu	a0,t0,a0
9d005934:	02242021 	addu	a0,s1,a0
9d005938:	2cc60001 	sltiu	a2,a2,1

		bdt	=	MYBDT(endpoint, tx, odd);
9d00593c:	000210c0 	sll	v0,v0,0x3
		// toggle the data toggle flag
		endpoints[endpoint].toggle[tx]	=	endpoints[endpoint].toggle[tx] ? 0 : BD_FLAGS_DATA;
		
		// toggle the next bdt entry to use
		ASSERT(odd == endpoints[endpoint].bdtodd[tx]);
		endpoints[endpoint].bdtodd[tx]	=	! endpoints[endpoint].bdtodd[tx];
9d005940:	a0860002 	sb	a2,2(a0)

		bdt	=	MYBDT(endpoint, tx, odd);
9d005944:	00621021 	addu	v0,v1,v0

		flags	=	TF_LITTLE(bdt->flags);
9d005948:	90450000 	lbu	a1,0(v0)
9d00594c:	90440001 	lbu	a0,1(v0)
9d005950:	90430002 	lbu	v1,2(v0)
9d005954:	90460003 	lbu	a2,3(v0)
9d005958:	308400ff 	andi	a0,a0,0xff
9d00595c:	30a500ff 	andi	a1,a1,0xff
9d005960:	00042200 	sll	a0,a0,0x8
9d005964:	306300ff 	andi	v1,v1,0xff
9d005968:	00852025 	or	a0,a0,a1
9d00596c:	00031c00 	sll	v1,v1,0x10
9d005970:	00641825 	or	v1,v1,a0
9d005974:	00063600 	sll	a2,a2,0x18
9d005978:	00c33025 	or	a2,a2,v1
		assert(! (flags & BD_FLAGS_OWN));

		bc	=	BD_FLAGS_BC_DEC(flags);
		assert(bc >= 0);

		pid	=	BD_FLAGS_TOK_PID_DEC(flags);
9d00597c:	7cc31880 	ext	v1,a2,0x2,0x4

		// if we're starting a new control transfer...
		if (pid == TOKEN_SETUP)
9d005980:	2404000d 	li	a0,13
9d005984:	10640099 	beq	v1,a0,9d005bec <IntUSB1Handler+0x4d4>
9d005988:	00000000 	nop
				}
			}
			assert((unsigned)endpoint < LENGTHOF(endpoints));
			assert(endpoints[endpoint].data_length <= sizeof(endpoints[endpoint].data_buffer));
		}
		else if (! endpoint)
9d00598c:	14e0007a 	bnez	a3,9d005b78 <IntUSB1Handler+0x460>
9d005990:	7cc64c00 	ext	a2,a2,0x10,0xa
		{
			assert(pid == TOKEN_IN || pid == TOKEN_OUT);
			data	=	(byte *)TF_LITTLE((int)PA_TO_KVA1((int)bdt->buffer));

			// if this is part of the data transfer...
			if (pid == endpoints[endpoint].data_pid)
9d005994:	92240006 	lbu	a0,6(s1)
			assert(endpoints[endpoint].data_length <= sizeof(endpoints[endpoint].data_buffer));
		}
		else if (! endpoint)
		{
			assert(pid == TOKEN_IN || pid == TOKEN_OUT);
			data	=	(byte *)TF_LITTLE((int)PA_TO_KVA1((int)bdt->buffer));
9d005998:	90450004 	lbu	a1,4(v0)
9d00599c:	90450005 	lbu	a1,5(v0)
9d0059a0:	90450006 	lbu	a1,6(v0)
9d0059a4:	90420007 	lbu	v0,7(v0)

			// if this is part of the data transfer...
			if (pid == endpoints[endpoint].data_pid)
9d0059a8:	108300ff 	beq	a0,v1,9d005da8 <IntUSB1Handler+0x690>
9d0059ac:	93828090 	lbu	v0,-32624(gp)
			else
			{
				assert(data == PA_TO_KVA1(0));

				// update our address after status
				if (next_address)
9d0059b0:	50400007 	beqzl	v0,9d0059d0 <IntUSB1Handler+0x2b8>
9d0059b4:	24020040 	li	v0,64
				{
					MCF_USB_OTG_ADDR |= next_address;
9d0059b8:	3c03bf88 	lui	v1,0xbf88
9d0059bc:	8c645260 	lw	a0,21088(v1)
					next_address	=	0;
9d0059c0:	a3808090 	sb	zero,-32624(gp)
				assert(data == PA_TO_KVA1(0));

				// update our address after status
				if (next_address)
				{
					MCF_USB_OTG_ADDR |= next_address;
9d0059c4:	00441025 	or	v0,v0,a0
9d0059c8:	ac625260 	sw	v0,21088(v1)
					next_address	=	0;
				}

				// setup always uses data0; following transactions start with data1
				endpoints[endpoint].toggle[0]	=	0;
				endpoints[endpoint].toggle[1]	=	BD_FLAGS_DATA;
9d0059cc:	24020040 	li	v0,64
					MCF_USB_OTG_ADDR |= next_address;
					next_address	=	0;
				}

				// setup always uses data0; following transactions start with data1
				endpoints[endpoint].toggle[0]	=	0;
9d0059d0:	a2401790 	sb	zero,6032(s2)
				endpoints[endpoint].toggle[1]	=	BD_FLAGS_DATA;

				// prepare to receive setup token
				usb_device_enqueue(0, 0, setup_buffer, sizeof(setup_buffer));
9d0059d4:	00002021 	move	a0,zero
9d0059d8:	00002821 	move	a1,zero
9d0059dc:	27868094 	addiu	a2,gp,-32620
9d0059e0:	24070008 	li	a3,8
9d0059e4:	0f401586 	jal	9d005618 <usb_device_enqueue>
9d0059e8:	a2220001 	sb	v0,1(s1)
			// we just received or sent data from or to the host
			assert(gBulk_transfer_cbfn);
			gBulk_transfer_cbfn(pid == TOKEN_IN, data, bc);
		}

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_TOK_DNE;
9d0059ec:	24020008 	li	v0,8
9d0059f0:	ae025200 	sw	v0,20992(s0)
	}

	// if we just got reset by the host...
	if (MCF_USB_OTG_INT_STAT & MCF_USB_OTG_INT_STAT_USB_RST)
9d0059f4:	8e025200 	lw	v0,20992(s0)
9d0059f8:	30420001 	andi	v0,v0,0x1
9d0059fc:	1040ff7f 	beqz	v0,9d0057fc <IntUSB1Handler+0xe4>
9d005a00:	3c02bf88 	lui	v0,0xbf88
// waiting for a "set configuration" command from the host.
//************************************************************************
static void	usb_device_default()
{
	// default to address 0 on reset
	MCF_USB_OTG_ADDR	=	(uint8)0;
9d005a04:	ac405260 	sw	zero,21088(v0)

	// enable usb device mode
	MCF_USB_OTG_CTL |= MCF_USB_OTG_CTL_ODD_RST;
9d005a08:	3c02bf88 	lui	v0,0xbf88
9d005a0c:	8c435250 	lw	v1,21072(v0)
	MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_ODD_RST;

	memset(bdts, 0, BDT_RAM_SIZE);
9d005a10:	8f848068 	lw	a0,-32664(gp)
	memset(endpoints, 0, sizeof(endpoints));
9d005a14:	3c12a000 	lui	s2,0xa000
{
	// default to address 0 on reset
	MCF_USB_OTG_ADDR	=	(uint8)0;

	// enable usb device mode
	MCF_USB_OTG_CTL |= MCF_USB_OTG_CTL_ODD_RST;
9d005a18:	34630002 	ori	v1,v1,0x2
9d005a1c:	ac435250 	sw	v1,21072(v0)
	MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_ODD_RST;
9d005a20:	8c465250 	lw	a2,21072(v0)
9d005a24:	2403fffd 	li	v1,-3

	memset(bdts, 0, BDT_RAM_SIZE);
9d005a28:	00002821 	move	a1,zero
	// default to address 0 on reset
	MCF_USB_OTG_ADDR	=	(uint8)0;

	// enable usb device mode
	MCF_USB_OTG_CTL |= MCF_USB_OTG_CTL_ODD_RST;
	MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_ODD_RST;
9d005a2c:	00c31824 	and	v1,a2,v1

	memset(bdts, 0, BDT_RAM_SIZE);
	memset(endpoints, 0, sizeof(endpoints));
9d005a30:	26511790 	addiu	s1,s2,6032

	// enable usb device mode
	MCF_USB_OTG_CTL |= MCF_USB_OTG_CTL_ODD_RST;
	MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_ODD_RST;

	memset(bdts, 0, BDT_RAM_SIZE);
9d005a34:	24060100 	li	a2,256
	// default to address 0 on reset
	MCF_USB_OTG_ADDR	=	(uint8)0;

	// enable usb device mode
	MCF_USB_OTG_CTL |= MCF_USB_OTG_CTL_ODD_RST;
	MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_ODD_RST;
9d005a38:	ac435250 	sw	v1,21072(v0)
	}

	// if we just got reset by the host...
	if (MCF_USB_OTG_INT_STAT & MCF_USB_OTG_INT_STAT_USB_RST)
	{
		gCdcacm_active		=	0;
9d005a3c:	a38080de 	sb	zero,-32546(gp)

	// enable usb device mode
	MCF_USB_OTG_CTL |= MCF_USB_OTG_CTL_ODD_RST;
	MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_ODD_RST;

	memset(bdts, 0, BDT_RAM_SIZE);
9d005a40:	0f401c0d 	jal	9d007034 <memset>
9d005a44:	a38080cc 	sb	zero,-32564(gp)
	memset(endpoints, 0, sizeof(endpoints));
9d005a48:	00002821 	move	a1,zero
9d005a4c:	24060180 	li	a2,384
9d005a50:	0f401c0d 	jal	9d007034 <memset>
9d005a54:	02202021 	move	a0,s1

	assert(configuration_descriptor);

	// extract the maximum packet size from the device descriptor
	endpoints[0].packetsize	=	device_descriptor[7];
9d005a58:	8f82807c 	lw	v0,-32644(gp)
static void	parse_configuration(const byte *configuration, int size)
{
unsigned int ii;

	// extract the bulk endpoint information
	for (ii = 0; ii < size; ii += configuration[ii])
9d005a5c:	8f858078 	lw	a1,-32648(gp)

	// extract the maximum packet size from the device descriptor
	endpoints[0].packetsize	=	device_descriptor[7];

	// parse the configuration descriptor
	parse_configuration(configuration_descriptor, configuration_descriptor_length);
9d005a60:	8f868074 	lw	a2,-32652(gp)
	memset(endpoints, 0, sizeof(endpoints));

	assert(configuration_descriptor);

	// extract the maximum packet size from the device descriptor
	endpoints[0].packetsize	=	device_descriptor[7];
9d005a64:	90420007 	lbu	v0,7(v0)
static void	parse_configuration(const byte *configuration, int size)
{
unsigned int ii;

	// extract the bulk endpoint information
	for (ii = 0; ii < size; ii += configuration[ii])
9d005a68:	10a00024 	beqz	a1,9d005afc <IntUSB1Handler+0x3e4>
9d005a6c:	a2220004 	sb	v0,4(s1)
9d005a70:	00001021 	move	v0,zero
	{
		if (configuration[ii+1] == ENDPOINT_DESCRIPTOR)
9d005a74:	24070005 	li	a3,5
		{
			if (configuration[ii+3] == BULK_ATTRIBUTES)
9d005a78:	24080002 	li	t0,2
					assert(bulk_out_ep < LENGTHOF(endpoints));
					assert(configuration[ii+4]);
					endpoints[bulk_out_ep].packetsize	=	configuration[ii+4];
				}
			}
			else if (configuration[ii+3] == INTERRUPT_ATTRIBUTES)
9d005a7c:	24090003 	li	t1,3
			{
				int_ep	=	(byte)(configuration[ii+2] & 0xf);
				assert(int_ep < LENGTHOF(endpoints));
				assert(configuration[ii+4]);
				endpoints[int_ep].packetsize	=	configuration[ii+4];
				endpoints[int_ep].inter			=	1;
9d005a80:	0b4016a7 	j	9d005a9c <IntUSB1Handler+0x384>
9d005a84:	240d0001 	li	t5,1
static void	parse_configuration(const byte *configuration, int size)
{
unsigned int ii;

	// extract the bulk endpoint information
	for (ii = 0; ii < size; ii += configuration[ii])
9d005a88:	90630000 	lbu	v1,0(v1)
9d005a8c:	00431021 	addu	v0,v0,v1
9d005a90:	0045182b 	sltu	v1,v0,a1
9d005a94:	5060001a 	beqzl	v1,9d005b00 <IntUSB1Handler+0x3e8>
9d005a98:	240200ff 	li	v0,255
	{
		if (configuration[ii+1] == ENDPOINT_DESCRIPTOR)
9d005a9c:	00c21821 	addu	v1,a2,v0
9d005aa0:	90640001 	lbu	a0,1(v1)
9d005aa4:	5487fff9 	bnel	a0,a3,9d005a8c <IntUSB1Handler+0x374>
9d005aa8:	90630000 	lbu	v1,0(v1)
		{
			if (configuration[ii+3] == BULK_ATTRIBUTES)
9d005aac:	90640003 	lbu	a0,3(v1)
9d005ab0:	50880026 	beql	a0,t0,9d005b4c <IntUSB1Handler+0x434>
9d005ab4:	906a0002 	lbu	t2,2(v1)
					assert(bulk_out_ep < LENGTHOF(endpoints));
					assert(configuration[ii+4]);
					endpoints[bulk_out_ep].packetsize	=	configuration[ii+4];
				}
			}
			else if (configuration[ii+3] == INTERRUPT_ATTRIBUTES)
9d005ab8:	5489fff4 	bnel	a0,t1,9d005a8c <IntUSB1Handler+0x374>
9d005abc:	90630000 	lbu	v1,0(v1)
			{
				int_ep	=	(byte)(configuration[ii+2] & 0xf);
9d005ac0:	90640002 	lbu	a0,2(v1)
9d005ac4:	3084000f 	andi	a0,a0,0xf
9d005ac8:	a38480ce 	sb	a0,-32562(gp)
				assert(int_ep < LENGTHOF(endpoints));
				assert(configuration[ii+4]);
				endpoints[int_ep].packetsize	=	configuration[ii+4];
9d005acc:	906a0004 	lbu	t2,4(v1)
9d005ad0:	00045940 	sll	t3,a0,0x5
9d005ad4:	000421c0 	sll	a0,a0,0x7
9d005ad8:	008b2023 	subu	a0,a0,t3
9d005adc:	02242021 	addu	a0,s1,a0
9d005ae0:	a08a0004 	sb	t2,4(a0)
				endpoints[int_ep].inter			=	1;
9d005ae4:	a08d0005 	sb	t5,5(a0)
static void	parse_configuration(const byte *configuration, int size)
{
unsigned int ii;

	// extract the bulk endpoint information
	for (ii = 0; ii < size; ii += configuration[ii])
9d005ae8:	90630000 	lbu	v1,0(v1)
9d005aec:	00431021 	addu	v0,v0,v1
9d005af0:	0045182b 	sltu	v1,v0,a1
9d005af4:	1460ffea 	bnez	v1,9d005aa0 <IntUSB1Handler+0x388>
9d005af8:	00c21821 	addu	v1,a2,v0

	// parse the configuration descriptor
	parse_configuration(configuration_descriptor, configuration_descriptor_length);

	// enable (also) usb sleep and token done interrupts
	MCF_USB_OTG_INT_STAT	=	0xff;
9d005afc:	240200ff 	li	v0,255
9d005b00:	ae025200 	sw	v0,20992(s0)
	MCF_USB_OTG_INT_ENB |= MCF_USB_OTG_INT_ENB_SLEEP_EN|MCF_USB_OTG_INT_ENB_TOK_DNE_EN;
9d005b04:	3c02bf88 	lui	v0,0xbf88
9d005b08:	8c435210 	lw	v1,21008(v0)
9d005b0c:	34630018 	ori	v1,v1,0x18
9d005b10:	ac435210 	sw	v1,21008(v0)
		gCdcacm_attached	=	0;

		usb_device_default();

		assert(gReset_cbfn);
		gReset_cbfn();
9d005b14:	8f828084 	lw	v0,-32636(gp)
9d005b18:	0040f809 	jalr	v0
9d005b1c:	00000000 	nop

		// setup always uses data0; following transactions start with data1
		endpoints[0].toggle[0]	=	0;
		endpoints[0].toggle[1]	=	BD_FLAGS_DATA;
9d005b20:	24020040 	li	v0,64

		assert(gReset_cbfn);
		gReset_cbfn();

		// setup always uses data0; following transactions start with data1
		endpoints[0].toggle[0]	=	0;
9d005b24:	a2401790 	sb	zero,6032(s2)
		endpoints[0].toggle[1]	=	BD_FLAGS_DATA;

		// prepare to receive setup token
		usb_device_enqueue(0, 0, setup_buffer, sizeof(setup_buffer));
9d005b28:	00002021 	move	a0,zero
		assert(gReset_cbfn);
		gReset_cbfn();

		// setup always uses data0; following transactions start with data1
		endpoints[0].toggle[0]	=	0;
		endpoints[0].toggle[1]	=	BD_FLAGS_DATA;
9d005b2c:	a2220001 	sb	v0,1(s1)

		// prepare to receive setup token
		usb_device_enqueue(0, 0, setup_buffer, sizeof(setup_buffer));
9d005b30:	00002821 	move	a1,zero
9d005b34:	27868094 	addiu	a2,gp,-32620
9d005b38:	0f401586 	jal	9d005618 <usb_device_enqueue>
9d005b3c:	24070008 	li	a3,8

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_USB_RST;
9d005b40:	24020001 	li	v0,1
9d005b44:	0b4015ff 	j	9d0057fc <IntUSB1Handler+0xe4>
9d005b48:	ae025200 	sw	v0,20992(s0)
					assert(configuration[ii+4]);
					endpoints[bulk_in_ep].packetsize	=	configuration[ii+4];
				}
				else
				{
					bulk_out_ep	=	(byte)(configuration[ii+2] & 0xf);
9d005b4c:	3144000f 	andi	a0,t2,0xf
					assert(bulk_out_ep < LENGTHOF(endpoints));
					assert(configuration[ii+4]);
					endpoints[bulk_out_ep].packetsize	=	configuration[ii+4];
9d005b50:	00045940 	sll	t3,a0,0x5
9d005b54:	000461c0 	sll	t4,a0,0x7
9d005b58:	018b6023 	subu	t4,t4,t3
	{
		if (configuration[ii+1] == ENDPOINT_DESCRIPTOR)
		{
			if (configuration[ii+3] == BULK_ATTRIBUTES)
			{
				if (configuration[ii+2] & 0x80)
9d005b5c:	7c0a5c20 	seb	t3,t2
9d005b60:	0560001e 	bltz	t3,9d005bdc <IntUSB1Handler+0x4c4>
9d005b64:	022c6021 	addu	t4,s1,t4
					assert(configuration[ii+4]);
					endpoints[bulk_in_ep].packetsize	=	configuration[ii+4];
				}
				else
				{
					bulk_out_ep	=	(byte)(configuration[ii+2] & 0xf);
9d005b68:	a38480cd 	sb	a0,-32563(gp)
					assert(bulk_out_ep < LENGTHOF(endpoints));
					assert(configuration[ii+4]);
					endpoints[bulk_out_ep].packetsize	=	configuration[ii+4];
9d005b6c:	90640004 	lbu	a0,4(v1)
9d005b70:	0b4016a2 	j	9d005a88 <IntUSB1Handler+0x370>
9d005b74:	a1840004 	sb	a0,4(t4)

				// prepare to receive setup token
				usb_device_enqueue(0, 0, setup_buffer, sizeof(setup_buffer));
			}
		}
		else if (endpoint != int_ep)
9d005b78:	938480ce 	lbu	a0,-32562(gp)
9d005b7c:	5087ff9c 	beql	a0,a3,9d0059f0 <IntUSB1Handler+0x2d8>
9d005b80:	24020008 	li	v0,8
		{
			assert(pid == TOKEN_IN || pid == TOKEN_OUT);
			data	=	(byte *)TF_LITTLE((int)PA_TO_KVA1((int)bdt->buffer));
9d005b84:	90470004 	lbu	a3,4(v0)
9d005b88:	90440005 	lbu	a0,5(v0)
9d005b8c:	90480006 	lbu	t0,6(v0)
9d005b90:	90450007 	lbu	a1,7(v0)
9d005b94:	308400ff 	andi	a0,a0,0xff
9d005b98:	30e700ff 	andi	a3,a3,0xff
9d005b9c:	310200ff 	andi	v0,t0,0xff
9d005ba0:	00042200 	sll	a0,a0,0x8
9d005ba4:	00872025 	or	a0,a0,a3
9d005ba8:	00021400 	sll	v0,v0,0x10
9d005bac:	00441025 	or	v0,v0,a0
9d005bb0:	00052e00 	sll	a1,a1,0x18
9d005bb4:	00a22825 	or	a1,a1,v0

			// we just received or sent data from or to the host
			assert(gBulk_transfer_cbfn);
			gBulk_transfer_cbfn(pid == TOKEN_IN, data, bc);
9d005bb8:	3c02a000 	lui	v0,0xa000
9d005bbc:	00a22825 	or	a1,a1,v0
9d005bc0:	8f82808c 	lw	v0,-32628(gp)
9d005bc4:	38630009 	xori	v1,v1,0x9
9d005bc8:	0040f809 	jalr	v0
9d005bcc:	2c640001 	sltiu	a0,v1,1
		}

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_TOK_DNE;
9d005bd0:	24020008 	li	v0,8
9d005bd4:	0b40167d 	j	9d0059f4 <IntUSB1Handler+0x2dc>
9d005bd8:	ae025200 	sw	v0,20992(s0)
		{
			if (configuration[ii+3] == BULK_ATTRIBUTES)
			{
				if (configuration[ii+2] & 0x80)
				{
					bulk_in_ep	=	(byte)(configuration[ii+2] & 0xf);
9d005bdc:	a38480cf 	sb	a0,-32561(gp)
					assert(bulk_in_ep < LENGTHOF(endpoints));
					assert(configuration[ii+4]);
					endpoints[bulk_in_ep].packetsize	=	configuration[ii+4];
9d005be0:	906b0004 	lbu	t3,4(v1)
9d005be4:	0b4016a2 	j	9d005a88 <IntUSB1Handler+0x370>
9d005be8:	a18b0004 	sb	t3,4(t4)
		{
			assert(! endpoint);
			assert(bc == 8);
			assert(! tx);

			setup	=	(struct setup *)TF_LITTLE((int)PA_TO_KVA1((int)bdt->buffer));
9d005bec:	90490004 	lbu	t1,4(v0)
9d005bf0:	90460005 	lbu	a2,5(v0)
9d005bf4:	904a0006 	lbu	t2,6(v0)
9d005bf8:	90440007 	lbu	a0,7(v0)
9d005bfc:	30c600ff 	andi	a2,a2,0xff
			assert((void *)setup == (void *)setup_buffer);

			// unsuspend the usb packet engine
			MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_TXSUSPEND_TOKENBUSY;
9d005c00:	3c03bf88 	lui	v1,0xbf88
		{
			assert(! endpoint);
			assert(bc == 8);
			assert(! tx);

			setup	=	(struct setup *)TF_LITTLE((int)PA_TO_KVA1((int)bdt->buffer));
9d005c04:	312900ff 	andi	t1,t1,0xff
9d005c08:	00063200 	sll	a2,a2,0x8
9d005c0c:	314200ff 	andi	v0,t2,0xff
			assert((void *)setup == (void *)setup_buffer);

			// unsuspend the usb packet engine
			MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_TXSUSPEND_TOKENBUSY;
9d005c10:	8c655250 	lw	a1,21072(v1)
		{
			assert(! endpoint);
			assert(bc == 8);
			assert(! tx);

			setup	=	(struct setup *)TF_LITTLE((int)PA_TO_KVA1((int)bdt->buffer));
9d005c14:	00c93025 	or	a2,a2,t1
9d005c18:	00021400 	sll	v0,v0,0x10
9d005c1c:	00461025 	or	v0,v0,a2
9d005c20:	00042600 	sll	a0,a0,0x18
9d005c24:	00822025 	or	a0,a0,v0
			assert((void *)setup == (void *)setup_buffer);

			// unsuspend the usb packet engine
			MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_TXSUSPEND_TOKENBUSY;
9d005c28:	2402ffdf 	li	v0,-33
9d005c2c:	00a21024 	and	v0,a1,v0
		{
			assert(! endpoint);
			assert(bc == 8);
			assert(! tx);

			setup	=	(struct setup *)TF_LITTLE((int)PA_TO_KVA1((int)bdt->buffer));
9d005c30:	3c05a000 	lui	a1,0xa000
9d005c34:	00852025 	or	a0,a0,a1
			// unsuspend the usb packet engine
			MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_TXSUSPEND_TOKENBUSY;

			length	=	TF_LITTLE(setup->length);

			endpoints[endpoint].data_pid	=	TOKEN_OUT;
9d005c38:	01119021 	addu	s2,t0,s1

			setup	=	(struct setup *)TF_LITTLE((int)PA_TO_KVA1((int)bdt->buffer));
			assert((void *)setup == (void *)setup_buffer);

			// unsuspend the usb packet engine
			MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_TXSUSPEND_TOKENBUSY;
9d005c3c:	ac625250 	sw	v0,21072(v1)

			length	=	TF_LITTLE(setup->length);

			endpoints[endpoint].data_pid	=	TOKEN_OUT;
9d005c40:	24030001 	li	v1,1
			assert((void *)setup == (void *)setup_buffer);

			// unsuspend the usb packet engine
			MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_TXSUSPEND_TOKENBUSY;

			length	=	TF_LITTLE(setup->length);
9d005c44:	90850006 	lbu	a1,6(a0)
9d005c48:	90820007 	lbu	v0,7(a0)

			endpoints[endpoint].data_pid	=	TOKEN_OUT;
9d005c4c:	a2430006 	sb	v1,6(s2)
			endpoints[endpoint].data_length	=	0;
			endpoints[endpoint].data_offset	=	0;

			// is this a standard command...
			if (! (setup->requesttype & 0x60))
9d005c50:	90830000 	lbu	v1,0(a0)
			assert((void *)setup == (void *)setup_buffer);

			// unsuspend the usb packet engine
			MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_TXSUSPEND_TOKENBUSY;

			length	=	TF_LITTLE(setup->length);
9d005c54:	00021200 	sll	v0,v0,0x8
9d005c58:	00451025 	or	v0,v0,a1
			endpoints[endpoint].data_pid	=	TOKEN_OUT;
			endpoints[endpoint].data_length	=	0;
			endpoints[endpoint].data_offset	=	0;

			// is this a standard command...
			if (! (setup->requesttype & 0x60))
9d005c5c:	30650060 	andi	a1,v1,0x60
			assert((void *)setup == (void *)setup_buffer);

			// unsuspend the usb packet engine
			MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_TXSUSPEND_TOKENBUSY;

			length	=	TF_LITTLE(setup->length);
9d005c60:	7c021620 	seh	v0,v0

			endpoints[endpoint].data_pid	=	TOKEN_OUT;
			endpoints[endpoint].data_length	=	0;
9d005c64:	ae40000c 	sw	zero,12(s2)
			endpoints[endpoint].data_offset	=	0;

			// is this a standard command...
			if (! (setup->requesttype & 0x60))
9d005c68:	14a0001d 	bnez	a1,9d005ce0 <IntUSB1Handler+0x5c8>
9d005c6c:	ae400008 	sw	zero,8(s2)
			{
				value	=	TF_LITTLE(setup->value);
9d005c70:	90860003 	lbu	a2,3(a0)
9d005c74:	90890002 	lbu	t1,2(a0)
				if (setup->request == REQUEST_GET_DESCRIPTOR)
9d005c78:	90850001 	lbu	a1,1(a0)
			endpoints[endpoint].data_offset	=	0;

			// is this a standard command...
			if (! (setup->requesttype & 0x60))
			{
				value	=	TF_LITTLE(setup->value);
9d005c7c:	00063200 	sll	a2,a2,0x8
9d005c80:	00c93025 	or	a2,a2,t1
9d005c84:	7c064e20 	seh	t1,a2
				if (setup->request == REQUEST_GET_DESCRIPTOR)
9d005c88:	24060006 	li	a2,6
9d005c8c:	50a60029 	beql	a1,a2,9d005d34 <IntUSB1Handler+0x61c>
9d005c90:	24040009 	li	a0,9
					assert(endpoints[endpoint].toggle[1] == BD_FLAGS_DATA);
					usb_device_enqueue(0, 1, endpoints[endpoint].data_buffer, MIN(endpoints[endpoint].data_length, endpoints[endpoint].packetsize));
				}
				else
				{
					if (setup->request == REQUEST_CLEAR_FEATURE)
9d005c94:	24020001 	li	v0,1
9d005c98:	50a20053 	beql	a1,v0,9d005de8 <IntUSB1Handler+0x6d0>
9d005c9c:	24020002 	li	v0,2
						else
						{
							assert(0);
						}
					}
					else if (setup->request == REQUEST_SET_ADDRESS)
9d005ca0:	24030005 	li	v1,5
9d005ca4:	10a30069 	beq	a1,v1,9d005e4c <IntUSB1Handler+0x734>
9d005ca8:	24030009 	li	v1,9
					{
						next_address	=	value;
					}
					else if (setup->request == REQUEST_SET_CONFIGURATION)
9d005cac:	50a30081 	beql	a1,v1,9d005eb4 <IntUSB1Handler+0x79c>
9d005cb0:	a38280cc 	sb	v0,-32564(gp)
					{
						assert(value == 1);
						gCdcacm_attached_count++;
						gCdcacm_attached	=	1;
					}
					else if (setup->request == REQUEST_GET_CONFIGURATION)
9d005cb4:	24040008 	li	a0,8
9d005cb8:	50a400ac 	beql	a1,a0,9d005f6c <IntUSB1Handler+0x854>
9d005cbc:	92450004 	lbu	a1,4(s2)

						// status uses data1
						assert(endpoints[endpoint].toggle[1] == BD_FLAGS_DATA);

						// prepare to transfer status (in the other direction)
						usb_device_enqueue(0, 1, NULL, 0);
9d005cc0:	00002021 	move	a0,zero
9d005cc4:	24050001 	li	a1,1
9d005cc8:	00003021 	move	a2,zero
9d005ccc:	0f401586 	jal	9d005618 <usb_device_enqueue>
9d005cd0:	00003821 	move	a3,zero
			// we just received or sent data from or to the host
			assert(gBulk_transfer_cbfn);
			gBulk_transfer_cbfn(pid == TOKEN_IN, data, bc);
		}

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_TOK_DNE;
9d005cd4:	24020008 	li	v0,8
9d005cd8:	0b40167d 	j	9d0059f4 <IntUSB1Handler+0x2dc>
9d005cdc:	ae025200 	sw	v0,20992(s0)
				}
			// otherwise, this is a class or vendor command
			}
			else
			{
				if (setup->requesttype & 0x80/*in*/)
9d005ce0:	7c031c20 	seb	v1,v1
9d005ce4:	04620063 	bltzl	v1,9d005e74 <IntUSB1Handler+0x75c>
9d005ce8:	25080010 	addiu	t0,t0,16
					usb_device_enqueue(0, 1, endpoints[endpoint].data_buffer, endpoints[endpoint].data_length);
				}
				else
				{
					// host is sending data
					if (length)
9d005cec:	5040000b 	beqzl	v0,9d005d1c <IntUSB1Handler+0x604>
9d005cf0:	8f828088 	lw	v0,-32632(gp)
					{
						// we will receive data, TOKEN_OUT(s) will follow
						endpoints[endpoint].data_length	=	length;
						usb_device_enqueue(0, 0, endpoints[endpoint].data_buffer, endpoints[endpoint].packetsize);
9d005cf4:	92470004 	lbu	a3,4(s2)
9d005cf8:	25060010 	addiu	a2,t0,16
				{
					// host is sending data
					if (length)
					{
						// we will receive data, TOKEN_OUT(s) will follow
						endpoints[endpoint].data_length	=	length;
9d005cfc:	ae42000c 	sw	v0,12(s2)
						usb_device_enqueue(0, 0, endpoints[endpoint].data_buffer, endpoints[endpoint].packetsize);
9d005d00:	00002021 	move	a0,zero
9d005d04:	00002821 	move	a1,zero
9d005d08:	0f401586 	jal	9d005618 <usb_device_enqueue>
9d005d0c:	02263021 	addu	a2,s1,a2
			// we just received or sent data from or to the host
			assert(gBulk_transfer_cbfn);
			gBulk_transfer_cbfn(pid == TOKEN_IN, data, bc);
		}

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_TOK_DNE;
9d005d10:	24020008 	li	v0,8
9d005d14:	0b40167d 	j	9d0059f4 <IntUSB1Handler+0x2dc>
9d005d18:	ae025200 	sw	v0,20992(s0)
					}
					else
					{
						// data transfer is done; put it to our caller!
						assert(gControl_transfer_cbfn);
						rv	=	gControl_transfer_cbfn((struct setup *)setup_buffer, NULL, 0);
9d005d1c:	27848094 	addiu	a0,gp,-32620
9d005d20:	00002821 	move	a1,zero
9d005d24:	0040f809 	jalr	v0
9d005d28:	00003021 	move	a2,zero

						// status uses data1
						assert(endpoints[endpoint].toggle[1] == BD_FLAGS_DATA);

						// prepare to transfer status (in the other direction)
						usb_device_enqueue(0, 1, NULL, 0);
9d005d2c:	0b401731 	j	9d005cc4 <IntUSB1Handler+0x5ac>
9d005d30:	00002021 	move	a0,zero
			if (! (setup->requesttype & 0x60))
			{
				value	=	TF_LITTLE(setup->value);
				if (setup->request == REQUEST_GET_DESCRIPTOR)
				{
					endpoints[endpoint].data_pid	=	TOKEN_IN;
9d005d34:	a2440006 	sb	a0,6(s2)

					if ((value >> 8) == DEVICE_DESCRIPTOR)
9d005d38:	00091a03 	sra	v1,t1,0x8
9d005d3c:	24040001 	li	a0,1
9d005d40:	50640080 	beql	v1,a0,9d005f44 <IntUSB1Handler+0x82c>
9d005d44:	8f838080 	lw	v1,-32640(gp)
					{
						assert(device_descriptor_length);
						endpoints[endpoint].data_length	=	MIN(device_descriptor_length, length);
						memcpy(endpoints[endpoint].data_buffer, device_descriptor, endpoints[endpoint].data_length);
					}
					else if ((value >> 8) == CONFIGURATION_DESCRIPTOR)
9d005d48:	24040002 	li	a0,2
9d005d4c:	50640095 	beql	v1,a0,9d005fa4 <IntUSB1Handler+0x88c>
9d005d50:	8f838078 	lw	v1,-32648(gp)
					{
						assert(configuration_descriptor_length);
						endpoints[endpoint].data_length	=	MIN(configuration_descriptor_length, length);
						memcpy(endpoints[endpoint].data_buffer, configuration_descriptor, endpoints[endpoint].data_length);
					}
					else if ((value >> 8) == STRING_DESCRIPTOR)
9d005d54:	24040003 	li	a0,3
9d005d58:	1064005a 	beq	v1,a0,9d005ec4 <IntUSB1Handler+0x7ac>
9d005d5c:	312900ff 	andi	t1,t1,0xff
							assert(string_descriptor[j]);
							endpoints[endpoint].data_length	=	MIN(string_descriptor[j], length);
							memcpy(endpoints[endpoint].data_buffer, string_descriptor+j, endpoints[endpoint].data_length);
						}
					}
					else if ((value >> 8) == DEVICE_QUALIFIER_DESCRIPTOR)
9d005d60:	50650001 	beql	v1,a1,9d005d68 <IntUSB1Handler+0x650>
9d005d64:	ae40000c 	sw	zero,12(s2)
					{
						endpoints[endpoint].data_length	=	0;
9d005d68:	00001021 	move	v0,zero
						assert(0);
					}

					// data phase starts with data1
					assert(endpoints[endpoint].toggle[1] == BD_FLAGS_DATA);
					usb_device_enqueue(0, 1, endpoints[endpoint].data_buffer, MIN(endpoints[endpoint].data_length, endpoints[endpoint].packetsize));
9d005d6c:	02933023 	subu	a2,s4,s3
9d005d70:	02261821 	addu	v1,s1,a2
9d005d74:	90630004 	lbu	v1,4(v1)
9d005d78:	24c60010 	addiu	a2,a2,16
9d005d7c:	00002021 	move	a0,zero
9d005d80:	0062382a 	slt	a3,v1,v0
9d005d84:	00602821 	move	a1,v1
9d005d88:	0047280a 	movz	a1,v0,a3
9d005d8c:	00a03821 	move	a3,a1
9d005d90:	02263021 	addu	a2,s1,a2
9d005d94:	0f401586 	jal	9d005618 <usb_device_enqueue>
9d005d98:	24050001 	li	a1,1
			// we just received or sent data from or to the host
			assert(gBulk_transfer_cbfn);
			gBulk_transfer_cbfn(pid == TOKEN_IN, data, bc);
		}

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_TOK_DNE;
9d005d9c:	24020008 	li	v0,8
9d005da0:	0b40167d 	j	9d0059f4 <IntUSB1Handler+0x2dc>
9d005da4:	ae025200 	sw	v0,20992(s0)

			// if this is part of the data transfer...
			if (pid == endpoints[endpoint].data_pid)
			{
				assert((char *)data >= (char *)endpoints[endpoint].data_buffer && (char *)data < (char *)endpoints[endpoint].data_buffer+sizeof(endpoints[endpoint].data_buffer));
				if (pid == TOKEN_IN)
9d005da8:	24020009 	li	v0,9
9d005dac:	1082001a 	beq	a0,v0,9d005e18 <IntUSB1Handler+0x700>
9d005db0:	8e220008 	lw	v0,8(s1)
					// we just received data from the host
					endpoints[endpoint].data_offset += bc;
					assert(endpoints[endpoint].data_offset <= endpoints[endpoint].data_length);

					// if there's more data to receive...
					if (endpoints[endpoint].data_offset != endpoints[endpoint].data_length)
9d005db4:	8e27000c 	lw	a3,12(s1)
				}
				else
				{
					assert(! tx);
					// we just received data from the host
					endpoints[endpoint].data_offset += bc;
9d005db8:	00c21021 	addu	v0,a2,v0
					assert(endpoints[endpoint].data_offset <= endpoints[endpoint].data_length);

					// if there's more data to receive...
					if (endpoints[endpoint].data_offset != endpoints[endpoint].data_length)
9d005dbc:	10470025 	beq	v0,a3,9d005e54 <IntUSB1Handler+0x73c>
9d005dc0:	ae220008 	sw	v0,8(s1)
					{
						// receive it
						usb_device_enqueue(0, 0, endpoints[endpoint].data_buffer+endpoints[endpoint].data_offset, endpoints[endpoint].data_length-endpoints[endpoint].data_offset);
9d005dc4:	24460010 	addiu	a2,v0,16
9d005dc8:	00e23823 	subu	a3,a3,v0
9d005dcc:	00002021 	move	a0,zero
9d005dd0:	00002821 	move	a1,zero
9d005dd4:	0f401586 	jal	9d005618 <usb_device_enqueue>
9d005dd8:	02263021 	addu	a2,s1,a2
			// we just received or sent data from or to the host
			assert(gBulk_transfer_cbfn);
			gBulk_transfer_cbfn(pid == TOKEN_IN, data, bc);
		}

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_TOK_DNE;
9d005ddc:	24020008 	li	v0,8
9d005de0:	0b40167d 	j	9d0059f4 <IntUSB1Handler+0x2dc>
9d005de4:	ae025200 	sw	v0,20992(s0)
				{
					if (setup->request == REQUEST_CLEAR_FEATURE)
					{
						assert(! length);
						// if we're recovering from an error...
						if (setup->requesttype == 0x02 && ! value)
9d005de8:	5462ffb6 	bnel	v1,v0,9d005cc4 <IntUSB1Handler+0x5ac>
9d005dec:	00002021 	move	a0,zero
9d005df0:	5520ffb4 	bnezl	t1,9d005cc4 <IntUSB1Handler+0x5ac>
9d005df4:	00002021 	move	a0,zero
						{
							endpoint2	=	TF_LITTLE(setup->index) & 0x0f;
9d005df8:	90830004 	lbu	v1,4(a0)
							assert(endpoint2);
							// clear the data toggle
							endpoints[endpoint2].toggle[0]	=	0;
9d005dfc:	24020060 	li	v0,96
					{
						assert(! length);
						// if we're recovering from an error...
						if (setup->requesttype == 0x02 && ! value)
						{
							endpoint2	=	TF_LITTLE(setup->index) & 0x0f;
9d005e00:	3063000f 	andi	v1,v1,0xf
							assert(endpoint2);
							// clear the data toggle
							endpoints[endpoint2].toggle[0]	=	0;
9d005e04:	70622002 	mul	a0,v1,v0
9d005e08:	00918821 	addu	s1,a0,s1
9d005e0c:	a2200000 	sb	zero,0(s1)
							endpoints[endpoint2].toggle[1]	=	0;
9d005e10:	0b401730 	j	9d005cc0 <IntUSB1Handler+0x5a8>
9d005e14:	a2200001 	sb	zero,1(s1)
					// we just sent data to the host
					endpoints[endpoint].data_offset += bc;
					assert(endpoints[endpoint].data_offset <= endpoints[endpoint].data_length);

					// if there's more data to send...
					if (endpoints[endpoint].data_offset != endpoints[endpoint].data_length)
9d005e18:	8e27000c 	lw	a3,12(s1)
				assert((char *)data >= (char *)endpoints[endpoint].data_buffer && (char *)data < (char *)endpoints[endpoint].data_buffer+sizeof(endpoints[endpoint].data_buffer));
				if (pid == TOKEN_IN)
				{
					assert(tx);
					// we just sent data to the host
					endpoints[endpoint].data_offset += bc;
9d005e1c:	00c21021 	addu	v0,a2,v0
					assert(endpoints[endpoint].data_offset <= endpoints[endpoint].data_length);

					// if there's more data to send...
					if (endpoints[endpoint].data_offset != endpoints[endpoint].data_length)
9d005e20:	10470040 	beq	v0,a3,9d005f24 <IntUSB1Handler+0x80c>
9d005e24:	ae220008 	sw	v0,8(s1)
					{
						// send it
						usb_device_enqueue(0, 1, endpoints[endpoint].data_buffer+endpoints[endpoint].data_offset, endpoints[endpoint].data_length-endpoints[endpoint].data_offset);
9d005e28:	24460010 	addiu	a2,v0,16
9d005e2c:	00e23823 	subu	a3,a3,v0
9d005e30:	00002021 	move	a0,zero
9d005e34:	24050001 	li	a1,1
9d005e38:	0f401586 	jal	9d005618 <usb_device_enqueue>
9d005e3c:	02263021 	addu	a2,s1,a2
			// we just received or sent data from or to the host
			assert(gBulk_transfer_cbfn);
			gBulk_transfer_cbfn(pid == TOKEN_IN, data, bc);
		}

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_TOK_DNE;
9d005e40:	24020008 	li	v0,8
9d005e44:	0b40167d 	j	9d0059f4 <IntUSB1Handler+0x2dc>
9d005e48:	ae025200 	sw	v0,20992(s0)
							assert(0);
						}
					}
					else if (setup->request == REQUEST_SET_ADDRESS)
					{
						next_address	=	value;
9d005e4c:	0b401730 	j	9d005cc0 <IntUSB1Handler+0x5a8>
9d005e50:	a3898090 	sb	t1,-32624(gp)
					}
					else
					{
						// put it to our caller!
						assert(gControl_transfer_cbfn);
						rv	=	gControl_transfer_cbfn((struct setup *)setup_buffer, endpoints[endpoint].data_buffer, endpoints[endpoint].data_length);
9d005e54:	00403021 	move	a2,v0
9d005e58:	8f828088 	lw	v0,-32632(gp)
9d005e5c:	3c05a000 	lui	a1,0xa000
9d005e60:	24a517a0 	addiu	a1,a1,6048
9d005e64:	0040f809 	jalr	v0
9d005e68:	27848094 	addiu	a0,gp,-32620

						// status uses data1
						assert(endpoints[endpoint].toggle[1] == BD_FLAGS_DATA);

						// prepare to transfer status (in the other direction)
						usb_device_enqueue(0, 1, NULL, 0);
9d005e6c:	0b401731 	j	9d005cc4 <IntUSB1Handler+0x5ac>
9d005e70:	00002021 	move	a0,zero
			{
				if (setup->requesttype & 0x80/*in*/)
				{
					// host wants to receive data, get it from our caller!
					assert(gControl_transfer_cbfn);
					rv	=	gControl_transfer_cbfn(setup, endpoints[endpoint].data_buffer, length);
9d005e74:	00403021 	move	a2,v0
9d005e78:	8f828088 	lw	v0,-32632(gp)
9d005e7c:	02288821 	addu	s1,s1,t0
9d005e80:	0040f809 	jalr	v0
9d005e84:	02202821 	move	a1,s1
					assert(rv >= 0);
					assert(rv <= length);

					// prepare to send data, TOKEN_IN(s) will follow
					endpoints[endpoint].data_pid	=	TOKEN_IN;
9d005e88:	24030009 	li	v1,9
					assert(rv > 0);	// if you don't have a length, use out!
					endpoints[endpoint].data_length	=	rv;
					usb_device_enqueue(0, 1, endpoints[endpoint].data_buffer, endpoints[endpoint].data_length);
9d005e8c:	00403821 	move	a3,v0
					assert(rv <= length);

					// prepare to send data, TOKEN_IN(s) will follow
					endpoints[endpoint].data_pid	=	TOKEN_IN;
					assert(rv > 0);	// if you don't have a length, use out!
					endpoints[endpoint].data_length	=	rv;
9d005e90:	ae42000c 	sw	v0,12(s2)
					usb_device_enqueue(0, 1, endpoints[endpoint].data_buffer, endpoints[endpoint].data_length);
9d005e94:	00002021 	move	a0,zero
9d005e98:	24050001 	li	a1,1
9d005e9c:	02203021 	move	a2,s1
9d005ea0:	0f401586 	jal	9d005618 <usb_device_enqueue>
9d005ea4:	a2430006 	sb	v1,6(s2)
			// we just received or sent data from or to the host
			assert(gBulk_transfer_cbfn);
			gBulk_transfer_cbfn(pid == TOKEN_IN, data, bc);
		}

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_TOK_DNE;
9d005ea8:	24020008 	li	v0,8
9d005eac:	0b40167d 	j	9d0059f4 <IntUSB1Handler+0x2dc>
9d005eb0:	ae025200 	sw	v0,20992(s0)
						next_address	=	value;
					}
					else if (setup->request == REQUEST_SET_CONFIGURATION)
					{
						assert(value == 1);
						gCdcacm_attached_count++;
9d005eb4:	8f8280d4 	lw	v0,-32556(gp)
9d005eb8:	24420001 	addiu	v0,v0,1
9d005ebc:	0b401730 	j	9d005cc0 <IntUSB1Handler+0x5a8>
9d005ec0:	af8280d4 	sw	v0,-32556(gp)
						int j;

						// find the string descriptor
						i	=	value & 0xff;
						j	=	0;
						while (i-- && j < string_descriptor_length)
9d005ec4:	2524ffff 	addiu	a0,t1,-1
9d005ec8:	1120000e 	beqz	t1,9d005f04 <IntUSB1Handler+0x7ec>
9d005ecc:	00001821 	move	v1,zero
9d005ed0:	8f868070 	lw	a2,-32656(gp)
9d005ed4:	18c0000b 	blez	a2,9d005f04 <IntUSB1Handler+0x7ec>
9d005ed8:	8f89806c 	lw	t1,-32660(gp)
9d005edc:	0b4017bb 	j	9d005eec <IntUSB1Handler+0x7d4>
9d005ee0:	2408ffff 	li	t0,-1
9d005ee4:	50a00008 	beqzl	a1,9d005f08 <IntUSB1Handler+0x7f0>
9d005ee8:	2405ffff 	li	a1,-1
						{
							j += string_descriptor[j];
9d005eec:	01232821 	addu	a1,t1,v1
9d005ef0:	90a50000 	lbu	a1,0(a1)
						int j;

						// find the string descriptor
						i	=	value & 0xff;
						j	=	0;
						while (i-- && j < string_descriptor_length)
9d005ef4:	2484ffff 	addiu	a0,a0,-1
						{
							j += string_descriptor[j];
9d005ef8:	00651821 	addu	v1,v1,a1
						int j;

						// find the string descriptor
						i	=	value & 0xff;
						j	=	0;
						while (i-- && j < string_descriptor_length)
9d005efc:	1488fff9 	bne	a0,t0,9d005ee4 <IntUSB1Handler+0x7cc>
9d005f00:	0066282a 	slt	a1,v1,a2
						{
							j += string_descriptor[j];
						}
						if (i != -1)
9d005f04:	2405ffff 	li	a1,-1
9d005f08:	50850028 	beql	a0,a1,9d005fac <IntUSB1Handler+0x894>
9d005f0c:	24120060 	li	s2,96
						{
							assert(j == string_descriptor_length);
							endpoints[endpoint].data_length	=	0;	// what to return here?
9d005f10:	02931023 	subu	v0,s4,s3
9d005f14:	02221021 	addu	v0,s1,v0
9d005f18:	ac40000c 	sw	zero,12(v0)
9d005f1c:	0b40175b 	j	9d005d6c <IntUSB1Handler+0x654>
9d005f20:	00001021 	move	v0,zero
					{
						// status uses data1
						assert(endpoints[endpoint].toggle[0] == BD_FLAGS_DATA);

						// prepare to transfer status (in the other direction)
						usb_device_enqueue(0, 0, NULL, 0);
9d005f24:	00002021 	move	a0,zero
9d005f28:	00002821 	move	a1,zero
9d005f2c:	00003021 	move	a2,zero
9d005f30:	0f401586 	jal	9d005618 <usb_device_enqueue>
9d005f34:	00003821 	move	a3,zero
			// we just received or sent data from or to the host
			assert(gBulk_transfer_cbfn);
			gBulk_transfer_cbfn(pid == TOKEN_IN, data, bc);
		}

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_TOK_DNE;
9d005f38:	24020008 	li	v0,8
9d005f3c:	0b40167d 	j	9d0059f4 <IntUSB1Handler+0x2dc>
9d005f40:	ae025200 	sw	v0,20992(s0)

					if ((value >> 8) == DEVICE_DESCRIPTOR)
					{
						assert(device_descriptor_length);
						endpoints[endpoint].data_length	=	MIN(device_descriptor_length, length);
						memcpy(endpoints[endpoint].data_buffer, device_descriptor, endpoints[endpoint].data_length);
9d005f44:	8f85807c 	lw	a1,-32644(gp)
					}
					else if ((value >> 8) == CONFIGURATION_DESCRIPTOR)
					{
						assert(configuration_descriptor_length);
						endpoints[endpoint].data_length	=	MIN(configuration_descriptor_length, length);
9d005f48:	0062302a 	slt	a2,v1,v0
9d005f4c:	0066100b 	movn	v0,v1,a2
						memcpy(endpoints[endpoint].data_buffer, configuration_descriptor, endpoints[endpoint].data_length);
9d005f50:	25040010 	addiu	a0,t0,16
9d005f54:	02242021 	addu	a0,s1,a0
9d005f58:	00403021 	move	a2,v0
9d005f5c:	0f401c02 	jal	9d007008 <memcpy>
9d005f60:	ae42000c 	sw	v0,12(s2)
9d005f64:	0b40175b 	j	9d005d6c <IntUSB1Handler+0x654>
9d005f68:	8e42000c 	lw	v0,12(s2)
						endpoints[endpoint].data_length	=	1;
						endpoints[endpoint].data_buffer[0]	=	1;

						// data phase starts with data1
						assert(endpoints[endpoint].toggle[1] == BD_FLAGS_DATA);
						usb_device_enqueue(0, 1, endpoints[endpoint].data_buffer, MIN(endpoints[endpoint].data_length, endpoints[endpoint].packetsize));
9d005f6c:	25060010 	addiu	a2,t0,16
					}
					else if (setup->request == REQUEST_GET_CONFIGURATION)
					{
						endpoints[endpoint].data_pid	=	TOKEN_IN;

						endpoints[endpoint].data_length	=	1;
9d005f70:	ae42000c 	sw	v0,12(s2)
						endpoints[endpoint].data_buffer[0]	=	1;

						// data phase starts with data1
						assert(endpoints[endpoint].toggle[1] == BD_FLAGS_DATA);
						usb_device_enqueue(0, 1, endpoints[endpoint].data_buffer, MIN(endpoints[endpoint].data_length, endpoints[endpoint].packetsize));
9d005f74:	0045382a 	slt	a3,v0,a1
9d005f78:	0047280b 	movn	a1,v0,a3
9d005f7c:	00a03821 	move	a3,a1
					else if (setup->request == REQUEST_GET_CONFIGURATION)
					{
						endpoints[endpoint].data_pid	=	TOKEN_IN;

						endpoints[endpoint].data_length	=	1;
						endpoints[endpoint].data_buffer[0]	=	1;
9d005f80:	a2420010 	sb	v0,16(s2)

						// data phase starts with data1
						assert(endpoints[endpoint].toggle[1] == BD_FLAGS_DATA);
						usb_device_enqueue(0, 1, endpoints[endpoint].data_buffer, MIN(endpoints[endpoint].data_length, endpoints[endpoint].packetsize));
9d005f84:	00002021 	move	a0,zero
9d005f88:	24050001 	li	a1,1
9d005f8c:	02263021 	addu	a2,s1,a2
9d005f90:	0f401586 	jal	9d005618 <usb_device_enqueue>
9d005f94:	a2430006 	sb	v1,6(s2)
			// we just received or sent data from or to the host
			assert(gBulk_transfer_cbfn);
			gBulk_transfer_cbfn(pid == TOKEN_IN, data, bc);
		}

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_TOK_DNE;
9d005f98:	24020008 	li	v0,8
9d005f9c:	0b40167d 	j	9d0059f4 <IntUSB1Handler+0x2dc>
9d005fa0:	ae025200 	sw	v0,20992(s0)
					}
					else if ((value >> 8) == CONFIGURATION_DESCRIPTOR)
					{
						assert(configuration_descriptor_length);
						endpoints[endpoint].data_length	=	MIN(configuration_descriptor_length, length);
						memcpy(endpoints[endpoint].data_buffer, configuration_descriptor, endpoints[endpoint].data_length);
9d005fa4:	0b4017d2 	j	9d005f48 <IntUSB1Handler+0x830>
9d005fa8:	8f858074 	lw	a1,-32652(gp)
							endpoints[endpoint].data_length	=	0;	// what to return here?
						}
						else
						{
							assert(string_descriptor[j]);
							endpoints[endpoint].data_length	=	MIN(string_descriptor[j], length);
9d005fac:	70f29002 	mul	s2,a3,s2
9d005fb0:	8f85806c 	lw	a1,-32660(gp)
9d005fb4:	00a32821 	addu	a1,a1,v1
9d005fb8:	90a30000 	lbu	v1,0(a1)
9d005fbc:	0043202a 	slt	a0,v0,v1
9d005fc0:	0064100a 	movz	v0,v1,a0
							memcpy(endpoints[endpoint].data_buffer, string_descriptor+j, endpoints[endpoint].data_length);
9d005fc4:	00403021 	move	a2,v0
9d005fc8:	26440010 	addiu	a0,s2,16
							endpoints[endpoint].data_length	=	0;	// what to return here?
						}
						else
						{
							assert(string_descriptor[j]);
							endpoints[endpoint].data_length	=	MIN(string_descriptor[j], length);
9d005fcc:	02329021 	addu	s2,s1,s2
							memcpy(endpoints[endpoint].data_buffer, string_descriptor+j, endpoints[endpoint].data_length);
9d005fd0:	02242021 	addu	a0,s1,a0
9d005fd4:	0f401c02 	jal	9d007008 <memcpy>
9d005fd8:	ae42000c 	sw	v0,12(s2)
9d005fdc:	0b40175b 	j	9d005d6c <IntUSB1Handler+0x654>
9d005fe0:	8e42000c 	lw	v0,12(s2)

9d005fe4 <usb_register>:
// this function is called by upper level code to register callback
// functions.
//************************************************************************
void	usb_register(usb_reset_cbfn reset, usb_control_cbfn control_transfer, usb_bulk_cbfn bulk_transfer)
{
	gReset_cbfn				=	reset;
9d005fe4:	af848084 	sw	a0,-32636(gp)
	gControl_transfer_cbfn	=	control_transfer;
9d005fe8:	af858088 	sw	a1,-32632(gp)
	gBulk_transfer_cbfn		=	bulk_transfer;
}
9d005fec:	03e00008 	jr	ra
9d005ff0:	af86808c 	sw	a2,-32628(gp)

9d005ff4 <usb_device_descriptor>:
// called by upper level code to specify the device descriptor to
// return to the host.
//************************************************************************
void	usb_device_descriptor(const byte *descriptor, int length)
{
	device_descriptor = descriptor;
9d005ff4:	af84807c 	sw	a0,-32644(gp)
	device_descriptor_length = length;
}
9d005ff8:	03e00008 	jr	ra
9d005ffc:	af858080 	sw	a1,-32640(gp)

9d006000 <usb_configuration_descriptor>:
// called by upper level code to specify the configuration descriptor
// to return to the host.
//************************************************************************
void	usb_configuration_descriptor(const byte *descriptor, int length)
{
	configuration_descriptor = descriptor;
9d006000:	af848074 	sw	a0,-32652(gp)
	configuration_descriptor_length = length;
}
9d006004:	03e00008 	jr	ra
9d006008:	af858078 	sw	a1,-32648(gp)

9d00600c <usb_string_descriptor>:
// called by upper level code to specify the string descriptors to
// return to the host.
//************************************************************************
void	usb_string_descriptor(const byte *descriptor, int length)
{
	string_descriptor = descriptor;
9d00600c:	af84806c 	sw	a0,-32660(gp)
	string_descriptor_length = length;
}
9d006010:	03e00008 	jr	ra
9d006014:	af858070 	sw	a1,-32656(gp)

9d006018 <usb_initialize>:
void	usb_initialize(void)
{
	static __attribute__ ((aligned(512))) byte bdt_ram[BDT_RAM_SIZE];

#ifdef _USE_USB_IRQ_
    setIntVector(_USB_1_VECTOR, IntUSB1Handler);
9d006018:	3c059d00 	lui	a1,0x9d00
#endif
}

//************************************************************************
void	usb_initialize(void)
{
9d00601c:	27bdffe8 	addiu	sp,sp,-24
	static __attribute__ ((aligned(512))) byte bdt_ram[BDT_RAM_SIZE];

#ifdef _USE_USB_IRQ_
    setIntVector(_USB_1_VECTOR, IntUSB1Handler);
9d006020:	2404002d 	li	a0,45
#endif
}

//************************************************************************
void	usb_initialize(void)
{
9d006024:	afbf0014 	sw	ra,20(sp)
	static __attribute__ ((aligned(512))) byte bdt_ram[BDT_RAM_SIZE];

#ifdef _USE_USB_IRQ_
    setIntVector(_USB_1_VECTOR, IntUSB1Handler);
9d006028:	0f400feb 	jal	9d003fac <setIntVector>
9d00602c:	24a55718 	addiu	a1,a1,22296
	bdts = (struct bdt *)bdt_ram;

	assert(BDT_RAM_SIZE >= LENGTHOF(endpoints)*4*sizeof(struct bdt));

	// power on
	U1PWRCbits.USBPWR = 1;
9d006030:	3c03bf88 	lui	v1,0xbf88
9d006034:	8c655080 	lw	a1,20608(v1)
9d006038:	24020001 	li	v0,1
    /// TODO: Plib replacement function should go here
	IEC1bits.USBIE = 1;
    IPC7bits.USBIP = 6;
    IPC7bits.USBIS = 0;
#else
	IEC1bits.USBIE = 1;
9d00603c:	3c04bf88 	lui	a0,0xbf88
	bdts = (struct bdt *)bdt_ram;

	assert(BDT_RAM_SIZE >= LENGTHOF(endpoints)*4*sizeof(struct bdt));

	// power on
	U1PWRCbits.USBPWR = 1;
9d006040:	7c450004 	ins	a1,v0,0x0,0x1
9d006044:	ac655080 	sw	a1,20608(v1)
    /// TODO: Plib replacement function should go here
	IEC1bits.USBIE = 1;
    IPC7bits.USBIP = 6;
    IPC7bits.USBIS = 0;
#else
	IEC1bits.USBIE = 1;
9d006048:	8c851070 	lw	a1,4208(a0)
	IPC11bits.USBIP = 6;
9d00604c:	3c03bf88 	lui	v1,0xbf88
9d006050:	24060006 	li	a2,6
    /// TODO: Plib replacement function should go here
	IEC1bits.USBIE = 1;
    IPC7bits.USBIP = 6;
    IPC7bits.USBIS = 0;
#else
	IEC1bits.USBIE = 1;
9d006054:	7c45ce44 	ins	a1,v0,0x19,0x1
9d006058:	ac851070 	sw	a1,4208(a0)
	IPC11bits.USBIP = 6;
9d00605c:	8c641140 	lw	a0,4416(v1)

#ifdef _USE_USB_IRQ_
    setIntVector(_USB_1_VECTOR, IntUSB1Handler);
#endif

	bdts = (struct bdt *)bdt_ram;
9d006060:	3c05a000 	lui	a1,0xa000
9d006064:	24a51400 	addiu	a1,a1,5120
	IEC1bits.USBIE = 1;
    IPC7bits.USBIP = 6;
    IPC7bits.USBIS = 0;
#else
	IEC1bits.USBIE = 1;
	IPC11bits.USBIP = 6;
9d006068:	7cc46284 	ins	a0,a2,0xa,0x3
9d00606c:	ac641140 	sw	a0,4416(v1)
	IPC11bits.USBIS = 0;
9d006070:	8c661140 	lw	a2,4416(v1)

	MCF_USB_OTG_SOF_THLD = 74;

	// initialize usb bdt
	assert(! ((unsigned int)bdts & 0x1ff));
	MCF_USB_OTG_BDT_PAGE_01 = (uint8)(KVA_TO_PA((unsigned int)bdts) >> 8);
9d006074:	7ca4e000 	ext	a0,a1,0x0,0x1d

#ifdef _USE_USB_IRQ_
    setIntVector(_USB_1_VECTOR, IntUSB1Handler);
#endif

	bdts = (struct bdt *)bdt_ram;
9d006078:	af858068 	sw	a1,-32664(gp)
    IPC7bits.USBIP = 6;
    IPC7bits.USBIS = 0;
#else
	IEC1bits.USBIE = 1;
	IPC11bits.USBIP = 6;
	IPC11bits.USBIS = 0;
9d00607c:	7c064a04 	ins	a2,zero,0x8,0x2
9d006080:	ac661140 	sw	a2,4416(v1)
#endif
#endif

	MCF_USB_OTG_SOF_THLD = 74;
9d006084:	2405004a 	li	a1,74
9d006088:	3c03bf88 	lui	v1,0xbf88
9d00608c:	ac6552b0 	sw	a1,21168(v1)

	// initialize usb bdt
	assert(! ((unsigned int)bdts & 0x1ff));
	MCF_USB_OTG_BDT_PAGE_01 = (uint8)(KVA_TO_PA((unsigned int)bdts) >> 8);
9d006090:	7c883a00 	ext	t0,a0,0x8,0x8
9d006094:	3c03bf88 	lui	v1,0xbf88
9d006098:	ac685270 	sw	t0,21104(v1)
	MCF_USB_OTG_BDT_PAGE_02 = (uint8)(KVA_TO_PA((unsigned int)bdts) >> 16);
9d00609c:	7c873c00 	ext	a3,a0,0x10,0x8
9d0060a0:	3c03bf88 	lui	v1,0xbf88
9d0060a4:	ac6752c0 	sw	a3,21184(v1)
	MCF_USB_OTG_BDT_PAGE_03 = (uint8)(KVA_TO_PA((unsigned int)bdts) >> 24);
9d0060a8:	00042602 	srl	a0,a0,0x18
9d0060ac:	3c03bf88 	lui	v1,0xbf88
9d0060b0:	ac6452d0 	sw	a0,21200(v1)
// for a usb reset from the host.
//************************************************************************
static void	usb_device_wait()
{
	// enable usb device mode
	MCF_USB_OTG_CTL			=	MCF_USB_OTG_CTL_USB_EN_SOF_EN;
9d0060b4:	3c03bf88 	lui	v1,0xbf88
9d0060b8:	ac625250 	sw	v0,21072(v1)

	// enable usb pull ups
	MCF_USB_OTG_OTG_CTRL	=	MCF_USB_OTG_OTG_CTRL_DP_HIGH|MCF_USB_OTG_OTG_CTRL_OTG_EN;
9d0060bc:	24040084 	li	a0,132
9d0060c0:	3c03bf88 	lui	v1,0xbf88
	MCF_USB_OTG_BDT_PAGE_02 = (uint8)(KVA_TO_PA((unsigned int)bdts) >> 16);
	MCF_USB_OTG_BDT_PAGE_03 = (uint8)(KVA_TO_PA((unsigned int)bdts) >> 24);

	// enable usb to interrupt on reset
	usb_device_wait();
}
9d0060c4:	8fbf0014 	lw	ra,20(sp)
{
	// enable usb device mode
	MCF_USB_OTG_CTL			=	MCF_USB_OTG_CTL_USB_EN_SOF_EN;

	// enable usb pull ups
	MCF_USB_OTG_OTG_CTRL	=	MCF_USB_OTG_OTG_CTRL_DP_HIGH|MCF_USB_OTG_OTG_CTRL_OTG_EN;
9d0060c8:	ac645070 	sw	a0,20592(v1)

	// enable (only) usb reset interrupt
	MCF_USB_OTG_INT_STAT	=	0xff;
9d0060cc:	3c03bf88 	lui	v1,0xbf88
9d0060d0:	240400ff 	li	a0,255
9d0060d4:	ac645200 	sw	a0,20992(v1)
	MCF_USB_OTG_INT_ENB		=	MCF_USB_OTG_INT_ENB_USB_RST_EN;
9d0060d8:	3c03bf88 	lui	v1,0xbf88
9d0060dc:	ac625210 	sw	v0,21008(v1)
	MCF_USB_OTG_BDT_PAGE_02 = (uint8)(KVA_TO_PA((unsigned int)bdts) >> 16);
	MCF_USB_OTG_BDT_PAGE_03 = (uint8)(KVA_TO_PA((unsigned int)bdts) >> 24);

	// enable usb to interrupt on reset
	usb_device_wait();
}
9d0060e0:	03e00008 	jr	ra
9d0060e4:	27bd0018 	addiu	sp,sp,24

9d0060e8 <cdcacm_bulk_transfer>:

//************************************************************************
// this function implements the CDCACM usb bulk transfer.
//************************************************************************
static int	cdcacm_bulk_transfer(boolean in, byte *buffer, int length)
{
9d0060e8:	27bdffe8 	addiu	sp,sp,-24
9d0060ec:	308200ff 	andi	v0,a0,0xff
9d0060f0:	afbf0014 	sw	ra,20(sp)
	if (! in)
9d0060f4:	1040002d 	beqz	v0,9d0061ac <cdcacm_bulk_transfer+0xc4>
9d0060f8:	afb00010 	sw	s0,16(sp)
			gWaiting	=	true;
		}
	}
	else
	{
		gRX_length[gRX_out]	=	0;
9d0060fc:	938480a9 	lbu	a0,-32599(gp)
		gRX_out	=	(gRX_out+1)%NRX;
9d006100:	938280a9 	lbu	v0,-32599(gp)
			gWaiting	=	true;
		}
	}
	else
	{
		gRX_length[gRX_out]	=	0;
9d006104:	3c03a000 	lui	v1,0xa000
9d006108:	308400ff 	andi	a0,a0,0xff
		gRX_out	=	(gRX_out+1)%NRX;
9d00610c:	24420001 	addiu	v0,v0,1
9d006110:	30420003 	andi	v0,v0,0x3
9d006114:	a38280a9 	sb	v0,-32599(gp)

		// if there is more data to transfer...
		if (gRX_length[gRX_out] > 0)
9d006118:	938280a9 	lbu	v0,-32599(gp)
			gWaiting	=	true;
		}
	}
	else
	{
		gRX_length[gRX_out]	=	0;
9d00611c:	24631600 	addiu	v1,v1,5632
9d006120:	00042080 	sll	a0,a0,0x2
		gRX_out	=	(gRX_out+1)%NRX;

		// if there is more data to transfer...
		if (gRX_length[gRX_out] > 0)
9d006124:	304200ff 	andi	v0,v0,0xff
			gWaiting	=	true;
		}
	}
	else
	{
		gRX_length[gRX_out]	=	0;
9d006128:	00642021 	addu	a0,v1,a0
		gRX_out	=	(gRX_out+1)%NRX;

		// if there is more data to transfer...
		if (gRX_length[gRX_out] > 0)
9d00612c:	00021080 	sll	v0,v0,0x2
			gWaiting	=	true;
		}
	}
	else
	{
		gRX_length[gRX_out]	=	0;
9d006130:	ac800000 	sw	zero,0(a0)
		gRX_out	=	(gRX_out+1)%NRX;

		// if there is more data to transfer...
		if (gRX_length[gRX_out] > 0)
9d006134:	00621021 	addu	v0,v1,v0
9d006138:	8c420000 	lw	v0,0(v0)
9d00613c:	18400017 	blez	v0,9d00619c <cdcacm_bulk_transfer+0xb4>
9d006140:	8fbf0014 	lw	ra,20(sp)
		{
			if (gRX_in == gRX_out)
9d006144:	938480aa 	lbu	a0,-32598(gp)
9d006148:	938280a9 	lbu	v0,-32599(gp)
9d00614c:	308400ff 	andi	a0,a0,0xff
9d006150:	304200ff 	andi	v0,v0,0xff
9d006154:	10820022 	beq	a0,v0,9d0061e0 <cdcacm_bulk_transfer+0xf8>
9d006158:	00000000 	nop
			}

			// keep the rx ball rolling
			assert(gRX_out != gRX_in);
			assert(gRX_length[gRX_out] > 0 && gRX_length[gRX_out] < PACKET_SIZE);
			usb_device_enqueue(bulk_in_ep, 1, gRXbuffer[gRX_out], gRX_length[gRX_out]);
9d00615c:	938280a9 	lbu	v0,-32599(gp)
9d006160:	938580a9 	lbu	a1,-32599(gp)
9d006164:	3c06a000 	lui	a2,0xa000
9d006168:	304200ff 	andi	v0,v0,0xff
9d00616c:	30a500ff 	andi	a1,a1,0xff
9d006170:	00052880 	sll	a1,a1,0x2
9d006174:	00652821 	addu	a1,v1,a1
9d006178:	8ca70000 	lw	a3,0(a1)
9d00617c:	00021980 	sll	v1,v0,0x6
9d006180:	938480cf 	lbu	a0,-32561(gp)
9d006184:	00621023 	subu	v0,v1,v0
9d006188:	24c61650 	addiu	a2,a2,5712
9d00618c:	24050001 	li	a1,1
9d006190:	0f401586 	jal	9d005618 <usb_device_enqueue>
9d006194:	00c23021 	addu	a2,a2,v0
		}
	}

	return 0;
}
9d006198:	8fbf0014 	lw	ra,20(sp)
9d00619c:	00001021 	move	v0,zero
9d0061a0:	8fb00010 	lw	s0,16(sp)
9d0061a4:	03e00008 	jr	ra
9d0061a8:	27bd0018 	addiu	sp,sp,24
	if (! in)
	{
		gCdcacm_active	=	true;
		
		// accumulate commands
		if (gStoredata_cbfn(buffer, length))
9d0061ac:	8f8280a4 	lw	v0,-32604(gp)
//************************************************************************
static int	cdcacm_bulk_transfer(boolean in, byte *buffer, int length)
{
	if (! in)
	{
		gCdcacm_active	=	true;
9d0061b0:	24100001 	li	s0,1
		
		// accumulate commands
		if (gStoredata_cbfn(buffer, length))
9d0061b4:	00a02021 	move	a0,a1
//************************************************************************
static int	cdcacm_bulk_transfer(boolean in, byte *buffer, int length)
{
	if (! in)
	{
		gCdcacm_active	=	true;
9d0061b8:	a39080de 	sb	s0,-32546(gp)
		
		// accumulate commands
		if (gStoredata_cbfn(buffer, length))
9d0061bc:	0040f809 	jalr	v0
9d0061c0:	00c02821 	move	a1,a2
9d0061c4:	1440000c 	bnez	v0,9d0061f8 <cdcacm_bulk_transfer+0x110>
9d0061c8:	00001021 	move	v0,zero
			usb_device_enqueue(bulk_in_ep, 1, gRXbuffer[gRX_out], gRX_length[gRX_out]);
		}
	}

	return 0;
}
9d0061cc:	8fbf0014 	lw	ra,20(sp)
			usb_device_enqueue(bulk_out_ep, 0, gTXbuffer, sizeof(gTXbuffer));
		}
		else
		{
			// drop the ball
			gWaiting	=	true;
9d0061d0:	a39080a8 	sb	s0,-32600(gp)
			usb_device_enqueue(bulk_in_ep, 1, gRXbuffer[gRX_out], gRX_length[gRX_out]);
		}
	}

	return 0;
}
9d0061d4:	8fb00010 	lw	s0,16(sp)
9d0061d8:	03e00008 	jr	ra
9d0061dc:	27bd0018 	addiu	sp,sp,24
		// if there is more data to transfer...
		if (gRX_length[gRX_out] > 0)
		{
			if (gRX_in == gRX_out)
			{
				gRX_in	=	(gRX_in+1)%NRX;
9d0061e0:	938280aa 	lbu	v0,-32598(gp)
9d0061e4:	24420001 	addiu	v0,v0,1
9d0061e8:	30420003 	andi	v0,v0,0x3
9d0061ec:	a38280aa 	sb	v0,-32598(gp)
9d0061f0:	0b401857 	j	9d00615c <cdcacm_bulk_transfer+0x74>
9d0061f4:	00000000 	nop
		
		// accumulate commands
		if (gStoredata_cbfn(buffer, length))
		{
			// keep the tx ball rolling
			usb_device_enqueue(bulk_out_ep, 0, gTXbuffer, sizeof(gTXbuffer));
9d0061f8:	938480cd 	lbu	a0,-32563(gp)
9d0061fc:	3c06a000 	lui	a2,0xa000
9d006200:	00002821 	move	a1,zero
9d006204:	24c61610 	addiu	a2,a2,5648
9d006208:	0f401586 	jal	9d005618 <usb_device_enqueue>
9d00620c:	24070040 	li	a3,64
			usb_device_enqueue(bulk_in_ep, 1, gRXbuffer[gRX_out], gRX_length[gRX_out]);
		}
	}

	return 0;
}
9d006210:	0b401867 	j	9d00619c <cdcacm_bulk_transfer+0xb4>
9d006214:	8fbf0014 	lw	ra,20(sp)

9d006218 <cdcacm_reset>:
	{
		gRX_length[i]	=	0;
	}

	// prepare for rx
	usb_device_enqueue(bulk_in_ep, -1, NULL, 0);
9d006218:	938480cf 	lbu	a0,-32561(gp)
{
	int i;

	for (i=0; i < NRX; i++)
	{
		gRX_length[i]	=	0;
9d00621c:	3c03a000 	lui	v1,0xa000
//************************************************************************
// this function is called by the usb driver when the USB device
// is reset.
//************************************************************************
static void	cdcacm_reset(void)
{
9d006220:	27bdffe8 	addiu	sp,sp,-24
	int i;

	for (i=0; i < NRX; i++)
	{
		gRX_length[i]	=	0;
9d006224:	24621600 	addiu	v0,v1,5632
	}

	// prepare for rx
	usb_device_enqueue(bulk_in_ep, -1, NULL, 0);
9d006228:	240500ff 	li	a1,255
9d00622c:	00003021 	move	a2,zero
9d006230:	00003821 	move	a3,zero
//************************************************************************
// this function is called by the usb driver when the USB device
// is reset.
//************************************************************************
static void	cdcacm_reset(void)
{
9d006234:	afbf0014 	sw	ra,20(sp)
	int i;

	for (i=0; i < NRX; i++)
	{
		gRX_length[i]	=	0;
9d006238:	ac601600 	sw	zero,5632(v1)
9d00623c:	ac400004 	sw	zero,4(v0)
9d006240:	ac400008 	sw	zero,8(v0)
	}

	// prepare for rx
	usb_device_enqueue(bulk_in_ep, -1, NULL, 0);
9d006244:	0f401586 	jal	9d005618 <usb_device_enqueue>
9d006248:	ac40000c 	sw	zero,12(v0)
	usb_device_enqueue(int_ep, -1, NULL, 0);
9d00624c:	938480ce 	lbu	a0,-32562(gp)
9d006250:	240500ff 	li	a1,255
9d006254:	00003021 	move	a2,zero
9d006258:	0f401586 	jal	9d005618 <usb_device_enqueue>
9d00625c:	00003821 	move	a3,zero
	
	// start the tx ball rolling
	usb_device_enqueue(bulk_out_ep, 0, gTXbuffer, sizeof(gTXbuffer));
9d006260:	938480cd 	lbu	a0,-32563(gp)
9d006264:	3c06a000 	lui	a2,0xa000
9d006268:	00002821 	move	a1,zero
9d00626c:	24c61610 	addiu	a2,a2,5648
9d006270:	0f401586 	jal	9d005618 <usb_device_enqueue>
9d006274:	24070040 	li	a3,64
	
	assert(gReset_cbfn);
	gReset_cbfn();
9d006278:	8f9980a0 	lw	t9,-32608(gp)
}
9d00627c:	8fbf0014 	lw	ra,20(sp)
	
	// start the tx ball rolling
	usb_device_enqueue(bulk_out_ep, 0, gTXbuffer, sizeof(gTXbuffer));
	
	assert(gReset_cbfn);
	gReset_cbfn();
9d006280:	03200008 	jr	t9
9d006284:	27bd0018 	addiu	sp,sp,24

9d006288 <cdcacm_control_transfer>:

//************************************************************************
// this function implements the CDCACM usb setup control transfer.
//************************************************************************
static int	cdcacm_control_transfer(struct setup *setup, byte *buffer, int length)
{
9d006288:	27bdffe8 	addiu	sp,sp,-24
9d00628c:	afb00010 	sw	s0,16(sp)
9d006290:	afbf0014 	sw	ra,20(sp)
	if (setup->index != 0 /*comm*/)
	{
		return 0;
	}
#endif
	switch(setup->request)
9d006294:	90820001 	lbu	v0,1(a0)
9d006298:	24030020 	li	v1,32
9d00629c:	10430021 	beq	v0,v1,9d006324 <cdcacm_control_transfer+0x9c>
9d0062a0:	00c08021 	move	s0,a2
9d0062a4:	2c430021 	sltiu	v1,v0,33
9d0062a8:	1460000c 	bnez	v1,9d0062dc <cdcacm_control_transfer+0x54>
9d0062ac:	24030001 	li	v1,1
9d0062b0:	24030021 	li	v1,33
9d0062b4:	1043002b 	beq	v0,v1,9d006364 <cdcacm_control_transfer+0xdc>
9d0062b8:	24030022 	li	v1,34
9d0062bc:	50430011 	beql	v0,v1,9d006304 <cdcacm_control_transfer+0x7c>
9d0062c0:	90820002 	lbu	v0,2(a0)
			length	=	0;
			break;
	}
	
	return length;
}
9d0062c4:	8fbf0014 	lw	ra,20(sp)
#endif
	switch(setup->request)
	{
		case CDCRQ_SEND_ENCAPSULATED_COMMAND:
			assert(! (setup->requesttype & 0x80));
			length	=	0;
9d0062c8:	00008021 	move	s0,zero
			length	=	0;
			break;
	}
	
	return length;
}
9d0062cc:	02001021 	move	v0,s0
9d0062d0:	8fb00010 	lw	s0,16(sp)
9d0062d4:	03e00008 	jr	ra
9d0062d8:	27bd0018 	addiu	sp,sp,24
	if (setup->index != 0 /*comm*/)
	{
		return 0;
	}
#endif
	switch(setup->request)
9d0062dc:	1443fffa 	bne	v0,v1,9d0062c8 <cdcacm_control_transfer+0x40>
9d0062e0:	8fbf0014 	lw	ra,20(sp)
			length	=	0;
			break;
		case CDCRQ_GET_ENCAPSULATED_RESPONSE:
			assert(setup->requesttype & 0x80);
			assert(length <= 64);
			memset(buffer, 0, length);
9d0062e4:	00a02021 	move	a0,a1
9d0062e8:	0f401c0d 	jal	9d007034 <memset>
9d0062ec:	00002821 	move	a1,zero
			length	=	0;
			break;
	}
	
	return length;
}
9d0062f0:	8fbf0014 	lw	ra,20(sp)
9d0062f4:	02001021 	move	v0,s0
9d0062f8:	8fb00010 	lw	s0,16(sp)
9d0062fc:	03e00008 	jr	ra
9d006300:	27bd0018 	addiu	sp,sp,24
9d006304:	8fbf0014 	lw	ra,20(sp)
			memcpy(buffer, line_coding, sizeof(line_coding));
			break;
		case CDCRQ_SET_CONTROL_LINE_STATE:
			assert(! (setup->requesttype & 0x80));
            gConnected = setup->value & 0x01; 
			length	=	0;
9d006308:	00008021 	move	s0,zero
			assert(length == sizeof(line_coding));
			memcpy(buffer, line_coding, sizeof(line_coding));
			break;
		case CDCRQ_SET_CONTROL_LINE_STATE:
			assert(! (setup->requesttype & 0x80));
            gConnected = setup->value & 0x01; 
9d00630c:	30420001 	andi	v0,v0,0x1
9d006310:	a382809c 	sb	v0,-32612(gp)
			length	=	0;
			break;
	}
	
	return length;
}
9d006314:	02001021 	move	v0,s0
9d006318:	8fb00010 	lw	s0,16(sp)
9d00631c:	03e00008 	jr	ra
9d006320:	27bd0018 	addiu	sp,sp,24
			memset(buffer, 0, length);
			break;
		case CDCRQ_SET_LINE_CODING:
			assert(! (setup->requesttype & 0x80));
			assert(length == sizeof(line_coding));
			memcpy(line_coding, buffer, sizeof(line_coding));
9d006324:	88a20003 	lwl	v0,3(a1)
9d006328:	27838018 	addiu	v1,gp,-32744
			length	=	0;
9d00632c:	00008021 	move	s0,zero
			memset(buffer, 0, length);
			break;
		case CDCRQ_SET_LINE_CODING:
			assert(! (setup->requesttype & 0x80));
			assert(length == sizeof(line_coding));
			memcpy(line_coding, buffer, sizeof(line_coding));
9d006330:	98a20000 	lwr	v0,0(a1)
9d006334:	af828014 	sw	v0,-32748(gp)
9d006338:	90a20004 	lbu	v0,4(a1)
9d00633c:	a3828018 	sb	v0,-32744(gp)
9d006340:	90a20005 	lbu	v0,5(a1)
9d006344:	a0620001 	sb	v0,1(v1)
9d006348:	90a20006 	lbu	v0,6(a1)
9d00634c:	a0620002 	sb	v0,2(v1)
			length	=	0;
			break;
	}
	
	return length;
}
9d006350:	8fbf0014 	lw	ra,20(sp)
9d006354:	02001021 	move	v0,s0
9d006358:	8fb00010 	lw	s0,16(sp)
9d00635c:	03e00008 	jr	ra
9d006360:	27bd0018 	addiu	sp,sp,24
			length	=	0;
			break;
		case CDCRQ_GET_LINE_CODING:
			assert(setup->requesttype & 0x80);
			assert(length == sizeof(line_coding));
			memcpy(buffer, line_coding, sizeof(line_coding));
9d006364:	8f828014 	lw	v0,-32748(gp)
9d006368:	a8a20003 	swl	v0,3(a1)
9d00636c:	b8a20000 	swr	v0,0(a1)
9d006370:	93828018 	lbu	v0,-32744(gp)
9d006374:	a0a20004 	sb	v0,4(a1)
9d006378:	93828019 	lbu	v0,-32743(gp)
9d00637c:	a0a20005 	sb	v0,5(a1)
9d006380:	9382801a 	lbu	v0,-32742(gp)
9d006384:	a0a20006 	sb	v0,6(a1)
			length	=	0;
			break;
	}
	
	return length;
}
9d006388:	8fbf0014 	lw	ra,20(sp)
9d00638c:	02001021 	move	v0,s0
9d006390:	8fb00010 	lw	s0,16(sp)
9d006394:	03e00008 	jr	ra
9d006398:	27bd0018 	addiu	sp,sp,24

9d00639c <SPLX>:
{
	int csr;
	int oldlevel;

	// get the sr
	csr	=	_CP0_GET_STATUS();
9d00639c:	40036000 	mfc0	v1,c0_status

	oldlevel	=	(csr >> 10) & 7;
	if (level <= 0)
9d0063a0:	1880000b 	blez	a0,9d0063d0 <SPLX+0x34>
9d0063a4:	7c621280 	ext	v0,v1,0xa,0x3
		level	=	-level;
	}
	else
	{
		// we're going up
		level	=	MAX(level, oldlevel);
9d0063a8:	0044282a 	slt	a1,v0,a0
9d0063ac:	0045200a 	movz	a0,v0,a1
	}
	assert(level >= 0 && level <= 7);
	csr	=	(csr & 0xffffe3ff) | (level << 10);
9d0063b0:	2405e3ff 	li	a1,-7169
9d0063b4:	00042280 	sll	a0,a0,0xa
9d0063b8:	00651824 	and	v1,v1,a1
9d0063bc:	00831825 	or	v1,a0,v1

	// update the sr
	_CP0_SET_STATUS(csr);
9d0063c0:	40836000 	mtc0	v1,c0_status
9d0063c4:	000000c0 	ehb

	assert(oldlevel >= 0 && oldlevel <= 7);
	return -oldlevel;
}
9d0063c8:	03e00008 	jr	ra
9d0063cc:	00021023 	negu	v0,v0
	{
		// we're going up
		level	=	MAX(level, oldlevel);
	}
	assert(level >= 0 && level <= 7);
	csr	=	(csr & 0xffffe3ff) | (level << 10);
9d0063d0:	2405e3ff 	li	a1,-7169

	oldlevel	=	(csr >> 10) & 7;
	if (level <= 0)
	{
		// we're going down
		level	=	-level;
9d0063d4:	00042023 	negu	a0,a0
	{
		// we're going up
		level	=	MAX(level, oldlevel);
	}
	assert(level >= 0 && level <= 7);
	csr	=	(csr & 0xffffe3ff) | (level << 10);
9d0063d8:	00042280 	sll	a0,a0,0xa
9d0063dc:	00651824 	and	v1,v1,a1
9d0063e0:	00831825 	or	v1,a0,v1

	// update the sr
	_CP0_SET_STATUS(csr);
9d0063e4:	40836000 	mtc0	v1,c0_status
9d0063e8:	000000c0 	ehb

	assert(oldlevel >= 0 && oldlevel <= 7);
	return -oldlevel;
}
9d0063ec:	03e00008 	jr	ra
9d0063f0:	00021023 	negu	v0,v0

9d0063f4 <setStrings>:
boolean      gConnected = false;

void setStrings(char *man, char *prod, char *ser) {
    int i;
    int pos = 0;
    if (cdcacm_string_descriptor) {
9d0063f4:	8f8280ac 	lw	v0,-32596(gp)
static volatile byte			gRX_in;
static volatile byte			gRX_out;

boolean      gConnected = false;

void setStrings(char *man, char *prod, char *ser) {
9d0063f8:	27bdffc8 	addiu	sp,sp,-56
9d0063fc:	afb2001c 	sw	s2,28(sp)
9d006400:	afb10018 	sw	s1,24(sp)
9d006404:	afb00014 	sw	s0,20(sp)
9d006408:	afbf0034 	sw	ra,52(sp)
9d00640c:	afb70030 	sw	s7,48(sp)
9d006410:	afb6002c 	sw	s6,44(sp)
9d006414:	afb50028 	sw	s5,40(sp)
9d006418:	afb40024 	sw	s4,36(sp)
9d00641c:	afb30020 	sw	s3,32(sp)
9d006420:	00808821 	move	s1,a0
9d006424:	00a09021 	move	s2,a1
    int i;
    int pos = 0;
    if (cdcacm_string_descriptor) {
9d006428:	10400003 	beqz	v0,9d006438 <setStrings+0x44>
9d00642c:	00c08021 	move	s0,a2
        free(cdcacm_string_descriptor);
9d006430:	0f401a58 	jal	9d006960 <free>
9d006434:	00402021 	move	a0,v0
    }
    int totlen = 4;
    totlen += strlen(man) * 2 + 2;
9d006438:	0f401c2e 	jal	9d0070b8 <strlen>
9d00643c:	02202021 	move	a0,s1
    totlen += strlen(prod) * 2 + 2;
9d006440:	02402021 	move	a0,s2
9d006444:	0f401c2e 	jal	9d0070b8 <strlen>
9d006448:	0040a021 	move	s4,v0
9d00644c:	00409821 	move	s3,v0
    totlen += strlen(ser) * 2 + 2;
9d006450:	02002021 	move	a0,s0
9d006454:	0f401c2e 	jal	9d0070b8 <strlen>
9d006458:	0293a021 	addu	s4,s4,s3
    int pos = 0;
    if (cdcacm_string_descriptor) {
        free(cdcacm_string_descriptor);
    }
    int totlen = 4;
    totlen += strlen(man) * 2 + 2;
9d00645c:	26940003 	addiu	s4,s4,3
9d006460:	0282a021 	addu	s4,s4,v0
    totlen += strlen(prod) * 2 + 2;
    totlen += strlen(ser) * 2 + 2;
9d006464:	0014a040 	sll	s4,s4,0x1
9d006468:	26940004 	addiu	s4,s4,4

    cdcacm_string_descriptor = malloc(totlen);
9d00646c:	0f401a4e 	jal	9d006938 <malloc>
9d006470:	02802021 	move	a0,s4
9d006474:	00409821 	move	s3,v0

    // Header
    cdcacm_string_descriptor[pos++] = 0x04;
    cdcacm_string_descriptor[pos++] = 0x03;
9d006478:	24150003 	li	s5,3
    totlen += strlen(ser) * 2 + 2;

    cdcacm_string_descriptor = malloc(totlen);

    // Header
    cdcacm_string_descriptor[pos++] = 0x04;
9d00647c:	24020004 	li	v0,4
    cdcacm_string_descriptor[pos++] = 0x03;
    cdcacm_string_descriptor[pos++] = 0x09;
9d006480:	24030009 	li	v1,9
    int totlen = 4;
    totlen += strlen(man) * 2 + 2;
    totlen += strlen(prod) * 2 + 2;
    totlen += strlen(ser) * 2 + 2;

    cdcacm_string_descriptor = malloc(totlen);
9d006484:	af9380ac 	sw	s3,-32596(gp)
    cdcacm_string_descriptor[pos++] = 0x09;
    cdcacm_string_descriptor[pos++] = 0x04;

    // Manufacturer
    
    cdcacm_string_descriptor[pos++] = strlen(man)*2 + 2;
9d006488:	02202021 	move	a0,s1

    cdcacm_string_descriptor = malloc(totlen);

    // Header
    cdcacm_string_descriptor[pos++] = 0x04;
    cdcacm_string_descriptor[pos++] = 0x03;
9d00648c:	a2750001 	sb	s5,1(s3)
    totlen += strlen(ser) * 2 + 2;

    cdcacm_string_descriptor = malloc(totlen);

    // Header
    cdcacm_string_descriptor[pos++] = 0x04;
9d006490:	a2620000 	sb	v0,0(s3)
    cdcacm_string_descriptor[pos++] = 0x03;
    cdcacm_string_descriptor[pos++] = 0x09;
9d006494:	a2630002 	sb	v1,2(s3)
    cdcacm_string_descriptor[pos++] = 0x04;

    // Manufacturer
    
    cdcacm_string_descriptor[pos++] = strlen(man)*2 + 2;
9d006498:	0f401c2e 	jal	9d0070b8 <strlen>
9d00649c:	a2620003 	sb	v0,3(s3)
9d0064a0:	24420001 	addiu	v0,v0,1
9d0064a4:	00021040 	sll	v0,v0,0x1
    cdcacm_string_descriptor[pos++] = 0x03;
9d0064a8:	a2750005 	sb	s5,5(s3)
    cdcacm_string_descriptor[pos++] = 0x09;
    cdcacm_string_descriptor[pos++] = 0x04;

    // Manufacturer
    
    cdcacm_string_descriptor[pos++] = strlen(man)*2 + 2;
9d0064ac:	a2620004 	sb	v0,4(s3)
    cdcacm_string_descriptor[pos++] = 0x03;
9d0064b0:	0260b021 	move	s6,s3
9d0064b4:	24170006 	li	s7,6
    for (i = 0; i < strlen(man); i++) {
9d0064b8:	0b401935 	j	9d0064d4 <setStrings+0xe0>
9d0064bc:	0000a821 	move	s5,zero
        cdcacm_string_descriptor[pos++] = man[i];
9d0064c0:	90620000 	lbu	v0,0(v1)
static volatile byte			gRX_in;
static volatile byte			gRX_out;

boolean      gConnected = false;

void setStrings(char *man, char *prod, char *ser) {
9d0064c4:	26f70002 	addiu	s7,s7,2
    
    cdcacm_string_descriptor[pos++] = strlen(man)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(man); i++) {
        cdcacm_string_descriptor[pos++] = man[i];
        cdcacm_string_descriptor[pos++] = 0;
9d0064c8:	a2c00005 	sb	zero,5(s6)
    // Manufacturer
    
    cdcacm_string_descriptor[pos++] = strlen(man)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(man); i++) {
        cdcacm_string_descriptor[pos++] = man[i];
9d0064cc:	a2c20004 	sb	v0,4(s6)

    // Manufacturer
    
    cdcacm_string_descriptor[pos++] = strlen(man)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(man); i++) {
9d0064d0:	26b50001 	addiu	s5,s5,1
9d0064d4:	0f401c2e 	jal	9d0070b8 <strlen>
9d0064d8:	02202021 	move	a0,s1
9d0064dc:	02a2102b 	sltu	v0,s5,v0
static volatile byte			gRX_in;
static volatile byte			gRX_out;

boolean      gConnected = false;

void setStrings(char *man, char *prod, char *ser) {
9d0064e0:	02351821 	addu	v1,s1,s5

    // Manufacturer
    
    cdcacm_string_descriptor[pos++] = strlen(man)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(man); i++) {
9d0064e4:	1440fff6 	bnez	v0,9d0064c0 <setStrings+0xcc>
9d0064e8:	26d60002 	addiu	s6,s6,2
        cdcacm_string_descriptor[pos++] = man[i];
        cdcacm_string_descriptor[pos++] = 0;
    }

    // Product
    cdcacm_string_descriptor[pos++] = strlen(prod)*2 + 2;
9d0064ec:	0f401c2e 	jal	9d0070b8 <strlen>
9d0064f0:	02402021 	move	a0,s2
9d0064f4:	24420001 	addiu	v0,v0,1
9d0064f8:	0277b021 	addu	s6,s3,s7
9d0064fc:	00021040 	sll	v0,v0,0x1
9d006500:	a2c20000 	sb	v0,0(s6)
    cdcacm_string_descriptor[pos++] = 0x03;
9d006504:	24020003 	li	v0,3
9d006508:	26f10002 	addiu	s1,s7,2
9d00650c:	a2c20001 	sb	v0,1(s6)
    for (i = 0; i < strlen(prod); i++) {
9d006510:	0b40194b 	j	9d00652c <setStrings+0x138>
9d006514:	0000a821 	move	s5,zero
        cdcacm_string_descriptor[pos++] = prod[i];
9d006518:	90620000 	lbu	v0,0(v1)
static volatile byte			gRX_in;
static volatile byte			gRX_out;

boolean      gConnected = false;

void setStrings(char *man, char *prod, char *ser) {
9d00651c:	26310002 	addiu	s1,s1,2
    // Product
    cdcacm_string_descriptor[pos++] = strlen(prod)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(prod); i++) {
        cdcacm_string_descriptor[pos++] = prod[i];
        cdcacm_string_descriptor[pos++] = 0;
9d006520:	a2c00001 	sb	zero,1(s6)

    // Product
    cdcacm_string_descriptor[pos++] = strlen(prod)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(prod); i++) {
        cdcacm_string_descriptor[pos++] = prod[i];
9d006524:	a2c20000 	sb	v0,0(s6)
    }

    // Product
    cdcacm_string_descriptor[pos++] = strlen(prod)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(prod); i++) {
9d006528:	26b50001 	addiu	s5,s5,1
9d00652c:	0f401c2e 	jal	9d0070b8 <strlen>
9d006530:	02402021 	move	a0,s2
9d006534:	02a2102b 	sltu	v0,s5,v0
static volatile byte			gRX_in;
static volatile byte			gRX_out;

boolean      gConnected = false;

void setStrings(char *man, char *prod, char *ser) {
9d006538:	02551821 	addu	v1,s2,s5
    }

    // Product
    cdcacm_string_descriptor[pos++] = strlen(prod)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(prod); i++) {
9d00653c:	1440fff6 	bnez	v0,9d006518 <setStrings+0x124>
9d006540:	26d60002 	addiu	s6,s6,2
        cdcacm_string_descriptor[pos++] = prod[i];
        cdcacm_string_descriptor[pos++] = 0;
    }

    // Serial number
    cdcacm_string_descriptor[pos++] = strlen(ser)*2 + 2;
9d006544:	0f401c2e 	jal	9d0070b8 <strlen>
9d006548:	02002021 	move	a0,s0
9d00654c:	24420001 	addiu	v0,v0,1
9d006550:	02718821 	addu	s1,s3,s1
9d006554:	00021040 	sll	v0,v0,0x1
9d006558:	a2220000 	sb	v0,0(s1)
    cdcacm_string_descriptor[pos++] = 0x03;
9d00655c:	24020003 	li	v0,3
9d006560:	a2220001 	sb	v0,1(s1)
    for (i = 0; i < strlen(ser); i++) {
9d006564:	0b40195f 	j	9d00657c <setStrings+0x188>
9d006568:	00009021 	move	s2,zero
        cdcacm_string_descriptor[pos++] = ser[i];
9d00656c:	90620000 	lbu	v0,0(v1)
    }

    // Serial number
    cdcacm_string_descriptor[pos++] = strlen(ser)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(ser); i++) {
9d006570:	26520001 	addiu	s2,s2,1
        cdcacm_string_descriptor[pos++] = ser[i];
        cdcacm_string_descriptor[pos++] = 0;
9d006574:	a2200001 	sb	zero,1(s1)

    // Serial number
    cdcacm_string_descriptor[pos++] = strlen(ser)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(ser); i++) {
        cdcacm_string_descriptor[pos++] = ser[i];
9d006578:	a2220000 	sb	v0,0(s1)
    }

    // Serial number
    cdcacm_string_descriptor[pos++] = strlen(ser)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(ser); i++) {
9d00657c:	0f401c2e 	jal	9d0070b8 <strlen>
9d006580:	02002021 	move	a0,s0
9d006584:	0242102b 	sltu	v0,s2,v0
static volatile byte			gRX_in;
static volatile byte			gRX_out;

boolean      gConnected = false;

void setStrings(char *man, char *prod, char *ser) {
9d006588:	02121821 	addu	v1,s0,s2
    }

    // Serial number
    cdcacm_string_descriptor[pos++] = strlen(ser)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(ser); i++) {
9d00658c:	1440fff7 	bnez	v0,9d00656c <setStrings+0x178>
9d006590:	26310002 	addiu	s1,s1,2
        cdcacm_string_descriptor[pos++] = ser[i];
        cdcacm_string_descriptor[pos++] = 0;
    }

	usb_string_descriptor(cdcacm_string_descriptor, totlen);
9d006594:	02602021 	move	a0,s3
9d006598:	02802821 	move	a1,s4
}
9d00659c:	8fbf0034 	lw	ra,52(sp)
9d0065a0:	8fb70030 	lw	s7,48(sp)
9d0065a4:	8fb6002c 	lw	s6,44(sp)
9d0065a8:	8fb50028 	lw	s5,40(sp)
9d0065ac:	8fb40024 	lw	s4,36(sp)
9d0065b0:	8fb30020 	lw	s3,32(sp)
9d0065b4:	8fb2001c 	lw	s2,28(sp)
9d0065b8:	8fb10018 	lw	s1,24(sp)
9d0065bc:	8fb00014 	lw	s0,20(sp)
    for (i = 0; i < strlen(ser); i++) {
        cdcacm_string_descriptor[pos++] = ser[i];
        cdcacm_string_descriptor[pos++] = 0;
    }

	usb_string_descriptor(cdcacm_string_descriptor, totlen);
9d0065c0:	0b401803 	j	9d00600c <usb_string_descriptor>
9d0065c4:	27bd0038 	addiu	sp,sp,56

9d0065c8 <cdcacm_print>:
    int m;
    int previousInterrutLevel;
		
	// ASSERT(length);

	if (! gCdcacm_attached || !gConnected || (length <= 0))
9d0065c8:	938280cc 	lbu	v0,-32564(gp)
// this function waits for space to be available in the transport
// buffers and then prints the specified line to the CDCACM transport
// console.
//************************************************************************
void	cdcacm_print(const byte *buffer, int length)
{
9d0065cc:	27bdffc0 	addiu	sp,sp,-64
9d0065d0:	afb5002c 	sw	s5,44(sp)
9d0065d4:	afb1001c 	sw	s1,28(sp)
9d0065d8:	afbf003c 	sw	ra,60(sp)
9d0065dc:	afbe0038 	sw	s8,56(sp)
9d0065e0:	afb70034 	sw	s7,52(sp)
9d0065e4:	afb60030 	sw	s6,48(sp)
9d0065e8:	afb40028 	sw	s4,40(sp)
9d0065ec:	afb30024 	sw	s3,36(sp)
9d0065f0:	afb20020 	sw	s2,32(sp)
9d0065f4:	afb00018 	sw	s0,24(sp)
9d0065f8:	0080a821 	move	s5,a0
    int m;
    int previousInterrutLevel;
		
	// ASSERT(length);

	if (! gCdcacm_attached || !gConnected || (length <= 0))
9d0065fc:	1040006f 	beqz	v0,9d0067bc <cdcacm_print+0x1f4>
9d006600:	00a08821 	move	s1,a1
9d006604:	9382809c 	lbu	v0,-32612(gp)
9d006608:	1040006d 	beqz	v0,9d0067c0 <cdcacm_print+0x1f8>
9d00660c:	8fbf003c 	lw	ra,60(sp)
9d006610:	18a0006b 	blez	a1,9d0067c0 <cdcacm_print+0x1f8>
9d006614:	3c020410 	lui	v0,0x410
	{
		return;
	}

	// figure out how many buffers we need
	buffersNeeded	=	(length + sizeof(gRXbuffer[0]) - 1) / sizeof(gRXbuffer[0]) + 1;
9d006618:	24a3003e 	addiu	v1,a1,62
9d00661c:	24424105 	addiu	v0,v0,16645
9d006620:	00620019 	multu	v1,v0

	previousInterrutLevel	=	SPLX(7);
9d006624:	24040007 	li	a0,7

	// forever...
	m	=	0;
9d006628:	00008021 	move	s0,zero
	{
		// compute the number of available buffers
		availableBuffers	=	(gRX_out + NRX-gRX_in) % NRX;
		if (! availableBuffers)
		{
			availableBuffers	=	NRX;
9d00662c:	24130004 	li	s3,4
		}
#ifdef _USE_USB_IRQ_
		SPLX(previousInterrutLevel);

		delay(1);
		if (m++ > 1000)
9d006630:	241403e9 	li	s4,1001
	{
		return;
	}

	// figure out how many buffers we need
	buffersNeeded	=	(length + sizeof(gRXbuffer[0]) - 1) / sizeof(gRXbuffer[0]) + 1;
9d006634:	00001010 	mfhi	v0
9d006638:	00629023 	subu	s2,v1,v0
9d00663c:	00129042 	srl	s2,s2,0x1
9d006640:	00529021 	addu	s2,v0,s2

	previousInterrutLevel	=	SPLX(7);
9d006644:	0f4018e7 	jal	9d00639c <SPLX>
9d006648:	00129142 	srl	s2,s2,0x5
	{
		return;
	}

	// figure out how many buffers we need
	buffersNeeded	=	(length + sizeof(gRXbuffer[0]) - 1) / sizeof(gRXbuffer[0]) + 1;
9d00664c:	26520001 	addiu	s2,s2,1

	previousInterrutLevel	=	SPLX(7);
9d006650:	0b40199f 	j	9d00667c <cdcacm_print+0xb4>
9d006654:	0040b021 	move	s6,v0
		{
			// we're ready to go
			break;
		}
#ifdef _USE_USB_IRQ_
		SPLX(previousInterrutLevel);
9d006658:	0f4018e7 	jal	9d00639c <SPLX>
9d00665c:	00000000 	nop

		delay(1);
9d006660:	0f401207 	jal	9d00481c <delay>
9d006664:	24040001 	li	a0,1
		if (m++ > 1000)
9d006668:	12140054 	beq	s0,s4,9d0067bc <cdcacm_print+0x1f4>
9d00666c:	24040007 	li	a0,7
		{
			return;
		}
		previousInterrutLevel	=	SPLX(7);
9d006670:	0f4018e7 	jal	9d00639c <SPLX>
9d006674:	26100001 	addiu	s0,s0,1
9d006678:	0040b021 	move	s6,v0
	// forever...
	m	=	0;
	for (;;)
	{
		// compute the number of available buffers
		availableBuffers	=	(gRX_out + NRX-gRX_in) % NRX;
9d00667c:	938380a9 	lbu	v1,-32599(gp)
9d006680:	938280aa 	lbu	v0,-32598(gp)
9d006684:	306300ff 	andi	v1,v1,0xff
9d006688:	304200ff 	andi	v0,v0,0xff
9d00668c:	24630004 	addiu	v1,v1,4
9d006690:	00621823 	subu	v1,v1,v0
9d006694:	000317c3 	sra	v0,v1,0x1f
9d006698:	00021782 	srl	v0,v0,0x1e
9d00669c:	0062b821 	addu	s7,v1,v0
9d0066a0:	32f70003 	andi	s7,s7,0x3
9d0066a4:	02e2b823 	subu	s7,s7,v0
		if (! availableBuffers)
		{
			availableBuffers	=	NRX;
9d0066a8:	0277b80a 	movz	s7,s3,s7
		}

		// if we have as many as we need...
		if (availableBuffers >= buffersNeeded)
9d0066ac:	02f2102a 	slt	v0,s7,s2
9d0066b0:	1440ffe9 	bnez	v0,9d006658 <cdcacm_print+0x90>
9d0066b4:	02c02021 	move	a0,s6
9d0066b8:	3c07a000 	lui	a3,0xa000
9d0066bc:	24e71600 	addiu	a3,a3,5632
9d0066c0:	3c12a000 	lui	s2,0xa000
9d0066c4:	26521650 	addiu	s2,s2,5712

	// while there is more data to send...
	do
	{
		// append to next gRX_in(s)
		m	=	MIN(length, sizeof(gRXbuffer[gRX_in])-gRX_length[gRX_in]);
9d0066c8:	00e0a021 	move	s4,a3
9d0066cc:	2410003f 	li	s0,63

		buffer	+=	m;
		length	-=	m;

		// if this is the first buffer of the transfer or if the transfer will need more buffers...
		if (availableBuffers == NRX || length)
9d0066d0:	24130004 	li	s3,4

	// while there is more data to send...
	do
	{
		// append to next gRX_in(s)
		m	=	MIN(length, sizeof(gRXbuffer[gRX_in])-gRX_length[gRX_in]);
9d0066d4:	938280aa 	lbu	v0,-32598(gp)
9d0066d8:	02201821 	move	v1,s1
9d0066dc:	304200ff 	andi	v0,v0,0xff
9d0066e0:	00021080 	sll	v0,v0,0x2
9d0066e4:	00e21021 	addu	v0,a3,v0
9d0066e8:	8c420000 	lw	v0,0(v0)
9d0066ec:	02021023 	subu	v0,s0,v0
9d0066f0:	0222102b 	sltu	v0,s1,v0
9d0066f4:	1440003d 	bnez	v0,9d0067ec <cdcacm_print+0x224>
9d0066f8:	0220f021 	move	s8,s1
9d0066fc:	938280aa 	lbu	v0,-32598(gp)
9d006700:	304200ff 	andi	v0,v0,0xff
9d006704:	00021080 	sll	v0,v0,0x2
9d006708:	00541021 	addu	v0,v0,s4
9d00670c:	8c5e0000 	lw	s8,0(v0)
9d006710:	021ef023 	subu	s8,s0,s8
9d006714:	03c01821 	move	v1,s8
9d006718:	023e8823 	subu	s1,s1,s8

		assert(gRX_length[gRX_in]+m <= sizeof(gRXbuffer[gRX_in]));
		memcpy(gRXbuffer[gRX_in]+gRX_length[gRX_in], buffer, m);
9d00671c:	938280aa 	lbu	v0,-32598(gp)
9d006720:	938480aa 	lbu	a0,-32598(gp)
9d006724:	02a02821 	move	a1,s5
9d006728:	304200ff 	andi	v0,v0,0xff
9d00672c:	308400ff 	andi	a0,a0,0xff
9d006730:	00042080 	sll	a0,a0,0x2
9d006734:	00e42021 	addu	a0,a3,a0
9d006738:	8c860000 	lw	a2,0(a0)
9d00673c:	00022180 	sll	a0,v0,0x6
9d006740:	00821023 	subu	v0,a0,v0
9d006744:	00462021 	addu	a0,v0,a2
9d006748:	02442021 	addu	a0,s2,a0
9d00674c:	00603021 	move	a2,v1
9d006750:	afa30010 	sw	v1,16(sp)
9d006754:	0f401c02 	jal	9d007008 <memcpy>
9d006758:	afa70014 	sw	a3,20(sp)

		gRX_length[gRX_in]	+=	m;
9d00675c:	938280aa 	lbu	v0,-32598(gp)
9d006760:	8fa70014 	lw	a3,20(sp)

		buffer	+=	m;
		length	-=	m;

		// if this is the first buffer of the transfer or if the transfer will need more buffers...
		if (availableBuffers == NRX || length)
9d006764:	8fa30010 	lw	v1,16(sp)
		m	=	MIN(length, sizeof(gRXbuffer[gRX_in])-gRX_length[gRX_in]);

		assert(gRX_length[gRX_in]+m <= sizeof(gRXbuffer[gRX_in]));
		memcpy(gRXbuffer[gRX_in]+gRX_length[gRX_in], buffer, m);

		gRX_length[gRX_in]	+=	m;
9d006768:	304200ff 	andi	v0,v0,0xff
9d00676c:	00021080 	sll	v0,v0,0x2
9d006770:	00e21021 	addu	v0,a3,v0
9d006774:	8c440000 	lw	a0,0(v0)
9d006778:	03c4f021 	addu	s8,s8,a0

		buffer	+=	m;
		length	-=	m;

		// if this is the first buffer of the transfer or if the transfer will need more buffers...
		if (availableBuffers == NRX || length)
9d00677c:	12f30023 	beq	s7,s3,9d00680c <cdcacm_print+0x244>
9d006780:	ac5e0000 	sw	s8,0(v0)
9d006784:	1620001b 	bnez	s1,9d0067f4 <cdcacm_print+0x22c>
9d006788:	02c02021 	move	a0,s6
		assert(gRX_length[gRX_out] > 0 && gRX_length[gRX_out] < PACKET_SIZE);
		usb_device_enqueue(bulk_in_ep, 1, gRXbuffer[gRX_out], gRX_length[gRX_out]);
	}

	SPLX(previousInterrutLevel);
}
9d00678c:	8fbf003c 	lw	ra,60(sp)
9d006790:	8fbe0038 	lw	s8,56(sp)
9d006794:	8fb70034 	lw	s7,52(sp)
9d006798:	8fb60030 	lw	s6,48(sp)
9d00679c:	8fb5002c 	lw	s5,44(sp)
9d0067a0:	8fb40028 	lw	s4,40(sp)
9d0067a4:	8fb30024 	lw	s3,36(sp)
9d0067a8:	8fb20020 	lw	s2,32(sp)
9d0067ac:	8fb1001c 	lw	s1,28(sp)
9d0067b0:	8fb00018 	lw	s0,24(sp)
		assert(gRX_out != gRX_in);
		assert(gRX_length[gRX_out] > 0 && gRX_length[gRX_out] < PACKET_SIZE);
		usb_device_enqueue(bulk_in_ep, 1, gRXbuffer[gRX_out], gRX_length[gRX_out]);
	}

	SPLX(previousInterrutLevel);
9d0067b4:	0b4018e7 	j	9d00639c <SPLX>
9d0067b8:	27bd0040 	addiu	sp,sp,64
}
9d0067bc:	8fbf003c 	lw	ra,60(sp)
9d0067c0:	8fbe0038 	lw	s8,56(sp)
9d0067c4:	8fb70034 	lw	s7,52(sp)
9d0067c8:	8fb60030 	lw	s6,48(sp)
9d0067cc:	8fb5002c 	lw	s5,44(sp)
9d0067d0:	8fb40028 	lw	s4,40(sp)
9d0067d4:	8fb30024 	lw	s3,36(sp)
9d0067d8:	8fb20020 	lw	s2,32(sp)
9d0067dc:	8fb1001c 	lw	s1,28(sp)
9d0067e0:	8fb00018 	lw	s0,24(sp)
9d0067e4:	03e00008 	jr	ra
9d0067e8:	27bd0040 	addiu	sp,sp,64

	// while there is more data to send...
	do
	{
		// append to next gRX_in(s)
		m	=	MIN(length, sizeof(gRXbuffer[gRX_in])-gRX_length[gRX_in]);
9d0067ec:	0b4019c7 	j	9d00671c <cdcacm_print+0x154>
9d0067f0:	00008821 	move	s1,zero
		// if this is the first buffer of the transfer or if the transfer will need more buffers...
		if (availableBuffers == NRX || length)
		{
			// advance to the next buffer
			assert(length ? gRX_length[gRX_in] == sizeof(gRXbuffer[gRX_in]) : true);
			gRX_in	=	(gRX_in+1)%NRX;
9d0067f4:	938280aa 	lbu	v0,-32598(gp)
9d0067f8:	24420001 	addiu	v0,v0,1
9d0067fc:	30420003 	andi	v0,v0,0x3
9d006800:	a38280aa 	sb	v0,-32598(gp)
		assert(gRX_length[gRX_in]+m <= sizeof(gRXbuffer[gRX_in]));
		memcpy(gRXbuffer[gRX_in]+gRX_length[gRX_in], buffer, m);

		gRX_length[gRX_in]	+=	m;

		buffer	+=	m;
9d006804:	0b4019b5 	j	9d0066d4 <cdcacm_print+0x10c>
9d006808:	02a3a821 	addu	s5,s5,v1
		// if this is the first buffer of the transfer or if the transfer will need more buffers...
		if (availableBuffers == NRX || length)
		{
			// advance to the next buffer
			assert(length ? gRX_length[gRX_in] == sizeof(gRXbuffer[gRX_in]) : true);
			gRX_in	=	(gRX_in+1)%NRX;
9d00680c:	938280aa 	lbu	v0,-32598(gp)
9d006810:	24420001 	addiu	v0,v0,1
9d006814:	30420003 	andi	v0,v0,0x3
9d006818:	a38280aa 	sb	v0,-32598(gp)
			assert(gRX_in != gRX_out);
			assert(! gRX_length[gRX_in]);
		}
	} while (length);
9d00681c:	1620ffad 	bnez	s1,9d0066d4 <cdcacm_print+0x10c>
9d006820:	02a3a821 	addu	s5,s5,v1
	if (availableBuffers == NRX)
	{
		// start the rx ball rolling
		assert(gRX_out != gRX_in);
		assert(gRX_length[gRX_out] > 0 && gRX_length[gRX_out] < PACKET_SIZE);
		usb_device_enqueue(bulk_in_ep, 1, gRXbuffer[gRX_out], gRX_length[gRX_out]);
9d006824:	938680a9 	lbu	a2,-32599(gp)
9d006828:	2403003f 	li	v1,63
9d00682c:	938280a9 	lbu	v0,-32599(gp)
9d006830:	30c600ff 	andi	a2,a2,0xff
9d006834:	70c32002 	mul	a0,a2,v1
9d006838:	24050001 	li	a1,1
9d00683c:	304200ff 	andi	v0,v0,0xff
9d006840:	00021080 	sll	v0,v0,0x2
9d006844:	0054a021 	addu	s4,v0,s4
9d006848:	8e870000 	lw	a3,0(s4)
9d00684c:	00923021 	addu	a2,a0,s2
9d006850:	0f401586 	jal	9d005618 <usb_device_enqueue>
9d006854:	938480cf 	lbu	a0,-32561(gp)
	}

	SPLX(previousInterrutLevel);
9d006858:	0b4019e3 	j	9d00678c <cdcacm_print+0x1c4>
9d00685c:	02c02021 	move	a0,s6

9d006860 <cdcacm_command_ack>:
//************************************************************************
// this function acknowledges receipt of an CDCACM command from upper
// level code.
//************************************************************************
void	cdcacm_command_ack(void)
{
9d006860:	27bdffe0 	addiu	sp,sp,-32
9d006864:	afbf001c 	sw	ra,28(sp)
	int x;

	x	=	SPLX(7);
9d006868:	0f4018e7 	jal	9d00639c <SPLX>
9d00686c:	24040007 	li	a0,7

	if (gWaiting)
9d006870:	938380a8 	lbu	v1,-32600(gp)
9d006874:	1060000b 	beqz	v1,9d0068a4 <cdcacm_command_ack+0x44>
9d006878:	8fbf001c 	lw	ra,28(sp)
	{
		// start the tx ball rolling
		usb_device_enqueue(bulk_out_ep, 0, gTXbuffer, sizeof(gTXbuffer));
9d00687c:	938480cd 	lbu	a0,-32563(gp)
9d006880:	3c06a000 	lui	a2,0xa000
9d006884:	00002821 	move	a1,zero
9d006888:	24c61610 	addiu	a2,a2,5648
9d00688c:	24070040 	li	a3,64
9d006890:	0f401586 	jal	9d005618 <usb_device_enqueue>
9d006894:	afa20010 	sw	v0,16(sp)
		gWaiting	=	false;
9d006898:	8fa20010 	lw	v0,16(sp)
9d00689c:	a38080a8 	sb	zero,-32600(gp)
	}

	SPLX(x);
}
9d0068a0:	8fbf001c 	lw	ra,28(sp)
		// start the tx ball rolling
		usb_device_enqueue(bulk_out_ep, 0, gTXbuffer, sizeof(gTXbuffer));
		gWaiting	=	false;
	}

	SPLX(x);
9d0068a4:	00402021 	move	a0,v0
9d0068a8:	0b4018e7 	j	9d00639c <SPLX>
9d0068ac:	27bd0020 	addiu	sp,sp,32

9d0068b0 <cdcacm_register>:
{
	int i;

	for (i = 0; i < NRX; i++)
	{
		gRX_length[i]	=	0;
9d0068b0:	3c03a000 	lui	v1,0xa000
	}

	gReset_cbfn		=	reset;
9d0068b4:	af8480a0 	sw	a0,-32608(gp)
	gStoredata_cbfn	=	storeData;
9d0068b8:	af8580a4 	sw	a1,-32604(gp)

	usb_register(cdcacm_reset, cdcacm_control_transfer, cdcacm_bulk_transfer);
9d0068bc:	3c069d00 	lui	a2,0x9d00
9d0068c0:	3c049d00 	lui	a0,0x9d00
9d0068c4:	3c059d00 	lui	a1,0x9d00
//************************************************************************
// this function is called by upper level code to register callback
// functions.
//************************************************************************
void	cdcacm_register(cdcacm_reset_cbfn reset, cdcacm_storedata_cbfn storeData)
{
9d0068c8:	27bdffe8 	addiu	sp,sp,-24
	int i;

	for (i = 0; i < NRX; i++)
	{
		gRX_length[i]	=	0;
9d0068cc:	24621600 	addiu	v0,v1,5632
	}

	gReset_cbfn		=	reset;
	gStoredata_cbfn	=	storeData;

	usb_register(cdcacm_reset, cdcacm_control_transfer, cdcacm_bulk_transfer);
9d0068d0:	24c660e8 	addiu	a2,a2,24808
9d0068d4:	24846218 	addiu	a0,a0,25112
9d0068d8:	24a56288 	addiu	a1,a1,25224
//************************************************************************
// this function is called by upper level code to register callback
// functions.
//************************************************************************
void	cdcacm_register(cdcacm_reset_cbfn reset, cdcacm_storedata_cbfn storeData)
{
9d0068dc:	afbf0014 	sw	ra,20(sp)
	int i;

	for (i = 0; i < NRX; i++)
	{
		gRX_length[i]	=	0;
9d0068e0:	ac601600 	sw	zero,5632(v1)
9d0068e4:	ac400004 	sw	zero,4(v0)
9d0068e8:	ac400008 	sw	zero,8(v0)
	}

	gReset_cbfn		=	reset;
	gStoredata_cbfn	=	storeData;

	usb_register(cdcacm_reset, cdcacm_control_transfer, cdcacm_bulk_transfer);
9d0068ec:	0f4017f9 	jal	9d005fe4 <usb_register>
9d0068f0:	ac40000c 	sw	zero,12(v0)

	assert(check(cdcacm_device_descriptor, sizeof(cdcacm_device_descriptor)) == 1);
	usb_device_descriptor(cdcacm_device_descriptor, sizeof(cdcacm_device_descriptor));
9d0068f4:	3c049d00 	lui	a0,0x9d00
9d0068f8:	24847eb0 	addiu	a0,a0,32432
9d0068fc:	0f4017fd 	jal	9d005ff4 <usb_device_descriptor>
9d006900:	24050012 	li	a1,18

	assert(check(cdcacm_configuration_descriptor, sizeof(cdcacm_configuration_descriptor)) == 10);
	usb_configuration_descriptor(cdcacm_configuration_descriptor, sizeof(cdcacm_configuration_descriptor));
9d006904:	3c049d00 	lui	a0,0x9d00
9d006908:	24847ec4 	addiu	a0,a0,32452
9d00690c:	0f401800 	jal	9d006000 <usb_configuration_descriptor>
9d006910:	24050043 	li	a1,67

	assert(check(cdcacm_string_descriptor, sizeof(cdcacm_string_descriptor)) == 3);
    setStrings(CDCACM_MAN, CDCACM_PROD, CDCACM_SER);
9d006914:	3c049d00 	lui	a0,0x9d00
9d006918:	3c059d00 	lui	a1,0x9d00
9d00691c:	3c069d00 	lui	a2,0x9d00
//	usb_string_descriptor(cdcacm_string_descriptor, sizeof(cdcacm_string_descriptor));
}
9d006920:	8fbf0014 	lw	ra,20(sp)

	assert(check(cdcacm_configuration_descriptor, sizeof(cdcacm_configuration_descriptor)) == 10);
	usb_configuration_descriptor(cdcacm_configuration_descriptor, sizeof(cdcacm_configuration_descriptor));

	assert(check(cdcacm_string_descriptor, sizeof(cdcacm_string_descriptor)) == 3);
    setStrings(CDCACM_MAN, CDCACM_PROD, CDCACM_SER);
9d006924:	24847e90 	addiu	a0,a0,32400
9d006928:	24a57ea4 	addiu	a1,a1,32420
9d00692c:	24c67c18 	addiu	a2,a2,31768
9d006930:	0b4018fd 	j	9d0063f4 <setStrings>
9d006934:	27bd0018 	addiu	sp,sp,24

9d006938 <malloc>:
9d006938:	3c02a000 	lui	v0,0xa000
9d00693c:	00802821 	move	a1,a0
9d006940:	8c440924 	lw	a0,2340(v0)
9d006944:	27bdffe8 	addiu	sp,sp,-24
9d006948:	afbf0014 	sw	ra,20(sp)
9d00694c:	0f401a62 	jal	9d006988 <_malloc_r>
9d006950:	00000000 	nop
9d006954:	8fbf0014 	lw	ra,20(sp)
9d006958:	03e00008 	jr	ra
9d00695c:	27bd0018 	addiu	sp,sp,24

9d006960 <free>:
9d006960:	3c02a000 	lui	v0,0xa000
9d006964:	00802821 	move	a1,a0
9d006968:	8c440924 	lw	a0,2340(v0)
9d00696c:	27bdffe8 	addiu	sp,sp,-24
9d006970:	afbf0014 	sw	ra,20(sp)
9d006974:	0f401c7c 	jal	9d0071f0 <_free_r>
9d006978:	00000000 	nop
9d00697c:	8fbf0014 	lw	ra,20(sp)
9d006980:	03e00008 	jr	ra
9d006984:	27bd0018 	addiu	sp,sp,24

9d006988 <_malloc_r>:
9d006988:	24a2000b 	addiu	v0,a1,11
9d00698c:	27bdffc8 	addiu	sp,sp,-56
9d006990:	2c430017 	sltiu	v1,v0,23
9d006994:	afb3001c 	sw	s3,28(sp)
9d006998:	afb00010 	sw	s0,16(sp)
9d00699c:	afbf0034 	sw	ra,52(sp)
9d0069a0:	afbe0030 	sw	s8,48(sp)
9d0069a4:	afb7002c 	sw	s7,44(sp)
9d0069a8:	afb60028 	sw	s6,40(sp)
9d0069ac:	afb50024 	sw	s5,36(sp)
9d0069b0:	afb40020 	sw	s4,32(sp)
9d0069b4:	afb20018 	sw	s2,24(sp)
9d0069b8:	afb10014 	sw	s1,20(sp)
9d0069bc:	00809821 	move	s3,a0
9d0069c0:	14600005 	bnez	v1,9d0069d8 <_malloc_r+0x50>
9d0069c4:	24100010 	li	s0,16
9d0069c8:	2410fff8 	li	s0,-8
9d0069cc:	00508024 	and	s0,v0,s0
9d0069d0:	06000004 	bltz	s0,9d0069e4 <_malloc_r+0x5c>
9d0069d4:	2402000c 	li	v0,12
9d0069d8:	0205282b 	sltu	a1,s0,a1
9d0069dc:	10a00003 	beqz	a1,9d0069ec <_malloc_r+0x64>
9d0069e0:	2402000c 	li	v0,12
9d0069e4:	0b401beb 	j	9d006fac <_malloc_r+0x624>
9d0069e8:	ae620000 	sw	v0,0(s3)
9d0069ec:	0f401c16 	jal	9d007058 <__malloc_lock>
9d0069f0:	02602021 	move	a0,s3
9d0069f4:	2e0201f8 	sltiu	v0,s0,504
9d0069f8:	1040000e 	beqz	v0,9d006a34 <_malloc_r+0xac>
9d0069fc:	3c11a000 	lui	s1,0xa000
9d006a00:	262200f0 	addiu	v0,s1,240
9d006a04:	00501021 	addu	v0,v0,s0
9d006a08:	8c52000c 	lw	s2,12(v0)
9d006a0c:	16420005 	bne	s2,v0,9d006a24 <_malloc_r+0x9c>
9d006a10:	001020c2 	srl	a0,s0,0x3
9d006a14:	26420008 	addiu	v0,s2,8
9d006a18:	8e520014 	lw	s2,20(s2)
9d006a1c:	12420038 	beq	s2,v0,9d006b00 <_malloc_r+0x178>
9d006a20:	24840002 	addiu	a0,a0,2
9d006a24:	8e420004 	lw	v0,4(s2)
9d006a28:	2403fffc 	li	v1,-4
9d006a2c:	0b401ab8 	j	9d006ae0 <_malloc_r+0x158>
9d006a30:	00621024 	and	v0,v1,v0
9d006a34:	00102242 	srl	a0,s0,0x9
9d006a38:	14800003 	bnez	a0,9d006a48 <_malloc_r+0xc0>
9d006a3c:	2c820005 	sltiu	v0,a0,5
9d006a40:	0b401aa9 	j	9d006aa4 <_malloc_r+0x11c>
9d006a44:	001020c2 	srl	a0,s0,0x3
9d006a48:	10400004 	beqz	v0,9d006a5c <_malloc_r+0xd4>
9d006a4c:	2c820015 	sltiu	v0,a0,21
9d006a50:	00102182 	srl	a0,s0,0x6
9d006a54:	0b401aa9 	j	9d006aa4 <_malloc_r+0x11c>
9d006a58:	24840038 	addiu	a0,a0,56
9d006a5c:	10400003 	beqz	v0,9d006a6c <_malloc_r+0xe4>
9d006a60:	2c820055 	sltiu	v0,a0,85
9d006a64:	0b401aa9 	j	9d006aa4 <_malloc_r+0x11c>
9d006a68:	2484005b 	addiu	a0,a0,91
9d006a6c:	10400004 	beqz	v0,9d006a80 <_malloc_r+0xf8>
9d006a70:	2c820155 	sltiu	v0,a0,341
9d006a74:	00102302 	srl	a0,s0,0xc
9d006a78:	0b401aa9 	j	9d006aa4 <_malloc_r+0x11c>
9d006a7c:	2484006e 	addiu	a0,a0,110
9d006a80:	10400004 	beqz	v0,9d006a94 <_malloc_r+0x10c>
9d006a84:	2c820555 	sltiu	v0,a0,1365
9d006a88:	001023c2 	srl	a0,s0,0xf
9d006a8c:	0b401aa9 	j	9d006aa4 <_malloc_r+0x11c>
9d006a90:	24840077 	addiu	a0,a0,119
9d006a94:	10400003 	beqz	v0,9d006aa4 <_malloc_r+0x11c>
9d006a98:	2404007e 	li	a0,126
9d006a9c:	00102482 	srl	a0,s0,0x12
9d006aa0:	2484007c 	addiu	a0,a0,124
9d006aa4:	000410c0 	sll	v0,a0,0x3
9d006aa8:	262300f0 	addiu	v1,s1,240
9d006aac:	00621821 	addu	v1,v1,v0
9d006ab0:	8c72000c 	lw	s2,12(v1)
9d006ab4:	0b401abd 	j	9d006af4 <_malloc_r+0x16c>
9d006ab8:	2406fffc 	li	a2,-4
9d006abc:	00c21024 	and	v0,a2,v0
9d006ac0:	00502823 	subu	a1,v0,s0
9d006ac4:	28a70010 	slti	a3,a1,16
9d006ac8:	14e00003 	bnez	a3,9d006ad8 <_malloc_r+0x150>
9d006acc:	00000000 	nop
9d006ad0:	0b401abf 	j	9d006afc <_malloc_r+0x174>
9d006ad4:	2484ffff 	addiu	a0,a0,-1
9d006ad8:	04a20006 	bltzl	a1,9d006af4 <_malloc_r+0x16c>
9d006adc:	8e52000c 	lw	s2,12(s2)
9d006ae0:	8e43000c 	lw	v1,12(s2)
9d006ae4:	8e440008 	lw	a0,8(s2)
9d006ae8:	ac83000c 	sw	v1,12(a0)
9d006aec:	0b401ad1 	j	9d006b44 <_malloc_r+0x1bc>
9d006af0:	ac640008 	sw	a0,8(v1)
9d006af4:	5643fff1 	bnel	s2,v1,9d006abc <_malloc_r+0x134>
9d006af8:	8e420004 	lw	v0,4(s2)
9d006afc:	24840001 	addiu	a0,a0,1
9d006b00:	263100f0 	addiu	s1,s1,240
9d006b04:	26230008 	addiu	v1,s1,8
9d006b08:	8c720008 	lw	s2,8(v1)
9d006b0c:	12430051 	beq	s2,v1,9d006c54 <_malloc_r+0x2cc>
9d006b10:	2405fffc 	li	a1,-4
9d006b14:	8e420004 	lw	v0,4(s2)
9d006b18:	00a21024 	and	v0,a1,v0
9d006b1c:	00502823 	subu	a1,v0,s0
9d006b20:	28a60010 	slti	a2,a1,16
9d006b24:	54c00005 	bnezl	a2,9d006b3c <_malloc_r+0x1b4>
9d006b28:	ac63000c 	sw	v1,12(v1)
9d006b2c:	02501021 	addu	v0,s2,s0
9d006b30:	36100001 	ori	s0,s0,0x1
9d006b34:	0b401b38 	j	9d006ce0 <_malloc_r+0x358>
9d006b38:	ae500004 	sw	s0,4(s2)
9d006b3c:	04a00006 	bltz	a1,9d006b58 <_malloc_r+0x1d0>
9d006b40:	ac630008 	sw	v1,8(v1)
9d006b44:	02421021 	addu	v0,s2,v0
9d006b48:	8c430004 	lw	v1,4(v0)
9d006b4c:	34630001 	ori	v1,v1,0x1
9d006b50:	0b401bf3 	j	9d006fcc <_malloc_r+0x644>
9d006b54:	ac430004 	sw	v1,4(v0)
9d006b58:	2c450200 	sltiu	a1,v0,512
9d006b5c:	10a0000c 	beqz	a1,9d006b90 <_malloc_r+0x208>
9d006b60:	00023242 	srl	a2,v0,0x9
9d006b64:	000210c2 	srl	v0,v0,0x3
9d006b68:	00022883 	sra	a1,v0,0x2
9d006b6c:	24060001 	li	a2,1
9d006b70:	00a62804 	sllv	a1,a2,a1
9d006b74:	8e260004 	lw	a2,4(s1)
9d006b78:	000210c0 	sll	v0,v0,0x3
9d006b7c:	02221021 	addu	v0,s1,v0
9d006b80:	00c52825 	or	a1,a2,a1
9d006b84:	ae250004 	sw	a1,4(s1)
9d006b88:	0b401b11 	j	9d006c44 <_malloc_r+0x2bc>
9d006b8c:	8c450008 	lw	a1,8(v0)
9d006b90:	2cc50005 	sltiu	a1,a2,5
9d006b94:	10a00004 	beqz	a1,9d006ba8 <_malloc_r+0x220>
9d006b98:	2cc50015 	sltiu	a1,a2,21
9d006b9c:	00023182 	srl	a2,v0,0x6
9d006ba0:	0b401afc 	j	9d006bf0 <_malloc_r+0x268>
9d006ba4:	24c60038 	addiu	a2,a2,56
9d006ba8:	10a00003 	beqz	a1,9d006bb8 <_malloc_r+0x230>
9d006bac:	2cc50055 	sltiu	a1,a2,85
9d006bb0:	0b401afc 	j	9d006bf0 <_malloc_r+0x268>
9d006bb4:	24c6005b 	addiu	a2,a2,91
9d006bb8:	10a00004 	beqz	a1,9d006bcc <_malloc_r+0x244>
9d006bbc:	2cc50155 	sltiu	a1,a2,341
9d006bc0:	00023302 	srl	a2,v0,0xc
9d006bc4:	0b401afc 	j	9d006bf0 <_malloc_r+0x268>
9d006bc8:	24c6006e 	addiu	a2,a2,110
9d006bcc:	10a00004 	beqz	a1,9d006be0 <_malloc_r+0x258>
9d006bd0:	2cc50555 	sltiu	a1,a2,1365
9d006bd4:	000233c2 	srl	a2,v0,0xf
9d006bd8:	0b401afc 	j	9d006bf0 <_malloc_r+0x268>
9d006bdc:	24c60077 	addiu	a2,a2,119
9d006be0:	10a00003 	beqz	a1,9d006bf0 <_malloc_r+0x268>
9d006be4:	2406007e 	li	a2,126
9d006be8:	00023482 	srl	a2,v0,0x12
9d006bec:	24c6007c 	addiu	a2,a2,124
9d006bf0:	000638c0 	sll	a3,a2,0x3
9d006bf4:	02273821 	addu	a3,s1,a3
9d006bf8:	8ce50008 	lw	a1,8(a3)
9d006bfc:	14a7000b 	bne	a1,a3,9d006c2c <_malloc_r+0x2a4>
9d006c00:	2408fffc 	li	t0,-4
9d006c04:	24020001 	li	v0,1
9d006c08:	00063083 	sra	a2,a2,0x2
9d006c0c:	00c23004 	sllv	a2,v0,a2
9d006c10:	8e220004 	lw	v0,4(s1)
9d006c14:	00463025 	or	a2,v0,a2
9d006c18:	ae260004 	sw	a2,4(s1)
9d006c1c:	0b401b11 	j	9d006c44 <_malloc_r+0x2bc>
9d006c20:	00a01021 	move	v0,a1
9d006c24:	50a70007 	beql	a1,a3,9d006c44 <_malloc_r+0x2bc>
9d006c28:	8ca2000c 	lw	v0,12(a1)
9d006c2c:	8ca60004 	lw	a2,4(a1)
9d006c30:	01063024 	and	a2,t0,a2
9d006c34:	0046302b 	sltu	a2,v0,a2
9d006c38:	54c0fffa 	bnezl	a2,9d006c24 <_malloc_r+0x29c>
9d006c3c:	8ca50008 	lw	a1,8(a1)
9d006c40:	8ca2000c 	lw	v0,12(a1)
9d006c44:	ae42000c 	sw	v0,12(s2)
9d006c48:	ae450008 	sw	a1,8(s2)
9d006c4c:	ac520008 	sw	s2,8(v0)
9d006c50:	acb2000c 	sw	s2,12(a1)
9d006c54:	24050001 	li	a1,1
9d006c58:	00041083 	sra	v0,a0,0x2
9d006c5c:	00451004 	sllv	v0,a1,v0
9d006c60:	8e250004 	lw	a1,4(s1)
9d006c64:	00a2302b 	sltu	a2,a1,v0
9d006c68:	54c00053 	bnezl	a2,9d006db8 <_malloc_r+0x430>
9d006c6c:	8e340008 	lw	s4,8(s1)
9d006c70:	00453024 	and	a2,v0,a1
9d006c74:	14c00008 	bnez	a2,9d006c98 <_malloc_r+0x310>
9d006c78:	240afffc 	li	t2,-4
9d006c7c:	2406fffc 	li	a2,-4
9d006c80:	00862024 	and	a0,a0,a2
9d006c84:	00021040 	sll	v0,v0,0x1
9d006c88:	00453024 	and	a2,v0,a1
9d006c8c:	10c0fffd 	beqz	a2,9d006c84 <_malloc_r+0x2fc>
9d006c90:	24840004 	addiu	a0,a0,4
9d006c94:	240afffc 	li	t2,-4
9d006c98:	000448c0 	sll	t1,a0,0x3
9d006c9c:	02294821 	addu	t1,s1,t1
9d006ca0:	01203821 	move	a3,t1
9d006ca4:	00803021 	move	a2,a0
9d006ca8:	0b401b4c 	j	9d006d30 <_malloc_r+0x3a8>
9d006cac:	8cf2000c 	lw	s2,12(a3)
9d006cb0:	01484024 	and	t0,t2,t0
9d006cb4:	01102823 	subu	a1,t0,s0
9d006cb8:	28ab0010 	slti	t3,a1,16
9d006cbc:	15600011 	bnez	t3,9d006d04 <_malloc_r+0x37c>
9d006cc0:	00000000 	nop
9d006cc4:	8e44000c 	lw	a0,12(s2)
9d006cc8:	8e460008 	lw	a2,8(s2)
9d006ccc:	02501021 	addu	v0,s2,s0
9d006cd0:	36100001 	ori	s0,s0,0x1
9d006cd4:	ae500004 	sw	s0,4(s2)
9d006cd8:	acc4000c 	sw	a0,12(a2)
9d006cdc:	ac860008 	sw	a2,8(a0)
9d006ce0:	ac62000c 	sw	v0,12(v1)
9d006ce4:	ac620008 	sw	v0,8(v1)
9d006ce8:	ac43000c 	sw	v1,12(v0)
9d006cec:	ac430008 	sw	v1,8(v0)
9d006cf0:	34a30001 	ori	v1,a1,0x1
9d006cf4:	ac430004 	sw	v1,4(v0)
9d006cf8:	00451021 	addu	v0,v0,a1
9d006cfc:	0b401bf3 	j	9d006fcc <_malloc_r+0x644>
9d006d00:	ac450000 	sw	a1,0(v0)
9d006d04:	04a2000a 	bltzl	a1,9d006d30 <_malloc_r+0x3a8>
9d006d08:	8e52000c 	lw	s2,12(s2)
9d006d0c:	02481021 	addu	v0,s2,t0
9d006d10:	8c430004 	lw	v1,4(v0)
9d006d14:	34630001 	ori	v1,v1,0x1
9d006d18:	ac430004 	sw	v1,4(v0)
9d006d1c:	8e42000c 	lw	v0,12(s2)
9d006d20:	8e430008 	lw	v1,8(s2)
9d006d24:	ac62000c 	sw	v0,12(v1)
9d006d28:	0b401bf3 	j	9d006fcc <_malloc_r+0x644>
9d006d2c:	ac430008 	sw	v1,8(v0)
9d006d30:	5647ffdf 	bnel	s2,a3,9d006cb0 <_malloc_r+0x328>
9d006d34:	8e480004 	lw	t0,4(s2)
9d006d38:	24c60001 	addiu	a2,a2,1
9d006d3c:	30c50003 	andi	a1,a2,0x3
9d006d40:	14a0ffd9 	bnez	a1,9d006ca8 <_malloc_r+0x320>
9d006d44:	24e70008 	addiu	a3,a3,8
9d006d48:	01202821 	move	a1,t1
9d006d4c:	30870003 	andi	a3,a0,0x3
9d006d50:	14e00006 	bnez	a3,9d006d6c <_malloc_r+0x3e4>
9d006d54:	24a7fff8 	addiu	a3,a1,-8
9d006d58:	8e250004 	lw	a1,4(s1)
9d006d5c:	00022027 	nor	a0,zero,v0
9d006d60:	00a42024 	and	a0,a1,a0
9d006d64:	0b401b5e 	j	9d006d78 <_malloc_r+0x3f0>
9d006d68:	ae240004 	sw	a0,4(s1)
9d006d6c:	8ca50000 	lw	a1,0(a1)
9d006d70:	10a7fff6 	beq	a1,a3,9d006d4c <_malloc_r+0x3c4>
9d006d74:	2484ffff 	addiu	a0,a0,-1
9d006d78:	8e250004 	lw	a1,4(s1)
9d006d7c:	00021040 	sll	v0,v0,0x1
9d006d80:	00a2202b 	sltu	a0,a1,v0
9d006d84:	5480000c 	bnezl	a0,9d006db8 <_malloc_r+0x430>
9d006d88:	8e340008 	lw	s4,8(s1)
9d006d8c:	10400009 	beqz	v0,9d006db4 <_malloc_r+0x42c>
9d006d90:	00c02021 	move	a0,a2
9d006d94:	0b401b69 	j	9d006da4 <_malloc_r+0x41c>
9d006d98:	00453024 	and	a2,v0,a1
9d006d9c:	00021040 	sll	v0,v0,0x1
9d006da0:	00453024 	and	a2,v0,a1
9d006da4:	14c0ffbd 	bnez	a2,9d006c9c <_malloc_r+0x314>
9d006da8:	000448c0 	sll	t1,a0,0x3
9d006dac:	0b401b67 	j	9d006d9c <_malloc_r+0x414>
9d006db0:	24840004 	addiu	a0,a0,4
9d006db4:	8e340008 	lw	s4,8(s1)
9d006db8:	2415fffc 	li	s5,-4
9d006dbc:	8e820004 	lw	v0,4(s4)
9d006dc0:	02a2a824 	and	s5,s5,v0
9d006dc4:	02b0102b 	sltu	v0,s5,s0
9d006dc8:	14400004 	bnez	v0,9d006ddc <_malloc_r+0x454>
9d006dcc:	02b01023 	subu	v0,s5,s0
9d006dd0:	28430010 	slti	v1,v0,16
9d006dd4:	50600077 	beqzl	v1,9d006fb4 <_malloc_r+0x62c>
9d006dd8:	8e320008 	lw	s2,8(s1)
9d006ddc:	3c02a000 	lui	v0,0xa000
9d006de0:	8c5609b0 	lw	s6,2480(v0)
9d006de4:	3c1ea000 	lui	s8,0xa000
9d006de8:	8fc30920 	lw	v1,2336(s8)
9d006dec:	26d60010 	addiu	s6,s6,16
9d006df0:	2402ffff 	li	v0,-1
9d006df4:	10620004 	beq	v1,v0,9d006e08 <_malloc_r+0x480>
9d006df8:	02d0b021 	addu	s6,s6,s0
9d006dfc:	26d6007f 	addiu	s6,s6,127
9d006e00:	2402ff80 	li	v0,-128
9d006e04:	02c2b024 	and	s6,s6,v0
9d006e08:	02602021 	move	a0,s3
9d006e0c:	0f401c1a 	jal	9d007068 <_sbrk_r>
9d006e10:	02c02821 	move	a1,s6
9d006e14:	00409021 	move	s2,v0
9d006e18:	2402ffff 	li	v0,-1
9d006e1c:	12420056 	beq	s2,v0,9d006f78 <_malloc_r+0x5f0>
9d006e20:	02951021 	addu	v0,s4,s5
9d006e24:	0242182b 	sltu	v1,s2,v0
9d006e28:	10600004 	beqz	v1,9d006e3c <_malloc_r+0x4b4>
9d006e2c:	3c17a000 	lui	s7,0xa000
9d006e30:	56910052 	bnel	s4,s1,9d006f7c <_malloc_r+0x5f4>
9d006e34:	8e220008 	lw	v0,8(s1)
9d006e38:	3c17a000 	lui	s7,0xa000
9d006e3c:	8ee3174c 	lw	v1,5964(s7)
9d006e40:	02c31821 	addu	v1,s6,v1
9d006e44:	16420009 	bne	s2,v0,9d006e6c <_malloc_r+0x4e4>
9d006e48:	aee3174c 	sw	v1,5964(s7)
9d006e4c:	3244007f 	andi	a0,s2,0x7f
9d006e50:	54800007 	bnezl	a0,9d006e70 <_malloc_r+0x4e8>
9d006e54:	8fc50920 	lw	a1,2336(s8)
9d006e58:	8e220008 	lw	v0,8(s1)
9d006e5c:	02d5a821 	addu	s5,s6,s5
9d006e60:	36b50001 	ori	s5,s5,0x1
9d006e64:	0b401bd3 	j	9d006f4c <_malloc_r+0x5c4>
9d006e68:	ac550004 	sw	s5,4(v0)
9d006e6c:	8fc50920 	lw	a1,2336(s8)
9d006e70:	2404ffff 	li	a0,-1
9d006e74:	14a40004 	bne	a1,a0,9d006e88 <_malloc_r+0x500>
9d006e78:	02431821 	addu	v1,s2,v1
9d006e7c:	3c02a000 	lui	v0,0xa000
9d006e80:	0b401ba4 	j	9d006e90 <_malloc_r+0x508>
9d006e84:	ac520920 	sw	s2,2336(v0)
9d006e88:	00621023 	subu	v0,v1,v0
9d006e8c:	aee2174c 	sw	v0,5964(s7)
9d006e90:	32430007 	andi	v1,s2,0x7
9d006e94:	10600004 	beqz	v1,9d006ea8 <_malloc_r+0x520>
9d006e98:	00001021 	move	v0,zero
9d006e9c:	24020008 	li	v0,8
9d006ea0:	00431023 	subu	v0,v0,v1
9d006ea4:	02429021 	addu	s2,s2,v0
9d006ea8:	0256b021 	addu	s6,s2,s6
9d006eac:	24420080 	addiu	v0,v0,128
9d006eb0:	32d6007f 	andi	s6,s6,0x7f
9d006eb4:	0056b023 	subu	s6,v0,s6
9d006eb8:	02602021 	move	a0,s3
9d006ebc:	0f401c1a 	jal	9d007068 <_sbrk_r>
9d006ec0:	02c02821 	move	a1,s6
9d006ec4:	2403ffff 	li	v1,-1
9d006ec8:	14430003 	bne	v0,v1,9d006ed8 <_malloc_r+0x550>
9d006ecc:	8ee3174c 	lw	v1,5964(s7)
9d006ed0:	02401021 	move	v0,s2
9d006ed4:	0000b021 	move	s6,zero
9d006ed8:	00521023 	subu	v0,v0,s2
9d006edc:	ae320008 	sw	s2,8(s1)
9d006ee0:	02c31821 	addu	v1,s6,v1
9d006ee4:	0056b021 	addu	s6,v0,s6
9d006ee8:	36d60001 	ori	s6,s6,0x1
9d006eec:	aee3174c 	sw	v1,5964(s7)
9d006ef0:	12910016 	beq	s4,s1,9d006f4c <_malloc_r+0x5c4>
9d006ef4:	ae560004 	sw	s6,4(s2)
9d006ef8:	2ea20010 	sltiu	v0,s5,16
9d006efc:	10400004 	beqz	v0,9d006f10 <_malloc_r+0x588>
9d006f00:	2402fff8 	li	v0,-8
9d006f04:	24020001 	li	v0,1
9d006f08:	0b401bde 	j	9d006f78 <_malloc_r+0x5f0>
9d006f0c:	ae420004 	sw	v0,4(s2)
9d006f10:	26b5fff4 	addiu	s5,s5,-12
9d006f14:	02a2a824 	and	s5,s5,v0
9d006f18:	8e820004 	lw	v0,4(s4)
9d006f1c:	24030005 	li	v1,5
9d006f20:	30420001 	andi	v0,v0,0x1
9d006f24:	02a21025 	or	v0,s5,v0
9d006f28:	ae820004 	sw	v0,4(s4)
9d006f2c:	02951021 	addu	v0,s4,s5
9d006f30:	2eb50010 	sltiu	s5,s5,16
9d006f34:	ac430004 	sw	v1,4(v0)
9d006f38:	16a00004 	bnez	s5,9d006f4c <_malloc_r+0x5c4>
9d006f3c:	ac430008 	sw	v1,8(v0)
9d006f40:	02602021 	move	a0,s3
9d006f44:	0f401c7c 	jal	9d0071f0 <_free_r>
9d006f48:	26850008 	addiu	a1,s4,8
9d006f4c:	3c03a000 	lui	v1,0xa000
9d006f50:	8ee2174c 	lw	v0,5964(s7)
9d006f54:	8c6409b4 	lw	a0,2484(v1)
9d006f58:	0082202b 	sltu	a0,a0,v0
9d006f5c:	54800001 	bnezl	a0,9d006f64 <_malloc_r+0x5dc>
9d006f60:	ac6209b4 	sw	v0,2484(v1)
9d006f64:	3c03a000 	lui	v1,0xa000
9d006f68:	8c6409b8 	lw	a0,2488(v1)
9d006f6c:	0082202b 	sltu	a0,a0,v0
9d006f70:	54800001 	bnezl	a0,9d006f78 <_malloc_r+0x5f0>
9d006f74:	ac6209b8 	sw	v0,2488(v1)
9d006f78:	8e220008 	lw	v0,8(s1)
9d006f7c:	2403fffc 	li	v1,-4
9d006f80:	8c420004 	lw	v0,4(v0)
9d006f84:	00621024 	and	v0,v1,v0
9d006f88:	0050182b 	sltu	v1,v0,s0
9d006f8c:	14600005 	bnez	v1,9d006fa4 <_malloc_r+0x61c>
9d006f90:	00000000 	nop
9d006f94:	00501023 	subu	v0,v0,s0
9d006f98:	28430010 	slti	v1,v0,16
9d006f9c:	50600005 	beqzl	v1,9d006fb4 <_malloc_r+0x62c>
9d006fa0:	8e320008 	lw	s2,8(s1)
9d006fa4:	0f401c18 	jal	9d007060 <__malloc_unlock>
9d006fa8:	02602021 	move	a0,s3
9d006fac:	0b401bf6 	j	9d006fd8 <_malloc_r+0x650>
9d006fb0:	00001021 	move	v0,zero
9d006fb4:	36030001 	ori	v1,s0,0x1
9d006fb8:	34420001 	ori	v0,v0,0x1
9d006fbc:	02508021 	addu	s0,s2,s0
9d006fc0:	ae430004 	sw	v1,4(s2)
9d006fc4:	ae300008 	sw	s0,8(s1)
9d006fc8:	ae020004 	sw	v0,4(s0)
9d006fcc:	0f401c18 	jal	9d007060 <__malloc_unlock>
9d006fd0:	02602021 	move	a0,s3
9d006fd4:	26420008 	addiu	v0,s2,8
9d006fd8:	8fbf0034 	lw	ra,52(sp)
9d006fdc:	8fbe0030 	lw	s8,48(sp)
9d006fe0:	8fb7002c 	lw	s7,44(sp)
9d006fe4:	8fb60028 	lw	s6,40(sp)
9d006fe8:	8fb50024 	lw	s5,36(sp)
9d006fec:	8fb40020 	lw	s4,32(sp)
9d006ff0:	8fb3001c 	lw	s3,28(sp)
9d006ff4:	8fb20018 	lw	s2,24(sp)
9d006ff8:	8fb10014 	lw	s1,20(sp)
9d006ffc:	8fb00010 	lw	s0,16(sp)
9d007000:	03e00008 	jr	ra
9d007004:	27bd0038 	addiu	sp,sp,56

9d007008 <memcpy>:
9d007008:	00801021 	move	v0,a0
9d00700c:	0b401c09 	j	9d007024 <memcpy+0x1c>
9d007010:	00801821 	move	v1,a0
9d007014:	24c6ffff 	addiu	a2,a2,-1
9d007018:	24a50001 	addiu	a1,a1,1
9d00701c:	a0640000 	sb	a0,0(v1)
9d007020:	24630001 	addiu	v1,v1,1
9d007024:	54c0fffb 	bnezl	a2,9d007014 <memcpy+0xc>
9d007028:	90a40000 	lbu	a0,0(a1)
9d00702c:	03e00008 	jr	ra
9d007030:	00000000 	nop

9d007034 <memset>:
9d007034:	00801021 	move	v0,a0
9d007038:	0b401c12 	j	9d007048 <memset+0x14>
9d00703c:	00801821 	move	v1,a0
9d007040:	24c6ffff 	addiu	a2,a2,-1
9d007044:	24630001 	addiu	v1,v1,1
9d007048:	54c0fffd 	bnezl	a2,9d007040 <memset+0xc>
9d00704c:	a0650000 	sb	a1,0(v1)
9d007050:	03e00008 	jr	ra
9d007054:	00000000 	nop

9d007058 <__malloc_lock>:
9d007058:	03e00008 	jr	ra
9d00705c:	00000000 	nop

9d007060 <__malloc_unlock>:
9d007060:	03e00008 	jr	ra
9d007064:	00000000 	nop

9d007068 <_sbrk_r>:
9d007068:	27bdffe0 	addiu	sp,sp,-32
9d00706c:	afb10018 	sw	s1,24(sp)
9d007070:	afb00014 	sw	s0,20(sp)
9d007074:	00808821 	move	s1,a0
9d007078:	3c10a000 	lui	s0,0xa000
9d00707c:	00a02021 	move	a0,a1
9d007080:	afbf001c 	sw	ra,28(sp)
9d007084:	0f401e0e 	jal	9d007838 <sbrk>
9d007088:	ae0009e0 	sw	zero,2528(s0)
9d00708c:	2403ffff 	li	v1,-1
9d007090:	14430005 	bne	v0,v1,9d0070a8 <_sbrk_r+0x40>
9d007094:	8fbf001c 	lw	ra,28(sp)
9d007098:	8e0309e0 	lw	v1,2528(s0)
9d00709c:	54600001 	bnezl	v1,9d0070a4 <_sbrk_r+0x3c>
9d0070a0:	ae230000 	sw	v1,0(s1)
9d0070a4:	8fbf001c 	lw	ra,28(sp)
9d0070a8:	8fb10018 	lw	s1,24(sp)
9d0070ac:	8fb00014 	lw	s0,20(sp)
9d0070b0:	03e00008 	jr	ra
9d0070b4:	27bd0020 	addiu	sp,sp,32

9d0070b8 <strlen>:
9d0070b8:	24820001 	addiu	v0,a0,1
9d0070bc:	90830000 	lbu	v1,0(a0)
9d0070c0:	1460fffe 	bnez	v1,9d0070bc <strlen+0x4>
9d0070c4:	24840001 	addiu	a0,a0,1
9d0070c8:	03e00008 	jr	ra
9d0070cc:	00821023 	subu	v0,a0,v0

9d0070d0 <_malloc_trim_r>:
9d0070d0:	27bdffd0 	addiu	sp,sp,-48
9d0070d4:	afb20024 	sw	s2,36(sp)
9d0070d8:	3c12a000 	lui	s2,0xa000
9d0070dc:	265200f0 	addiu	s2,s2,240
9d0070e0:	afb30028 	sw	s3,40(sp)
9d0070e4:	afb10020 	sw	s1,32(sp)
9d0070e8:	afb0001c 	sw	s0,28(sp)
9d0070ec:	afa50010 	sw	a1,16(sp)
9d0070f0:	afbf002c 	sw	ra,44(sp)
9d0070f4:	0f401c16 	jal	9d007058 <__malloc_lock>
9d0070f8:	00808021 	move	s0,a0
9d0070fc:	8e420008 	lw	v0,8(s2)
9d007100:	2413fffc 	li	s3,-4
9d007104:	8fa50010 	lw	a1,16(sp)
9d007108:	8c420004 	lw	v0,4(v0)
9d00710c:	02629824 	and	s3,s3,v0
9d007110:	2671006f 	addiu	s1,s3,111
9d007114:	02258823 	subu	s1,s1,a1
9d007118:	001189c2 	srl	s1,s1,0x7
9d00711c:	2631ffff 	addiu	s1,s1,-1
9d007120:	001189c0 	sll	s1,s1,0x7
9d007124:	2a220080 	slti	v0,s1,128
9d007128:	1440001c 	bnez	v0,9d00719c <_malloc_trim_r+0xcc>
9d00712c:	00000000 	nop
9d007130:	02002021 	move	a0,s0
9d007134:	0f401c1a 	jal	9d007068 <_sbrk_r>
9d007138:	00002821 	move	a1,zero
9d00713c:	8e430008 	lw	v1,8(s2)
9d007140:	00731821 	addu	v1,v1,s3
9d007144:	14430015 	bne	v0,v1,9d00719c <_malloc_trim_r+0xcc>
9d007148:	00000000 	nop
9d00714c:	02002021 	move	a0,s0
9d007150:	0f401c1a 	jal	9d007068 <_sbrk_r>
9d007154:	00112823 	negu	a1,s1
9d007158:	2403ffff 	li	v1,-1
9d00715c:	54430013 	bnel	v0,v1,9d0071ac <_malloc_trim_r+0xdc>
9d007160:	8e420008 	lw	v0,8(s2)
9d007164:	02002021 	move	a0,s0
9d007168:	0f401c1a 	jal	9d007068 <_sbrk_r>
9d00716c:	00002821 	move	a1,zero
9d007170:	8e430008 	lw	v1,8(s2)
9d007174:	00432023 	subu	a0,v0,v1
9d007178:	28850010 	slti	a1,a0,16
9d00717c:	14a00007 	bnez	a1,9d00719c <_malloc_trim_r+0xcc>
9d007180:	3c05a000 	lui	a1,0xa000
9d007184:	8ca50920 	lw	a1,2336(a1)
9d007188:	34840001 	ori	a0,a0,0x1
9d00718c:	ac640004 	sw	a0,4(v1)
9d007190:	00451023 	subu	v0,v0,a1
9d007194:	3c05a000 	lui	a1,0xa000
9d007198:	aca2174c 	sw	v0,5964(a1)
9d00719c:	0f401c18 	jal	9d007060 <__malloc_unlock>
9d0071a0:	02002021 	move	a0,s0
9d0071a4:	0b401c75 	j	9d0071d4 <_malloc_trim_r+0x104>
9d0071a8:	00001021 	move	v0,zero
9d0071ac:	02719823 	subu	s3,s3,s1
9d0071b0:	36730001 	ori	s3,s3,0x1
9d0071b4:	ac530004 	sw	s3,4(v0)
9d0071b8:	3c02a000 	lui	v0,0xa000
9d0071bc:	8c43174c 	lw	v1,5964(v0)
9d0071c0:	02002021 	move	a0,s0
9d0071c4:	00718823 	subu	s1,v1,s1
9d0071c8:	0f401c18 	jal	9d007060 <__malloc_unlock>
9d0071cc:	ac51174c 	sw	s1,5964(v0)
9d0071d0:	24020001 	li	v0,1
9d0071d4:	8fbf002c 	lw	ra,44(sp)
9d0071d8:	8fb30028 	lw	s3,40(sp)
9d0071dc:	8fb20024 	lw	s2,36(sp)
9d0071e0:	8fb10020 	lw	s1,32(sp)
9d0071e4:	8fb0001c 	lw	s0,28(sp)
9d0071e8:	03e00008 	jr	ra
9d0071ec:	27bd0030 	addiu	sp,sp,48

9d0071f0 <_free_r>:
9d0071f0:	27bdffe0 	addiu	sp,sp,-32
9d0071f4:	afb00018 	sw	s0,24(sp)
9d0071f8:	afbf001c 	sw	ra,28(sp)
9d0071fc:	10a00093 	beqz	a1,9d00744c <_free_r+0x25c>
9d007200:	00808021 	move	s0,a0
9d007204:	0f401c16 	jal	9d007058 <__malloc_lock>
9d007208:	afa50010 	sw	a1,16(sp)
9d00720c:	8fa50010 	lw	a1,16(sp)
9d007210:	2403fffe 	li	v1,-2
9d007214:	2408fffc 	li	t0,-4
9d007218:	24a2fff8 	addiu	v0,a1,-8
9d00721c:	8c490004 	lw	t1,4(v0)
9d007220:	01231824 	and	v1,t1,v1
9d007224:	00433021 	addu	a2,v0,v1
9d007228:	8cc40004 	lw	a0,4(a2)
9d00722c:	01044024 	and	t0,t0,a0
9d007230:	3c04a000 	lui	a0,0xa000
9d007234:	248400f0 	addiu	a0,a0,240
9d007238:	8c870008 	lw	a3,8(a0)
9d00723c:	14c70017 	bne	a2,a3,9d00729c <_free_r+0xac>
9d007240:	31290001 	andi	t1,t1,0x1
9d007244:	15200008 	bnez	t1,9d007268 <_free_r+0x78>
9d007248:	01031821 	addu	v1,t0,v1
9d00724c:	8ca5fff8 	lw	a1,-8(a1)
9d007250:	00451023 	subu	v0,v0,a1
9d007254:	8c460008 	lw	a2,8(v0)
9d007258:	00651821 	addu	v1,v1,a1
9d00725c:	8c45000c 	lw	a1,12(v0)
9d007260:	acc5000c 	sw	a1,12(a2)
9d007264:	aca60008 	sw	a2,8(a1)
9d007268:	34650001 	ori	a1,v1,0x1
9d00726c:	ac450004 	sw	a1,4(v0)
9d007270:	ac820008 	sw	v0,8(a0)
9d007274:	3c02a000 	lui	v0,0xa000
9d007278:	8c48091c 	lw	t0,2332(v0)
9d00727c:	0068182b 	sltu	v1,v1,t0
9d007280:	14600070 	bnez	v1,9d007444 <_free_r+0x254>
9d007284:	3c02a000 	lui	v0,0xa000
9d007288:	8c4509b0 	lw	a1,2480(v0)
9d00728c:	0f401c34 	jal	9d0070d0 <_malloc_trim_r>
9d007290:	02002021 	move	a0,s0
9d007294:	0b401d11 	j	9d007444 <_free_r+0x254>
9d007298:	00000000 	nop
9d00729c:	acc80004 	sw	t0,4(a2)
9d0072a0:	1520000c 	bnez	t1,9d0072d4 <_free_r+0xe4>
9d0072a4:	00003821 	move	a3,zero
9d0072a8:	8ca5fff8 	lw	a1,-8(a1)
9d0072ac:	24890008 	addiu	t1,a0,8
9d0072b0:	00451023 	subu	v0,v0,a1
9d0072b4:	00651821 	addu	v1,v1,a1
9d0072b8:	8c450008 	lw	a1,8(v0)
9d0072bc:	10a90005 	beq	a1,t1,9d0072d4 <_free_r+0xe4>
9d0072c0:	24070001 	li	a3,1
9d0072c4:	8c47000c 	lw	a3,12(v0)
9d0072c8:	aca7000c 	sw	a3,12(a1)
9d0072cc:	ace50008 	sw	a1,8(a3)
9d0072d0:	00003821 	move	a3,zero
9d0072d4:	00c82821 	addu	a1,a2,t0
9d0072d8:	8ca50004 	lw	a1,4(a1)
9d0072dc:	30a50001 	andi	a1,a1,0x1
9d0072e0:	14a00011 	bnez	a1,9d007328 <_free_r+0x138>
9d0072e4:	34650001 	ori	a1,v1,0x1
9d0072e8:	00681821 	addu	v1,v1,t0
9d0072ec:	14e0000a 	bnez	a3,9d007318 <_free_r+0x128>
9d0072f0:	8cc50008 	lw	a1,8(a2)
9d0072f4:	24880008 	addiu	t0,a0,8
9d0072f8:	54a80008 	bnel	a1,t0,9d00731c <_free_r+0x12c>
9d0072fc:	8cc6000c 	lw	a2,12(a2)
9d007300:	aca2000c 	sw	v0,12(a1)
9d007304:	aca20008 	sw	v0,8(a1)
9d007308:	ac45000c 	sw	a1,12(v0)
9d00730c:	ac450008 	sw	a1,8(v0)
9d007310:	0b401cc9 	j	9d007324 <_free_r+0x134>
9d007314:	24070001 	li	a3,1
9d007318:	8cc6000c 	lw	a2,12(a2)
9d00731c:	aca6000c 	sw	a2,12(a1)
9d007320:	acc50008 	sw	a1,8(a2)
9d007324:	34650001 	ori	a1,v1,0x1
9d007328:	ac450004 	sw	a1,4(v0)
9d00732c:	00432821 	addu	a1,v0,v1
9d007330:	14e00044 	bnez	a3,9d007444 <_free_r+0x254>
9d007334:	aca30000 	sw	v1,0(a1)
9d007338:	2c650200 	sltiu	a1,v1,512
9d00733c:	10a00010 	beqz	a1,9d007380 <_free_r+0x190>
9d007340:	00033242 	srl	a2,v1,0x9
9d007344:	000318c2 	srl	v1,v1,0x3
9d007348:	00032883 	sra	a1,v1,0x2
9d00734c:	24060001 	li	a2,1
9d007350:	00a62804 	sllv	a1,a2,a1
9d007354:	8c860004 	lw	a2,4(a0)
9d007358:	000318c0 	sll	v1,v1,0x3
9d00735c:	00c52825 	or	a1,a2,a1
9d007360:	ac850004 	sw	a1,4(a0)
9d007364:	00832021 	addu	a0,a0,v1
9d007368:	8c830008 	lw	v1,8(a0)
9d00736c:	ac44000c 	sw	a0,12(v0)
9d007370:	ac430008 	sw	v1,8(v0)
9d007374:	ac62000c 	sw	v0,12(v1)
9d007378:	0b401d11 	j	9d007444 <_free_r+0x254>
9d00737c:	ac820008 	sw	v0,8(a0)
9d007380:	2cc50005 	sltiu	a1,a2,5
9d007384:	10a00004 	beqz	a1,9d007398 <_free_r+0x1a8>
9d007388:	2cc50015 	sltiu	a1,a2,21
9d00738c:	00033182 	srl	a2,v1,0x6
9d007390:	0b401cf8 	j	9d0073e0 <_free_r+0x1f0>
9d007394:	24c60038 	addiu	a2,a2,56
9d007398:	10a00003 	beqz	a1,9d0073a8 <_free_r+0x1b8>
9d00739c:	2cc50055 	sltiu	a1,a2,85
9d0073a0:	0b401cf8 	j	9d0073e0 <_free_r+0x1f0>
9d0073a4:	24c6005b 	addiu	a2,a2,91
9d0073a8:	10a00004 	beqz	a1,9d0073bc <_free_r+0x1cc>
9d0073ac:	2cc50155 	sltiu	a1,a2,341
9d0073b0:	00033302 	srl	a2,v1,0xc
9d0073b4:	0b401cf8 	j	9d0073e0 <_free_r+0x1f0>
9d0073b8:	24c6006e 	addiu	a2,a2,110
9d0073bc:	10a00004 	beqz	a1,9d0073d0 <_free_r+0x1e0>
9d0073c0:	2cc50555 	sltiu	a1,a2,1365
9d0073c4:	000333c2 	srl	a2,v1,0xf
9d0073c8:	0b401cf8 	j	9d0073e0 <_free_r+0x1f0>
9d0073cc:	24c60077 	addiu	a2,a2,119
9d0073d0:	10a00003 	beqz	a1,9d0073e0 <_free_r+0x1f0>
9d0073d4:	2406007e 	li	a2,126
9d0073d8:	00033482 	srl	a2,v1,0x12
9d0073dc:	24c6007c 	addiu	a2,a2,124
9d0073e0:	000638c0 	sll	a3,a2,0x3
9d0073e4:	00873821 	addu	a3,a0,a3
9d0073e8:	8ce50008 	lw	a1,8(a3)
9d0073ec:	14a7000b 	bne	a1,a3,9d00741c <_free_r+0x22c>
9d0073f0:	2408fffc 	li	t0,-4
9d0073f4:	24030001 	li	v1,1
9d0073f8:	00063083 	sra	a2,a2,0x2
9d0073fc:	00c33004 	sllv	a2,v1,a2
9d007400:	8c830004 	lw	v1,4(a0)
9d007404:	00663025 	or	a2,v1,a2
9d007408:	ac860004 	sw	a2,4(a0)
9d00740c:	0b401d0d 	j	9d007434 <_free_r+0x244>
9d007410:	00a01821 	move	v1,a1
9d007414:	50a70007 	beql	a1,a3,9d007434 <_free_r+0x244>
9d007418:	8ca3000c 	lw	v1,12(a1)
9d00741c:	8ca40004 	lw	a0,4(a1)
9d007420:	01042024 	and	a0,t0,a0
9d007424:	0064202b 	sltu	a0,v1,a0
9d007428:	5480fffa 	bnezl	a0,9d007414 <_free_r+0x224>
9d00742c:	8ca50008 	lw	a1,8(a1)
9d007430:	8ca3000c 	lw	v1,12(a1)
9d007434:	ac43000c 	sw	v1,12(v0)
9d007438:	ac450008 	sw	a1,8(v0)
9d00743c:	aca2000c 	sw	v0,12(a1)
9d007440:	ac620008 	sw	v0,8(v1)
9d007444:	0f401c18 	jal	9d007060 <__malloc_unlock>
9d007448:	02002021 	move	a0,s0
9d00744c:	8fbf001c 	lw	ra,28(sp)
9d007450:	8fb00018 	lw	s0,24(sp)
9d007454:	03e00008 	jr	ra
9d007458:	27bd0020 	addiu	sp,sp,32

9d00745c <_Znwm>:
9d00745c:	27bdffe8 	addiu	sp,sp,-24
9d007460:	afb00010 	sw	s0,16(sp)
9d007464:	24100001 	li	s0,1
9d007468:	0084800b 	movn	s0,a0,a0
9d00746c:	afbf0014 	sw	ra,20(sp)
9d007470:	0f401a4e 	jal	9d006938 <malloc>
9d007474:	02002021 	move	a0,s0
9d007478:	1440000b 	bnez	v0,9d0074a8 <_Znwm+0x4c>
9d00747c:	8fbf0014 	lw	ra,20(sp)
9d007480:	8f8280bc 	lw	v0,-32580(gp)
9d007484:	1040000b 	beqz	v0,9d0074b4 <_Znwm+0x58>
9d007488:	00000000 	nop
9d00748c:	0040f809 	jalr	v0
9d007490:	00000000 	nop
9d007494:	0f401a4e 	jal	9d006938 <malloc>
9d007498:	02002021 	move	a0,s0
9d00749c:	5040fff9 	beqzl	v0,9d007484 <_Znwm+0x28>
9d0074a0:	8f8280bc 	lw	v0,-32580(gp)
9d0074a4:	8fbf0014 	lw	ra,20(sp)
9d0074a8:	8fb00010 	lw	s0,16(sp)
9d0074ac:	03e00008 	jr	ra
9d0074b0:	27bd0018 	addiu	sp,sp,24
9d0074b4:	0f401e22 	jal	9d007888 <abort>
9d0074b8:	00000000 	nop

9d0074bc <_general_exception_context>:
9d0074bc:	27bdffa8 	addiu	sp,sp,-88
9d0074c0:	afa10004 	sw	at,4(sp)
9d0074c4:	afa20008 	sw	v0,8(sp)
9d0074c8:	afa3000c 	sw	v1,12(sp)
9d0074cc:	afa40010 	sw	a0,16(sp)
9d0074d0:	afa50014 	sw	a1,20(sp)
9d0074d4:	afa60018 	sw	a2,24(sp)
9d0074d8:	afa7001c 	sw	a3,28(sp)
9d0074dc:	afa80020 	sw	t0,32(sp)
9d0074e0:	afa90024 	sw	t1,36(sp)
9d0074e4:	afaa0028 	sw	t2,40(sp)
9d0074e8:	afab002c 	sw	t3,44(sp)
9d0074ec:	afac0030 	sw	t4,48(sp)
9d0074f0:	afad0034 	sw	t5,52(sp)
9d0074f4:	afae0038 	sw	t6,56(sp)
9d0074f8:	afaf003c 	sw	t7,60(sp)
9d0074fc:	afb80040 	sw	t8,64(sp)
9d007500:	afb90044 	sw	t9,68(sp)
9d007504:	afbf0048 	sw	ra,72(sp)
9d007508:	00004012 	mflo	t0
9d00750c:	afa8004c 	sw	t0,76(sp)
9d007510:	00004010 	mfhi	t0
9d007514:	afa80050 	sw	t0,80(sp)
9d007518:	40046800 	mfc0	a0,c0_cause
9d00751c:	40056000 	mfc0	a1,c0_status
9d007520:	0f401d63 	jal	9d00758c <_general_exception_handler>
9d007524:	00000000 	nop
9d007528:	8fa80050 	lw	t0,80(sp)
9d00752c:	01000011 	mthi	t0
9d007530:	8fa8004c 	lw	t0,76(sp)
9d007534:	01000013 	mtlo	t0
9d007538:	8fa10004 	lw	at,4(sp)
9d00753c:	8fa20008 	lw	v0,8(sp)
9d007540:	8fa3000c 	lw	v1,12(sp)
9d007544:	8fa40010 	lw	a0,16(sp)
9d007548:	8fa50014 	lw	a1,20(sp)
9d00754c:	8fa60018 	lw	a2,24(sp)
9d007550:	8fa7001c 	lw	a3,28(sp)
9d007554:	8fa80020 	lw	t0,32(sp)
9d007558:	8fa90024 	lw	t1,36(sp)
9d00755c:	8faa0028 	lw	t2,40(sp)
9d007560:	8fab002c 	lw	t3,44(sp)
9d007564:	8fac0030 	lw	t4,48(sp)
9d007568:	8fad0034 	lw	t5,52(sp)
9d00756c:	8fae0038 	lw	t6,56(sp)
9d007570:	8faf003c 	lw	t7,60(sp)
9d007574:	8fb80040 	lw	t8,64(sp)
9d007578:	8fb90044 	lw	t9,68(sp)
9d00757c:	8fbf0048 	lw	ra,72(sp)
9d007580:	27bd0058 	addiu	sp,sp,88
9d007584:	000000c0 	ehb
9d007588:	42000018 	eret

9d00758c <_general_exception_handler>:
9d00758c:	0b401d63 	j	9d00758c <_general_exception_handler>
9d007590:	00000000 	nop

9d007594 <_on_reset>:
9d007594:	03e00008 	jr	ra
9d007598:	00000000 	nop

9d00759c <_on_bootstrap>:
9d00759c:	03e00008 	jr	ra
9d0075a0:	00000000 	nop

9d0075a4 <_nmi_handler>:
9d0075a4:	401a6000 	mfc0	k0,c0_status
9d0075a8:	3c1bffbf 	lui	k1,0xffbf
9d0075ac:	377bffff 	ori	k1,k1,0xffff
9d0075b0:	035bd024 	and	k0,k0,k1
9d0075b4:	409a6000 	mtc0	k0,c0_status
9d0075b8:	42000018 	eret

9d0075bc <_stub_sbd_memlayout>:
9d0075bc:	3c03a000 	lui	v1,0xa000
9d0075c0:	24621778 	addiu	v0,v1,6008
9d0075c4:	24040001 	li	a0,1
9d0075c8:	ac440008 	sw	a0,8(v0)
9d0075cc:	3c04a000 	lui	a0,0xa000
9d0075d0:	24841910 	addiu	a0,a0,6416
9d0075d4:	ac641778 	sw	a0,6008(v1)
9d0075d8:	3c030000 	lui	v1,0x0
9d0075dc:	24630800 	addiu	v1,v1,2048
9d0075e0:	03e00008 	jr	ra
9d0075e4:	ac430004 	sw	v1,4(v0)

9d0075e8 <_sbrk_init>:
9d0075e8:	27bdffd8 	addiu	sp,sp,-40
9d0075ec:	afb00010 	sw	s0,16(sp)
9d0075f0:	3c10a000 	lui	s0,0xa000
9d0075f4:	8e021774 	lw	v0,6004(s0)
9d0075f8:	afbf0024 	sw	ra,36(sp)
9d0075fc:	afb40020 	sw	s4,32(sp)
9d007600:	afb3001c 	sw	s3,28(sp)
9d007604:	afb20018 	sw	s2,24(sp)
9d007608:	10400009 	beqz	v0,9d007630 <_sbrk_init+0x48>
9d00760c:	afb10014 	sw	s1,20(sp)
9d007610:	8fbf0024 	lw	ra,36(sp)
9d007614:	8fb40020 	lw	s4,32(sp)
9d007618:	8fb3001c 	lw	s3,28(sp)
9d00761c:	8fb20018 	lw	s2,24(sp)
9d007620:	8fb10014 	lw	s1,20(sp)
9d007624:	8fb00010 	lw	s0,16(sp)
9d007628:	03e00008 	jr	ra
9d00762c:	27bd0028 	addiu	sp,sp,40
9d007630:	3c13a000 	lui	s3,0xa000
9d007634:	8e6309c0 	lw	v1,2496(s3)
9d007638:	50600040 	beqzl	v1,9d00773c <_sbrk_init+0x154>
9d00763c:	3c03a000 	lui	v1,0xa000
9d007640:	3c14a000 	lui	s4,0xa000
9d007644:	8e8209c4 	lw	v0,2500(s4)
9d007648:	10400039 	beqz	v0,9d007730 <_sbrk_init+0x148>
9d00764c:	00000000 	nop
9d007650:	00038f82 	srl	s1,v1,0x1e
9d007654:	00029782 	srl	s2,v0,0x1e
9d007658:	7c44e000 	ext	a0,v0,0x0,0x1d
9d00765c:	7c65e000 	ext	a1,v1,0x0,0x1d
9d007660:	3a310002 	xori	s1,s1,0x2
9d007664:	3a520002 	xori	s2,s2,0x2
9d007668:	00b1180a 	movz	v1,a1,s1
9d00766c:	0092100a 	movz	v0,a0,s2
9d007670:	00608821 	move	s1,v1
9d007674:	0f401d6f 	jal	9d0075bc <_stub_sbd_memlayout>
9d007678:	00409021 	move	s2,v0
9d00767c:	8c430000 	lw	v1,0(v0)
9d007680:	8c420004 	lw	v0,4(v0)
9d007684:	0223202b 	sltu	a0,s1,v1
9d007688:	10800024 	beqz	a0,9d00771c <_sbrk_init+0x134>
9d00768c:	00621021 	addu	v0,v1,v0
9d007690:	3c04a000 	lui	a0,0xa000
9d007694:	24841910 	addiu	a0,a0,6416
9d007698:	7c84e000 	ext	a0,a0,0x0,0x1d
9d00769c:	0064202b 	sltu	a0,v1,a0
9d0076a0:	1480ffdb 	bnez	a0,9d007610 <_sbrk_init+0x28>
9d0076a4:	00608821 	move	s1,v1
9d0076a8:	0251182b 	sltu	v1,s2,s1
9d0076ac:	14600005 	bnez	v1,9d0076c4 <_sbrk_init+0xdc>
9d0076b0:	0222182b 	sltu	v1,s1,v0
9d0076b4:	0242182b 	sltu	v1,s2,v0
9d0076b8:	54600005 	bnezl	v1,9d0076d0 <_sbrk_init+0xe8>
9d0076bc:	3c02a000 	lui	v0,0xa000
9d0076c0:	0222182b 	sltu	v1,s1,v0
9d0076c4:	1060ffd2 	beqz	v1,9d007610 <_sbrk_init+0x28>
9d0076c8:	00409021 	move	s2,v0
9d0076cc:	3c02a000 	lui	v0,0xa000
9d0076d0:	24421910 	addiu	v0,v0,6416
9d0076d4:	00021742 	srl	v0,v0,0x1d
9d0076d8:	24030005 	li	v1,5
9d0076dc:	14430019 	bne	v0,v1,9d007744 <_sbrk_init+0x15c>
9d0076e0:	24030004 	li	v1,4
9d0076e4:	3c02a000 	lui	v0,0xa000
9d0076e8:	02228825 	or	s1,s1,v0
9d0076ec:	02429025 	or	s2,s2,v0
9d0076f0:	ae7109c0 	sw	s1,2496(s3)
9d0076f4:	ae9209c4 	sw	s2,2500(s4)
9d0076f8:	ae111774 	sw	s1,6004(s0)
9d0076fc:	8fbf0024 	lw	ra,36(sp)
9d007700:	8fb40020 	lw	s4,32(sp)
9d007704:	8fb3001c 	lw	s3,28(sp)
9d007708:	8fb20018 	lw	s2,24(sp)
9d00770c:	8fb10014 	lw	s1,20(sp)
9d007710:	8fb00010 	lw	s0,16(sp)
9d007714:	03e00008 	jr	ra
9d007718:	27bd0028 	addiu	sp,sp,40
9d00771c:	0222202b 	sltu	a0,s1,v0
9d007720:	5480ffe2 	bnezl	a0,9d0076ac <_sbrk_init+0xc4>
9d007724:	0251182b 	sltu	v1,s2,s1
9d007728:	0b401da5 	j	9d007694 <_sbrk_init+0xac>
9d00772c:	3c04a000 	lui	a0,0xa000
9d007730:	03a01021 	move	v0,sp
9d007734:	0b401d94 	j	9d007650 <_sbrk_init+0x68>
9d007738:	2442f800 	addiu	v0,v0,-2048
9d00773c:	0b401d90 	j	9d007640 <_sbrk_init+0x58>
9d007740:	24631910 	addiu	v1,v1,6416
9d007744:	14430007 	bne	v0,v1,9d007764 <_sbrk_init+0x17c>
9d007748:	3c028000 	lui	v0,0x8000
9d00774c:	02228825 	or	s1,s1,v0
9d007750:	02421025 	or	v0,s2,v0
9d007754:	ae7109c0 	sw	s1,2496(s3)
9d007758:	ae8209c4 	sw	v0,2500(s4)
9d00775c:	0b401dbf 	j	9d0076fc <_sbrk_init+0x114>
9d007760:	ae111774 	sw	s1,6004(s0)
9d007764:	02408821 	move	s1,s2
9d007768:	ae7209c0 	sw	s2,2496(s3)
9d00776c:	0b401dbf 	j	9d0076fc <_sbrk_init+0x114>
9d007770:	ae111774 	sw	s1,6004(s0)

9d007774 <_sbrk>:
9d007774:	27bdffe0 	addiu	sp,sp,-32
9d007778:	afb00018 	sw	s0,24(sp)
9d00777c:	3c10a000 	lui	s0,0xa000
9d007780:	8e021774 	lw	v0,6004(s0)
9d007784:	1040000e 	beqz	v0,9d0077c0 <_sbrk+0x4c>
9d007788:	afbf001c 	sw	ra,28(sp)
9d00778c:	1880001a 	blez	a0,9d0077f8 <_sbrk+0x84>
9d007790:	00441821 	addu	v1,v0,a0
9d007794:	0062202b 	sltu	a0,v1,v0
9d007798:	1480000e 	bnez	a0,9d0077d4 <_sbrk+0x60>
9d00779c:	3c04a000 	lui	a0,0xa000
9d0077a0:	8c8409c4 	lw	a0,2500(a0)
9d0077a4:	0083202b 	sltu	a0,a0,v1
9d0077a8:	1480000a 	bnez	a0,9d0077d4 <_sbrk+0x60>
9d0077ac:	8fbf001c 	lw	ra,28(sp)
9d0077b0:	ae031774 	sw	v1,6004(s0)
9d0077b4:	8fb00018 	lw	s0,24(sp)
9d0077b8:	03e00008 	jr	ra
9d0077bc:	27bd0020 	addiu	sp,sp,32
9d0077c0:	0f401d7a 	jal	9d0075e8 <_sbrk_init>
9d0077c4:	afa40010 	sw	a0,16(sp)
9d0077c8:	8e021774 	lw	v0,6004(s0)
9d0077cc:	1440ffef 	bnez	v0,9d00778c <_sbrk+0x18>
9d0077d0:	8fa40010 	lw	a0,16(sp)
9d0077d4:	0f401e28 	jal	9d0078a0 <__errno>
9d0077d8:	00000000 	nop
9d0077dc:	8fbf001c 	lw	ra,28(sp)
9d0077e0:	2403000c 	li	v1,12
9d0077e4:	ac430000 	sw	v1,0(v0)
9d0077e8:	8fb00018 	lw	s0,24(sp)
9d0077ec:	2402ffff 	li	v0,-1
9d0077f0:	03e00008 	jr	ra
9d0077f4:	27bd0020 	addiu	sp,sp,32
9d0077f8:	0043202b 	sltu	a0,v0,v1
9d0077fc:	14800005 	bnez	a0,9d007814 <_sbrk+0xa0>
9d007800:	3c04a000 	lui	a0,0xa000
9d007804:	8c8409c0 	lw	a0,2496(a0)
9d007808:	0064202b 	sltu	a0,v1,a0
9d00780c:	1080ffe8 	beqz	a0,9d0077b0 <_sbrk+0x3c>
9d007810:	8fbf001c 	lw	ra,28(sp)
9d007814:	0f401e28 	jal	9d0078a0 <__errno>
9d007818:	00000000 	nop
9d00781c:	8fbf001c 	lw	ra,28(sp)
9d007820:	24030016 	li	v1,22
9d007824:	ac430000 	sw	v1,0(v0)
9d007828:	8fb00018 	lw	s0,24(sp)
9d00782c:	2402ffff 	li	v0,-1
9d007830:	03e00008 	jr	ra
9d007834:	27bd0020 	addiu	sp,sp,32

9d007838 <sbrk>:
9d007838:	27bdffe0 	addiu	sp,sp,-32
9d00783c:	afb10018 	sw	s1,24(sp)
9d007840:	afb00014 	sw	s0,20(sp)
9d007844:	afbf001c 	sw	ra,28(sp)
9d007848:	0f401ddd 	jal	9d007774 <_sbrk>
9d00784c:	00808821 	move	s1,a0
9d007850:	1a200007 	blez	s1,9d007870 <sbrk+0x38>
9d007854:	00408021 	move	s0,v0
9d007858:	2402ffff 	li	v0,-1
9d00785c:	12020004 	beq	s0,v0,9d007870 <sbrk+0x38>
9d007860:	02002021 	move	a0,s0
9d007864:	00002821 	move	a1,zero
9d007868:	0f401c0d 	jal	9d007034 <memset>
9d00786c:	02203021 	move	a2,s1
9d007870:	8fbf001c 	lw	ra,28(sp)
9d007874:	02001021 	move	v0,s0
9d007878:	8fb10018 	lw	s1,24(sp)
9d00787c:	8fb00014 	lw	s0,20(sp)
9d007880:	03e00008 	jr	ra
9d007884:	27bd0020 	addiu	sp,sp,32

9d007888 <abort>:
9d007888:	27bdffe8 	addiu	sp,sp,-24
9d00788c:	afbf0014 	sw	ra,20(sp)
9d007890:	0f401e58 	jal	9d007960 <raise>
9d007894:	24040006 	li	a0,6
9d007898:	0f401e78 	jal	9d0079e0 <_exit>
9d00789c:	24040001 	li	a0,1

9d0078a0 <__errno>:
9d0078a0:	3c02a000 	lui	v0,0xa000
9d0078a4:	03e00008 	jr	ra
9d0078a8:	8c420924 	lw	v0,2340(v0)

9d0078ac <_raise_r>:
9d0078ac:	27bdffe0 	addiu	sp,sp,-32
9d0078b0:	2ca20020 	sltiu	v0,a1,32
9d0078b4:	afb00018 	sw	s0,24(sp)
9d0078b8:	afbf001c 	sw	ra,28(sp)
9d0078bc:	00808021 	move	s0,a0
9d0078c0:	14400005 	bnez	v0,9d0078d8 <_raise_r+0x2c>
9d0078c4:	00a03021 	move	a2,a1
9d0078c8:	24020016 	li	v0,22
9d0078cc:	ac820000 	sw	v0,0(a0)
9d0078d0:	0b401e54 	j	9d007950 <_raise_r+0xa4>
9d0078d4:	2402ffff 	li	v0,-1
9d0078d8:	8c8202dc 	lw	v0,732(a0)
9d0078dc:	10400007 	beqz	v0,9d0078fc <_raise_r+0x50>
9d0078e0:	02002021 	move	a0,s0
9d0078e4:	00052080 	sll	a0,a1,0x2
9d0078e8:	00442021 	addu	a0,v0,a0
9d0078ec:	8c830000 	lw	v1,0(a0)
9d0078f0:	1460000a 	bnez	v1,9d00791c <_raise_r+0x70>
9d0078f4:	24050001 	li	a1,1
9d0078f8:	02002021 	move	a0,s0
9d0078fc:	0f401e71 	jal	9d0079c4 <_getpid_r>
9d007900:	afa60010 	sw	a2,16(sp)
9d007904:	8fa60010 	lw	a2,16(sp)
9d007908:	02002021 	move	a0,s0
9d00790c:	0f401e5c 	jal	9d007970 <_kill_r>
9d007910:	00402821 	move	a1,v0
9d007914:	0b401e55 	j	9d007954 <_raise_r+0xa8>
9d007918:	8fbf001c 	lw	ra,28(sp)
9d00791c:	1065000c 	beq	v1,a1,9d007950 <_raise_r+0xa4>
9d007920:	00001021 	move	v0,zero
9d007924:	2405ffff 	li	a1,-1
9d007928:	54650005 	bnel	v1,a1,9d007940 <_raise_r+0x94>
9d00792c:	ac800000 	sw	zero,0(a0)
9d007930:	24020016 	li	v0,22
9d007934:	ae020000 	sw	v0,0(s0)
9d007938:	0b401e54 	j	9d007950 <_raise_r+0xa4>
9d00793c:	24020001 	li	v0,1
9d007940:	afa20010 	sw	v0,16(sp)
9d007944:	0060f809 	jalr	v1
9d007948:	00c02021 	move	a0,a2
9d00794c:	8fa20010 	lw	v0,16(sp)
9d007950:	8fbf001c 	lw	ra,28(sp)
9d007954:	8fb00018 	lw	s0,24(sp)
9d007958:	03e00008 	jr	ra
9d00795c:	27bd0020 	addiu	sp,sp,32

9d007960 <raise>:
9d007960:	3c02a000 	lui	v0,0xa000
9d007964:	00802821 	move	a1,a0
9d007968:	0b401e2b 	j	9d0078ac <_raise_r>
9d00796c:	8c440924 	lw	a0,2340(v0)

9d007970 <_kill_r>:
9d007970:	27bdffe0 	addiu	sp,sp,-32
9d007974:	afb10018 	sw	s1,24(sp)
9d007978:	afb00014 	sw	s0,20(sp)
9d00797c:	00808821 	move	s1,a0
9d007980:	3c10a000 	lui	s0,0xa000
9d007984:	00a02021 	move	a0,a1
9d007988:	00c02821 	move	a1,a2
9d00798c:	afbf001c 	sw	ra,28(sp)
9d007990:	0f401e7a 	jal	9d0079e8 <kill>
9d007994:	ae0009e0 	sw	zero,2528(s0)
9d007998:	2403ffff 	li	v1,-1
9d00799c:	14430005 	bne	v0,v1,9d0079b4 <_kill_r+0x44>
9d0079a0:	8fbf001c 	lw	ra,28(sp)
9d0079a4:	8e0309e0 	lw	v1,2528(s0)
9d0079a8:	54600001 	bnezl	v1,9d0079b0 <_kill_r+0x40>
9d0079ac:	ae230000 	sw	v1,0(s1)
9d0079b0:	8fbf001c 	lw	ra,28(sp)
9d0079b4:	8fb10018 	lw	s1,24(sp)
9d0079b8:	8fb00014 	lw	s0,20(sp)
9d0079bc:	03e00008 	jr	ra
9d0079c0:	27bd0020 	addiu	sp,sp,32

9d0079c4 <_getpid_r>:
9d0079c4:	27bdffe8 	addiu	sp,sp,-24
9d0079c8:	afbf0014 	sw	ra,20(sp)
9d0079cc:	0f401e88 	jal	9d007a20 <getpid>
9d0079d0:	00000000 	nop
9d0079d4:	8fbf0014 	lw	ra,20(sp)
9d0079d8:	03e00008 	jr	ra
9d0079dc:	27bd0018 	addiu	sp,sp,24

9d0079e0 <_exit>:
9d0079e0:	0b401e78 	j	9d0079e0 <_exit>
9d0079e4:	00000000 	nop

9d0079e8 <kill>:
9d0079e8:	27bdffe8 	addiu	sp,sp,-24
9d0079ec:	24020001 	li	v0,1
9d0079f0:	10820005 	beq	a0,v0,9d007a08 <kill+0x20>
9d0079f4:	afbf0014 	sw	ra,20(sp)
9d0079f8:	8fbf0014 	lw	ra,20(sp)
9d0079fc:	00001021 	move	v0,zero
9d007a00:	03e00008 	jr	ra
9d007a04:	27bd0018 	addiu	sp,sp,24
9d007a08:	0f401e78 	jal	9d0079e0 <_exit>
9d007a0c:	00a02021 	move	a0,a1
9d007a10:	8fbf0014 	lw	ra,20(sp)
9d007a14:	00001021 	move	v0,zero
9d007a18:	03e00008 	jr	ra
9d007a1c:	27bd0018 	addiu	sp,sp,24

9d007a20 <getpid>:
9d007a20:	03e00008 	jr	ra
9d007a24:	24020001 	li	v0,1

9d007a28 <__do_global_ctors_aux>:
9d007a28:	3c029d00 	lui	v0,0x9d00
9d007a2c:	8c427ac4 	lw	v0,31428(v0)
9d007a30:	27bdffe0 	addiu	sp,sp,-32
9d007a34:	2403ffff 	li	v1,-1
9d007a38:	afbf001c 	sw	ra,28(sp)
9d007a3c:	afb10018 	sw	s1,24(sp)
9d007a40:	10430009 	beq	v0,v1,9d007a68 <__do_global_ctors_aux+0x40>
9d007a44:	afb00014 	sw	s0,20(sp)
9d007a48:	3c119d00 	lui	s1,0x9d00
9d007a4c:	26317ac4 	addiu	s1,s1,31428
9d007a50:	2410ffff 	li	s0,-1
9d007a54:	0040f809 	jalr	v0
9d007a58:	2631fffc 	addiu	s1,s1,-4
9d007a5c:	8e220000 	lw	v0,0(s1)
9d007a60:	1450fffc 	bne	v0,s0,9d007a54 <__do_global_ctors_aux+0x2c>
9d007a64:	00000000 	nop
9d007a68:	8fbf001c 	lw	ra,28(sp)
9d007a6c:	8fb10018 	lw	s1,24(sp)
9d007a70:	8fb00014 	lw	s0,20(sp)
9d007a74:	03e00008 	jr	ra
9d007a78:	27bd0020 	addiu	sp,sp,32

Disassembly of section .init:

9d007a7c <_init>:
9d007a7c:	27bdffe0 	addiu	sp,sp,-32
9d007a80:	afbf0014 	sw	ra,20(sp)
9d007a84:	0f4004b3 	jal	9d0012cc <frame_dummy>
9d007a88:	00000000 	nop
9d007a8c:	0f401e8a 	jal	9d007a28 <__do_global_ctors_aux>
9d007a90:	00000000 	nop
9d007a94:	8fbf0014 	lw	ra,20(sp)
9d007a98:	03e00008 	jr	ra
9d007a9c:	27bd0020 	addiu	sp,sp,32

Disassembly of section .fini:

9d007aa0 <_fini>:
9d007aa0:	27bdffe0 	addiu	sp,sp,-32
9d007aa4:	afbf0014 	sw	ra,20(sp)
9d007aa8:	0f400484 	jal	9d001210 <__do_global_dtors_aux>
9d007aac:	00000000 	nop
9d007ab0:	8fbf0014 	lw	ra,20(sp)
9d007ab4:	03e00008 	jr	ra
9d007ab8:	27bd0020 	addiu	sp,sp,32
