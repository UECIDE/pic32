/home/matt/.uecide/compilers/pic32-gcc/bin/pic32-objdump -h -S /tmp/build-9680b2f2-8d3e-419c-be8f-c1c7a5cb1582/ReadWrite.elf 

/tmp/build-9680b2f2-8d3e-419c-be8f-c1c7a5cb1582/ReadWrite.elf:     file format elf32-tradlittlemips

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00000010  9d001000  9d001000  00011000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .image_ptr_table 00000008  9d0000f8  9d0000f8  000100f8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .app_excpt    00000010  9d000180  9d000180  00010180  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .vector_0     00000014  9d000200  9d000200  00010200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .vector_1     00000014  9d000220  9d000220  00010220  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .vector_2     00000014  9d000240  9d000240  00010240  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .vector_3     00000014  9d000260  9d000260  00010260  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .vector_4     00000014  9d000280  9d000280  00010280  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .vector_5     00000014  9d0002a0  9d0002a0  000102a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .vector_6     00000014  9d0002c0  9d0002c0  000102c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .vector_7     00000014  9d0002e0  9d0002e0  000102e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .vector_8     00000014  9d000300  9d000300  00010300  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .vector_9     00000014  9d000320  9d000320  00010320  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .vector_10    00000014  9d000340  9d000340  00010340  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .vector_11    00000014  9d000360  9d000360  00010360  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .vector_12    00000014  9d000380  9d000380  00010380  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .vector_13    00000014  9d0003a0  9d0003a0  000103a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .vector_14    00000014  9d0003c0  9d0003c0  000103c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .vector_15    00000014  9d0003e0  9d0003e0  000103e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .vector_16    00000014  9d000400  9d000400  00010400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .vector_17    00000014  9d000420  9d000420  00010420  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .vector_18    00000014  9d000440  9d000440  00010440  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .vector_19    00000014  9d000460  9d000460  00010460  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .vector_20    00000014  9d000480  9d000480  00010480  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .vector_21    00000014  9d0004a0  9d0004a0  000104a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 25 .vector_22    00000014  9d0004c0  9d0004c0  000104c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 26 .vector_23    00000014  9d0004e0  9d0004e0  000104e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .vector_24    00000014  9d000500  9d000500  00010500  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .vector_25    00000014  9d000520  9d000520  00010520  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 29 .vector_26    00000014  9d000540  9d000540  00010540  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 30 .vector_27    00000014  9d000560  9d000560  00010560  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .vector_28    00000014  9d000580  9d000580  00010580  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .vector_29    00000014  9d0005a0  9d0005a0  000105a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .vector_30    00000014  9d0005c0  9d0005c0  000105c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 34 .vector_31    00000014  9d0005e0  9d0005e0  000105e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 35 .vector_32    00000014  9d000600  9d000600  00010600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 36 .vector_33    00000014  9d000620  9d000620  00010620  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 37 .vector_34    00000014  9d000640  9d000640  00010640  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 38 .vector_35    00000014  9d000660  9d000660  00010660  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 39 .vector_36    00000014  9d000680  9d000680  00010680  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 40 .vector_37    00000014  9d0006a0  9d0006a0  000106a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 41 .vector_38    00000014  9d0006c0  9d0006c0  000106c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 42 .vector_39    00000014  9d0006e0  9d0006e0  000106e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 43 .vector_40    00000014  9d000700  9d000700  00010700  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 44 .vector_41    00000014  9d000720  9d000720  00010720  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 45 .vector_42    00000014  9d000740  9d000740  00010740  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 46 .vector_43    00000014  9d000760  9d000760  00010760  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 47 .vector_44    00000014  9d000780  9d000780  00010780  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 48 .vector_45    00000014  9d0007a0  9d0007a0  000107a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 49 .vector_46    00000014  9d0007c0  9d0007c0  000107c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 50 .vector_47    00000014  9d0007e0  9d0007e0  000107e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 51 .vector_48    00000014  9d000800  9d000800  00010800  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 52 .vector_49    00000014  9d000820  9d000820  00010820  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 53 .vector_50    00000014  9d000840  9d000840  00010840  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 54 .vector_51    00000014  9d000860  9d000860  00010860  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 55 .vector_52    00000014  9d000880  9d000880  00010880  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 56 .vector_53    00000014  9d0008a0  9d0008a0  000108a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 57 .vector_54    00000014  9d0008c0  9d0008c0  000108c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 58 .vector_55    00000014  9d0008e0  9d0008e0  000108e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 59 .vector_56    00000014  9d000900  9d000900  00010900  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 60 .vector_57    00000014  9d000920  9d000920  00010920  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 61 .vector_58    00000014  9d000940  9d000940  00010940  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 62 .vector_59    00000014  9d000960  9d000960  00010960  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 63 .vector_60    00000014  9d000980  9d000980  00010980  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 64 .vector_61    00000014  9d0009a0  9d0009a0  000109a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 65 .vector_62    00000014  9d0009c0  9d0009c0  000109c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 66 .vector_63    00000014  9d0009e0  9d0009e0  000109e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 67 .startup      000001e0  9d001010  9d001010  00011010  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 68 .text         00007480  9d0011f0  9d0011f0  000111f0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 69 .init         00000024  9d008670  9d008670  00018670  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 70 .fini         0000001c  9d008694  9d008694  00018694  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 71 .ctors        00000014  9d0086b0  9d0086b0  000186b0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 72 .dtors        0000000c  9d0086c4  9d0086c4  000186c4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 73 .header_info  0000004c  9d0086d0  9d0086d0  000186d0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 74 .ram_exchange_data 00000008  a0000000  a0000000  00023000  2**0
                  CONTENTS
 75 .rodata       00000310  9d00871c  9d00871c  0001871c  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 76 .data         00000908  a0000008  9d008a2c  00020008  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 77 .sdata        0000001c  a0000910  9d009334  00020910  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 78 .sbss         000000b8  a000092c  9d009350  0002092c  2**2
                  ALLOC
 79 .bss          00000f10  a0000a00  9d009350  00020a00  2**9
                  ALLOC
 80 .heap         00000800  a0001910  9d009350  00021910  2**0
                  ALLOC
 81 .stack        00000800  a0002110  9d009350  00022110  2**0
                  ALLOC
 82 .comment      00000095  00000000  00000000  00023008  2**0
                  CONTENTS, READONLY
 83 .debug_aranges 00001ac0  00000000  00000000  000230a0  2**3
                  CONTENTS, READONLY, DEBUGGING
 84 .debug_pubnames 00002f6b  00000000  00000000  00024b60  2**0
                  CONTENTS, READONLY, DEBUGGING
 85 .debug_info   000409e7  00000000  00000000  00027acb  2**0
                  CONTENTS, READONLY, DEBUGGING
 86 .debug_abbrev 0000b969  00000000  00000000  000684b2  2**0
                  CONTENTS, READONLY, DEBUGGING
 87 .debug_line   000103cc  00000000  00000000  00073e1b  2**0
                  CONTENTS, READONLY, DEBUGGING
 88 .debug_frame  00003448  00000000  00000000  000841e8  2**2
                  CONTENTS, READONLY, DEBUGGING
 89 .debug_str    000098b1  00000000  00000000  00087630  2**0
                  CONTENTS, READONLY, DEBUGGING
 90 .debug_loc    000223c1  00000000  00000000  00090ee1  2**0
                  CONTENTS, READONLY, DEBUGGING
 91 .debug_pubtypes 0000392a  00000000  00000000  000b32a2  2**0
                  CONTENTS, READONLY, DEBUGGING
 92 .debug_ranges 000052a8  00000000  00000000  000b6bd0  2**3
                  CONTENTS, READONLY, DEBUGGING
 93 .gnu.attributes 00000010  00000000  00000000  000bbe78  2**0
                  CONTENTS, READONLY
 94 .mdebug.abi32 00000000  a0003000  a0003000  00023000  2**0
                  CONTENTS, ALLOC, LOAD, DATA

Disassembly of section .reset:

9d001000 <_reset>:
9d001000:	3c1a9d00 	lui	k0,0x9d00
9d001004:	275a1010 	addiu	k0,k0,4112
9d001008:	03400008 	jr	k0
9d00100c:	00000000 	nop

Disassembly of section .app_excpt:

9d000180 <_gen_exception>:
9d000180:	3c1a9d01 	lui	k0,0x9d01
9d000184:	275a80b0 	addiu	k0,k0,-32592
9d000188:	03400008 	jr	k0
9d00018c:	00000000 	nop

Disassembly of section .vector_0:

9d000200 <__vector_0>:
    lw       k0,4 * number (k0); \
    jr       k0; \
    .end VECTOR_SYMBOLNAME(number); \
    .size VECTOR_SYMBOLNAME(number), .-VECTOR_SYMBOLNAME(number);

 VECTOR_ENTRY(0)
9d000200:	3c1aa000 	lui	k0,0xa000
9d000204:	275a0008 	addiu	k0,k0,8
9d000208:	8f5a0000 	lw	k0,0(k0)
9d00020c:	03400008 	jr	k0
9d000210:	00000000 	nop

Disassembly of section .vector_1:

9d000220 <__vector_1>:
 VECTOR_ENTRY(1)
9d000220:	3c1aa000 	lui	k0,0xa000
9d000224:	275a0008 	addiu	k0,k0,8
9d000228:	8f5a0004 	lw	k0,4(k0)
9d00022c:	03400008 	jr	k0
9d000230:	00000000 	nop

Disassembly of section .vector_2:

9d000240 <__vector_2>:
 VECTOR_ENTRY(2)
9d000240:	3c1aa000 	lui	k0,0xa000
9d000244:	275a0008 	addiu	k0,k0,8
9d000248:	8f5a0008 	lw	k0,8(k0)
9d00024c:	03400008 	jr	k0
9d000250:	00000000 	nop

Disassembly of section .vector_3:

9d000260 <__vector_3>:
 VECTOR_ENTRY(3)
9d000260:	3c1aa000 	lui	k0,0xa000
9d000264:	275a0008 	addiu	k0,k0,8
9d000268:	8f5a000c 	lw	k0,12(k0)
9d00026c:	03400008 	jr	k0
9d000270:	00000000 	nop

Disassembly of section .vector_4:

9d000280 <__vector_4>:
 VECTOR_ENTRY(4)
9d000280:	3c1aa000 	lui	k0,0xa000
9d000284:	275a0008 	addiu	k0,k0,8
9d000288:	8f5a0010 	lw	k0,16(k0)
9d00028c:	03400008 	jr	k0
9d000290:	00000000 	nop

Disassembly of section .vector_5:

9d0002a0 <__vector_5>:
 VECTOR_ENTRY(5)
9d0002a0:	3c1aa000 	lui	k0,0xa000
9d0002a4:	275a0008 	addiu	k0,k0,8
9d0002a8:	8f5a0014 	lw	k0,20(k0)
9d0002ac:	03400008 	jr	k0
9d0002b0:	00000000 	nop

Disassembly of section .vector_6:

9d0002c0 <__vector_6>:
 VECTOR_ENTRY(6)
9d0002c0:	3c1aa000 	lui	k0,0xa000
9d0002c4:	275a0008 	addiu	k0,k0,8
9d0002c8:	8f5a0018 	lw	k0,24(k0)
9d0002cc:	03400008 	jr	k0
9d0002d0:	00000000 	nop

Disassembly of section .vector_7:

9d0002e0 <__vector_7>:
 VECTOR_ENTRY(7)
9d0002e0:	3c1aa000 	lui	k0,0xa000
9d0002e4:	275a0008 	addiu	k0,k0,8
9d0002e8:	8f5a001c 	lw	k0,28(k0)
9d0002ec:	03400008 	jr	k0
9d0002f0:	00000000 	nop

Disassembly of section .vector_8:

9d000300 <__vector_8>:
 VECTOR_ENTRY(8)
9d000300:	3c1aa000 	lui	k0,0xa000
9d000304:	275a0008 	addiu	k0,k0,8
9d000308:	8f5a0020 	lw	k0,32(k0)
9d00030c:	03400008 	jr	k0
9d000310:	00000000 	nop

Disassembly of section .vector_9:

9d000320 <__vector_9>:
 VECTOR_ENTRY(9)
9d000320:	3c1aa000 	lui	k0,0xa000
9d000324:	275a0008 	addiu	k0,k0,8
9d000328:	8f5a0024 	lw	k0,36(k0)
9d00032c:	03400008 	jr	k0
9d000330:	00000000 	nop

Disassembly of section .vector_10:

9d000340 <__vector_10>:
 VECTOR_ENTRY(10)
9d000340:	3c1aa000 	lui	k0,0xa000
9d000344:	275a0008 	addiu	k0,k0,8
9d000348:	8f5a0028 	lw	k0,40(k0)
9d00034c:	03400008 	jr	k0
9d000350:	00000000 	nop

Disassembly of section .vector_11:

9d000360 <__vector_11>:
 VECTOR_ENTRY(11)
9d000360:	3c1aa000 	lui	k0,0xa000
9d000364:	275a0008 	addiu	k0,k0,8
9d000368:	8f5a002c 	lw	k0,44(k0)
9d00036c:	03400008 	jr	k0
9d000370:	00000000 	nop

Disassembly of section .vector_12:

9d000380 <__vector_12>:
 VECTOR_ENTRY(12)
9d000380:	3c1aa000 	lui	k0,0xa000
9d000384:	275a0008 	addiu	k0,k0,8
9d000388:	8f5a0030 	lw	k0,48(k0)
9d00038c:	03400008 	jr	k0
9d000390:	00000000 	nop

Disassembly of section .vector_13:

9d0003a0 <__vector_13>:
 VECTOR_ENTRY(13)
9d0003a0:	3c1aa000 	lui	k0,0xa000
9d0003a4:	275a0008 	addiu	k0,k0,8
9d0003a8:	8f5a0034 	lw	k0,52(k0)
9d0003ac:	03400008 	jr	k0
9d0003b0:	00000000 	nop

Disassembly of section .vector_14:

9d0003c0 <__vector_14>:
 VECTOR_ENTRY(14)
9d0003c0:	3c1aa000 	lui	k0,0xa000
9d0003c4:	275a0008 	addiu	k0,k0,8
9d0003c8:	8f5a0038 	lw	k0,56(k0)
9d0003cc:	03400008 	jr	k0
9d0003d0:	00000000 	nop

Disassembly of section .vector_15:

9d0003e0 <__vector_15>:
 VECTOR_ENTRY(15)
9d0003e0:	3c1aa000 	lui	k0,0xa000
9d0003e4:	275a0008 	addiu	k0,k0,8
9d0003e8:	8f5a003c 	lw	k0,60(k0)
9d0003ec:	03400008 	jr	k0
9d0003f0:	00000000 	nop

Disassembly of section .vector_16:

9d000400 <__vector_16>:
 VECTOR_ENTRY(16)
9d000400:	3c1aa000 	lui	k0,0xa000
9d000404:	275a0008 	addiu	k0,k0,8
9d000408:	8f5a0040 	lw	k0,64(k0)
9d00040c:	03400008 	jr	k0
9d000410:	00000000 	nop

Disassembly of section .vector_17:

9d000420 <__vector_17>:
 VECTOR_ENTRY(17)
9d000420:	3c1aa000 	lui	k0,0xa000
9d000424:	275a0008 	addiu	k0,k0,8
9d000428:	8f5a0044 	lw	k0,68(k0)
9d00042c:	03400008 	jr	k0
9d000430:	00000000 	nop

Disassembly of section .vector_18:

9d000440 <__vector_18>:
 VECTOR_ENTRY(18)
9d000440:	3c1aa000 	lui	k0,0xa000
9d000444:	275a0008 	addiu	k0,k0,8
9d000448:	8f5a0048 	lw	k0,72(k0)
9d00044c:	03400008 	jr	k0
9d000450:	00000000 	nop

Disassembly of section .vector_19:

9d000460 <__vector_19>:
 VECTOR_ENTRY(19)
9d000460:	3c1aa000 	lui	k0,0xa000
9d000464:	275a0008 	addiu	k0,k0,8
9d000468:	8f5a004c 	lw	k0,76(k0)
9d00046c:	03400008 	jr	k0
9d000470:	00000000 	nop

Disassembly of section .vector_20:

9d000480 <__vector_20>:
 VECTOR_ENTRY(20)
9d000480:	3c1aa000 	lui	k0,0xa000
9d000484:	275a0008 	addiu	k0,k0,8
9d000488:	8f5a0050 	lw	k0,80(k0)
9d00048c:	03400008 	jr	k0
9d000490:	00000000 	nop

Disassembly of section .vector_21:

9d0004a0 <__vector_21>:
 VECTOR_ENTRY(21)
9d0004a0:	3c1aa000 	lui	k0,0xa000
9d0004a4:	275a0008 	addiu	k0,k0,8
9d0004a8:	8f5a0054 	lw	k0,84(k0)
9d0004ac:	03400008 	jr	k0
9d0004b0:	00000000 	nop

Disassembly of section .vector_22:

9d0004c0 <__vector_22>:
 VECTOR_ENTRY(22)
9d0004c0:	3c1aa000 	lui	k0,0xa000
9d0004c4:	275a0008 	addiu	k0,k0,8
9d0004c8:	8f5a0058 	lw	k0,88(k0)
9d0004cc:	03400008 	jr	k0
9d0004d0:	00000000 	nop

Disassembly of section .vector_23:

9d0004e0 <__vector_23>:
 VECTOR_ENTRY(23)
9d0004e0:	3c1aa000 	lui	k0,0xa000
9d0004e4:	275a0008 	addiu	k0,k0,8
9d0004e8:	8f5a005c 	lw	k0,92(k0)
9d0004ec:	03400008 	jr	k0
9d0004f0:	00000000 	nop

Disassembly of section .vector_24:

9d000500 <__vector_24>:
 VECTOR_ENTRY(24)
9d000500:	3c1aa000 	lui	k0,0xa000
9d000504:	275a0008 	addiu	k0,k0,8
9d000508:	8f5a0060 	lw	k0,96(k0)
9d00050c:	03400008 	jr	k0
9d000510:	00000000 	nop

Disassembly of section .vector_25:

9d000520 <__vector_25>:
 VECTOR_ENTRY(25)
9d000520:	3c1aa000 	lui	k0,0xa000
9d000524:	275a0008 	addiu	k0,k0,8
9d000528:	8f5a0064 	lw	k0,100(k0)
9d00052c:	03400008 	jr	k0
9d000530:	00000000 	nop

Disassembly of section .vector_26:

9d000540 <__vector_26>:
 VECTOR_ENTRY(26)
9d000540:	3c1aa000 	lui	k0,0xa000
9d000544:	275a0008 	addiu	k0,k0,8
9d000548:	8f5a0068 	lw	k0,104(k0)
9d00054c:	03400008 	jr	k0
9d000550:	00000000 	nop

Disassembly of section .vector_27:

9d000560 <__vector_27>:
 VECTOR_ENTRY(27)
9d000560:	3c1aa000 	lui	k0,0xa000
9d000564:	275a0008 	addiu	k0,k0,8
9d000568:	8f5a006c 	lw	k0,108(k0)
9d00056c:	03400008 	jr	k0
9d000570:	00000000 	nop

Disassembly of section .vector_28:

9d000580 <__vector_28>:
 VECTOR_ENTRY(28)
9d000580:	3c1aa000 	lui	k0,0xa000
9d000584:	275a0008 	addiu	k0,k0,8
9d000588:	8f5a0070 	lw	k0,112(k0)
9d00058c:	03400008 	jr	k0
9d000590:	00000000 	nop

Disassembly of section .vector_29:

9d0005a0 <__vector_29>:
 VECTOR_ENTRY(29)
9d0005a0:	3c1aa000 	lui	k0,0xa000
9d0005a4:	275a0008 	addiu	k0,k0,8
9d0005a8:	8f5a0074 	lw	k0,116(k0)
9d0005ac:	03400008 	jr	k0
9d0005b0:	00000000 	nop

Disassembly of section .vector_30:

9d0005c0 <__vector_30>:
 VECTOR_ENTRY(30)
9d0005c0:	3c1aa000 	lui	k0,0xa000
9d0005c4:	275a0008 	addiu	k0,k0,8
9d0005c8:	8f5a0078 	lw	k0,120(k0)
9d0005cc:	03400008 	jr	k0
9d0005d0:	00000000 	nop

Disassembly of section .vector_31:

9d0005e0 <__vector_31>:
 VECTOR_ENTRY(31)
9d0005e0:	3c1aa000 	lui	k0,0xa000
9d0005e4:	275a0008 	addiu	k0,k0,8
9d0005e8:	8f5a007c 	lw	k0,124(k0)
9d0005ec:	03400008 	jr	k0
9d0005f0:	00000000 	nop

Disassembly of section .vector_32:

9d000600 <__vector_32>:
 VECTOR_ENTRY(32)
9d000600:	3c1aa000 	lui	k0,0xa000
9d000604:	275a0008 	addiu	k0,k0,8
9d000608:	8f5a0080 	lw	k0,128(k0)
9d00060c:	03400008 	jr	k0
9d000610:	00000000 	nop

Disassembly of section .vector_33:

9d000620 <__vector_33>:
 VECTOR_ENTRY(33)
9d000620:	3c1aa000 	lui	k0,0xa000
9d000624:	275a0008 	addiu	k0,k0,8
9d000628:	8f5a0084 	lw	k0,132(k0)
9d00062c:	03400008 	jr	k0
9d000630:	00000000 	nop

Disassembly of section .vector_34:

9d000640 <__vector_34>:
 VECTOR_ENTRY(34)
9d000640:	3c1aa000 	lui	k0,0xa000
9d000644:	275a0008 	addiu	k0,k0,8
9d000648:	8f5a0088 	lw	k0,136(k0)
9d00064c:	03400008 	jr	k0
9d000650:	00000000 	nop

Disassembly of section .vector_35:

9d000660 <__vector_35>:
 VECTOR_ENTRY(35)
9d000660:	3c1aa000 	lui	k0,0xa000
9d000664:	275a0008 	addiu	k0,k0,8
9d000668:	8f5a008c 	lw	k0,140(k0)
9d00066c:	03400008 	jr	k0
9d000670:	00000000 	nop

Disassembly of section .vector_36:

9d000680 <__vector_36>:
 VECTOR_ENTRY(36)
9d000680:	3c1aa000 	lui	k0,0xa000
9d000684:	275a0008 	addiu	k0,k0,8
9d000688:	8f5a0090 	lw	k0,144(k0)
9d00068c:	03400008 	jr	k0
9d000690:	00000000 	nop

Disassembly of section .vector_37:

9d0006a0 <__vector_37>:
 VECTOR_ENTRY(37)
9d0006a0:	3c1aa000 	lui	k0,0xa000
9d0006a4:	275a0008 	addiu	k0,k0,8
9d0006a8:	8f5a0094 	lw	k0,148(k0)
9d0006ac:	03400008 	jr	k0
9d0006b0:	00000000 	nop

Disassembly of section .vector_38:

9d0006c0 <__vector_38>:
 VECTOR_ENTRY(38)
9d0006c0:	3c1aa000 	lui	k0,0xa000
9d0006c4:	275a0008 	addiu	k0,k0,8
9d0006c8:	8f5a0098 	lw	k0,152(k0)
9d0006cc:	03400008 	jr	k0
9d0006d0:	00000000 	nop

Disassembly of section .vector_39:

9d0006e0 <__vector_39>:
 VECTOR_ENTRY(39)
9d0006e0:	3c1aa000 	lui	k0,0xa000
9d0006e4:	275a0008 	addiu	k0,k0,8
9d0006e8:	8f5a009c 	lw	k0,156(k0)
9d0006ec:	03400008 	jr	k0
9d0006f0:	00000000 	nop

Disassembly of section .vector_40:

9d000700 <__vector_40>:
 VECTOR_ENTRY(40)
9d000700:	3c1aa000 	lui	k0,0xa000
9d000704:	275a0008 	addiu	k0,k0,8
9d000708:	8f5a00a0 	lw	k0,160(k0)
9d00070c:	03400008 	jr	k0
9d000710:	00000000 	nop

Disassembly of section .vector_41:

9d000720 <__vector_41>:
 VECTOR_ENTRY(41)
9d000720:	3c1aa000 	lui	k0,0xa000
9d000724:	275a0008 	addiu	k0,k0,8
9d000728:	8f5a00a4 	lw	k0,164(k0)
9d00072c:	03400008 	jr	k0
9d000730:	00000000 	nop

Disassembly of section .vector_42:

9d000740 <__vector_42>:
 VECTOR_ENTRY(42)
9d000740:	3c1aa000 	lui	k0,0xa000
9d000744:	275a0008 	addiu	k0,k0,8
9d000748:	8f5a00a8 	lw	k0,168(k0)
9d00074c:	03400008 	jr	k0
9d000750:	00000000 	nop

Disassembly of section .vector_43:

9d000760 <__vector_43>:
 VECTOR_ENTRY(43)
9d000760:	3c1aa000 	lui	k0,0xa000
9d000764:	275a0008 	addiu	k0,k0,8
9d000768:	8f5a00ac 	lw	k0,172(k0)
9d00076c:	03400008 	jr	k0
9d000770:	00000000 	nop

Disassembly of section .vector_44:

9d000780 <__vector_44>:
 VECTOR_ENTRY(44)
9d000780:	3c1aa000 	lui	k0,0xa000
9d000784:	275a0008 	addiu	k0,k0,8
9d000788:	8f5a00b0 	lw	k0,176(k0)
9d00078c:	03400008 	jr	k0
9d000790:	00000000 	nop

Disassembly of section .vector_45:

9d0007a0 <__vector_45>:
 VECTOR_ENTRY(45)
9d0007a0:	3c1aa000 	lui	k0,0xa000
9d0007a4:	275a0008 	addiu	k0,k0,8
9d0007a8:	8f5a00b4 	lw	k0,180(k0)
9d0007ac:	03400008 	jr	k0
9d0007b0:	00000000 	nop

Disassembly of section .vector_46:

9d0007c0 <__vector_46>:
 VECTOR_ENTRY(46)
9d0007c0:	3c1aa000 	lui	k0,0xa000
9d0007c4:	275a0008 	addiu	k0,k0,8
9d0007c8:	8f5a00b8 	lw	k0,184(k0)
9d0007cc:	03400008 	jr	k0
9d0007d0:	00000000 	nop

Disassembly of section .vector_47:

9d0007e0 <__vector_47>:
 VECTOR_ENTRY(47)
9d0007e0:	3c1aa000 	lui	k0,0xa000
9d0007e4:	275a0008 	addiu	k0,k0,8
9d0007e8:	8f5a00bc 	lw	k0,188(k0)
9d0007ec:	03400008 	jr	k0
9d0007f0:	00000000 	nop

Disassembly of section .vector_48:

9d000800 <__vector_48>:
 VECTOR_ENTRY(48)
9d000800:	3c1aa000 	lui	k0,0xa000
9d000804:	275a0008 	addiu	k0,k0,8
9d000808:	8f5a00c0 	lw	k0,192(k0)
9d00080c:	03400008 	jr	k0
9d000810:	00000000 	nop

Disassembly of section .vector_49:

9d000820 <__vector_49>:
 VECTOR_ENTRY(49)
9d000820:	3c1aa000 	lui	k0,0xa000
9d000824:	275a0008 	addiu	k0,k0,8
9d000828:	8f5a00c4 	lw	k0,196(k0)
9d00082c:	03400008 	jr	k0
9d000830:	00000000 	nop

Disassembly of section .vector_50:

9d000840 <__vector_50>:
 VECTOR_ENTRY(50)
9d000840:	3c1aa000 	lui	k0,0xa000
9d000844:	275a0008 	addiu	k0,k0,8
9d000848:	8f5a00c8 	lw	k0,200(k0)
9d00084c:	03400008 	jr	k0
9d000850:	00000000 	nop

Disassembly of section .vector_51:

9d000860 <__vector_51>:
 VECTOR_ENTRY(51)
9d000860:	3c1aa000 	lui	k0,0xa000
9d000864:	275a0008 	addiu	k0,k0,8
9d000868:	8f5a00cc 	lw	k0,204(k0)
9d00086c:	03400008 	jr	k0
9d000870:	00000000 	nop

Disassembly of section .vector_52:

9d000880 <__vector_52>:
 VECTOR_ENTRY(52)
9d000880:	3c1aa000 	lui	k0,0xa000
9d000884:	275a0008 	addiu	k0,k0,8
9d000888:	8f5a00d0 	lw	k0,208(k0)
9d00088c:	03400008 	jr	k0
9d000890:	00000000 	nop

Disassembly of section .vector_53:

9d0008a0 <__vector_53>:
 VECTOR_ENTRY(53)
9d0008a0:	3c1aa000 	lui	k0,0xa000
9d0008a4:	275a0008 	addiu	k0,k0,8
9d0008a8:	8f5a00d4 	lw	k0,212(k0)
9d0008ac:	03400008 	jr	k0
9d0008b0:	00000000 	nop

Disassembly of section .vector_54:

9d0008c0 <__vector_54>:
 VECTOR_ENTRY(54)
9d0008c0:	3c1aa000 	lui	k0,0xa000
9d0008c4:	275a0008 	addiu	k0,k0,8
9d0008c8:	8f5a00d8 	lw	k0,216(k0)
9d0008cc:	03400008 	jr	k0
9d0008d0:	00000000 	nop

Disassembly of section .vector_55:

9d0008e0 <__vector_55>:
 VECTOR_ENTRY(55)
9d0008e0:	3c1aa000 	lui	k0,0xa000
9d0008e4:	275a0008 	addiu	k0,k0,8
9d0008e8:	8f5a00dc 	lw	k0,220(k0)
9d0008ec:	03400008 	jr	k0
9d0008f0:	00000000 	nop

Disassembly of section .vector_56:

9d000900 <__vector_56>:
 VECTOR_ENTRY(56)
9d000900:	3c1aa000 	lui	k0,0xa000
9d000904:	275a0008 	addiu	k0,k0,8
9d000908:	8f5a00e0 	lw	k0,224(k0)
9d00090c:	03400008 	jr	k0
9d000910:	00000000 	nop

Disassembly of section .vector_57:

9d000920 <__vector_57>:
 VECTOR_ENTRY(57)
9d000920:	3c1aa000 	lui	k0,0xa000
9d000924:	275a0008 	addiu	k0,k0,8
9d000928:	8f5a00e4 	lw	k0,228(k0)
9d00092c:	03400008 	jr	k0
9d000930:	00000000 	nop

Disassembly of section .vector_58:

9d000940 <__vector_58>:
 VECTOR_ENTRY(58)
9d000940:	3c1aa000 	lui	k0,0xa000
9d000944:	275a0008 	addiu	k0,k0,8
9d000948:	8f5a00e8 	lw	k0,232(k0)
9d00094c:	03400008 	jr	k0
9d000950:	00000000 	nop

Disassembly of section .vector_59:

9d000960 <__vector_59>:
 VECTOR_ENTRY(59)
9d000960:	3c1aa000 	lui	k0,0xa000
9d000964:	275a0008 	addiu	k0,k0,8
9d000968:	8f5a00ec 	lw	k0,236(k0)
9d00096c:	03400008 	jr	k0
9d000970:	00000000 	nop

Disassembly of section .vector_60:

9d000980 <__vector_60>:
 VECTOR_ENTRY(60)
9d000980:	3c1aa000 	lui	k0,0xa000
9d000984:	275a0008 	addiu	k0,k0,8
9d000988:	8f5a00f0 	lw	k0,240(k0)
9d00098c:	03400008 	jr	k0
9d000990:	00000000 	nop

Disassembly of section .vector_61:

9d0009a0 <__vector_61>:
 VECTOR_ENTRY(61)
9d0009a0:	3c1aa000 	lui	k0,0xa000
9d0009a4:	275a0008 	addiu	k0,k0,8
9d0009a8:	8f5a00f4 	lw	k0,244(k0)
9d0009ac:	03400008 	jr	k0
9d0009b0:	00000000 	nop

Disassembly of section .vector_62:

9d0009c0 <__vector_62>:
 VECTOR_ENTRY(62)
9d0009c0:	3c1aa000 	lui	k0,0xa000
9d0009c4:	275a0008 	addiu	k0,k0,8
9d0009c8:	8f5a00f8 	lw	k0,248(k0)
9d0009cc:	03400008 	jr	k0
9d0009d0:	00000000 	nop

Disassembly of section .vector_63:

9d0009e0 <__vector_63>:
 VECTOR_ENTRY(63)
9d0009e0:	3c1aa000 	lui	k0,0xa000
9d0009e4:	275a0008 	addiu	k0,k0,8
9d0009e8:	8f5a00fc 	lw	k0,252(k0)
9d0009ec:	03400008 	jr	k0
9d0009f0:	00000000 	nop

Disassembly of section .startup:

9d001010 <_startup>:
9d001010:	401a6000 	mfc0	k0,c0_status
9d001014:	7f5a04c0 	ext	k0,k0,0x13,0x1
9d001018:	13400005 	beqz	k0,9d001030 <_no_nmi>
9d00101c:	00000000 	nop
9d001020:	3c1a9d01 	lui	k0,0x9d01
9d001024:	275a8198 	addiu	k0,k0,-32360
9d001028:	03400008 	jr	k0
9d00102c:	00000000 	nop

9d001030 <_no_nmi>:
9d001030:	3c1da002 	lui	sp,0xa002
9d001034:	27bd0000 	addiu	sp,sp,0
9d001038:	3c1ca001 	lui	gp,0xa001
9d00103c:	279c8900 	addiu	gp,gp,-30464
9d001040:	40096002 	mfc0	t1,c0_srsctl
9d001044:	01205820 	add	t3,t1,zero
9d001048:	7d2a1e80 	ext	t2,t1,0x1a,0x4
9d00104c:	7d494984 	ins	t1,t2,0x6,0x4
9d001050:	40896002 	mtc0	t1,c0_srsctl
9d001054:	41dce000 	wrpgpr	gp,gp
9d001058:	408b6002 	mtc0	t3,c0_srsctl
9d00105c:	3c089d01 	lui	t0,0x9d01
9d001060:	25088188 	addiu	t0,t0,-32376
9d001064:	0100f809 	jalr	t0
9d001068:	00000000 	nop
9d00106c:	3c08a000 	lui	t0,0xa000
9d001070:	2508092c 	addiu	t0,t0,2348
9d001074:	3c09a000 	lui	t1,0xa000
9d001078:	25291910 	addiu	t1,t1,6416
9d00107c:	10000006 	b	9d001098 <_bss_check>
9d001080:	00000000 	nop

9d001084 <_bss_init>:
9d001084:	ad000000 	sw	zero,0(t0)
9d001088:	ad000004 	sw	zero,4(t0)
9d00108c:	ad000008 	sw	zero,8(t0)
9d001090:	ad00000c 	sw	zero,12(t0)
9d001094:	25080010 	addiu	t0,t0,16

9d001098 <_bss_check>:
9d001098:	0109082b 	sltu	at,t0,t1
9d00109c:	1420fff9 	bnez	at,9d001084 <_bss_init>
9d0010a0:	00000000 	nop
9d0010a4:	3c089d01 	lui	t0,0x9d01
9d0010a8:	25088a2c 	addiu	t0,t0,-30164
9d0010ac:	3c09a000 	lui	t1,0xa000
9d0010b0:	25290008 	addiu	t1,t1,8
9d0010b4:	3c0aa000 	lui	t2,0xa000
9d0010b8:	254a092c 	addiu	t2,t2,2348
9d0010bc:	10000005 	b	9d0010d4 <_init_check>
9d0010c0:	00000000 	nop

9d0010c4 <_init_data>:
9d0010c4:	8d0b0000 	lw	t3,0(t0)
9d0010c8:	ad2b0000 	sw	t3,0(t1)
9d0010cc:	25080004 	addiu	t0,t0,4
9d0010d0:	25290004 	addiu	t1,t1,4

9d0010d4 <_init_check>:
9d0010d4:	012a082b 	sltu	at,t1,t2
9d0010d8:	1420fffa 	bnez	at,9d0010c4 <_init_data>
9d0010dc:	00000000 	nop
9d0010e0:	3c090000 	lui	t1,0x0
9d0010e4:	25290000 	addiu	t1,t1,0
9d0010e8:	1120001d 	beqz	t1,9d001160 <_ramfunc_done>
9d0010ec:	00000000 	nop
9d0010f0:	3c089d01 	lui	t0,0x9d01
9d0010f4:	25089350 	addiu	t0,t0,-27824
9d0010f8:	3c09a000 	lui	t1,0xa000
9d0010fc:	25293000 	addiu	t1,t1,12288
9d001100:	3c0aa000 	lui	t2,0xa000
9d001104:	254a3000 	addiu	t2,t2,12288

9d001108 <_init_ramfunc>:
9d001108:	8d0b0000 	lw	t3,0(t0)
9d00110c:	ad2b0000 	sw	t3,0(t1)
9d001110:	25080004 	addiu	t0,t0,4
9d001114:	25290004 	addiu	t1,t1,4

9d001118 <_ramfunc_check>:
9d001118:	012a082b 	sltu	at,t1,t2
9d00111c:	1420fffa 	bnez	at,9d001108 <_init_ramfunc>
9d001120:	00000000 	nop
9d001124:	3c090000 	lui	t1,0x0
9d001128:	25293000 	addiu	t1,t1,12288
9d00112c:	3c0abf88 	lui	t2,0xbf88
9d001130:	254a2010 	addiu	t2,t2,8208
9d001134:	ad490000 	sw	t1,0(t2)
9d001138:	3c090002 	lui	t1,0x2
9d00113c:	25290000 	addiu	t1,t1,0
9d001140:	3c0abf88 	lui	t2,0xbf88
9d001144:	254a2020 	addiu	t2,t2,8224
9d001148:	ad490000 	sw	t1,0(t2)
9d00114c:	3c090002 	lui	t1,0x2
9d001150:	25290000 	addiu	t1,t1,0
9d001154:	3c0abf88 	lui	t2,0xbf88
9d001158:	254a2030 	addiu	t2,t2,8240
9d00115c:	ad490000 	sw	t1,0(t2)

9d001160 <_ramfunc_done>:
9d001160:	40804800 	mtc0	zero,c0_count
9d001164:	240affff 	li	t2,-1
9d001168:	408a5800 	mtc0	t2,c0_compare
9d00116c:	3c099d00 	lui	t1,0x9d00
9d001170:	25290000 	addiu	t1,t1,0
9d001174:	40897801 	mtc0	t1,c0_ebase
9d001178:	3c090000 	lui	t1,0x0
9d00117c:	25290001 	addiu	t1,t1,1
9d001180:	240a0000 	li	t2,0
9d001184:	7d2a4944 	ins	t2,t1,0x5,0x5
9d001188:	408a6001 	mtc0	t2,c0_intctl
9d00118c:	3c090080 	lui	t1,0x80
9d001190:	40896800 	mtc0	t1,c0_cause
9d001194:	40088000 	mfc0	t0,c0_config
9d001198:	7d090580 	ext	t1,t0,0x16,0x1
9d00119c:	00094c40 	sll	t1,t1,0x11
9d0011a0:	40086000 	mfc0	t0,c0_status
9d0011a4:	3c010058 	lui	at,0x58
9d0011a8:	01014024 	and	t0,t0,at
9d0011ac:	01284025 	or	t0,t1,t0
9d0011b0:	40886000 	mtc0	t0,c0_status
9d0011b4:	3c089d01 	lui	t0,0x9d01
9d0011b8:	25088190 	addiu	t0,t0,-32368
9d0011bc:	0100f809 	jalr	t0
9d0011c0:	00000000 	nop
9d0011c4:	40086000 	mfc0	t0,c0_status
9d0011c8:	3c01ffbf 	lui	at,0xffbf
9d0011cc:	3421ffff 	ori	at,at,0xffff
9d0011d0:	01014024 	and	t0,t0,at
9d0011d4:	40886000 	mtc0	t0,c0_status
9d0011d8:	30840000 	andi	a0,a0,0x0
9d0011dc:	30a50000 	andi	a1,a1,0x0
9d0011e0:	3c089d00 	lui	t0,0x9d00
9d0011e4:	250811f0 	addiu	t0,t0,4592
9d0011e8:	01000008 	jr	t0
9d0011ec:	00000000 	nop

Disassembly of section .text:

9d0011f0 <_main_entry>:
9d0011f0:	0f40219c 	jal	9d008670 <_text_end>
9d0011f4:	00000000 	nop
9d0011f8:	30840000 	andi	a0,a0,0x0
9d0011fc:	30a50000 	andi	a1,a1,0x0
9d001200:	0f40159f 	jal	9d00567c <main>
9d001204:	00000000 	nop
9d001208:	1000fffd 	b	9d001200 <_main_entry+0x10>
9d00120c:	00000000 	nop

9d001210 <__do_global_dtors_aux>:
9d001210:	27bdffd8 	addiu	sp,sp,-40
9d001214:	afb2001c 	sw	s2,28(sp)
9d001218:	3c12a000 	lui	s2,0xa000
9d00121c:	92420a00 	lbu	v0,2560(s2)
9d001220:	afbf0024 	sw	ra,36(sp)
9d001224:	afb30020 	sw	s3,32(sp)
9d001228:	afb10018 	sw	s1,24(sp)
9d00122c:	14400020 	bnez	v0,9d0012b0 <__do_global_dtors_aux+0xa0>
9d001230:	afb00014 	sw	s0,20(sp)
9d001234:	3c119d01 	lui	s1,0x9d01
9d001238:	3c109d01 	lui	s0,0x9d01
9d00123c:	3c13a000 	lui	s3,0xa000
9d001240:	263186c4 	addiu	s1,s1,-31036
9d001244:	261086cc 	addiu	s0,s0,-31028
9d001248:	8e620a04 	lw	v0,2564(s3)
9d00124c:	02118023 	subu	s0,s0,s1
9d001250:	00108083 	sra	s0,s0,0x2
9d001254:	2610ffff 	addiu	s0,s0,-1
9d001258:	0050182b 	sltu	v1,v0,s0
9d00125c:	5060000c 	beqzl	v1,9d001290 <__do_global_dtors_aux+0x80>
9d001260:	3c020000 	lui	v0,0x0
9d001264:	24420001 	addiu	v0,v0,1
9d001268:	00021880 	sll	v1,v0,0x2
9d00126c:	02231821 	addu	v1,s1,v1
9d001270:	8c630000 	lw	v1,0(v1)
9d001274:	0060f809 	jalr	v1
9d001278:	ae620a04 	sw	v0,2564(s3)
9d00127c:	8e620a04 	lw	v0,2564(s3)
9d001280:	0050182b 	sltu	v1,v0,s0
9d001284:	1460fff8 	bnez	v1,9d001268 <__do_global_dtors_aux+0x58>
9d001288:	24420001 	addiu	v0,v0,1
9d00128c:	3c020000 	lui	v0,0x0
9d001290:	24420000 	addiu	v0,v0,0
9d001294:	10400005 	beqz	v0,9d0012ac <__do_global_dtors_aux+0x9c>
9d001298:	24020001 	li	v0,1
9d00129c:	3c04a000 	lui	a0,0xa000
9d0012a0:	0c000000 	jal	90000000 <_imageExecutionJumpToFirstInFlash+0x8e000000>
9d0012a4:	24840008 	addiu	a0,a0,8
9d0012a8:	24020001 	li	v0,1
9d0012ac:	a2420a00 	sb	v0,2560(s2)
9d0012b0:	8fbf0024 	lw	ra,36(sp)
9d0012b4:	8fb30020 	lw	s3,32(sp)
9d0012b8:	8fb2001c 	lw	s2,28(sp)
9d0012bc:	8fb10018 	lw	s1,24(sp)
9d0012c0:	8fb00014 	lw	s0,20(sp)
9d0012c4:	03e00008 	jr	ra
9d0012c8:	27bd0028 	addiu	sp,sp,40

9d0012cc <frame_dummy>:
9d0012cc:	3c020000 	lui	v0,0x0
9d0012d0:	27bdffe8 	addiu	sp,sp,-24
9d0012d4:	24420000 	addiu	v0,v0,0
9d0012d8:	10400006 	beqz	v0,9d0012f4 <frame_dummy+0x28>
9d0012dc:	afbf0014 	sw	ra,20(sp)
9d0012e0:	3c04a000 	lui	a0,0xa000
9d0012e4:	3c05a000 	lui	a1,0xa000
9d0012e8:	24840008 	addiu	a0,a0,8
9d0012ec:	0c000000 	jal	90000000 <_imageExecutionJumpToFirstInFlash+0x8e000000>
9d0012f0:	24a50a08 	addiu	a1,a1,2568
9d0012f4:	3c04a000 	lui	a0,0xa000
9d0012f8:	8c820008 	lw	v0,8(a0)
9d0012fc:	10400007 	beqz	v0,9d00131c <frame_dummy+0x50>
9d001300:	3c190000 	lui	t9,0x0
9d001304:	27390000 	addiu	t9,t9,0
9d001308:	13200004 	beqz	t9,9d00131c <frame_dummy+0x50>
9d00130c:	8fbf0014 	lw	ra,20(sp)
9d001310:	24840008 	addiu	a0,a0,8
9d001314:	03200008 	jr	t9
9d001318:	27bd0018 	addiu	sp,sp,24
9d00131c:	8fbf0014 	lw	ra,20(sp)
9d001320:	03e00008 	jr	ra
9d001324:	27bd0018 	addiu	sp,sp,24

9d001328 <_Z41__static_initialization_and_destruction_0ii.clone.2>:
9d001328:	24020001 	li	v0,1
9d00132c:	50820008 	beql	a0,v0,9d001350 <_Z41__static_initialization_and_destruction_0ii.clone.2+0x28>
9d001330:	3c04a000 	lui	a0,0xa000
9d001334:	14800004 	bnez	a0,9d001348 <_Z41__static_initialization_and_destruction_0ii.clone.2+0x20>
9d001338:	00000000 	nop
9d00133c:	3c04a000 	lui	a0,0xa000
9d001340:	0b400633 	j	9d0018cc <_ZN4FileD1Ev>
9d001344:	24840a20 	addiu	a0,a0,2592
9d001348:	03e00008 	jr	ra
9d00134c:	00000000 	nop
9d001350:	0b40062d 	j	9d0018b4 <_ZN4FileC1Ev>
9d001354:	24840a20 	addiu	a0,a0,2592

9d001358 <setup>:
9d001358:	27bdfb98 	addiu	sp,sp,-1128
9d00135c:	27848060 	addiu	a0,gp,-32672
9d001360:	24052580 	li	a1,9600
9d001364:	afbf0464 	sw	ra,1124(sp)
9d001368:	afb50460 	sw	s5,1120(sp)
9d00136c:	afb4045c 	sw	s4,1116(sp)
9d001370:	afb30458 	sw	s3,1112(sp)
9d001374:	afb20454 	sw	s2,1108(sp)
9d001378:	afb10450 	sw	s1,1104(sp)
9d00137c:	0f4017f7 	jal	9d005fdc <_ZN9USBSerial5beginEm>
9d001380:	afb0044c 	sw	s0,1100(sp)
9d001384:	0f4017f4 	jal	9d005fd0 <_ZN9USBSerialcviEv>
9d001388:	27848060 	addiu	a0,gp,-32672
9d00138c:	1040fffd 	beqz	v0,9d001384 <setup+0x2c>
9d001390:	00000000 	nop
9d001394:	0f4014db 	jal	9d00536c <delay>
9d001398:	240403e8 	li	a0,1000
9d00139c:	3c059d01 	lui	a1,0x9d01
9d0013a0:	27848060 	addiu	a0,gp,-32672
9d0013a4:	0f4015d9 	jal	9d005764 <_ZN5Print5printEPKc>
9d0013a8:	24a5871c 	addiu	a1,a1,-30948
9d0013ac:	2404001b 	li	a0,27
9d0013b0:	0f401387 	jal	9d004e1c <pinMode>
9d0013b4:	24050001 	li	a1,1
9d0013b8:	2404001b 	li	a0,27
9d0013bc:	0f4013cf 	jal	9d004f3c <digitalWrite>
9d0013c0:	24050001 	li	a1,1
9d0013c4:	2404001b 	li	a0,27
9d0013c8:	0f401387 	jal	9d004e1c <pinMode>
9d0013cc:	24050001 	li	a1,1
9d0013d0:	3c11a000 	lui	s1,0xa000
9d0013d4:	2404001b 	li	a0,27
9d0013d8:	0f4013cf 	jal	9d004f3c <digitalWrite>
9d0013dc:	24050001 	li	a1,1
9d0013e0:	26240a50 	addiu	a0,s1,2640
9d0013e4:	0f4006e8 	jal	9d001ba0 <_ZN7SDClass5beginEh>
9d0013e8:	2405001b 	li	a1,27
9d0013ec:	1040008f 	beqz	v0,9d00162c <setup+0x2d4>
9d0013f0:	27848060 	addiu	a0,gp,-32672
9d0013f4:	3c059d01 	lui	a1,0x9d01
9d0013f8:	24a5874c 	addiu	a1,a1,-30900
9d0013fc:	0f401645 	jal	9d005914 <_ZN5Print7printlnEPKc>
9d001400:	3c139d01 	lui	s3,0x9d01
9d001404:	26240a50 	addiu	a0,s1,2640
9d001408:	0f400823 	jal	9d00208c <_ZN7SDClass6existsEPc>
9d00140c:	26658764 	addiu	a1,s3,-30876
9d001410:	1440009e 	bnez	v0,9d00168c <setup+0x334>
9d001414:	3c059d01 	lui	a1,0x9d01
9d001418:	27a40010 	addiu	a0,sp,16
9d00141c:	26250a50 	addiu	a1,s1,2640
9d001420:	26668764 	addiu	a2,s3,-30876
9d001424:	0f40079d 	jal	9d001e74 <_ZN7SDClass4openEPKch>
9d001428:	24070013 	li	a3,19
#include <Stream.h>

#define FILE_READ O_READ
#define FILE_WRITE (O_READ | O_WRITE | O_CREAT)

class File : public Stream {
9d00142c:	8fa20014 	lw	v0,20(sp)
9d001430:	3c12a000 	lui	s2,0xa000
9d001434:	26500a20 	addiu	s0,s2,2592
9d001438:	ae020004 	sw	v0,4(s0)
9d00143c:	8fa20018 	lw	v0,24(sp)
9d001440:	27a40010 	addiu	a0,sp,16
9d001444:	ae020008 	sw	v0,8(s0)
9d001448:	8fa2001c 	lw	v0,28(sp)
9d00144c:	ae02000c 	sw	v0,12(s0)
9d001450:	93a20020 	lbu	v0,32(sp)
9d001454:	a2020010 	sb	v0,16(s0)
9d001458:	8fa20024 	lw	v0,36(sp)
9d00145c:	0f400633 	jal	9d0018cc <_ZN4FileD1Ev>
9d001460:	ae020014 	sw	v0,20(s0)
9d001464:	0f400646 	jal	9d001918 <_ZN4FilecvbEv>
9d001468:	02002021 	move	a0,s0
9d00146c:	1040008f 	beqz	v0,9d0016ac <setup+0x354>
9d001470:	3c059d01 	lui	a1,0x9d01
9d001474:	27b50040 	addiu	s5,sp,64
9d001478:	27b40440 	addiu	s4,sp,1088
9d00147c:	0f401ee2 	jal	9d007b88 <rand>
9d001480:	00000000 	nop
9d001484:	a2a20000 	sb	v0,0(s5)
9d001488:	26b50001 	addiu	s5,s5,1
9d00148c:	16b4fffb 	bne	s5,s4,9d00147c <setup+0x124>
9d001490:	3c059d01 	lui	a1,0x9d01
9d001494:	27848060 	addiu	a0,gp,-32672
9d001498:	0f4015d9 	jal	9d005764 <_ZN5Print5printEPKc>
9d00149c:	24a58788 	addiu	a1,a1,-30840
9d0014a0:	0f4014d8 	jal	9d005360 <millis>
9d0014a4:	24152800 	li	s5,10240
9d0014a8:	0040a021 	move	s4,v0
9d0014ac:	26520a20 	addiu	s2,s2,2592
9d0014b0:	26b5ffff 	addiu	s5,s5,-1
9d0014b4:	02402021 	move	a0,s2
9d0014b8:	27a50040 	addiu	a1,sp,64
9d0014bc:	0f4005f3 	jal	9d0017cc <_ZN4File5writeEPKhm>
9d0014c0:	24060400 	li	a2,1024
9d0014c4:	56a0fffb 	bnezl	s5,9d0014b4 <setup+0x15c>
9d0014c8:	26b5ffff 	addiu	s5,s5,-1
9d0014cc:	0f400637 	jal	9d0018dc <_ZN4File5closeEv>
9d0014d0:	02402021 	move	a0,s2
9d0014d4:	0f4014d8 	jal	9d005360 <millis>
9d0014d8:	00000000 	nop
9d0014dc:	3c059d01 	lui	a1,0x9d01
9d0014e0:	24a587a4 	addiu	a1,a1,-30812
9d0014e4:	27848060 	addiu	a0,gp,-32672
9d0014e8:	0f401645 	jal	9d005914 <_ZN5Print7printlnEPKc>
9d0014ec:	afa20440 	sw	v0,1088(sp)
9d0014f0:	3c059d01 	lui	a1,0x9d01
9d0014f4:	24a587ac 	addiu	a1,a1,-30804
9d0014f8:	0f4015d9 	jal	9d005764 <_ZN5Print5printEPKc>
9d0014fc:	27848060 	addiu	a0,gp,-32672
9d001500:	8fa20440 	lw	v0,1088(sp)
9d001504:	27848060 	addiu	a0,gp,-32672
9d001508:	2406000a 	li	a2,10
9d00150c:	0f40160b 	jal	9d00582c <_ZN5Print5printEmi>
9d001510:	00542823 	subu	a1,v0,s4
9d001514:	3c059d01 	lui	a1,0x9d01
9d001518:	27848060 	addiu	a0,gp,-32672
9d00151c:	0f401645 	jal	9d005914 <_ZN5Print7printlnEPKc>
9d001520:	24a587bc 	addiu	a1,a1,-30788
9d001524:	27a40028 	addiu	a0,sp,40
9d001528:	26250a50 	addiu	a1,s1,2640
9d00152c:	26668764 	addiu	a2,s3,-30876
9d001530:	0f40079d 	jal	9d001e74 <_ZN7SDClass4openEPKch>
9d001534:	24070001 	li	a3,1
9d001538:	8fa2002c 	lw	v0,44(sp)
9d00153c:	27a40028 	addiu	a0,sp,40
9d001540:	ae020004 	sw	v0,4(s0)
9d001544:	8fa20030 	lw	v0,48(sp)
9d001548:	ae020008 	sw	v0,8(s0)
9d00154c:	8fa20034 	lw	v0,52(sp)
9d001550:	ae02000c 	sw	v0,12(s0)
9d001554:	93a20038 	lbu	v0,56(sp)
9d001558:	a2020010 	sb	v0,16(s0)
9d00155c:	8fa2003c 	lw	v0,60(sp)
9d001560:	0f400633 	jal	9d0018cc <_ZN4FileD1Ev>
9d001564:	ae020014 	sw	v0,20(s0)
9d001568:	0f400646 	jal	9d001918 <_ZN4FilecvbEv>
9d00156c:	02002021 	move	a0,s0
9d001570:	5040003a 	beqzl	v0,9d00165c <setup+0x304>
9d001574:	3c059d01 	lui	a1,0x9d01
9d001578:	3c059d01 	lui	a1,0x9d01
9d00157c:	27848060 	addiu	a0,gp,-32672
9d001580:	0f401645 	jal	9d005914 <_ZN5Print7printlnEPKc>
9d001584:	24a587d8 	addiu	a1,a1,-30760
9d001588:	0f4014d8 	jal	9d005360 <millis>
9d00158c:	02008821 	move	s1,s0
9d001590:	0b400568 	j	9d0015a0 <setup+0x248>
9d001594:	00409021 	move	s2,v0
9d001598:	0f4005f6 	jal	9d0017d8 <_ZN4File4readEv>
9d00159c:	00000000 	nop
9d0015a0:	0f4005c1 	jal	9d001704 <_ZN4File9availableEv>
9d0015a4:	02002021 	move	a0,s0
9d0015a8:	1440fffb 	bnez	v0,9d001598 <setup+0x240>
9d0015ac:	02202021 	move	a0,s1
9d0015b0:	0f400637 	jal	9d0018dc <_ZN4File5closeEv>
9d0015b4:	02002021 	move	a0,s0
9d0015b8:	0f4014d8 	jal	9d005360 <millis>
9d0015bc:	00000000 	nop
9d0015c0:	3c059d01 	lui	a1,0x9d01
9d0015c4:	24a587a4 	addiu	a1,a1,-30812
9d0015c8:	27848060 	addiu	a0,gp,-32672
9d0015cc:	0f401645 	jal	9d005914 <_ZN5Print7printlnEPKc>
9d0015d0:	afa20440 	sw	v0,1088(sp)
9d0015d4:	3c059d01 	lui	a1,0x9d01
9d0015d8:	24a587ac 	addiu	a1,a1,-30804
9d0015dc:	0f4015d9 	jal	9d005764 <_ZN5Print5printEPKc>
9d0015e0:	27848060 	addiu	a0,gp,-32672
9d0015e4:	8fa20440 	lw	v0,1088(sp)
9d0015e8:	27848060 	addiu	a0,gp,-32672
9d0015ec:	2406000a 	li	a2,10
9d0015f0:	0f40160b 	jal	9d00582c <_ZN5Print5printEmi>
9d0015f4:	00522823 	subu	a1,v0,s2
9d0015f8:	3c059d01 	lui	a1,0x9d01
9d0015fc:	27848060 	addiu	a0,gp,-32672
9d001600:	0f401645 	jal	9d005914 <_ZN5Print7printlnEPKc>
9d001604:	24a587bc 	addiu	a1,a1,-30788
9d001608:	8fbf0464 	lw	ra,1124(sp)
9d00160c:	8fb50460 	lw	s5,1120(sp)
9d001610:	8fb4045c 	lw	s4,1116(sp)
9d001614:	8fb30458 	lw	s3,1112(sp)
9d001618:	8fb20454 	lw	s2,1108(sp)
9d00161c:	8fb10450 	lw	s1,1104(sp)
9d001620:	8fb0044c 	lw	s0,1100(sp)
9d001624:	03e00008 	jr	ra
9d001628:	27bd0468 	addiu	sp,sp,1128
9d00162c:	3c059d01 	lui	a1,0x9d01
9d001630:	0f401645 	jal	9d005914 <_ZN5Print7printlnEPKc>
9d001634:	24a58734 	addiu	a1,a1,-30924
9d001638:	8fbf0464 	lw	ra,1124(sp)
9d00163c:	8fb50460 	lw	s5,1120(sp)
9d001640:	8fb4045c 	lw	s4,1116(sp)
9d001644:	8fb30458 	lw	s3,1112(sp)
9d001648:	8fb20454 	lw	s2,1108(sp)
9d00164c:	8fb10450 	lw	s1,1104(sp)
9d001650:	8fb0044c 	lw	s0,1100(sp)
9d001654:	03e00008 	jr	ra
9d001658:	27bd0468 	addiu	sp,sp,1128
9d00165c:	27848060 	addiu	a0,gp,-32672
9d001660:	0f401645 	jal	9d005914 <_ZN5Print7printlnEPKc>
9d001664:	24a587c0 	addiu	a1,a1,-30784
9d001668:	8fbf0464 	lw	ra,1124(sp)
9d00166c:	8fb50460 	lw	s5,1120(sp)
9d001670:	8fb4045c 	lw	s4,1116(sp)
9d001674:	8fb30458 	lw	s3,1112(sp)
9d001678:	8fb20454 	lw	s2,1108(sp)
9d00167c:	8fb10450 	lw	s1,1104(sp)
9d001680:	8fb0044c 	lw	s0,1100(sp)
9d001684:	03e00008 	jr	ra
9d001688:	27bd0468 	addiu	sp,sp,1128
9d00168c:	27848060 	addiu	a0,gp,-32672
9d001690:	0f401645 	jal	9d005914 <_ZN5Print7printlnEPKc>
9d001694:	24a58770 	addiu	a1,a1,-30864
9d001698:	26240a50 	addiu	a0,s1,2640
9d00169c:	0f40082a 	jal	9d0020a8 <_ZN7SDClass6removeEPc>
9d0016a0:	26658764 	addiu	a1,s3,-30876
9d0016a4:	0b400507 	j	9d00141c <setup+0xc4>
9d0016a8:	27a40010 	addiu	a0,sp,16
9d0016ac:	27848060 	addiu	a0,gp,-32672
9d0016b0:	0f401645 	jal	9d005914 <_ZN5Print7printlnEPKc>
9d0016b4:	24a587c0 	addiu	a1,a1,-30784
9d0016b8:	0b40054a 	j	9d001528 <setup+0x1d0>
9d0016bc:	27a40028 	addiu	a0,sp,40

9d0016c0 <loop>:
9d0016c0:	03e00008 	jr	ra
9d0016c4:	00000000 	nop

9d0016c8 <_GLOBAL__I_myFile>:
9d0016c8:	0b4004ca 	j	9d001328 <_Z41__static_initialization_and_destruction_0ii.clone.2>
9d0016cc:	24040001 	li	a0,1

9d0016d0 <_GLOBAL__D_myFile>:
9d0016d0:	0b4004ca 	j	9d001328 <_Z41__static_initialization_and_destruction_0ii.clone.2>
9d0016d4:	00002021 	move	a0,zero

9d0016d8 <_ZN4File5writeEh>:
}


void File::write(uint8_t val) {
  //return 
  write(&val, 1);
9d0016d8:	8c820000 	lw	v0,0(a0)
boolean File::isDirectory(void) {
  return (_file && _file->isDir());
}


void File::write(uint8_t val) {
9d0016dc:	27bdffe8 	addiu	sp,sp,-24
9d0016e0:	a3a5001c 	sb	a1,28(sp)
  //return 
  write(&val, 1);
9d0016e4:	8c420008 	lw	v0,8(v0)
boolean File::isDirectory(void) {
  return (_file && _file->isDir());
}


void File::write(uint8_t val) {
9d0016e8:	afbf0014 	sw	ra,20(sp)
  //return 
  write(&val, 1);
9d0016ec:	27a5001c 	addiu	a1,sp,28
9d0016f0:	0040f809 	jalr	v0
9d0016f4:	24060001 	li	a2,1
}
9d0016f8:	8fbf0014 	lw	ra,20(sp)
9d0016fc:	03e00008 	jr	ra
9d001700:	27bd0018 	addiu	sp,sp,24

9d001704 <_ZN4File9availableEv>:
    return _file->read(buf, nbyte);
  return 0;
}

int File::available() {
  if (! _file) return 0;
9d001704:	8c830014 	lw	v1,20(a0)
9d001708:	10600008 	beqz	v1,9d00172c <_ZN4File9availableEv+0x28>
9d00170c:	00001021 	move	v0,zero

  uint32_t n = size() - position();
9d001710:	8c640018 	lw	a0,24(v1)
9d001714:	8c62000c 	lw	v0,12(v1)

  return n > 0X7FFF ? 0X7FFF : n;
9d001718:	24037fff 	li	v1,32767
}

int File::available() {
  if (! _file) return 0;

  uint32_t n = size() - position();
9d00171c:	00821023 	subu	v0,a0,v0

  return n > 0X7FFF ? 0X7FFF : n;
9d001720:	34048000 	li	a0,0x8000
9d001724:	0044202b 	sltu	a0,v0,a0
9d001728:	0064100a 	movz	v0,v1,a0
}
9d00172c:	03e00008 	jr	ra
9d001730:	00000000 	nop

9d001734 <_ZN4File5flushEv>:

void File::flush() {
  if (_file)
9d001734:	8c840014 	lw	a0,20(a0)
9d001738:	10800003 	beqz	a0,9d001748 <_ZN4File5flushEv+0x14>
9d00173c:	00000000 	nop
    _file->sync();
9d001740:	0b400c6a 	j	9d0031a8 <_ZN6SdFile4syncEv>
9d001744:	00000000 	nop
9d001748:	03e00008 	jr	ra
9d00174c:	00000000 	nop

9d001750 <_ZN4File4peekEv>:
  //  return 0;
  //}
  //return t;
}

int File::peek() {
9d001750:	27bdffd8 	addiu	sp,sp,-40
9d001754:	afb0001c 	sw	s0,28(sp)
9d001758:	00808021 	move	s0,a0
  if (! _file) 
9d00175c:	8c840014 	lw	a0,20(a0)
  //  return 0;
  //}
  //return t;
}

int File::peek() {
9d001760:	afb10020 	sw	s1,32(sp)
9d001764:	afbf0024 	sw	ra,36(sp)
  if (! _file) 
9d001768:	10800007 	beqz	a0,9d001788 <_ZN4File4peekEv+0x38>
9d00176c:	00008821 	move	s1,zero
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int16_t read(void) {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
9d001770:	27a50010 	addiu	a1,sp,16
9d001774:	0f400b66 	jal	9d002d98 <_ZN6SdFile4readEPvt>
9d001778:	24060001 	li	a2,1
9d00177c:	24030001 	li	v1,1
9d001780:	10430007 	beq	v0,v1,9d0017a0 <_ZN4File4peekEv+0x50>
9d001784:	2411ffff 	li	s1,-1
    return 0;

  int c = _file->read();
  if (c != -1) _file->seekCur(-1);
  return c;
}
9d001788:	8fbf0024 	lw	ra,36(sp)
9d00178c:	02201021 	move	v0,s1
9d001790:	8fb10020 	lw	s1,32(sp)
9d001794:	8fb0001c 	lw	s0,28(sp)
9d001798:	03e00008 	jr	ra
9d00179c:	27bd0028 	addiu	sp,sp,40
int File::peek() {
  if (! _file) 
    return 0;

  int c = _file->read();
  if (c != -1) _file->seekCur(-1);
9d0017a0:	8e040014 	lw	a0,20(s0)

int File::peek() {
  if (! _file) 
    return 0;

  int c = _file->read();
9d0017a4:	93b10010 	lbu	s1,16(sp)
  }
  uint8_t rmDir(void);
  uint8_t rmRfStar(void);
  /** Set the files position to current position + \a pos. See seekSet(). */
  uint8_t seekCur(uint32_t pos) {
    return seekSet(curPosition_ + pos);
9d0017a8:	8c85000c 	lw	a1,12(a0)
9d0017ac:	0f400c23 	jal	9d00308c <_ZN6SdFile7seekSetEm>
9d0017b0:	24a5ffff 	addiu	a1,a1,-1
  if (c != -1) _file->seekCur(-1);
  return c;
}
9d0017b4:	8fbf0024 	lw	ra,36(sp)
9d0017b8:	02201021 	move	v0,s1
9d0017bc:	8fb10020 	lw	s1,32(sp)
9d0017c0:	8fb0001c 	lw	s0,28(sp)
9d0017c4:	03e00008 	jr	ra
9d0017c8:	27bd0028 	addiu	sp,sp,40

9d0017cc <_ZN4File5writeEPKhm>:
  //if (!_file) {
  //  setWriteError();
  //  return 0;
  //}
  //_file->clearWriteError();
  t = _file->write(buf, size);
9d0017cc:	8c840014 	lw	a0,20(a0)
9d0017d0:	0b400e36 	j	9d0038d8 <_ZN6SdFile5writeEPKvt>
9d0017d4:	30c6ffff 	andi	a2,a2,0xffff

9d0017d8 <_ZN4File4readEv>:
  if (c != -1) _file->seekCur(-1);
  return c;
}

int File::read() {
  if (_file) 
9d0017d8:	8c840014 	lw	a0,20(a0)
  int c = _file->read();
  if (c != -1) _file->seekCur(-1);
  return c;
}

int File::read() {
9d0017dc:	27bdffe0 	addiu	sp,sp,-32
9d0017e0:	afb00018 	sw	s0,24(sp)
9d0017e4:	afbf001c 	sw	ra,28(sp)
  if (_file) 
9d0017e8:	10800007 	beqz	a0,9d001808 <_ZN4File4readEv+0x30>
9d0017ec:	2410ffff 	li	s0,-1
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int16_t read(void) {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
9d0017f0:	27a50010 	addiu	a1,sp,16
9d0017f4:	0f400b66 	jal	9d002d98 <_ZN6SdFile4readEPvt>
9d0017f8:	24060001 	li	a2,1
9d0017fc:	93a30010 	lbu	v1,16(sp)
9d001800:	38420001 	xori	v0,v0,0x1
9d001804:	0062800a 	movz	s0,v1,v0
    return _file->read();
  return -1;
}
9d001808:	8fbf001c 	lw	ra,28(sp)
9d00180c:	02001021 	move	v0,s0
9d001810:	8fb00018 	lw	s0,24(sp)
9d001814:	03e00008 	jr	ra
9d001818:	27bd0020 	addiu	sp,sp,32

9d00181c <_ZN4FileC1E6SdFilePKc>:

/* for debugging file open/close leaks
   uint8_t nfilecount=0;
*/

File::File(SdFile f, const char *n) {
9d00181c:	3c029d01 	lui	v0,0x9d01
9d001820:	27bdffe0 	addiu	sp,sp,-32
9d001824:	24428800 	addiu	v0,v0,-30720
9d001828:	afb00018 	sw	s0,24(sp)
9d00182c:	afbf001c 	sw	ra,28(sp)
9d001830:	00808021 	move	s0,a0
9d001834:	ac820000 	sw	v0,0(a0)
  // oh man you are kidding me, new() doesnt exist? Ok we do it by hand!
  _file = (SdFile *)malloc(sizeof(SdFile)); 
9d001838:	24040024 	li	a0,36
9d00183c:	afa50010 	sw	a1,16(sp)
9d001840:	0f401d09 	jal	9d007424 <malloc>
9d001844:	afa60014 	sw	a2,20(sp)
9d001848:	ae020014 	sw	v0,20(s0)
  if (_file) {
9d00184c:	8fa50010 	lw	a1,16(sp)
9d001850:	10400014 	beqz	v0,9d0018a4 <_ZN4FileC1E6SdFilePKc+0x88>
9d001854:	8fa60014 	lw	a2,20(sp)
    memcpy(_file, &f, sizeof(SdFile));
9d001858:	24a30020 	addiu	v1,a1,32
9d00185c:	8ca90000 	lw	t1,0(a1)
9d001860:	8ca80004 	lw	t0,4(a1)
9d001864:	8ca70008 	lw	a3,8(a1)
9d001868:	8ca4000c 	lw	a0,12(a1)
9d00186c:	24a50010 	addiu	a1,a1,16
9d001870:	ac490000 	sw	t1,0(v0)
9d001874:	ac480004 	sw	t0,4(v0)
9d001878:	ac470008 	sw	a3,8(v0)
9d00187c:	ac44000c 	sw	a0,12(v0)
9d001880:	14a3fff6 	bne	a1,v1,9d00185c <_ZN4FileC1E6SdFilePKc+0x40>
9d001884:	24420010 	addiu	v0,v0,16
9d001888:	8ca30000 	lw	v1,0(a1)
    
    strncpy(_name, n, 12);
9d00188c:	26040004 	addiu	a0,s0,4
9d001890:	00c02821 	move	a1,a2

File::File(SdFile f, const char *n) {
  // oh man you are kidding me, new() doesnt exist? Ok we do it by hand!
  _file = (SdFile *)malloc(sizeof(SdFile)); 
  if (_file) {
    memcpy(_file, &f, sizeof(SdFile));
9d001894:	ac430000 	sw	v1,0(v0)
    
    strncpy(_name, n, 12);
9d001898:	0f401f1e 	jal	9d007c78 <strncpy>
9d00189c:	2406000c 	li	a2,12
    _name[12] = 0;
9d0018a0:	a2000010 	sb	zero,16(s0)
       Serial.print(n);
       Serial.print("\": ");
       Serial.println(nfilecount, DEC);
    */
  }
}
9d0018a4:	8fbf001c 	lw	ra,28(sp)
9d0018a8:	8fb00018 	lw	s0,24(sp)
9d0018ac:	03e00008 	jr	ra
9d0018b0:	27bd0020 	addiu	sp,sp,32

9d0018b4 <_ZN4FileC1Ev>:

File::File(void) {
9d0018b4:	3c029d01 	lui	v0,0x9d01
9d0018b8:	24428800 	addiu	v0,v0,-30720
9d0018bc:	ac820000 	sw	v0,0(a0)
  _file = 0;
9d0018c0:	ac800014 	sw	zero,20(a0)
  _name[0] = 0;
  //Serial.print("Created empty file object");
}
9d0018c4:	03e00008 	jr	ra
9d0018c8:	a0800004 	sb	zero,4(a0)

9d0018cc <_ZN4FileD1Ev>:

File::~File(void) {
9d0018cc:	3c029d01 	lui	v0,0x9d01
9d0018d0:	24428800 	addiu	v0,v0,-30720
  //  Serial.print("Deleted file object");
}
9d0018d4:	03e00008 	jr	ra
9d0018d8:	ac820000 	sw	v0,0(a0)

9d0018dc <_ZN4File5closeEv>:
uint32_t File::size() {
  if (! _file) return 0;
  return _file->fileSize();
}

void File::close() {
9d0018dc:	27bdffe8 	addiu	sp,sp,-24
9d0018e0:	afb00010 	sw	s0,16(sp)
9d0018e4:	00808021 	move	s0,a0
  if (_file) {
9d0018e8:	8c840014 	lw	a0,20(a0)
9d0018ec:	10800006 	beqz	a0,9d001908 <_ZN4File5closeEv+0x2c>
9d0018f0:	afbf0014 	sw	ra,20(sp)
    _file->close();
9d0018f4:	0f400ca4 	jal	9d003290 <_ZN6SdFile5closeEv>
9d0018f8:	00000000 	nop
    free(_file); 
9d0018fc:	0f401d13 	jal	9d00744c <free>
9d001900:	8e040014 	lw	a0,20(s0)
    _file = 0;
9d001904:	ae000014 	sw	zero,20(s0)
    nfilecount--;
    Serial.print("Deleted ");
    Serial.println(nfilecount, DEC);
    */
  }
}
9d001908:	8fbf0014 	lw	ra,20(sp)
9d00190c:	8fb00010 	lw	s0,16(sp)
9d001910:	03e00008 	jr	ra
9d001914:	27bd0018 	addiu	sp,sp,24

9d001918 <_ZN4FilecvbEv>:

File::operator bool() {
  if (_file) 
9d001918:	8c830014 	lw	v1,20(a0)
9d00191c:	10600003 	beqz	v1,9d00192c <_ZN4FilecvbEv+0x14>
9d001920:	00001021 	move	v0,zero
    return  _file->isOpen();
9d001924:	90620005 	lbu	v0,5(v1)
9d001928:	0002102b 	sltu	v0,zero,v0
  return false;
}
9d00192c:	03e00008 	jr	ra
9d001930:	00000000 	nop

9d001934 <_Z19callback_pathExistsR6SdFilePchPv>:
   a pointer to an arbitrary object used for context.

 */

boolean callback_pathExists(SdFile& parentDir, char *filePathComponent, 
			    boolean isLastComponent, void *object) {
9d001934:	00801021 	move	v0,a0
9d001938:	27bdffc0 	addiu	sp,sp,-64
9d00193c:	00a03021 	move	a2,a1
  /** \deprecated Use:
   * uint8_t SdFile::open(SdFile* dirFile, const char* fileName, uint8_t oflag);
   */
  uint8_t open(SdFile& dirFile, // NOLINT
    const char* fileName, uint8_t oflag) {
    return open(&dirFile, fileName, oflag);
9d001940:	00402821 	move	a1,v0
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
9d001944:	3c029d01 	lui	v0,0x9d01
9d001948:	24428840 	addiu	v0,v0,-30656
  /** \deprecated Use:
   * uint8_t SdFile::open(SdFile* dirFile, const char* fileName, uint8_t oflag);
   */
  uint8_t open(SdFile& dirFile, // NOLINT
    const char* fileName, uint8_t oflag) {
    return open(&dirFile, fileName, oflag);
9d00194c:	27a40010 	addiu	a0,sp,16
9d001950:	24070001 	li	a3,1
9d001954:	afb00038 	sw	s0,56(sp)
9d001958:	afbf003c 	sw	ra,60(sp)
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
9d00195c:	afa20010 	sw	v0,16(sp)
  /** \deprecated Use:
   * uint8_t SdFile::open(SdFile* dirFile, const char* fileName, uint8_t oflag);
   */
  uint8_t open(SdFile& dirFile, // NOLINT
    const char* fileName, uint8_t oflag) {
    return open(&dirFile, fileName, oflag);
9d001960:	0f400d72 	jal	9d0035c8 <_ZN6SdFile4openEPS_PKch>
9d001964:	a3a00015 	sb	zero,21(sp)
  */
  SdFile child;

  boolean exists = child.open(parentDir, filePathComponent, O_RDONLY);
  
  if (exists) {
9d001968:	10400003 	beqz	v0,9d001978 <_Z19callback_pathExistsR6SdFilePchPv+0x44>
9d00196c:	00408021 	move	s0,v0
     child.close(); 
9d001970:	0f400ca4 	jal	9d003290 <_ZN6SdFile5closeEv>
9d001974:	27a40010 	addiu	a0,sp,16
  }
  
  return exists;
}
9d001978:	8fbf003c 	lw	ra,60(sp)
9d00197c:	02001021 	move	v0,s0
9d001980:	8fb00038 	lw	s0,56(sp)
9d001984:	03e00008 	jr	ra
9d001988:	27bd0040 	addiu	sp,sp,64

9d00198c <_Z15callback_removeR6SdFilePchPv>:
  */



boolean callback_remove(SdFile& parentDir, char *filePathComponent, 
			boolean isLastComponent, void *object) {
9d00198c:	30c600ff 	andi	a2,a2,0xff
  if (isLastComponent) {
9d001990:	14c00003 	bnez	a2,9d0019a0 <_Z15callback_removeR6SdFilePchPv+0x14>
9d001994:	24020001 	li	v0,1
    return SdFile::remove(parentDir, filePathComponent);
  }
  return true;
}
9d001998:	03e00008 	jr	ra
9d00199c:	00000000 	nop
  int8_t readDir(dir_t& dir) {return readDir(&dir);}  // NOLINT
  /** \deprecated Use:
   * static uint8_t SdFile::remove(SdFile* dirFile, const char* fileName);
   */
  static uint8_t remove(SdFile& dirFile, const char* fileName) {  // NOLINT
    return remove(&dirFile, fileName);
9d0019a0:	0b400e21 	j	9d003884 <_ZN6SdFile6removeEPS_PKc>
9d0019a4:	00000000 	nop

9d0019a8 <_Z20getNextPathComponentPcPjS_>:
  // TODO: Have buffer local to this function, so we know it's the
  //       correct length?

  int bufferOffset = 0;

  int offset = *p_offset;
9d0019a8:	8ca20000 	lw	v0,0(a1)

  // Skip root or other separator
  if (path[offset] == '/') {
9d0019ac:	2408002f 	li	t0,47
9d0019b0:	00821821 	addu	v1,a0,v0
9d0019b4:	80670000 	lb	a3,0(v1)
9d0019b8:	50e8001f 	beql	a3,t0,9d001a38 <_Z20getNextPathComponentPcPjS_+0x90>
9d0019bc:	24420001 	addiu	v0,v0,1

// Used by `getNextPathComponent`
#define MAX_COMPONENT_LEN 12 // What is max length?
#define PATH_COMPONENT_BUFFER_LEN MAX_COMPONENT_LEN+1

bool getNextPathComponent(char *path, unsigned int *p_offset,
9d0019c0:	00003821 	move	a3,zero
  if (path[offset] == '/') {
    offset++;
  }
  
  // Copy the next next path segment
  while (bufferOffset < MAX_COMPONENT_LEN
9d0019c4:	240a002f 	li	t2,47
9d0019c8:	240c000c 	li	t4,12
	 && (path[offset] != '/')
9d0019cc:	80680000 	lb	t0,0(v1)
  if (path[offset] == '/') {
    offset++;
  }
  
  // Copy the next next path segment
  while (bufferOffset < MAX_COMPONENT_LEN
9d0019d0:	110a000a 	beq	t0,t2,9d0019fc <_Z20getNextPathComponentPcPjS_+0x54>
9d0019d4:	00404821 	move	t1,v0
9d0019d8:	11000008 	beqz	t0,9d0019fc <_Z20getNextPathComponentPcPjS_+0x54>
9d0019dc:	00c75821 	addu	t3,a2,a3
	 && (path[offset] != '/')
	 && (path[offset] != '\0')) {
    buffer[bufferOffset++] = path[offset++];
9d0019e0:	24e70001 	addiu	a3,a3,1
9d0019e4:	a1680000 	sb	t0,0(t3)
9d0019e8:	24420001 	addiu	v0,v0,1
  if (path[offset] == '/') {
    offset++;
  }
  
  // Copy the next next path segment
  while (bufferOffset < MAX_COMPONENT_LEN
9d0019ec:	14ecfff7 	bne	a3,t4,9d0019cc <_Z20getNextPathComponentPcPjS_+0x24>
9d0019f0:	24630001 	addiu	v1,v1,1
9d0019f4:	00404821 	move	t1,v0
9d0019f8:	00821821 	addu	v1,a0,v0
	 && (path[offset] != '/')
	 && (path[offset] != '\0')) {
    buffer[bufferOffset++] = path[offset++];
  }

  buffer[bufferOffset] = '\0';
9d0019fc:	00c73821 	addu	a3,a2,a3
9d001a00:	a0e00000 	sb	zero,0(a3)

  // Skip trailing separator so we can determine if this
  // is the last component in the path or not.
  if (path[offset] == '/') {
9d001a04:	80670000 	lb	a3,0(v1)
9d001a08:	2406002f 	li	a2,47
9d001a0c:	50e60005 	beql	a3,a2,9d001a24 <_Z20getNextPathComponentPcPjS_+0x7c>
9d001a10:	24490001 	addiu	t1,v0,1
    offset++;
  }

  *p_offset = offset;
9d001a14:	aca90000 	sw	t1,0(a1)

  return (path[offset] != '\0');
9d001a18:	80620000 	lb	v0,0(v1)
}
9d001a1c:	03e00008 	jr	ra
9d001a20:	0002102b 	sltu	v0,zero,v0
  if (path[offset] == '/') {
    offset++;
  }
  
  // Copy the next next path segment
  while (bufferOffset < MAX_COMPONENT_LEN
9d001a24:	00891821 	addu	v1,a0,t1
  // is the last component in the path or not.
  if (path[offset] == '/') {
    offset++;
  }

  *p_offset = offset;
9d001a28:	aca90000 	sw	t1,0(a1)

  return (path[offset] != '\0');
9d001a2c:	80620000 	lb	v0,0(v1)
}
9d001a30:	03e00008 	jr	ra
9d001a34:	0002102b 	sltu	v0,zero,v0
9d001a38:	0b400670 	j	9d0019c0 <_Z20getNextPathComponentPcPjS_+0x18>
9d001a3c:	00821821 	addu	v1,a0,v0

9d001a40 <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_>:
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
9d001a40:	3c029d01 	lui	v0,0x9d01
boolean walkPath(char *filepath, SdFile& parentDir,
		 boolean (*callback)(SdFile& parentDir,
				     char *filePathComponent,
				     boolean isLastComponent,
				     void *object),
		 void *object = NULL) {
9d001a44:	27bdff68 	addiu	sp,sp,-152
9d001a48:	24428840 	addiu	v0,v0,-30656
9d001a4c:	afb6008c 	sw	s6,140(sp)
9d001a50:	afb50088 	sw	s5,136(sp)
9d001a54:	afb40084 	sw	s4,132(sp)
9d001a58:	afb30080 	sw	s3,128(sp)
9d001a5c:	afb2007c 	sw	s2,124(sp)
9d001a60:	afb10078 	sw	s1,120(sp)
9d001a64:	afb00074 	sw	s0,116(sp)
9d001a68:	afbf0094 	sw	ra,148(sp)
9d001a6c:	afb70090 	sw	s7,144(sp)
9d001a70:	00a09021 	move	s2,a1
9d001a74:	00809821 	move	s3,a0
9d001a78:	00c0a021 	move	s4,a2
9d001a7c:	00e0a821 	move	s5,a3
9d001a80:	afa20024 	sw	v0,36(sp)
9d001a84:	a3a00029 	sb	zero,41(sp)
9d001a88:	afa20048 	sw	v0,72(sp)
9d001a8c:	a3a0004d 	sb	zero,77(sp)
  SdFile subfile1;
  SdFile subfile2;

  char buffer[PATH_COMPONENT_BUFFER_LEN]; 

  unsigned int offset = 0;
9d001a90:	afa00010 	sw	zero,16(sp)
9d001a94:	00a08021 	move	s0,a1
  SdFile *p_parent;
  SdFile *p_child;

  SdFile *p_tmp_sdfile;  
  
  p_child = &subfile1;
9d001a98:	27b10024 	addiu	s1,sp,36
    
    // Handle case when it doesn't exist and we can't continue...
    if (exists) {
      // We alternate between two file handles as we go down
      // the path.
      if (p_parent == &parentDir) {
9d001a9c:	0b4006b8 	j	9d001ae0 <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_+0xa0>
9d001aa0:	27b60048 	addiu	s6,sp,72
        (*p_parent).close();
      }
      return false;
    }
    
    if (!moreComponents) {
9d001aa4:	12e0002d 	beqz	s7,9d001b5c <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_+0x11c>
9d001aa8:	00000000 	nop
  /** \deprecated Use:
   * uint8_t SdFile::open(SdFile* dirFile, const char* fileName, uint8_t oflag);
   */
  uint8_t open(SdFile& dirFile, // NOLINT
    const char* fileName, uint8_t oflag) {
    return open(&dirFile, fileName, oflag);
9d001aac:	0f400d72 	jal	9d0035c8 <_ZN6SdFile4openEPS_PKch>
9d001ab0:	00000000 	nop
9d001ab4:	0040b821 	move	s7,v0
    
    boolean exists = (*p_child).open(*p_parent, buffer, O_RDONLY);

    // If it's one we've created then we
    // don't need the parent handle anymore.
    if (p_parent != &parentDir) {
9d001ab8:	12120003 	beq	s0,s2,9d001ac8 <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_+0x88>
9d001abc:	02002021 	move	a0,s0
      (*p_parent).close();
9d001ac0:	0f400ca4 	jal	9d003290 <_ZN6SdFile5closeEv>
9d001ac4:	00000000 	nop
    
    // Handle case when it doesn't exist and we can't continue...
    if (exists) {
      // We alternate between two file handles as we go down
      // the path.
      if (p_parent == &parentDir) {
9d001ac8:	02121026 	xor	v0,s0,s2
9d001acc:	02c2800a 	movz	s0,s6,v0
    if (p_parent != &parentDir) {
      (*p_parent).close();
    }
    
    // Handle case when it doesn't exist and we can't continue...
    if (exists) {
9d001ad0:	12e00026 	beqz	s7,9d001b6c <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_+0x12c>
9d001ad4:	02001021 	move	v0,s0
  SdFile subfile1;
  SdFile subfile2;

  char buffer[PATH_COMPONENT_BUFFER_LEN]; 

  unsigned int offset = 0;
9d001ad8:	02208021 	move	s0,s1
    
    // Handle case when it doesn't exist and we can't continue...
    if (exists) {
      // We alternate between two file handles as we go down
      // the path.
      if (p_parent == &parentDir) {
9d001adc:	00408821 	move	s1,v0
  
  p_parent = &parentDir;

  while (true) {

    boolean moreComponents = getNextPathComponent(filepath, &offset, buffer);
9d001ae0:	27a60014 	addiu	a2,sp,20
9d001ae4:	02602021 	move	a0,s3
9d001ae8:	0f40066a 	jal	9d0019a8 <_Z20getNextPathComponentPcPjS_>
9d001aec:	27a50010 	addiu	a1,sp,16

    boolean shouldContinue = callback((*p_parent), buffer, !moreComponents, object);
9d001af0:	2c460001 	sltiu	a2,v0,1
9d001af4:	02002021 	move	a0,s0
9d001af8:	27a50014 	addiu	a1,sp,20
9d001afc:	02a03821 	move	a3,s5
9d001b00:	0280f809 	jalr	s4
9d001b04:	0040b821 	move	s7,v0
9d001b08:	02202021 	move	a0,s1
9d001b0c:	02002821 	move	a1,s0
9d001b10:	27a60014 	addiu	a2,sp,20

    if (!shouldContinue) {
9d001b14:	1440ffe3 	bnez	v0,9d001aa4 <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_+0x64>
9d001b18:	24070001 	li	a3,1
      // TODO: Don't repeat this code?
      // If it's one we've created then we
      // don't need the parent handle anymore.
      if (p_parent != &parentDir) {
9d001b1c:	12500003 	beq	s2,s0,9d001b2c <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_+0xec>
9d001b20:	00008821 	move	s1,zero
      return false;
    }
  }
  
  if (p_parent != &parentDir) {
    (*p_parent).close(); // TODO: Return/ handle different?
9d001b24:	0f400ca4 	jal	9d003290 <_ZN6SdFile5closeEv>
9d001b28:	02002021 	move	a0,s0
  }

  return true;
}
9d001b2c:	8fbf0094 	lw	ra,148(sp)
9d001b30:	02201021 	move	v0,s1
9d001b34:	8fb70090 	lw	s7,144(sp)
9d001b38:	8fb6008c 	lw	s6,140(sp)
9d001b3c:	8fb50088 	lw	s5,136(sp)
9d001b40:	8fb40084 	lw	s4,132(sp)
9d001b44:	8fb30080 	lw	s3,128(sp)
9d001b48:	8fb2007c 	lw	s2,124(sp)
9d001b4c:	8fb10078 	lw	s1,120(sp)
9d001b50:	8fb00074 	lw	s0,116(sp)
9d001b54:	03e00008 	jr	ra
9d001b58:	27bd0098 	addiu	sp,sp,152
    } else {
      return false;
    }
  }
  
  if (p_parent != &parentDir) {
9d001b5c:	1650fff1 	bne	s2,s0,9d001b24 <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_+0xe4>
9d001b60:	24110001 	li	s1,1
    (*p_parent).close(); // TODO: Return/ handle different?
  }

  return true;
}
9d001b64:	0b4006cc 	j	9d001b30 <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_+0xf0>
9d001b68:	8fbf0094 	lw	ra,148(sp)
9d001b6c:	8fbf0094 	lw	ra,148(sp)

      p_tmp_sdfile = p_parent;
      p_parent = p_child;
      p_child = p_tmp_sdfile;
    } else {
      return false;
9d001b70:	00008821 	move	s1,zero
  if (p_parent != &parentDir) {
    (*p_parent).close(); // TODO: Return/ handle different?
  }

  return true;
}
9d001b74:	02201021 	move	v0,s1
9d001b78:	8fb70090 	lw	s7,144(sp)
9d001b7c:	8fb6008c 	lw	s6,140(sp)
9d001b80:	8fb50088 	lw	s5,136(sp)
9d001b84:	8fb40084 	lw	s4,132(sp)
9d001b88:	8fb30080 	lw	s3,128(sp)
9d001b8c:	8fb2007c 	lw	s2,124(sp)
9d001b90:	8fb10078 	lw	s1,120(sp)
9d001b94:	8fb00074 	lw	s0,116(sp)
9d001b98:	03e00008 	jr	ra
9d001b9c:	27bd0098 	addiu	sp,sp,152

9d001ba0 <_ZN7SDClass5beginEh>:

/* Implementation of class used to create `SDCard` object. */



boolean SDClass::begin(uint8_t csPin) {
9d001ba0:	27bdffd8 	addiu	sp,sp,-40
9d001ba4:	afb00014 	sw	s0,20(sp)
9d001ba8:	00808021 	move	s0,a0
    Performs the initialisation required by the sdfatlib library.

    Return true if initialization succeeds, false otherwise.

   */
  return card->init(SPI_HALF_SPEED, csPin) &&
9d001bac:	8c840000 	lw	a0,0(a0)

/* Implementation of class used to create `SDCard` object. */



boolean SDClass::begin(uint8_t csPin) {
9d001bb0:	30a600ff 	andi	a2,a1,0xff
    Performs the initialisation required by the sdfatlib library.

    Return true if initialization succeeds, false otherwise.

   */
  return card->init(SPI_HALF_SPEED, csPin) &&
9d001bb4:	24050001 	li	a1,1

/* Implementation of class used to create `SDCard` object. */



boolean SDClass::begin(uint8_t csPin) {
9d001bb8:	afb2001c 	sw	s2,28(sp)
9d001bbc:	afbf0024 	sw	ra,36(sp)
9d001bc0:	afb30020 	sw	s3,32(sp)
    Performs the initialisation required by the sdfatlib library.

    Return true if initialization succeeds, false otherwise.

   */
  return card->init(SPI_HALF_SPEED, csPin) &&
9d001bc4:	0f400904 	jal	9d002410 <_ZN7Sd2Card4initEhh>
9d001bc8:	afb10018 	sw	s1,24(sp)
         volume.init(*card) &&
         root.openRoot(volume);
9d001bcc:	14400009 	bnez	v0,9d001bf4 <_ZN7SDClass5beginEh+0x54>
9d001bd0:	00009021 	move	s2,zero
}
9d001bd4:	8fbf0024 	lw	ra,36(sp)
9d001bd8:	02401021 	move	v0,s2
9d001bdc:	8fb30020 	lw	s3,32(sp)
9d001be0:	8fb2001c 	lw	s2,28(sp)
9d001be4:	8fb10018 	lw	s1,24(sp)
9d001be8:	8fb00014 	lw	s0,20(sp)
9d001bec:	03e00008 	jr	ra
9d001bf0:	27bd0028 	addiu	sp,sp,40

    Return true if initialization succeeds, false otherwise.

   */
  return card->init(SPI_HALF_SPEED, csPin) &&
         volume.init(*card) &&
9d001bf4:	8e130000 	lw	s3,0(s0)
9d001bf8:	26110004 	addiu	s1,s0,4
   * \return The value one, true, is returned for success and
   * the value zero, false, is returned for failure.  Reasons for
   * failure include not finding a valid partition, not finding a valid
   * FAT file system or an I/O error.
   */
  uint8_t init(Sd2Card* dev) { return init(dev, 1) ? true : init(dev, 0);}
9d001bfc:	02202021 	move	a0,s1
9d001c00:	02602821 	move	a1,s3
9d001c04:	0f4010c6 	jal	9d004318 <_ZN8SdVolume4initEP7Sd2Cardh>
9d001c08:	24060001 	li	a2,1
9d001c0c:	10400006 	beqz	v0,9d001c28 <_ZN7SDClass5beginEh+0x88>
9d001c10:	02202021 	move	a0,s1
   */
  uint8_t open(SdFile& dirFile, uint16_t index, uint8_t oflag) {  // NOLINT
    return open(&dirFile, index, oflag);
  }
  /** \deprecated Use: uint8_t SdFile::openRoot(SdVolume* vol); */
  uint8_t openRoot(SdVolume& vol) {return openRoot(&vol);}  // NOLINT
9d001c14:	2604002c 	addiu	a0,s0,44
9d001c18:	0f400b30 	jal	9d002cc0 <_ZN6SdFile8openRootEP8SdVolume>
9d001c1c:	02202821 	move	a1,s1
9d001c20:	0b4006f5 	j	9d001bd4 <_ZN7SDClass5beginEh+0x34>
9d001c24:	0002902b 	sltu	s2,zero,v0
   * \return The value one, true, is returned for success and
   * the value zero, false, is returned for failure.  Reasons for
   * failure include not finding a valid partition, not finding a valid
   * FAT file system or an I/O error.
   */
  uint8_t init(Sd2Card* dev) { return init(dev, 1) ? true : init(dev, 0);}
9d001c28:	02602821 	move	a1,s3
9d001c2c:	0f4010c6 	jal	9d004318 <_ZN8SdVolume4initEP7Sd2Cardh>
9d001c30:	00003021 	move	a2,zero
         root.openRoot(volume);
9d001c34:	1440fff7 	bnez	v0,9d001c14 <_ZN7SDClass5beginEh+0x74>
9d001c38:	8fbf0024 	lw	ra,36(sp)
}
9d001c3c:	02401021 	move	v0,s2
9d001c40:	8fb30020 	lw	s3,32(sp)
9d001c44:	8fb2001c 	lw	s2,28(sp)
9d001c48:	8fb10018 	lw	s1,24(sp)
9d001c4c:	8fb00014 	lw	s0,20(sp)
9d001c50:	03e00008 	jr	ra
9d001c54:	27bd0028 	addiu	sp,sp,40

9d001c58 <_ZN7SDClass12getParentDirEPKcPi>:



// this little helper is used to traverse paths
SdFile SDClass::getParentDir(const char *filepath, int *index) {
9d001c58:	27bdff70 	addiu	sp,sp,-144
9d001c5c:	afbe0088 	sw	s8,136(sp)
9d001c60:	afb60080 	sw	s6,128(sp)
9d001c64:	afb5007c 	sw	s5,124(sp)
9d001c68:	afb40078 	sw	s4,120(sp)
9d001c6c:	afb30074 	sw	s3,116(sp)
9d001c70:	afb20070 	sw	s2,112(sp)
9d001c74:	afb1006c 	sw	s1,108(sp)
9d001c78:	afb00068 	sw	s0,104(sp)
9d001c7c:	afbf008c 	sw	ra,140(sp)
9d001c80:	afb70084 	sw	s7,132(sp)
//------------------------------------------------------------------------------
/**
 * \class SdFile
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
9d001c84:	90ae0030 	lbu	t6,48(a1)
9d001c88:	90ad0031 	lbu	t5,49(a1)
9d001c8c:	8cac0034 	lw	t4,52(a1)
9d001c90:	8cab0038 	lw	t3,56(a1)
9d001c94:	8caa003c 	lw	t2,60(a1)
9d001c98:	90a90040 	lbu	t1,64(a1)
9d001c9c:	8ca80044 	lw	t0,68(a1)
9d001ca0:	8ca30048 	lw	v1,72(a1)
9d001ca4:	8ca2004c 	lw	v0,76(a1)
9d001ca8:	3c149d01 	lui	s4,0x9d01
9d001cac:	26948840 	addiu	s4,s4,-30656
9d001cb0:	00c0a821 	move	s5,a2
9d001cb4:	00809821 	move	s3,a0
9d001cb8:	00e0b021 	move	s6,a3
9d001cbc:	afb40020 	sw	s4,32(sp)
9d001cc0:	a3ae0024 	sb	t6,36(sp)
9d001cc4:	a3ad0025 	sb	t5,37(sp)
9d001cc8:	afac0028 	sw	t4,40(sp)
9d001ccc:	afab002c 	sw	t3,44(sp)
9d001cd0:	afaa0030 	sw	t2,48(sp)
9d001cd4:	a3a90034 	sb	t1,52(sp)
9d001cd8:	afa80038 	sw	t0,56(sp)
9d001cdc:	afa3003c 	sw	v1,60(sp)
9d001ce0:	afa20040 	sw	v0,64(sp)
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
9d001ce4:	afb40044 	sw	s4,68(sp)
9d001ce8:	a3a00049 	sb	zero,73(sp)
  SdFile *parent = &d1;
  SdFile *subdir = &d2;
  
  const char *origpath = filepath;

  while (strchr(filepath, '/')) {
9d001cec:	00c0f021 	move	s8,a2
  SdFile d1 = root; // start with the mostparent, root!
  SdFile d2;

  // we'll use the pointers to swap between the two objects
  SdFile *parent = &d1;
  SdFile *subdir = &d2;
9d001cf0:	27b10044 	addiu	s1,sp,68
  // get parent directory
  SdFile d1 = root; // start with the mostparent, root!
  SdFile d2;

  // we'll use the pointers to swap between the two objects
  SdFile *parent = &d1;
9d001cf4:	27b00020 	addiu	s0,sp,32
9d001cf8:	2412000c 	li	s2,12
  SdFile *subdir = &d2;
  
  const char *origpath = filepath;

  while (strchr(filepath, '/')) {
9d001cfc:	03c02021 	move	a0,s8
9d001d00:	0f401f0c 	jal	9d007c30 <strchr>
9d001d04:	2405002f 	li	a1,47
      // it was in the root directory, so leave now
      break;
    }

    // extract just the name of the next subdirectory
    uint8_t idx = strchr(filepath, '/') - filepath;
9d001d08:	005eb823 	subu	s7,v0,s8
9d001d0c:	32f700ff 	andi	s7,s7,0xff
9d001d10:	2ee3000d 	sltiu	v1,s7,13
9d001d14:	0243b80a 	movz	s7,s2,v1
    if (idx > 12)
      idx = 12;    // dont let them specify long names
    char subdirname[13];
    strncpy(subdirname, filepath, idx);
9d001d18:	03c02821 	move	a1,s8
9d001d1c:	27a40010 	addiu	a0,sp,16
  SdFile *parent = &d1;
  SdFile *subdir = &d2;
  
  const char *origpath = filepath;

  while (strchr(filepath, '/')) {
9d001d20:	10400023 	beqz	v0,9d001db0 <_ZN7SDClass12getParentDirEPKcPi+0x158>
9d001d24:	02e03021 	move	a2,s7

    // get rid of leading /'s
    if (filepath[0] == '/') {
9d001d28:	83c30000 	lb	v1,0(s8)
9d001d2c:	2402002f 	li	v0,47
9d001d30:	5062fff2 	beql	v1,v0,9d001cfc <_ZN7SDClass12getParentDirEPKcPi+0xa4>
9d001d34:	27de0001 	addiu	s8,s8,1
    // extract just the name of the next subdirectory
    uint8_t idx = strchr(filepath, '/') - filepath;
    if (idx > 12)
      idx = 12;    // dont let them specify long names
    char subdirname[13];
    strncpy(subdirname, filepath, idx);
9d001d38:	0f401f1e 	jal	9d007c78 <strncpy>
9d001d3c:	00000000 	nop
    subdirname[idx] = 0;
9d001d40:	27a30010 	addiu	v1,sp,16
9d001d44:	00771021 	addu	v0,v1,s7

    // close the subdir (we reuse them) if open
    subdir->close();
9d001d48:	02202021 	move	a0,s1
9d001d4c:	0f400ca4 	jal	9d003290 <_ZN6SdFile5closeEv>
9d001d50:	a0400000 	sb	zero,0(v0)
    if (! subdir->open(parent, subdirname, O_READ)) {
9d001d54:	02202021 	move	a0,s1
9d001d58:	02002821 	move	a1,s0
9d001d5c:	27a60010 	addiu	a2,sp,16
9d001d60:	0f400d72 	jal	9d0035c8 <_ZN6SdFile4openEPS_PKch>
9d001d64:	24070001 	li	a3,1
9d001d68:	10400033 	beqz	v0,9d001e38 <_ZN7SDClass12getParentDirEPKcPi+0x1e0>
9d001d6c:	02002021 	move	a0,s0
    }
    // move forward to the next subdirectory
    filepath += idx;

    // we reuse the objects, close it.
    parent->close();
9d001d70:	0f400ca4 	jal	9d003290 <_ZN6SdFile5closeEv>
9d001d74:	03d7f021 	addu	s8,s8,s7
9d001d78:	02001021 	move	v0,s0
  SdFile *parent = &d1;
  SdFile *subdir = &d2;
  
  const char *origpath = filepath;

  while (strchr(filepath, '/')) {
9d001d7c:	03c02021 	move	a0,s8
9d001d80:	2405002f 	li	a1,47
    // we reuse the objects, close it.
    parent->close();

    // swap the pointers
    SdFile *t = parent;
    parent = subdir;
9d001d84:	02208021 	move	s0,s1
  SdFile *parent = &d1;
  SdFile *subdir = &d2;
  
  const char *origpath = filepath;

  while (strchr(filepath, '/')) {
9d001d88:	0f401f0c 	jal	9d007c30 <strchr>
9d001d8c:	00408821 	move	s1,v0
      // it was in the root directory, so leave now
      break;
    }

    // extract just the name of the next subdirectory
    uint8_t idx = strchr(filepath, '/') - filepath;
9d001d90:	005eb823 	subu	s7,v0,s8
9d001d94:	32f700ff 	andi	s7,s7,0xff
9d001d98:	2ee3000d 	sltiu	v1,s7,13
9d001d9c:	0243b80a 	movz	s7,s2,v1
    if (idx > 12)
      idx = 12;    // dont let them specify long names
    char subdirname[13];
    strncpy(subdirname, filepath, idx);
9d001da0:	03c02821 	move	a1,s8
9d001da4:	27a40010 	addiu	a0,sp,16
  SdFile *parent = &d1;
  SdFile *subdir = &d2;
  
  const char *origpath = filepath;

  while (strchr(filepath, '/')) {
9d001da8:	1440ffdf 	bnez	v0,9d001d28 <_ZN7SDClass12getParentDirEPKcPi+0xd0>
9d001dac:	02e03021 	move	a2,s7
    SdFile *t = parent;
    parent = subdir;
    subdir = t;
  }

  *index = (int)(filepath - origpath);
9d001db0:	03d5a823 	subu	s5,s8,s5
9d001db4:	aed50000 	sw	s5,0(s6)
//------------------------------------------------------------------------------
/**
 * \class SdFile
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
9d001db8:	920a0004 	lbu	t2,4(s0)
9d001dbc:	92090005 	lbu	t1,5(s0)
9d001dc0:	92050014 	lbu	a1,20(s0)
9d001dc4:	a26a0004 	sb	t2,4(s3)
9d001dc8:	a2690005 	sb	t1,5(s3)
9d001dcc:	a2650014 	sb	a1,20(s3)
9d001dd0:	8e020020 	lw	v0,32(s0)
9d001dd4:	8e080008 	lw	t0,8(s0)
9d001dd8:	8e07000c 	lw	a3,12(s0)
9d001ddc:	8e060010 	lw	a2,16(s0)
9d001de0:	8e040018 	lw	a0,24(s0)
9d001de4:	8e03001c 	lw	v1,28(s0)
  // parent is now the parent diretory of the file!
  return *parent;
}
9d001de8:	8fbf008c 	lw	ra,140(sp)
9d001dec:	ae740000 	sw	s4,0(s3)
9d001df0:	ae620020 	sw	v0,32(s3)
9d001df4:	ae680008 	sw	t0,8(s3)
9d001df8:	02601021 	move	v0,s3
9d001dfc:	ae67000c 	sw	a3,12(s3)
9d001e00:	ae660010 	sw	a2,16(s3)
9d001e04:	ae640018 	sw	a0,24(s3)
9d001e08:	ae63001c 	sw	v1,28(s3)
9d001e0c:	8fbe0088 	lw	s8,136(sp)
9d001e10:	8fb70084 	lw	s7,132(sp)
9d001e14:	8fb60080 	lw	s6,128(sp)
9d001e18:	8fb5007c 	lw	s5,124(sp)
9d001e1c:	8fb40078 	lw	s4,120(sp)
9d001e20:	8fb30074 	lw	s3,116(sp)
9d001e24:	8fb20070 	lw	s2,112(sp)
9d001e28:	8fb1006c 	lw	s1,108(sp)
9d001e2c:	8fb00068 	lw	s0,104(sp)
9d001e30:	03e00008 	jr	ra
9d001e34:	27bd0090 	addiu	sp,sp,144
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
9d001e38:	a2600005 	sb	zero,5(s3)
9d001e3c:	8fbf008c 	lw	ra,140(sp)
9d001e40:	ae740000 	sw	s4,0(s3)
9d001e44:	02601021 	move	v0,s3
9d001e48:	8fbe0088 	lw	s8,136(sp)
9d001e4c:	8fb70084 	lw	s7,132(sp)
9d001e50:	8fb60080 	lw	s6,128(sp)
9d001e54:	8fb5007c 	lw	s5,124(sp)
9d001e58:	8fb40078 	lw	s4,120(sp)
9d001e5c:	8fb30074 	lw	s3,116(sp)
9d001e60:	8fb20070 	lw	s2,112(sp)
9d001e64:	8fb1006c 	lw	s1,108(sp)
9d001e68:	8fb00068 	lw	s0,104(sp)
9d001e6c:	03e00008 	jr	ra
9d001e70:	27bd0090 	addiu	sp,sp,144

9d001e74 <_ZN7SDClass4openEPKch>:


File SDClass::open(const char *filepath, uint8_t mode) {
9d001e74:	27bdff38 	addiu	sp,sp,-200
9d001e78:	afb100b0 	sw	s1,176(sp)
9d001e7c:	afb000ac 	sw	s0,172(sp)
9d001e80:	30f100ff 	andi	s1,a3,0xff
9d001e84:	00808021 	move	s0,a0
   */

  int pathidx;

  // do the interative search
  SdFile parentdir = getParentDir(filepath, &pathidx);
9d001e88:	27a70010 	addiu	a3,sp,16
9d001e8c:	27a40014 	addiu	a0,sp,20
  // parent is now the parent diretory of the file!
  return *parent;
}


File SDClass::open(const char *filepath, uint8_t mode) {
9d001e90:	afb500c0 	sw	s5,192(sp)
9d001e94:	afb300b8 	sw	s3,184(sp)
9d001e98:	afb200b4 	sw	s2,180(sp)
9d001e9c:	afbf00c4 	sw	ra,196(sp)
9d001ea0:	00c09021 	move	s2,a2
9d001ea4:	afb400bc 	sw	s4,188(sp)
   */

  int pathidx;

  // do the interative search
  SdFile parentdir = getParentDir(filepath, &pathidx);
9d001ea8:	0f400716 	jal	9d001c58 <_ZN7SDClass12getParentDirEPKcPi>
9d001eac:	00a09821 	move	s3,a1
  // no more subdirs!

  filepath += pathidx;
9d001eb0:	8fb50010 	lw	s5,16(sp)
9d001eb4:	0255a821 	addu	s5,s2,s5

  if (! filepath[0]) {
9d001eb8:	82a20000 	lb	v0,0(s5)
9d001ebc:	1040004b 	beqz	v0,9d001fec <_ZN7SDClass4openEPKch+0x178>
9d001ec0:	93a20019 	lbu	v0,25(sp)
9d001ec4:	3c129d01 	lui	s2,0x9d01
9d001ec8:	26528840 	addiu	s2,s2,-30656
9d001ecc:	afb2005c 	sw	s2,92(sp)

  // Open the file itself
  SdFile file;

  // failed to open a subdir!
  if (!parentdir.isOpen()) {
9d001ed0:	1040003a 	beqz	v0,9d001fbc <_ZN7SDClass4openEPKch+0x148>
9d001ed4:	a3a00061 	sb	zero,97(sp)
  uint8_t isOpen(void) const {return type_ != FAT_FILE_TYPE_CLOSED;}
  /** \return True if this is a SdFile for a subdirectory else false. */
  uint8_t isSubDir(void) const {return type_ == FAT_FILE_TYPE_SUBDIR;}
  /** \return True if this is a SdFile for the root directory. */
  uint8_t isRoot(void) const {
    return type_ == FAT_FILE_TYPE_ROOT16 || type_ == FAT_FILE_TYPE_ROOT32;
9d001ed8:	2442fffe 	addiu	v0,v0,-2
    return File();
  }
  

  // there is a special case for the Root directory since its a static dir
  if (parentdir.isRoot()) {
9d001edc:	304200ff 	andi	v0,v0,0xff
9d001ee0:	2c420002 	sltiu	v0,v0,2
9d001ee4:	1440002e 	bnez	v0,9d001fa0 <_ZN7SDClass4openEPKch+0x12c>
9d001ee8:	27b4005c 	addiu	s4,sp,92
  /** \deprecated Use:
   * uint8_t SdFile::open(SdFile* dirFile, const char* fileName, uint8_t oflag);
   */
  uint8_t open(SdFile& dirFile, // NOLINT
    const char* fileName, uint8_t oflag) {
    return open(&dirFile, fileName, oflag);
9d001eec:	02802021 	move	a0,s4
9d001ef0:	27a50014 	addiu	a1,sp,20
9d001ef4:	02a03021 	move	a2,s5
9d001ef8:	0f400d72 	jal	9d0035c8 <_ZN6SdFile4openEPS_PKch>
9d001efc:	02203821 	move	a3,s1
      // failed to open the file :(
      return File();
    }
    // dont close the root!
  } else {
    if ( ! file.open(parentdir, filepath, mode)) {
9d001f00:	1040002e 	beqz	v0,9d001fbc <_ZN7SDClass4openEPKch+0x148>
9d001f04:	00000000 	nop
      return File();
    }
    // close the parent
    parentdir.close();
9d001f08:	0f400ca4 	jal	9d003290 <_ZN6SdFile5closeEv>
9d001f0c:	27a40014 	addiu	a0,sp,20
  }

  if (mode & (O_APPEND | O_WRITE)) 
9d001f10:	32310006 	andi	s1,s1,0x6
9d001f14:	16200059 	bnez	s1,9d00207c <_ZN7SDClass4openEPKch+0x208>
9d001f18:	8fa50074 	lw	a1,116(sp)
//------------------------------------------------------------------------------
/**
 * \class SdFile
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
9d001f1c:	93a20060 	lbu	v0,96(sp)
    file.seekSet(file.fileSize());
  return File(file, filepath);
9d001f20:	02002021 	move	a0,s0
9d001f24:	27a50080 	addiu	a1,sp,128
9d001f28:	a3a20084 	sb	v0,132(sp)
9d001f2c:	93a20061 	lbu	v0,97(sp)
9d001f30:	02a03021 	move	a2,s5
9d001f34:	afb20080 	sw	s2,128(sp)
9d001f38:	a3a20085 	sb	v0,133(sp)
9d001f3c:	8fa20064 	lw	v0,100(sp)
9d001f40:	afa20088 	sw	v0,136(sp)
9d001f44:	8fa20068 	lw	v0,104(sp)
9d001f48:	afa2008c 	sw	v0,140(sp)
9d001f4c:	8fa2006c 	lw	v0,108(sp)
9d001f50:	afa20090 	sw	v0,144(sp)
9d001f54:	93a20070 	lbu	v0,112(sp)
9d001f58:	a3a20094 	sb	v0,148(sp)
9d001f5c:	8fa20074 	lw	v0,116(sp)
9d001f60:	afa20098 	sw	v0,152(sp)
9d001f64:	8fa20078 	lw	v0,120(sp)
9d001f68:	afa2009c 	sw	v0,156(sp)
9d001f6c:	8fa2007c 	lw	v0,124(sp)
9d001f70:	0f400607 	jal	9d00181c <_ZN4FileC1E6SdFilePKc>
9d001f74:	afa200a0 	sw	v0,160(sp)
}
9d001f78:	8fbf00c4 	lw	ra,196(sp)
9d001f7c:	02001021 	move	v0,s0
9d001f80:	8fb500c0 	lw	s5,192(sp)
9d001f84:	8fb400bc 	lw	s4,188(sp)
9d001f88:	8fb300b8 	lw	s3,184(sp)
9d001f8c:	8fb200b4 	lw	s2,180(sp)
9d001f90:	8fb100b0 	lw	s1,176(sp)
9d001f94:	8fb000ac 	lw	s0,172(sp)
9d001f98:	03e00008 	jr	ra
9d001f9c:	27bd00c8 	addiu	sp,sp,200
  /** \deprecated Use:
   * uint8_t SdFile::open(SdFile* dirFile, const char* fileName, uint8_t oflag);
   */
  uint8_t open(SdFile& dirFile, // NOLINT
    const char* fileName, uint8_t oflag) {
    return open(&dirFile, fileName, oflag);
9d001fa0:	02802021 	move	a0,s4
9d001fa4:	2665002c 	addiu	a1,s3,44
9d001fa8:	02a03021 	move	a2,s5
9d001fac:	0f400d72 	jal	9d0035c8 <_ZN6SdFile4openEPS_PKch>
9d001fb0:	02203821 	move	a3,s1
  }
  

  // there is a special case for the Root directory since its a static dir
  if (parentdir.isRoot()) {
    if ( ! file.open(root, filepath, mode)) {
9d001fb4:	1440ffd7 	bnez	v0,9d001f14 <_ZN7SDClass4openEPKch+0xa0>
9d001fb8:	32310006 	andi	s1,s1,0x6
      return File();
    }
    // dont close the root!
  } else {
    if ( ! file.open(parentdir, filepath, mode)) {
      return File();
9d001fbc:	0f40062d 	jal	9d0018b4 <_ZN4FileC1Ev>
9d001fc0:	02002021 	move	a0,s0
  }

  if (mode & (O_APPEND | O_WRITE)) 
    file.seekSet(file.fileSize());
  return File(file, filepath);
}
9d001fc4:	8fbf00c4 	lw	ra,196(sp)
9d001fc8:	02001021 	move	v0,s0
9d001fcc:	8fb500c0 	lw	s5,192(sp)
9d001fd0:	8fb400bc 	lw	s4,188(sp)
9d001fd4:	8fb300b8 	lw	s3,184(sp)
9d001fd8:	8fb200b4 	lw	s2,180(sp)
9d001fdc:	8fb100b0 	lw	s1,176(sp)
9d001fe0:	8fb000ac 	lw	s0,172(sp)
9d001fe4:	03e00008 	jr	ra
9d001fe8:	27bd00c8 	addiu	sp,sp,200
//------------------------------------------------------------------------------
/**
 * \class SdFile
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
9d001fec:	3c029d01 	lui	v0,0x9d01
9d001ff0:	24428840 	addiu	v0,v0,-30656
9d001ff4:	afa20038 	sw	v0,56(sp)
9d001ff8:	93a20018 	lbu	v0,24(sp)

  filepath += pathidx;

  if (! filepath[0]) {
    // it was the directory itself!
    return File(parentdir, "/");
9d001ffc:	3c069d01 	lui	a2,0x9d01
9d002000:	02002021 	move	a0,s0
9d002004:	a3a2003c 	sb	v0,60(sp)
9d002008:	93a20019 	lbu	v0,25(sp)
9d00200c:	27a50038 	addiu	a1,sp,56
9d002010:	24c68820 	addiu	a2,a2,-30688
9d002014:	a3a2003d 	sb	v0,61(sp)
9d002018:	8fa2001c 	lw	v0,28(sp)
9d00201c:	afa20040 	sw	v0,64(sp)
9d002020:	8fa20020 	lw	v0,32(sp)
9d002024:	afa20044 	sw	v0,68(sp)
9d002028:	8fa20024 	lw	v0,36(sp)
9d00202c:	afa20048 	sw	v0,72(sp)
9d002030:	93a20028 	lbu	v0,40(sp)
9d002034:	a3a2004c 	sb	v0,76(sp)
9d002038:	8fa2002c 	lw	v0,44(sp)
9d00203c:	afa20050 	sw	v0,80(sp)
9d002040:	8fa20030 	lw	v0,48(sp)
9d002044:	afa20054 	sw	v0,84(sp)
9d002048:	8fa20034 	lw	v0,52(sp)
9d00204c:	0f400607 	jal	9d00181c <_ZN4FileC1E6SdFilePKc>
9d002050:	afa20058 	sw	v0,88(sp)
  }

  if (mode & (O_APPEND | O_WRITE)) 
    file.seekSet(file.fileSize());
  return File(file, filepath);
}
9d002054:	8fbf00c4 	lw	ra,196(sp)
9d002058:	02001021 	move	v0,s0
9d00205c:	8fb500c0 	lw	s5,192(sp)
9d002060:	8fb400bc 	lw	s4,188(sp)
9d002064:	8fb300b8 	lw	s3,184(sp)
9d002068:	8fb200b4 	lw	s2,180(sp)
9d00206c:	8fb100b0 	lw	s1,176(sp)
9d002070:	8fb000ac 	lw	s0,172(sp)
9d002074:	03e00008 	jr	ra
9d002078:	27bd00c8 	addiu	sp,sp,200
    // close the parent
    parentdir.close();
  }

  if (mode & (O_APPEND | O_WRITE)) 
    file.seekSet(file.fileSize());
9d00207c:	0f400c23 	jal	9d00308c <_ZN6SdFile7seekSetEm>
9d002080:	02802021 	move	a0,s4
9d002084:	0b4007c8 	j	9d001f20 <_ZN7SDClass4openEPKch+0xac>
9d002088:	93a20060 	lbu	v0,96(sp)

9d00208c <_ZN7SDClass6existsEPc>:
  /*

     Returns true if the supplied file path exists.

   */
  return walkPath(filepath, root, callback_pathExists);
9d00208c:	2482002c 	addiu	v0,a0,44
9d002090:	3c069d00 	lui	a2,0x9d00
9d002094:	00a02021 	move	a0,a1
9d002098:	24c61934 	addiu	a2,a2,6452
9d00209c:	00402821 	move	a1,v0
9d0020a0:	0b400690 	j	9d001a40 <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_>
9d0020a4:	00003821 	move	a3,zero

9d0020a8 <_ZN7SDClass6removeEPc>:
   */
  return walkPath(filepath, root, callback_rmdir);
}

boolean SDClass::remove(char *filepath) {
  return walkPath(filepath, root, callback_remove);
9d0020a8:	2482002c 	addiu	v0,a0,44
9d0020ac:	3c069d00 	lui	a2,0x9d00
9d0020b0:	00a02021 	move	a0,a1
9d0020b4:	24c6198c 	addiu	a2,a2,6540
9d0020b8:	00402821 	move	a1,v0
9d0020bc:	0b400690 	j	9d001a40 <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_>
9d0020c0:	00003821 	move	a3,zero

9d0020c4 <_GLOBAL__I__Z20getNextPathComponentPcPjS_>:
  if (isDirectory())
    _file->rewind();
}

Sd2Card defaultSDCard;
SDClass SD(defaultSDCard);
9d0020c4:	27bdffe0 	addiu	sp,sp,-32
9d0020c8:	afb00018 	sw	s0,24(sp)
#include <DSPI.h>
#include <WProgram.h>
class Sd2Card {
    public:
        /** Construct an instance of Sd2Card. */
        Sd2Card(void) : errorCode_(0), inBlock_(0), partialBlockRead_(0), type_(0), _cs(10), _spi(new DSPI0) {}
9d0020cc:	3c10a000 	lui	s0,0xa000
9d0020d0:	26100a38 	addiu	s0,s0,2616
9d0020d4:	2404002c 	li	a0,44
9d0020d8:	2402000a 	li	v0,10
9d0020dc:	afbf001c 	sw	ra,28(sp)
9d0020e0:	a2000005 	sb	zero,5(s0)
9d0020e4:	a2000006 	sb	zero,6(s0)
9d0020e8:	a200000a 	sb	zero,10(s0)
9d0020ec:	a200000c 	sb	zero,12(s0)
9d0020f0:	0f402014 	jal	9d008050 <_Znwm>
9d0020f4:	a2020010 	sb	v0,16(s0)
9d0020f8:	00402021 	move	a0,v0
9d0020fc:	0f401290 	jal	9d004a40 <_ZN5DSPI0C1Ev>
9d002100:	afa20010 	sw	v0,16(sp)
9d002104:	8fa20010 	lw	v0,16(sp)
  
private:
  // my quick&dirty iterator, should be replaced
  SdFile getParentDir(const char *filepath, int *indx);
public:
	SDClass(Sd2Card& c) : card(&c) {}
9d002108:	3c04a000 	lui	a0,0xa000
 * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
 */
class SdVolume {
 public:
  /** Create an instance of SdVolume */
  SdVolume(void) :allocSearchStart_(2), fatType_(0) {}
9d00210c:	24830a50 	addiu	v1,a0,2640
9d002110:	ae020014 	sw	v0,20(s0)
9d002114:	8fbf001c 	lw	ra,28(sp)
9d002118:	24020002 	li	v0,2
9d00211c:	ac620004 	sw	v0,4(v1)
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
9d002120:	3c029d01 	lui	v0,0x9d01
9d002124:	24428840 	addiu	v0,v0,-30656
9d002128:	ac900a50 	sw	s0,2640(a0)
 * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
 */
class SdVolume {
 public:
  /** Create an instance of SdVolume */
  SdVolume(void) :allocSearchStart_(2), fatType_(0) {}
9d00212c:	a0600024 	sb	zero,36(v1)
9d002130:	8fb00018 	lw	s0,24(sp)
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
9d002134:	ac62002c 	sw	v0,44(v1)
9d002138:	a0600031 	sb	zero,49(v1)
9d00213c:	03e00008 	jr	ra
9d002140:	27bd0020 	addiu	sp,sp,32

9d002144 <_ZN7Sd2Card6spiRecEv>:
    extern void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, byte data);
}


/** Soft SPI receive */
uint8_t Sd2Card::spiRec(void) {
9d002144:	27bdffe8 	addiu	sp,sp,-24
9d002148:	afb00010 	sw	s0,16(sp)
9d00214c:	00808021 	move	s0,a0
    uint8_t data = 0;
    if (_spi) {
9d002150:	8c840014 	lw	a0,20(a0)
9d002154:	10800008 	beqz	a0,9d002178 <_ZN7Sd2Card6spiRecEv+0x34>
9d002158:	afbf0014 	sw	ra,20(sp)
        data = _spi->transfer(0xFF);
9d00215c:	0f4011ad 	jal	9d0046b4 <_ZN4DSPI8transferEm>
9d002160:	240500ff 	li	a1,255
        digitalWrite(_mosi, HIGH);
        digitalWrite(_miso, HIGH);
        data = shiftIn(_miso, _clk, MSBFIRST);
    }
    return data;
}
9d002164:	8fbf0014 	lw	ra,20(sp)
9d002168:	304200ff 	andi	v0,v0,0xff
9d00216c:	8fb00010 	lw	s0,16(sp)
9d002170:	03e00008 	jr	ra
9d002174:	27bd0018 	addiu	sp,sp,24
    uint8_t data = 0;
    if (_spi) {
        data = _spi->transfer(0xFF);
    } else {
        // output pin high - like sending 0XFF
        digitalWrite(_mosi, HIGH);
9d002178:	9204000d 	lbu	a0,13(s0)
9d00217c:	0f4013cf 	jal	9d004f3c <digitalWrite>
9d002180:	24050001 	li	a1,1
        digitalWrite(_miso, HIGH);
9d002184:	9204000e 	lbu	a0,14(s0)
9d002188:	0f4013cf 	jal	9d004f3c <digitalWrite>
9d00218c:	24050001 	li	a1,1
        data = shiftIn(_miso, _clk, MSBFIRST);
9d002190:	9204000e 	lbu	a0,14(s0)
9d002194:	9205000f 	lbu	a1,15(s0)
    }
    return data;
}
9d002198:	8fbf0014 	lw	ra,20(sp)
9d00219c:	8fb00010 	lw	s0,16(sp)
        data = _spi->transfer(0xFF);
    } else {
        // output pin high - like sending 0XFF
        digitalWrite(_mosi, HIGH);
        digitalWrite(_miso, HIGH);
        data = shiftIn(_miso, _clk, MSBFIRST);
9d0021a0:	24060001 	li	a2,1
9d0021a4:	0b401323 	j	9d004c8c <shiftIn>
9d0021a8:	27bd0018 	addiu	sp,sp,24

9d0021ac <_ZN7Sd2Card7spiSendEh>:
    }
    return data;
}
//------------------------------------------------------------------------------
/** Soft SPI send */
void Sd2Card::spiSend(uint8_t data) {
9d0021ac:	27bdffe0 	addiu	sp,sp,-32
9d0021b0:	afb00018 	sw	s0,24(sp)
9d0021b4:	00808021 	move	s0,a0
    if (_spi) {
9d0021b8:	8c840014 	lw	a0,20(a0)
    }
    return data;
}
//------------------------------------------------------------------------------
/** Soft SPI send */
void Sd2Card::spiSend(uint8_t data) {
9d0021bc:	afbf001c 	sw	ra,28(sp)
    if (_spi) {
9d0021c0:	10800006 	beqz	a0,9d0021dc <_ZN7Sd2Card7spiSendEh+0x30>
9d0021c4:	30a700ff 	andi	a3,a1,0xff
        _spi->transfer(data);
    } else {
        digitalWrite(_miso, HIGH);
        shiftOut(_mosi, _clk, MSBFIRST, data);
    }
}
9d0021c8:	8fbf001c 	lw	ra,28(sp)
9d0021cc:	8fb00018 	lw	s0,24(sp)
}
//------------------------------------------------------------------------------
/** Soft SPI send */
void Sd2Card::spiSend(uint8_t data) {
    if (_spi) {
        _spi->transfer(data);
9d0021d0:	00e02821 	move	a1,a3
9d0021d4:	0b4011ad 	j	9d0046b4 <_ZN4DSPI8transferEm>
9d0021d8:	27bd0020 	addiu	sp,sp,32
    } else {
        digitalWrite(_miso, HIGH);
9d0021dc:	9204000e 	lbu	a0,14(s0)
9d0021e0:	24050001 	li	a1,1
9d0021e4:	0f4013cf 	jal	9d004f3c <digitalWrite>
9d0021e8:	afa70010 	sw	a3,16(sp)
        shiftOut(_mosi, _clk, MSBFIRST, data);
9d0021ec:	9204000d 	lbu	a0,13(s0)
9d0021f0:	9205000f 	lbu	a1,15(s0)
9d0021f4:	8fa70010 	lw	a3,16(sp)
    }
}
9d0021f8:	8fbf001c 	lw	ra,28(sp)
9d0021fc:	8fb00018 	lw	s0,24(sp)
void Sd2Card::spiSend(uint8_t data) {
    if (_spi) {
        _spi->transfer(data);
    } else {
        digitalWrite(_miso, HIGH);
        shiftOut(_mosi, _clk, MSBFIRST, data);
9d002200:	24060001 	li	a2,1
9d002204:	0b40135b 	j	9d004d6c <shiftOut>
9d002208:	27bd0020 	addiu	sp,sp,32

9d00220c <_ZN7Sd2Card14chipSelectHighEv>:
  }
}

//------------------------------------------------------------------------------
void Sd2Card::chipSelectHigh(void) {
  digitalWrite(_cs, HIGH);
9d00220c:	90840010 	lbu	a0,16(a0)
9d002210:	0b4013cf 	j	9d004f3c <digitalWrite>
9d002214:	24050001 	li	a1,1

9d002218 <_ZN7Sd2Card13chipSelectLowEv>:
}
//------------------------------------------------------------------------------
void Sd2Card::chipSelectLow(void) {
9d002218:	27bdffe8 	addiu	sp,sp,-24
9d00221c:	afbf0014 	sw	ra,20(sp)
9d002220:	afb00010 	sw	s0,16(sp)
9d002224:	00808021 	move	s0,a0
    digitalWrite(_cs, LOW);
9d002228:	90840010 	lbu	a0,16(a0)
9d00222c:	0f4013cf 	jal	9d004f3c <digitalWrite>
9d002230:	00002821 	move	a1,zero
  digitalWrite(chipSelectPin_, LOW);
9d002234:	92040004 	lbu	a0,4(s0)
}
9d002238:	8fbf0014 	lw	ra,20(sp)
9d00223c:	8fb00010 	lw	s0,16(sp)
  digitalWrite(_cs, HIGH);
}
//------------------------------------------------------------------------------
void Sd2Card::chipSelectLow(void) {
    digitalWrite(_cs, LOW);
  digitalWrite(chipSelectPin_, LOW);
9d002240:	00002821 	move	a1,zero
9d002244:	0b4013cf 	j	9d004f3c <digitalWrite>
9d002248:	27bd0018 	addiu	sp,sp,24

9d00224c <_ZN7Sd2Card7readEndEv>:
  chipSelectHigh();
  return false;
}
//------------------------------------------------------------------------------
/** Skip remaining data in a block when in partial block read mode. */
void Sd2Card::readEnd(void) {
9d00224c:	27bdffe8 	addiu	sp,sp,-24
9d002250:	afb00010 	sw	s0,16(sp)
9d002254:	afbf0014 	sw	ra,20(sp)
  if (inBlock_) {
9d002258:	90820006 	lbu	v0,6(a0)
9d00225c:	14400005 	bnez	v0,9d002274 <_ZN7Sd2Card7readEndEv+0x28>
9d002260:	00808021 	move	s0,a0
        spiRec();
    }
    chipSelectHigh();
    inBlock_ = 0;
  }
}
9d002264:	0b4008a6 	j	9d002298 <_ZN7Sd2Card7readEndEv+0x4c>
9d002268:	8fbf0014 	lw	ra,20(sp)
/** Skip remaining data in a block when in partial block read mode. */
void Sd2Card::readEnd(void) {
  if (inBlock_) {
      // skip data and crc
    while (offset_++ < 514) {
        spiRec();
9d00226c:	0f400851 	jal	9d002144 <_ZN7Sd2Card6spiRecEv>
9d002270:	02002021 	move	a0,s0
//------------------------------------------------------------------------------
/** Skip remaining data in a block when in partial block read mode. */
void Sd2Card::readEnd(void) {
  if (inBlock_) {
      // skip data and crc
    while (offset_++ < 514) {
9d002274:	96020008 	lhu	v0,8(s0)
9d002278:	24430001 	addiu	v1,v0,1
9d00227c:	2c420202 	sltiu	v0,v0,514
9d002280:	1440fffa 	bnez	v0,9d00226c <_ZN7Sd2Card7readEndEv+0x20>
9d002284:	a6030008 	sh	v1,8(s0)
        spiRec();
    }
    chipSelectHigh();
9d002288:	0f400883 	jal	9d00220c <_ZN7Sd2Card14chipSelectHighEv>
9d00228c:	02002021 	move	a0,s0
    inBlock_ = 0;
9d002290:	a2000006 	sb	zero,6(s0)
  }
}
9d002294:	8fbf0014 	lw	ra,20(sp)
9d002298:	8fb00010 	lw	s0,16(sp)
9d00229c:	03e00008 	jr	ra
9d0022a0:	27bd0018 	addiu	sp,sp,24

9d0022a4 <_ZN7Sd2Card11waitNotBusyEt>:
  //  | (sckRateID & 2 ? (1 << SPR0) : 0);
  return true;
}
//------------------------------------------------------------------------------
// wait for card to go not busy
uint8_t Sd2Card::waitNotBusy(uint16_t timeoutMillis) {
9d0022a4:	27bdffd8 	addiu	sp,sp,-40
9d0022a8:	afb30020 	sw	s3,32(sp)
9d0022ac:	afb2001c 	sw	s2,28(sp)
9d0022b0:	afb10018 	sw	s1,24(sp)
9d0022b4:	afb00014 	sw	s0,20(sp)
9d0022b8:	afbf0024 	sw	ra,36(sp)
9d0022bc:	00808821 	move	s1,a0
  uint16_t t0 = millis();
9d0022c0:	0f4014d8 	jal	9d005360 <millis>
9d0022c4:	30b3ffff 	andi	s3,a1,0xffff
9d0022c8:	3052ffff 	andi	s2,v0,0xffff
  do {
    if (spiRec() == 0XFF) return true;
9d0022cc:	0b4008bc 	j	9d0022f0 <_ZN7Sd2Card11waitNotBusyEt+0x4c>
9d0022d0:	241000ff 	li	s0,255
  }
  while (((uint16_t)millis() - t0) < timeoutMillis);
9d0022d4:	0f4014d8 	jal	9d005360 <millis>
9d0022d8:	00000000 	nop
}
//------------------------------------------------------------------------------
// wait for card to go not busy
uint8_t Sd2Card::waitNotBusy(uint16_t timeoutMillis) {
  uint16_t t0 = millis();
  do {
9d0022dc:	3042ffff 	andi	v0,v0,0xffff
9d0022e0:	00521023 	subu	v0,v0,s2
9d0022e4:	0053102a 	slt	v0,v0,s3
9d0022e8:	10400006 	beqz	v0,9d002304 <_ZN7Sd2Card11waitNotBusyEt+0x60>
9d0022ec:	8fbf0024 	lw	ra,36(sp)
    if (spiRec() == 0XFF) return true;
9d0022f0:	0f400851 	jal	9d002144 <_ZN7Sd2Card6spiRecEv>
9d0022f4:	02202021 	move	a0,s1
9d0022f8:	1450fff6 	bne	v0,s0,9d0022d4 <_ZN7Sd2Card11waitNotBusyEt+0x30>
9d0022fc:	24020001 	li	v0,1
  }
  while (((uint16_t)millis() - t0) < timeoutMillis);
  return false;
}
9d002300:	8fbf0024 	lw	ra,36(sp)
9d002304:	8fb30020 	lw	s3,32(sp)
9d002308:	8fb2001c 	lw	s2,28(sp)
9d00230c:	8fb10018 	lw	s1,24(sp)
9d002310:	8fb00014 	lw	s0,20(sp)
9d002314:	03e00008 	jr	ra
9d002318:	27bd0028 	addiu	sp,sp,40

9d00231c <_ZN7Sd2Card11cardCommandEhm>:
        shiftOut(_mosi, _clk, MSBFIRST, data);
    }
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg) {
9d00231c:	27bdffd8 	addiu	sp,sp,-40
9d002320:	afb00010 	sw	s0,16(sp)
9d002324:	00808021 	move	s0,a0
9d002328:	afbf0024 	sw	ra,36(sp)
9d00232c:	afb40020 	sw	s4,32(sp)
9d002330:	afb3001c 	sw	s3,28(sp)
9d002334:	afb20018 	sw	s2,24(sp)
9d002338:	afb10014 	sw	s1,20(sp)
9d00233c:	30b200ff 	andi	s2,a1,0xff
  // end read if in partialBlockRead mode
  readEnd();
9d002340:	0f400893 	jal	9d00224c <_ZN7Sd2Card7readEndEv>
9d002344:	00c08821 	move	s1,a2

  // select card
  chipSelectLow();
9d002348:	0f400886 	jal	9d002218 <_ZN7Sd2Card13chipSelectLowEv>
9d00234c:	02002021 	move	a0,s0

  // wait up to 300 ms if busy
  waitNotBusy(300);
9d002350:	02002021 	move	a0,s0
9d002354:	0f4008a9 	jal	9d0022a4 <_ZN7Sd2Card11waitNotBusyEt>
9d002358:	2405012c 	li	a1,300

  // send command
  spiSend(cmd | 0x40);
9d00235c:	02002021 	move	a0,s0
9d002360:	0f40086b 	jal	9d0021ac <_ZN7Sd2Card7spiSendEh>
9d002364:	36450040 	ori	a1,s2,0x40
9d002368:	24140018 	li	s4,24

  // send argument
  for (int8_t s = 24; s >= 0; s -= 8) spiSend(arg >> s);
9d00236c:	2413fff8 	li	s3,-8
9d002370:	02912806 	srlv	a1,s1,s4
9d002374:	02002021 	move	a0,s0
9d002378:	2694fff8 	addiu	s4,s4,-8
9d00237c:	0f40086b 	jal	9d0021ac <_ZN7Sd2Card7spiSendEh>
9d002380:	30a500ff 	andi	a1,a1,0xff
9d002384:	1693fffb 	bne	s4,s3,9d002374 <_ZN7Sd2Card11cardCommandEhm+0x58>
9d002388:	02912806 	srlv	a1,s1,s4

  // send CRC
  uint8_t crc = 0XFF;
  if (cmd == CMD0) crc = 0X95;  // correct crc for CMD0 with arg 0
9d00238c:	12400005 	beqz	s2,9d0023a4 <_ZN7Sd2Card11cardCommandEhm+0x88>
9d002390:	24050095 	li	a1,149
  if (cmd == CMD8) crc = 0X87;  // correct crc for CMD8 with arg 0X1AA
9d002394:	240500ff 	li	a1,255
9d002398:	3a520008 	xori	s2,s2,0x8
9d00239c:	24020087 	li	v0,135
9d0023a0:	0052280a 	movz	a1,v0,s2
  spiSend(crc);
9d0023a4:	0f40086b 	jal	9d0021ac <_ZN7Sd2Card7spiSendEh>
9d0023a8:	02002021 	move	a0,s0

  // wait for response
  for (uint8_t i = 0; ((status_ = spiRec()) & 0X80) && i != 0XFF; i++);
9d0023ac:	00008821 	move	s1,zero
9d0023b0:	0f400851 	jal	9d002144 <_ZN7Sd2Card6spiRecEv>
9d0023b4:	02002021 	move	a0,s0
9d0023b8:	7c021c20 	seb	v1,v0
9d0023bc:	04600009 	bltz	v1,9d0023e4 <_ZN7Sd2Card11cardCommandEhm+0xc8>
9d0023c0:	a202000b 	sb	v0,11(s0)
  return status_;
}
9d0023c4:	8fbf0024 	lw	ra,36(sp)
9d0023c8:	8fb40020 	lw	s4,32(sp)
9d0023cc:	8fb3001c 	lw	s3,28(sp)
9d0023d0:	8fb20018 	lw	s2,24(sp)
9d0023d4:	8fb10014 	lw	s1,20(sp)
9d0023d8:	8fb00010 	lw	s0,16(sp)
9d0023dc:	03e00008 	jr	ra
9d0023e0:	27bd0028 	addiu	sp,sp,40
  if (cmd == CMD0) crc = 0X95;  // correct crc for CMD0 with arg 0
  if (cmd == CMD8) crc = 0X87;  // correct crc for CMD8 with arg 0X1AA
  spiSend(crc);

  // wait for response
  for (uint8_t i = 0; ((status_ = spiRec()) & 0X80) && i != 0XFF; i++);
9d0023e4:	2631ffff 	addiu	s1,s1,-1
9d0023e8:	323100ff 	andi	s1,s1,0xff
9d0023ec:	1620fff0 	bnez	s1,9d0023b0 <_ZN7Sd2Card11cardCommandEhm+0x94>
9d0023f0:	8fbf0024 	lw	ra,36(sp)
  return status_;
}
9d0023f4:	8fb40020 	lw	s4,32(sp)
9d0023f8:	8fb3001c 	lw	s3,28(sp)
9d0023fc:	8fb20018 	lw	s2,24(sp)
9d002400:	8fb10014 	lw	s1,20(sp)
9d002404:	8fb00010 	lw	s0,16(sp)
9d002408:	03e00008 	jr	ra
9d00240c:	27bd0028 	addiu	sp,sp,40

9d002410 <_ZN7Sd2Card4initEhh>:
 *
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.  The reason for failure
 * can be determined by calling errorCode() and errorData().
 */
uint8_t Sd2Card::init(uint8_t sckRateID, uint8_t chipSelectPin) {
9d002410:	27bdffd0 	addiu	sp,sp,-48
9d002414:	afb00018 	sw	s0,24(sp)
9d002418:	00808021 	move	s0,a0
    _cs = chipSelectPin;

    if (_spi) {
9d00241c:	8c840014 	lw	a0,20(a0)
 *
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.  The reason for failure
 * can be determined by calling errorCode() and errorData().
 */
uint8_t Sd2Card::init(uint8_t sckRateID, uint8_t chipSelectPin) {
9d002420:	afbf002c 	sw	ra,44(sp)
9d002424:	afb40028 	sw	s4,40(sp)
9d002428:	afb30024 	sw	s3,36(sp)
9d00242c:	afb20020 	sw	s2,32(sp)
9d002430:	afb1001c 	sw	s1,28(sp)
    _cs = chipSelectPin;

    if (_spi) {
9d002434:	10800064 	beqz	a0,9d0025c8 <_ZN7Sd2Card4initEhh+0x1b8>
9d002438:	a2060010 	sb	a2,16(s0)
        _spi->begin();
9d00243c:	0f4011ab 	jal	9d0046ac <_ZN4DSPI5beginEv>
9d002440:	00000000 	nop
	_spi->setSpeed(125000UL);
9d002444:	8e040014 	lw	a0,20(s0)
9d002448:	3c050001 	lui	a1,0x1
9d00244c:	0f40114c 	jal	9d004530 <_ZN4DSPI8setSpeedEm>
9d002450:	34a5e848 	ori	a1,a1,0xe848
        pinMode(_mosi, OUTPUT);
        pinMode(_miso, INPUT);
        pinMode(_clk, OUTPUT);
    }
    
    pinMode(_cs, OUTPUT);
9d002454:	92040010 	lbu	a0,16(s0)
9d002458:	24050001 	li	a1,1
9d00245c:	0f401387 	jal	9d004e1c <pinMode>
9d002460:	00009821 	move	s3,zero
    digitalWrite(_cs, HIGH);
9d002464:	92040010 	lbu	a0,16(s0)
9d002468:	24050001 	li	a1,1
9d00246c:	0f4013cf 	jal	9d004f3c <digitalWrite>
9d002470:	2412000a 	li	s2,10

    errorCode_ = inBlock_ = partialBlockRead_ = type_ = 0;
9d002474:	a200000c 	sb	zero,12(s0)
9d002478:	a200000a 	sb	zero,10(s0)
9d00247c:	a2000006 	sb	zero,6(s0)

    // 16-bit init start time allows over a minute
    uint16_t t0 = (uint16_t)millis();
9d002480:	0f4014d8 	jal	9d005360 <millis>
9d002484:	a2000005 	sb	zero,5(s0)
    uint32_t arg;

    chipSelectHigh();
9d002488:	02002021 	move	a0,s0
9d00248c:	0f400883 	jal	9d00220c <_ZN7Sd2Card14chipSelectHighEv>
9d002490:	3051ffff 	andi	s1,v0,0xffff

    // must supply min of 74 clock cycles with CS high.
    for (uint8_t i = 0; i < 10; i++) spiSend(0XFF);
9d002494:	26730001 	addiu	s3,s3,1
9d002498:	02002021 	move	a0,s0
9d00249c:	240500ff 	li	a1,255
9d0024a0:	0f40086b 	jal	9d0021ac <_ZN7Sd2Card7spiSendEh>
9d0024a4:	327300ff 	andi	s3,s3,0xff
9d0024a8:	5672fffb 	bnel	s3,s2,9d002498 <_ZN7Sd2Card4initEhh+0x88>
9d0024ac:	26730001 	addiu	s3,s3,1

    chipSelectLow();
9d0024b0:	0f400886 	jal	9d002218 <_ZN7Sd2Card13chipSelectLowEv>
9d0024b4:	02002021 	move	a0,s0

    // command to go idle in SPI mode
    while ((status_ = cardCommand(CMD0, 0)) != R1_IDLE_STATE) {
9d0024b8:	24120001 	li	s2,1
9d0024bc:	02002021 	move	a0,s0
9d0024c0:	00002821 	move	a1,zero
9d0024c4:	0f4008c7 	jal	9d00231c <_ZN7Sd2Card11cardCommandEhm>
9d0024c8:	00003021 	move	a2,zero
9d0024cc:	10520015 	beq	v0,s2,9d002524 <_ZN7Sd2Card4initEhh+0x114>
9d0024d0:	a202000b 	sb	v0,11(s0)
        if (((uint16_t)millis() - t0) > SD_INIT_TIMEOUT) {
9d0024d4:	0f4014d8 	jal	9d005360 <millis>
9d0024d8:	00000000 	nop
9d0024dc:	3042ffff 	andi	v0,v0,0xffff
9d0024e0:	00511023 	subu	v0,v0,s1
9d0024e4:	284207d1 	slti	v0,v0,2001
9d0024e8:	1440fff5 	bnez	v0,9d0024c0 <_ZN7Sd2Card4initEhh+0xb0>
9d0024ec:	02002021 	move	a0,s0
        uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
            cardCommand(CMD55, 0);
            return cardCommand(cmd, arg);
        }
        uint8_t cardCommand(uint8_t cmd, uint32_t arg);
        void error(uint8_t code) {errorCode_ = code;}
9d0024f0:	24020001 	li	v0,1
9d0024f4:	a2020005 	sb	v0,5(s0)
   	 setSckRate(sckRateID);
    }
    return true;

fail:
    chipSelectHigh();
9d0024f8:	0f400883 	jal	9d00220c <_ZN7Sd2Card14chipSelectHighEv>
9d0024fc:	02002021 	move	a0,s0
    return false;
9d002500:	00001021 	move	v0,zero
}
9d002504:	8fbf002c 	lw	ra,44(sp)
9d002508:	8fb40028 	lw	s4,40(sp)
9d00250c:	8fb30024 	lw	s3,36(sp)
9d002510:	8fb20020 	lw	s2,32(sp)
9d002514:	8fb1001c 	lw	s1,28(sp)
9d002518:	8fb00018 	lw	s0,24(sp)
9d00251c:	03e00008 	jr	ra
9d002520:	27bd0030 	addiu	sp,sp,48
            error(SD_CARD_ERROR_CMD0);
            goto fail;
        }
    }
    // check SD version
    if ((cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
9d002524:	02002021 	move	a0,s0
9d002528:	24050008 	li	a1,8
9d00252c:	0f4008c7 	jal	9d00231c <_ZN7Sd2Card11cardCommandEhm>
9d002530:	240601aa 	li	a2,426
9d002534:	30420004 	andi	v0,v0,0x4
9d002538:	0000a021 	move	s4,zero
9d00253c:	10400017 	beqz	v0,9d00259c <_ZN7Sd2Card4initEhh+0x18c>
9d002540:	24130004 	li	s3,4
        uint8_t readRegister(uint8_t cmd, void* buf);
        uint8_t sendWriteCommand(uint32_t blockNumber, uint32_t eraseCount);
        void chipSelectHigh(void);
        void chipSelectLow(void);
        void type(uint8_t value) {type_ = value;}
9d002544:	a212000c 	sb	s2,12(s0)
            goto fail;
        }
        type(SD_CARD_TYPE_SD2);
    }
    // initialize card and send host supports SDHC if SD2
    arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
9d002548:	00009021 	move	s2,zero
        uint8_t _cs;
        DSPI *_spi;

        // private functions
        uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
            cardCommand(CMD55, 0);
9d00254c:	24050037 	li	a1,55
9d002550:	00003021 	move	a2,zero
9d002554:	0f4008c7 	jal	9d00231c <_ZN7Sd2Card11cardCommandEhm>
9d002558:	02002021 	move	a0,s0
            return cardCommand(cmd, arg);
9d00255c:	02002021 	move	a0,s0
9d002560:	24050029 	li	a1,41
9d002564:	0f4008c7 	jal	9d00231c <_ZN7Sd2Card11cardCommandEhm>
9d002568:	02403021 	move	a2,s2

    while ((status_ = cardAcmd(ACMD41, arg)) != R1_READY_STATE) {
9d00256c:	10400021 	beqz	v0,9d0025f4 <_ZN7Sd2Card4initEhh+0x1e4>
9d002570:	a202000b 	sb	v0,11(s0)
        // check for timeout
        if (((uint16_t)millis() - t0) > SD_INIT_TIMEOUT) {
9d002574:	0f4014d8 	jal	9d005360 <millis>
9d002578:	00000000 	nop
9d00257c:	3042ffff 	andi	v0,v0,0xffff
9d002580:	00511023 	subu	v0,v0,s1
9d002584:	284207d1 	slti	v0,v0,2001
9d002588:	1440fff1 	bnez	v0,9d002550 <_ZN7Sd2Card4initEhh+0x140>
9d00258c:	24050037 	li	a1,55
        }
        uint8_t cardCommand(uint8_t cmd, uint32_t arg);
        void error(uint8_t code) {errorCode_ = code;}
9d002590:	24020008 	li	v0,8
            error(SD_CARD_ERROR_ACMD41);
            goto fail;
9d002594:	0b40093e 	j	9d0024f8 <_ZN7Sd2Card4initEhh+0xe8>
9d002598:	a2020005 	sb	v0,5(s0)
    // check SD version
    if ((cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
        type(SD_CARD_TYPE_SD1);
    } else {
        // only need last byte of r7 response
        for (uint8_t i = 0; i < 4; i++) status_ = spiRec();
9d00259c:	02002021 	move	a0,s0
9d0025a0:	0f400851 	jal	9d002144 <_ZN7Sd2Card6spiRecEv>
9d0025a4:	26940001 	addiu	s4,s4,1
9d0025a8:	329400ff 	andi	s4,s4,0xff
9d0025ac:	1693fffb 	bne	s4,s3,9d00259c <_ZN7Sd2Card4initEhh+0x18c>
9d0025b0:	a202000b 	sb	v0,11(s0)
        if (status_ != 0XAA) {
9d0025b4:	240300aa 	li	v1,170
9d0025b8:	1043001d 	beq	v0,v1,9d002630 <_ZN7Sd2Card4initEhh+0x220>
9d0025bc:	24020002 	li	v0,2
            error(SD_CARD_ERROR_CMD8);
            goto fail;
9d0025c0:	0b40093e 	j	9d0024f8 <_ZN7Sd2Card4initEhh+0xe8>
9d0025c4:	a2020005 	sb	v0,5(s0)

    if (_spi) {
        _spi->begin();
	_spi->setSpeed(125000UL);
    } else {
        pinMode(_mosi, OUTPUT);
9d0025c8:	9204000d 	lbu	a0,13(s0)
9d0025cc:	0f401387 	jal	9d004e1c <pinMode>
9d0025d0:	24050001 	li	a1,1
        pinMode(_miso, INPUT);
9d0025d4:	9204000e 	lbu	a0,14(s0)
9d0025d8:	0f401387 	jal	9d004e1c <pinMode>
9d0025dc:	00002821 	move	a1,zero
        pinMode(_clk, OUTPUT);
9d0025e0:	9204000f 	lbu	a0,15(s0)
9d0025e4:	0f401387 	jal	9d004e1c <pinMode>
9d0025e8:	24050001 	li	a1,1
    }
    
    pinMode(_cs, OUTPUT);
9d0025ec:	0b400916 	j	9d002458 <_ZN7Sd2Card4initEhh+0x48>
9d0025f0:	92040010 	lbu	a0,16(s0)
            error(SD_CARD_ERROR_ACMD41);
            goto fail;
        }
    }
    // if SD2 read OCR register to check for SDHC card
    if (type() == SD_CARD_TYPE_SD2) {
9d0025f4:	9203000c 	lbu	v1,12(s0)
9d0025f8:	24020002 	li	v0,2
9d0025fc:	1062000f 	beq	v1,v0,9d00263c <_ZN7Sd2Card4initEhh+0x22c>
9d002600:	02002021 	move	a0,s0
        }
        if ((spiRec() & 0XC0) == 0XC0) type(SD_CARD_TYPE_SDHC);
        // discard rest of ocr - contains allowed voltage range
        for (uint8_t i = 0; i < 3; i++) spiRec();
    }
    chipSelectHigh();
9d002604:	0f400883 	jal	9d00220c <_ZN7Sd2Card14chipSelectHighEv>
9d002608:	02002021 	move	a0,s0

    if (_spi) {
9d00260c:	8e040014 	lw	a0,20(s0)
9d002610:	1080ffbc 	beqz	a0,9d002504 <_ZN7Sd2Card4initEhh+0xf4>
9d002614:	24020001 	li	v0,1
	_spi->setSpeed(10000000UL);
9d002618:	3c050098 	lui	a1,0x98
9d00261c:	34a59680 	ori	a1,a1,0x9680
9d002620:	0f40114c 	jal	9d004530 <_ZN4DSPI8setSpeedEm>
9d002624:	afa20010 	sw	v0,16(sp)
9d002628:	0b400941 	j	9d002504 <_ZN7Sd2Card4initEhh+0xf4>
9d00262c:	8fa20010 	lw	v0,16(sp)
        uint8_t readRegister(uint8_t cmd, void* buf);
        uint8_t sendWriteCommand(uint32_t blockNumber, uint32_t eraseCount);
        void chipSelectHigh(void);
        void chipSelectLow(void);
        void type(uint8_t value) {type_ = value;}
9d002630:	a202000c 	sb	v0,12(s0)
            goto fail;
        }
        type(SD_CARD_TYPE_SD2);
    }
    // initialize card and send host supports SDHC if SD2
    arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
9d002634:	0b400953 	j	9d00254c <_ZN7Sd2Card4initEhh+0x13c>
9d002638:	3c124000 	lui	s2,0x4000
            goto fail;
        }
    }
    // if SD2 read OCR register to check for SDHC card
    if (type() == SD_CARD_TYPE_SD2) {
        if (cardCommand(CMD58, 0)) {
9d00263c:	2405003a 	li	a1,58
9d002640:	0f4008c7 	jal	9d00231c <_ZN7Sd2Card11cardCommandEhm>
9d002644:	00003021 	move	a2,zero
9d002648:	10400003 	beqz	v0,9d002658 <_ZN7Sd2Card4initEhh+0x248>
9d00264c:	24020006 	li	v0,6
            error(SD_CARD_ERROR_CMD58);
            goto fail;
9d002650:	0b40093e 	j	9d0024f8 <_ZN7Sd2Card4initEhh+0xe8>
9d002654:	a2020005 	sb	v0,5(s0)
        }
        if ((spiRec() & 0XC0) == 0XC0) type(SD_CARD_TYPE_SDHC);
9d002658:	0f400851 	jal	9d002144 <_ZN7Sd2Card6spiRecEv>
9d00265c:	02002021 	move	a0,s0
9d002660:	304200c0 	andi	v0,v0,0xc0
9d002664:	240300c0 	li	v1,192
9d002668:	14430003 	bne	v0,v1,9d002678 <_ZN7Sd2Card4initEhh+0x268>
9d00266c:	00000000 	nop
9d002670:	24020003 	li	v0,3
9d002674:	a202000c 	sb	v0,12(s0)
        // discard rest of ocr - contains allowed voltage range
        for (uint8_t i = 0; i < 3; i++) spiRec();
9d002678:	0f400851 	jal	9d002144 <_ZN7Sd2Card6spiRecEv>
9d00267c:	02002021 	move	a0,s0
9d002680:	0f400851 	jal	9d002144 <_ZN7Sd2Card6spiRecEv>
9d002684:	02002021 	move	a0,s0
9d002688:	0f400851 	jal	9d002144 <_ZN7Sd2Card6spiRecEv>
9d00268c:	02002021 	move	a0,s0
9d002690:	0b400981 	j	9d002604 <_ZN7Sd2Card4initEhh+0x1f4>
9d002694:	00000000 	nop

9d002698 <_ZN7Sd2Card14waitStartBlockEv>:
  while (((uint16_t)millis() - t0) < timeoutMillis);
  return false;
}
//------------------------------------------------------------------------------
/** Wait for start block token */
uint8_t Sd2Card::waitStartBlock(void) {
9d002698:	27bdffe0 	addiu	sp,sp,-32
9d00269c:	afb20018 	sw	s2,24(sp)
9d0026a0:	afb10014 	sw	s1,20(sp)
9d0026a4:	afb00010 	sw	s0,16(sp)
9d0026a8:	afbf001c 	sw	ra,28(sp)
  uint16_t t0 = millis();
9d0026ac:	0f4014d8 	jal	9d005360 <millis>
9d0026b0:	00808021 	move	s0,a0
9d0026b4:	3052ffff 	andi	s2,v0,0xffff
  while ((status_ = spiRec()) == 0XFF) {
9d0026b8:	0b4009b7 	j	9d0026dc <_ZN7Sd2Card14waitStartBlockEv+0x44>
9d0026bc:	241100ff 	li	s1,255
    if (((uint16_t)millis() - t0) > SD_READ_TIMEOUT) {
9d0026c0:	0f4014d8 	jal	9d005360 <millis>
9d0026c4:	00000000 	nop
9d0026c8:	3042ffff 	andi	v0,v0,0xffff
9d0026cc:	00521023 	subu	v0,v0,s2
9d0026d0:	2842012d 	slti	v0,v0,301
9d0026d4:	10400014 	beqz	v0,9d002728 <_ZN7Sd2Card14waitStartBlockEv+0x90>
9d0026d8:	2402000f 	li	v0,15
}
//------------------------------------------------------------------------------
/** Wait for start block token */
uint8_t Sd2Card::waitStartBlock(void) {
  uint16_t t0 = millis();
  while ((status_ = spiRec()) == 0XFF) {
9d0026dc:	0f400851 	jal	9d002144 <_ZN7Sd2Card6spiRecEv>
9d0026e0:	02002021 	move	a0,s0
9d0026e4:	1051fff6 	beq	v0,s1,9d0026c0 <_ZN7Sd2Card14waitStartBlockEv+0x28>
9d0026e8:	a202000b 	sb	v0,11(s0)
    if (((uint16_t)millis() - t0) > SD_READ_TIMEOUT) {
      error(SD_CARD_ERROR_READ_TIMEOUT);
      goto fail;
    }
  }
  if (status_ != DATA_START_BLOCK) {
9d0026ec:	240400fe 	li	a0,254
9d0026f0:	10440006 	beq	v0,a0,9d00270c <_ZN7Sd2Card14waitStartBlockEv+0x74>
9d0026f4:	24030001 	li	v1,1
        uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
            cardCommand(CMD55, 0);
            return cardCommand(cmd, arg);
        }
        uint8_t cardCommand(uint8_t cmd, uint32_t arg);
        void error(uint8_t code) {errorCode_ = code;}
9d0026f8:	2402000d 	li	v0,13
9d0026fc:	a2020005 	sb	v0,5(s0)
    goto fail;
  }
  return true;

 fail:
  chipSelectHigh();
9d002700:	0f400883 	jal	9d00220c <_ZN7Sd2Card14chipSelectHighEv>
9d002704:	02002021 	move	a0,s0
  return false;
9d002708:	00001821 	move	v1,zero
}
9d00270c:	8fbf001c 	lw	ra,28(sp)
9d002710:	00601021 	move	v0,v1
9d002714:	8fb20018 	lw	s2,24(sp)
9d002718:	8fb10014 	lw	s1,20(sp)
9d00271c:	8fb00010 	lw	s0,16(sp)
9d002720:	03e00008 	jr	ra
9d002724:	27bd0020 	addiu	sp,sp,32
uint8_t Sd2Card::waitStartBlock(void) {
  uint16_t t0 = millis();
  while ((status_ = spiRec()) == 0XFF) {
    if (((uint16_t)millis() - t0) > SD_READ_TIMEOUT) {
      error(SD_CARD_ERROR_READ_TIMEOUT);
      goto fail;
9d002728:	0b4009c0 	j	9d002700 <_ZN7Sd2Card14waitStartBlockEv+0x68>
9d00272c:	a2020005 	sb	v0,5(s0)

9d002730 <_ZN7Sd2Card8readDataEmttPh>:
 * \param[in] count Number of bytes to read
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::readData(uint32_t block,
        uint16_t offset, uint16_t count, uint8_t* dst) {
9d002730:	27bdffd8 	addiu	sp,sp,-40
9d002734:	afb00014 	sw	s0,20(sp)
9d002738:	30f0ffff 	andi	s0,a3,0xffff
9d00273c:	afb30020 	sw	s3,32(sp)
9d002740:	afb2001c 	sw	s2,28(sp)
9d002744:	afb10018 	sw	s1,24(sp)
9d002748:	afbf0024 	sw	ra,36(sp)
9d00274c:	00809821 	move	s3,a0
9d002750:	00a01821 	move	v1,a1
9d002754:	8fb20038 	lw	s2,56(sp)
9d002758:	30d1ffff 	andi	s1,a2,0xffff
  if (count == 0) return true;
9d00275c:	1200001a 	beqz	s0,9d0027c8 <_ZN7Sd2Card8readDataEmttPh+0x98>
9d002760:	24020001 	li	v0,1
  if ((count + offset) > 512) {
9d002764:	02111021 	addu	v0,s0,s1
9d002768:	28420201 	slti	v0,v0,513
9d00276c:	10400013 	beqz	v0,9d0027bc <_ZN7Sd2Card8readDataEmttPh+0x8c>
9d002770:	00000000 	nop
    goto fail;
  }
  if (!inBlock_ || block != block_ || offset < offset_) {
9d002774:	90820006 	lbu	v0,6(a0)
9d002778:	50400005 	beqzl	v0,9d002790 <_ZN7Sd2Card8readDataEmttPh+0x60>
9d00277c:	9266000c 	lbu	a2,12(s3)
9d002780:	8c820000 	lw	v0,0(a0)
9d002784:	50450017 	beql	v0,a1,9d0027e4 <_ZN7Sd2Card8readDataEmttPh+0xb4>
9d002788:	94820008 	lhu	v0,8(a0)
    block_ = block;
    // use address if not SDHC card
    if (type()!= SD_CARD_TYPE_SDHC) block <<= 9;
9d00278c:	9266000c 	lbu	a2,12(s3)
9d002790:	00031240 	sll	v0,v1,0x9
  if (count == 0) return true;
  if ((count + offset) > 512) {
    goto fail;
  }
  if (!inBlock_ || block != block_ || offset < offset_) {
    block_ = block;
9d002794:	ae630000 	sw	v1,0(s3)
    // use address if not SDHC card
    if (type()!= SD_CARD_TYPE_SDHC) block <<= 9;
9d002798:	38c60003 	xori	a2,a2,0x3
    if (cardCommand(CMD17, block)) {
9d00279c:	0046180b 	movn	v1,v0,a2
9d0027a0:	02602021 	move	a0,s3
9d0027a4:	24050011 	li	a1,17
9d0027a8:	0f4008c7 	jal	9d00231c <_ZN7Sd2Card11cardCommandEhm>
9d0027ac:	00603021 	move	a2,v1
9d0027b0:	1040002d 	beqz	v0,9d002868 <_ZN7Sd2Card8readDataEmttPh+0x138>
9d0027b4:	24020003 	li	v0,3
9d0027b8:	a2620005 	sb	v0,5(s3)
  }

  return true;

 fail:
  chipSelectHigh();
9d0027bc:	0f400883 	jal	9d00220c <_ZN7Sd2Card14chipSelectHighEv>
9d0027c0:	02602021 	move	a0,s3
  return false;
9d0027c4:	00001021 	move	v0,zero
}
9d0027c8:	8fbf0024 	lw	ra,36(sp)
9d0027cc:	8fb30020 	lw	s3,32(sp)
9d0027d0:	8fb2001c 	lw	s2,28(sp)
9d0027d4:	8fb10018 	lw	s1,24(sp)
9d0027d8:	8fb00014 	lw	s0,20(sp)
9d0027dc:	03e00008 	jr	ra
9d0027e0:	27bd0028 	addiu	sp,sp,40
        uint16_t offset, uint16_t count, uint8_t* dst) {
  if (count == 0) return true;
  if ((count + offset) > 512) {
    goto fail;
  }
  if (!inBlock_ || block != block_ || offset < offset_) {
9d0027e4:	0222202b 	sltu	a0,s1,v0
9d0027e8:	5480ffe9 	bnezl	a0,9d002790 <_ZN7Sd2Card8readDataEmttPh+0x60>
9d0027ec:	9266000c 	lbu	a2,12(s3)
  }



  // skip data before offset
  for (;offset_ < offset; offset_++) {
9d0027f0:	0051102b 	sltu	v0,v0,s1
9d0027f4:	5040000a 	beqzl	v0,9d002820 <_ZN7Sd2Card8readDataEmttPh+0xf0>
9d0027f8:	8e640014 	lw	a0,20(s3)
    spiRec();
9d0027fc:	0f400851 	jal	9d002144 <_ZN7Sd2Card6spiRecEv>
9d002800:	02602021 	move	a0,s3
  }



  // skip data before offset
  for (;offset_ < offset; offset_++) {
9d002804:	96620008 	lhu	v0,8(s3)
9d002808:	24420001 	addiu	v0,v0,1
9d00280c:	3042ffff 	andi	v0,v0,0xffff
9d002810:	0051182b 	sltu	v1,v0,s1
9d002814:	1460fff9 	bnez	v1,9d0027fc <_ZN7Sd2Card8readDataEmttPh+0xcc>
9d002818:	a6620008 	sh	v0,8(s3)
    spiRec();
  }
  // transfer data
  if (_spi != NULL) {
9d00281c:	8e640014 	lw	a0,20(s3)
9d002820:	10800019 	beqz	a0,9d002888 <_ZN7Sd2Card8readDataEmttPh+0x158>
9d002824:	02002821 	move	a1,s0
    _spi->transfer(count, 0xFF, dst);
9d002828:	240600ff 	li	a2,255
9d00282c:	0f4011e4 	jal	9d004790 <_ZN4DSPI8transferEthPh>
9d002830:	02403821 	move	a3,s2
      for (uint16_t i = 0; i < count; i++) {
        dst[i] = spiRec();
      }
  }

  offset_ += count;
9d002834:	96630008 	lhu	v1,8(s3)
  if (!partialBlockRead_ || offset_ >= 512) {
9d002838:	9262000a 	lbu	v0,10(s3)
      for (uint16_t i = 0; i < count; i++) {
        dst[i] = spiRec();
      }
  }

  offset_ += count;
9d00283c:	02038021 	addu	s0,s0,v1
9d002840:	3210ffff 	andi	s0,s0,0xffff
  if (!partialBlockRead_ || offset_ >= 512) {
9d002844:	10400004 	beqz	v0,9d002858 <_ZN7Sd2Card8readDataEmttPh+0x128>
9d002848:	a6700008 	sh	s0,8(s3)
9d00284c:	2e100200 	sltiu	s0,s0,512
9d002850:	1600ffdd 	bnez	s0,9d0027c8 <_ZN7Sd2Card8readDataEmttPh+0x98>
9d002854:	24020001 	li	v0,1
    // read rest of data, checksum and set chip select high
    readEnd();
9d002858:	0f400893 	jal	9d00224c <_ZN7Sd2Card7readEndEv>
9d00285c:	02602021 	move	a0,s3
  }

  return true;
9d002860:	0b4009f2 	j	9d0027c8 <_ZN7Sd2Card8readDataEmttPh+0x98>
9d002864:	24020001 	li	v0,1
    if (type()!= SD_CARD_TYPE_SDHC) block <<= 9;
    if (cardCommand(CMD17, block)) {
      error(SD_CARD_ERROR_CMD17);
      goto fail;
    }
    if (!waitStartBlock()) {
9d002868:	0f4009a6 	jal	9d002698 <_ZN7Sd2Card14waitStartBlockEv>
9d00286c:	02602021 	move	a0,s3
9d002870:	1040ffd2 	beqz	v0,9d0027bc <_ZN7Sd2Card8readDataEmttPh+0x8c>
9d002874:	24020001 	li	v0,1
      goto fail;
    }
    offset_ = 0;
    inBlock_ = 1;
9d002878:	a2620006 	sb	v0,6(s3)
      goto fail;
    }
    if (!waitStartBlock()) {
      goto fail;
    }
    offset_ = 0;
9d00287c:	a6600008 	sh	zero,8(s3)
    inBlock_ = 1;
9d002880:	0b4009fc 	j	9d0027f0 <_ZN7Sd2Card8readDataEmttPh+0xc0>
9d002884:	00001021 	move	v0,zero
  // skip data before offset
  for (;offset_ < offset; offset_++) {
    spiRec();
  }
  // transfer data
  if (_spi != NULL) {
9d002888:	00008821 	move	s1,zero
    _spi->transfer(count, 0xFF, dst);
  } else {
      for (uint16_t i = 0; i < count; i++) {
9d00288c:	26310001 	addiu	s1,s1,1
        dst[i] = spiRec();
9d002890:	02602021 	move	a0,s3
9d002894:	0f400851 	jal	9d002144 <_ZN7Sd2Card6spiRecEv>
9d002898:	3231ffff 	andi	s1,s1,0xffff
  }
  // transfer data
  if (_spi != NULL) {
    _spi->transfer(count, 0xFF, dst);
  } else {
      for (uint16_t i = 0; i < count; i++) {
9d00289c:	0230182b 	sltu	v1,s1,s0
        dst[i] = spiRec();
9d0028a0:	a2420000 	sb	v0,0(s2)
  }
  // transfer data
  if (_spi != NULL) {
    _spi->transfer(count, 0xFF, dst);
  } else {
      for (uint16_t i = 0; i < count; i++) {
9d0028a4:	1460fff9 	bnez	v1,9d00288c <_ZN7Sd2Card8readDataEmttPh+0x15c>
9d0028a8:	26520001 	addiu	s2,s2,1
        dst[i] = spiRec();
      }
  }

  offset_ += count;
9d0028ac:	0b400a0e 	j	9d002838 <_ZN7Sd2Card8readDataEmttPh+0x108>
9d0028b0:	96630008 	lhu	v1,8(s3)

9d0028b4 <_ZN7Sd2Card9readBlockEmPh>:
 * \param[out] dst Pointer to the location that will receive the data.

 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::readBlock(uint32_t block, uint8_t* dst) {
9d0028b4:	27bdffe0 	addiu	sp,sp,-32
  return readData(block, 0, 512, dst);
9d0028b8:	afa60010 	sw	a2,16(sp)
9d0028bc:	24070200 	li	a3,512
 * \param[out] dst Pointer to the location that will receive the data.

 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::readBlock(uint32_t block, uint8_t* dst) {
9d0028c0:	afbf001c 	sw	ra,28(sp)
  return readData(block, 0, 512, dst);
9d0028c4:	0f4009cc 	jal	9d002730 <_ZN7Sd2Card8readDataEmttPh>
9d0028c8:	00003021 	move	a2,zero
}
9d0028cc:	8fbf001c 	lw	ra,28(sp)
9d0028d0:	03e00008 	jr	ra
9d0028d4:	27bd0020 	addiu	sp,sp,32

9d0028d8 <_ZN7Sd2Card9writeDataEhPKh>:
  }
  return writeData(WRITE_MULTIPLE_TOKEN, src);
}
//------------------------------------------------------------------------------
// send one block of data for write block or write multiple blocks
uint8_t Sd2Card::writeData(uint8_t token, const uint8_t* src) {
9d0028d8:	27bdffd8 	addiu	sp,sp,-40
9d0028dc:	afb00018 	sw	s0,24(sp)

    spiSend(token);
9d0028e0:	30a500ff 	andi	a1,a1,0xff
  }
  return writeData(WRITE_MULTIPLE_TOKEN, src);
}
//------------------------------------------------------------------------------
// send one block of data for write block or write multiple blocks
uint8_t Sd2Card::writeData(uint8_t token, const uint8_t* src) {
9d0028e4:	00808021 	move	s0,a0

    spiSend(token);
9d0028e8:	afa60010 	sw	a2,16(sp)
  }
  return writeData(WRITE_MULTIPLE_TOKEN, src);
}
//------------------------------------------------------------------------------
// send one block of data for write block or write multiple blocks
uint8_t Sd2Card::writeData(uint8_t token, const uint8_t* src) {
9d0028ec:	afbf0024 	sw	ra,36(sp)
9d0028f0:	afb20020 	sw	s2,32(sp)

    spiSend(token);
9d0028f4:	0f40086b 	jal	9d0021ac <_ZN7Sd2Card7spiSendEh>
9d0028f8:	afb1001c 	sw	s1,28(sp)
    if (_spi != NULL) {
9d0028fc:	8e040014 	lw	a0,20(s0)
9d002900:	1080001b 	beqz	a0,9d002970 <_ZN7Sd2Card9writeDataEhPKh+0x98>
9d002904:	8fa60010 	lw	a2,16(sp)
        _spi->transfer(512, (uint8_t *)src);
9d002908:	0f4011ba 	jal	9d0046e8 <_ZN4DSPI8transferEtPh>
9d00290c:	24050200 	li	a1,512
        for (uint16_t i = 0; i < 512; i++) {
            spiSend(src[i]);
        }
    }

    spiSend(0xff);  // dummy crc
9d002910:	240500ff 	li	a1,255
9d002914:	0f40086b 	jal	9d0021ac <_ZN7Sd2Card7spiSendEh>
9d002918:	02002021 	move	a0,s0
    spiSend(0xff);  // dummy crc
9d00291c:	02002021 	move	a0,s0
9d002920:	0f40086b 	jal	9d0021ac <_ZN7Sd2Card7spiSendEh>
9d002924:	240500ff 	li	a1,255

    status_ = spiRec();
9d002928:	0f400851 	jal	9d002144 <_ZN7Sd2Card6spiRecEv>
9d00292c:	02002021 	move	a0,s0
    if ((status_ & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
9d002930:	3044001f 	andi	a0,v0,0x1f
9d002934:	24030005 	li	v1,5
    }

    spiSend(0xff);  // dummy crc
    spiSend(0xff);  // dummy crc

    status_ = spiRec();
9d002938:	a202000b 	sb	v0,11(s0)
    if ((status_ & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
9d00293c:	10830006 	beq	a0,v1,9d002958 <_ZN7Sd2Card9writeDataEhPKh+0x80>
9d002940:	24020001 	li	v0,1
9d002944:	24020011 	li	v0,17
9d002948:	a2020005 	sb	v0,5(s0)
        error(SD_CARD_ERROR_WRITE);
        chipSelectHigh();
9d00294c:	0f400883 	jal	9d00220c <_ZN7Sd2Card14chipSelectHighEv>
9d002950:	02002021 	move	a0,s0
        return false;
9d002954:	00001021 	move	v0,zero
    }
    return true;
}
9d002958:	8fbf0024 	lw	ra,36(sp)
9d00295c:	8fb20020 	lw	s2,32(sp)
9d002960:	8fb1001c 	lw	s1,28(sp)
9d002964:	8fb00018 	lw	s0,24(sp)
9d002968:	03e00008 	jr	ra
9d00296c:	27bd0028 	addiu	sp,sp,40
// send one block of data for write block or write multiple blocks
uint8_t Sd2Card::writeData(uint8_t token, const uint8_t* src) {

    spiSend(token);
    if (_spi != NULL) {
        _spi->transfer(512, (uint8_t *)src);
9d002970:	00c09021 	move	s2,a2
  }
  return writeData(WRITE_MULTIPLE_TOKEN, src);
}
//------------------------------------------------------------------------------
// send one block of data for write block or write multiple blocks
uint8_t Sd2Card::writeData(uint8_t token, const uint8_t* src) {
9d002974:	24d10200 	addiu	s1,a2,512
    spiSend(token);
    if (_spi != NULL) {
        _spi->transfer(512, (uint8_t *)src);
    } else {
        for (uint16_t i = 0; i < 512; i++) {
            spiSend(src[i]);
9d002978:	92450000 	lbu	a1,0(s2)
9d00297c:	02002021 	move	a0,s0
9d002980:	0f40086b 	jal	9d0021ac <_ZN7Sd2Card7spiSendEh>
9d002984:	26520001 	addiu	s2,s2,1

    spiSend(token);
    if (_spi != NULL) {
        _spi->transfer(512, (uint8_t *)src);
    } else {
        for (uint16_t i = 0; i < 512; i++) {
9d002988:	5651fffc 	bnel	s2,s1,9d00297c <_ZN7Sd2Card9writeDataEhPKh+0xa4>
9d00298c:	92450000 	lbu	a1,0(s2)
            spiSend(src[i]);
        }
    }

    spiSend(0xff);  // dummy crc
9d002990:	0b400a45 	j	9d002914 <_ZN7Sd2Card9writeDataEhPKh+0x3c>
9d002994:	240500ff 	li	a1,255

9d002998 <_ZN7Sd2Card10writeBlockEmPKh>:
 * \param[in] blockNumber Logical block to be written.
 * \param[in] src Pointer to the location of the data to be written.
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t* src) {
9d002998:	27bdffe0 	addiu	sp,sp,-32
9d00299c:	afb10018 	sw	s1,24(sp)
9d0029a0:	afb00014 	sw	s0,20(sp)
9d0029a4:	afbf001c 	sw	ra,28(sp)
9d0029a8:	00a01021 	move	v0,a1
9d0029ac:	00808021 	move	s0,a0
#if SD_PROTECT_BLOCK_ZERO
  // don't allow write to first block
  if (blockNumber == 0) {
9d0029b0:	14a0000b 	bnez	a1,9d0029e0 <_ZN7Sd2Card10writeBlockEmPKh+0x48>
9d0029b4:	00c08821 	move	s1,a2
9d0029b8:	24020012 	li	v0,18
9d0029bc:	a0820005 	sb	v0,5(a0)
  }
  chipSelectHigh();
  return true;

 fail:
  chipSelectHigh();
9d0029c0:	0f400883 	jal	9d00220c <_ZN7Sd2Card14chipSelectHighEv>
9d0029c4:	02002021 	move	a0,s0
  return false;
9d0029c8:	00001021 	move	v0,zero
}
9d0029cc:	8fbf001c 	lw	ra,28(sp)
9d0029d0:	8fb10018 	lw	s1,24(sp)
9d0029d4:	8fb00014 	lw	s0,20(sp)
9d0029d8:	03e00008 	jr	ra
9d0029dc:	27bd0020 	addiu	sp,sp,32
    error(SD_CARD_ERROR_WRITE_BLOCK_ZERO);
    goto fail;
  }
#endif  // SD_PROTECT_BLOCK_ZERO
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
9d0029e0:	9086000c 	lbu	a2,12(a0)
9d0029e4:	00051a40 	sll	v1,a1,0x9
  if (cardCommand(CMD24, blockNumber)) {
9d0029e8:	24050018 	li	a1,24
    error(SD_CARD_ERROR_WRITE_BLOCK_ZERO);
    goto fail;
  }
#endif  // SD_PROTECT_BLOCK_ZERO
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
9d0029ec:	38c60003 	xori	a2,a2,0x3
  if (cardCommand(CMD24, blockNumber)) {
9d0029f0:	0066100b 	movn	v0,v1,a2
9d0029f4:	0f4008c7 	jal	9d00231c <_ZN7Sd2Card11cardCommandEhm>
9d0029f8:	00403021 	move	a2,v0
9d0029fc:	10400003 	beqz	v0,9d002a0c <_ZN7Sd2Card10writeBlockEmPKh+0x74>
9d002a00:	24020004 	li	v0,4
    error(SD_CARD_ERROR_CMD24);
    goto fail;
9d002a04:	0b400a70 	j	9d0029c0 <_ZN7Sd2Card10writeBlockEmPKh+0x28>
9d002a08:	a2020005 	sb	v0,5(s0)
  }
  if (!writeData(DATA_START_BLOCK, src)) goto fail;
9d002a0c:	02002021 	move	a0,s0
9d002a10:	240500fe 	li	a1,254
9d002a14:	0f400a36 	jal	9d0028d8 <_ZN7Sd2Card9writeDataEhPKh>
9d002a18:	02203021 	move	a2,s1
9d002a1c:	1040ffe8 	beqz	v0,9d0029c0 <_ZN7Sd2Card10writeBlockEmPKh+0x28>
9d002a20:	02002021 	move	a0,s0

  // wait for flash programming to complete
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
9d002a24:	0f4008a9 	jal	9d0022a4 <_ZN7Sd2Card11waitNotBusyEt>
9d002a28:	24050258 	li	a1,600
9d002a2c:	14400003 	bnez	v0,9d002a3c <_ZN7Sd2Card10writeBlockEmPKh+0xa4>
9d002a30:	24020015 	li	v0,21
    error(SD_CARD_ERROR_WRITE_TIMEOUT);
    goto fail;
9d002a34:	0b400a70 	j	9d0029c0 <_ZN7Sd2Card10writeBlockEmPKh+0x28>
9d002a38:	a2020005 	sb	v0,5(s0)
  }

  // response is r2 so get and check two bytes for nonzero
  if (cardCommand(CMD13, 0) || spiRec()) {
9d002a3c:	02002021 	move	a0,s0
9d002a40:	2405000d 	li	a1,13
9d002a44:	0f4008c7 	jal	9d00231c <_ZN7Sd2Card11cardCommandEhm>
9d002a48:	00003021 	move	a2,zero
9d002a4c:	10400003 	beqz	v0,9d002a5c <_ZN7Sd2Card10writeBlockEmPKh+0xc4>
9d002a50:	24020014 	li	v0,20
    error(SD_CARD_ERROR_WRITE_PROGRAMMING);
    goto fail;
9d002a54:	0b400a70 	j	9d0029c0 <_ZN7Sd2Card10writeBlockEmPKh+0x28>
9d002a58:	a2020005 	sb	v0,5(s0)
    error(SD_CARD_ERROR_WRITE_TIMEOUT);
    goto fail;
  }

  // response is r2 so get and check two bytes for nonzero
  if (cardCommand(CMD13, 0) || spiRec()) {
9d002a5c:	0f400851 	jal	9d002144 <_ZN7Sd2Card6spiRecEv>
9d002a60:	02002021 	move	a0,s0
9d002a64:	5440fffb 	bnezl	v0,9d002a54 <_ZN7Sd2Card10writeBlockEmPKh+0xbc>
9d002a68:	24020014 	li	v0,20
    error(SD_CARD_ERROR_WRITE_PROGRAMMING);
    goto fail;
  }
  chipSelectHigh();
9d002a6c:	0f400883 	jal	9d00220c <_ZN7Sd2Card14chipSelectHighEv>
9d002a70:	02002021 	move	a0,s0
  return true;
9d002a74:	0b400a73 	j	9d0029cc <_ZN7Sd2Card10writeBlockEmPKh+0x34>
9d002a78:	24020001 	li	v0,1

9d002a7c <_ZN6SdFile10addClusterEv>:
// suppress cpplint warnings with NOLINT comment
void (*SdFile::oldDateTime_)(uint16_t& date, uint16_t& time) = NULL;  // NOLINT
#endif  // ALLOW_DEPRECATED_FUNCTIONS
//------------------------------------------------------------------------------
// add a cluster to a file
uint8_t SdFile::addCluster() {
9d002a7c:	27bdffe8 	addiu	sp,sp,-24
9d002a80:	afb00010 	sw	s0,16(sp)
9d002a84:	00808021 	move	s0,a0
  if (!vol_->allocContiguous(1, &curCluster_)) return false;
9d002a88:	8c840020 	lw	a0,32(a0)
9d002a8c:	24050001 	li	a1,1
// suppress cpplint warnings with NOLINT comment
void (*SdFile::oldDateTime_)(uint16_t& date, uint16_t& time) = NULL;  // NOLINT
#endif  // ALLOW_DEPRECATED_FUNCTIONS
//------------------------------------------------------------------------------
// add a cluster to a file
uint8_t SdFile::addCluster() {
9d002a90:	afbf0014 	sw	ra,20(sp)
  if (!vol_->allocContiguous(1, &curCluster_)) return false;
9d002a94:	0f401031 	jal	9d0040c4 <_ZN8SdVolume15allocContiguousEmPm>
9d002a98:	26060008 	addiu	a2,s0,8
9d002a9c:	1040000a 	beqz	v0,9d002ac8 <_ZN6SdFile10addClusterEv+0x4c>
9d002aa0:	00001821 	move	v1,zero

  // if first cluster of file link to directory entry
  if (firstCluster_ == 0) {
9d002aa4:	8e02001c 	lw	v0,28(s0)
9d002aa8:	14400007 	bnez	v0,9d002ac8 <_ZN6SdFile10addClusterEv+0x4c>
9d002aac:	24030001 	li	v1,1
    firstCluster_ = curCluster_;
    flags_ |= F_FILE_DIR_DIRTY;
9d002ab0:	92050004 	lbu	a1,4(s0)
uint8_t SdFile::addCluster() {
  if (!vol_->allocContiguous(1, &curCluster_)) return false;

  // if first cluster of file link to directory entry
  if (firstCluster_ == 0) {
    firstCluster_ = curCluster_;
9d002ab4:	8e040008 	lw	a0,8(s0)
    flags_ |= F_FILE_DIR_DIRTY;
9d002ab8:	2402ff80 	li	v0,-128
9d002abc:	00a21025 	or	v0,a1,v0
uint8_t SdFile::addCluster() {
  if (!vol_->allocContiguous(1, &curCluster_)) return false;

  // if first cluster of file link to directory entry
  if (firstCluster_ == 0) {
    firstCluster_ = curCluster_;
9d002ac0:	ae04001c 	sw	a0,28(s0)
    flags_ |= F_FILE_DIR_DIRTY;
9d002ac4:	a2020004 	sb	v0,4(s0)
  }
  return true;
}
9d002ac8:	8fbf0014 	lw	ra,20(sp)
9d002acc:	00601021 	move	v0,v1
9d002ad0:	8fb00010 	lw	s0,16(sp)
9d002ad4:	03e00008 	jr	ra
9d002ad8:	27bd0018 	addiu	sp,sp,24

9d002adc <_ZN6SdFile13addDirClusterEv>:
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// return with first block of cluster in the cache
uint8_t SdFile::addDirCluster(void) {
9d002adc:	27bdffe0 	addiu	sp,sp,-32
9d002ae0:	afb10014 	sw	s1,20(sp)
9d002ae4:	afbf001c 	sw	ra,28(sp)
9d002ae8:	afb20018 	sw	s2,24(sp)
9d002aec:	afb00010 	sw	s0,16(sp)
  if (!addCluster()) return false;
9d002af0:	0f400a9f 	jal	9d002a7c <_ZN6SdFile10addClusterEv>
9d002af4:	00808821 	move	s1,a0
9d002af8:	10400014 	beqz	v0,9d002b4c <_ZN6SdFile13addDirClusterEv+0x70>
9d002afc:	00001821 	move	v1,zero

  // zero data in cluster insure first cluster is in cache
  uint32_t block = vol_->clusterStartBlock(curCluster_);
9d002b00:	8e220020 	lw	v0,32(s1)
9d002b04:	8e300008 	lw	s0,8(s1)
  for (uint8_t i = vol_->blocksPerCluster_; i != 0; i--) {
9d002b08:	90520004 	lbu	s2,4(v0)
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(char* str) {
  write_P(str);
  println();
}
9d002b0c:	8c430014 	lw	v1,20(v0)
uint8_t SdFile::addDirCluster(void) {
  if (!addCluster()) return false;

  // zero data in cluster insure first cluster is in cache
  uint32_t block = vol_->clusterStartBlock(curCluster_);
  for (uint8_t i = vol_->blocksPerCluster_; i != 0; i--) {
9d002b10:	12400016 	beqz	s2,9d002b6c <_ZN6SdFile13addDirClusterEv+0x90>
9d002b14:	90420010 	lbu	v0,16(v0)
  //----------------------------------------------------------------------------
  uint8_t allocContiguous(uint32_t count, uint32_t* curCluster);
  uint8_t blockOfCluster(uint32_t position) const {
          return (position >> 9) & (blocksPerCluster_ - 1);}
  uint32_t clusterStartBlock(uint32_t cluster) const {
           return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);}
9d002b18:	2610fffe 	addiu	s0,s0,-2
9d002b1c:	2463ffff 	addiu	v1,v1,-1
9d002b20:	00501004 	sllv	v0,s0,v0
9d002b24:	0b400acd 	j	9d002b34 <_ZN6SdFile13addDirClusterEv+0x58>
9d002b28:	00628021 	addu	s0,v1,v0
9d002b2c:	5240000e 	beqzl	s2,9d002b68 <_ZN6SdFile13addDirClusterEv+0x8c>
9d002b30:	8e220020 	lw	v0,32(s1)
    if (!SdVolume::cacheZeroBlock(block + i - 1)) return false;
9d002b34:	0f400f71 	jal	9d003dc4 <_ZN8SdVolume14cacheZeroBlockEm>
9d002b38:	02502021 	addu	a0,s2,s0
uint8_t SdFile::addDirCluster(void) {
  if (!addCluster()) return false;

  // zero data in cluster insure first cluster is in cache
  uint32_t block = vol_->clusterStartBlock(curCluster_);
  for (uint8_t i = vol_->blocksPerCluster_; i != 0; i--) {
9d002b3c:	2652ffff 	addiu	s2,s2,-1
    if (!SdVolume::cacheZeroBlock(block + i - 1)) return false;
9d002b40:	1440fffa 	bnez	v0,9d002b2c <_ZN6SdFile13addDirClusterEv+0x50>
9d002b44:	325200ff 	andi	s2,s2,0xff
9d002b48:	00001821 	move	v1,zero
  }
  // Increase directory file size by cluster size
  fileSize_ += 512UL << vol_->clusterSizeShift_;
  return true;
}
9d002b4c:	8fbf001c 	lw	ra,28(sp)
9d002b50:	00601021 	move	v0,v1
9d002b54:	8fb20018 	lw	s2,24(sp)
9d002b58:	8fb10014 	lw	s1,20(sp)
9d002b5c:	8fb00010 	lw	s0,16(sp)
9d002b60:	03e00008 	jr	ra
9d002b64:	27bd0020 	addiu	sp,sp,32
uint8_t SdFile::addDirCluster(void) {
  if (!addCluster()) return false;

  // zero data in cluster insure first cluster is in cache
  uint32_t block = vol_->clusterStartBlock(curCluster_);
  for (uint8_t i = vol_->blocksPerCluster_; i != 0; i--) {
9d002b68:	90420010 	lbu	v0,16(v0)
    if (!SdVolume::cacheZeroBlock(block + i - 1)) return false;
  }
  // Increase directory file size by cluster size
  fileSize_ += 512UL << vol_->clusterSizeShift_;
9d002b6c:	8e230018 	lw	v1,24(s1)
9d002b70:	24040200 	li	a0,512
  return true;
}
9d002b74:	8fbf001c 	lw	ra,28(sp)
  uint32_t block = vol_->clusterStartBlock(curCluster_);
  for (uint8_t i = vol_->blocksPerCluster_; i != 0; i--) {
    if (!SdVolume::cacheZeroBlock(block + i - 1)) return false;
  }
  // Increase directory file size by cluster size
  fileSize_ += 512UL << vol_->clusterSizeShift_;
9d002b78:	00441004 	sllv	v0,a0,v0
9d002b7c:	00621021 	addu	v0,v1,v0
  return true;
9d002b80:	24030001 	li	v1,1
  uint32_t block = vol_->clusterStartBlock(curCluster_);
  for (uint8_t i = vol_->blocksPerCluster_; i != 0; i--) {
    if (!SdVolume::cacheZeroBlock(block + i - 1)) return false;
  }
  // Increase directory file size by cluster size
  fileSize_ += 512UL << vol_->clusterSizeShift_;
9d002b84:	ae220018 	sw	v0,24(s1)
  return true;
}
9d002b88:	8fb20018 	lw	s2,24(sp)
9d002b8c:	00601021 	move	v0,v1
9d002b90:	8fb10014 	lw	s1,20(sp)
9d002b94:	8fb00010 	lw	s0,16(sp)
9d002b98:	03e00008 	jr	ra
9d002b9c:	27bd0020 	addiu	sp,sp,32

9d002ba0 <_ZN6SdFile13cacheDirEntryEh>:
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
dir_t* SdFile::cacheDirEntry(uint8_t action) {
9d002ba0:	27bdffe8 	addiu	sp,sp,-24
9d002ba4:	afb00010 	sw	s0,16(sp)
9d002ba8:	00808021 	move	s0,a0
  if (!SdVolume::cacheRawBlock(dirBlock_, action)) return NULL;
9d002bac:	8c840010 	lw	a0,16(a0)
  return true;
}
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
dir_t* SdFile::cacheDirEntry(uint8_t action) {
9d002bb0:	afbf0014 	sw	ra,20(sp)
  if (!SdVolume::cacheRawBlock(dirBlock_, action)) return NULL;
9d002bb4:	0f400f4b 	jal	9d003d2c <_ZN8SdVolume13cacheRawBlockEmh>
9d002bb8:	30a500ff 	andi	a1,a1,0xff
9d002bbc:	10400006 	beqz	v0,9d002bd8 <_ZN6SdFile13cacheDirEntryEh+0x38>
9d002bc0:	00001821 	move	v1,zero
  return SdVolume::cacheBuffer_.dir + dirIndex_;
9d002bc4:	92020014 	lbu	v0,20(s0)
9d002bc8:	3c03a000 	lui	v1,0xa000
9d002bcc:	24630aa4 	addiu	v1,v1,2724
9d002bd0:	00021140 	sll	v0,v0,0x5
9d002bd4:	00621821 	addu	v1,v1,v0
}
9d002bd8:	8fbf0014 	lw	ra,20(sp)
9d002bdc:	00601021 	move	v0,v1
9d002be0:	8fb00010 	lw	s0,16(sp)
9d002be4:	03e00008 	jr	ra
9d002be8:	27bd0018 	addiu	sp,sp,24

9d002bec <_ZN6SdFile10make83NameEPKcPh>:
      // illegal FAT characters
      char* p = (char *)"|<>^+=?/[];,*\"\\";
      uint8_t b;
      while ((b = pgm_read_byte(p++))) if (b == c) return false;
      // check size and only allow ASCII printable characters
      if (i > n || c < 0X21 || c > 0X7E)return false;
9d002bec:	00a01021 	move	v0,a1
    }
  }
}
//------------------------------------------------------------------------------
// format directory name field from a 8.3 name string
uint8_t SdFile::make83Name(const char* str, uint8_t* name) {
9d002bf0:	24a6000b 	addiu	a2,a1,11
  uint8_t c;
  uint8_t n = 7;  // max index for part before dot
  uint8_t i = 0;
  // blank fill name and extension
  while (i < 11) name[i++] = ' ';
9d002bf4:	24030020 	li	v1,32
9d002bf8:	a0430000 	sb	v1,0(v0)
9d002bfc:	24420001 	addiu	v0,v0,1
9d002c00:	5446fffe 	bnel	v0,a2,9d002bfc <_ZN6SdFile10make83NameEPKcPh+0x10>
9d002c04:	a0430000 	sb	v1,0(v0)
9d002c08:	00004821 	move	t1,zero
9d002c0c:	240a0007 	li	t2,7
  i = 0;
  while ((c = *str++) != '\0') {
    if (c == '.') {
9d002c10:	2408002e 	li	t0,46
9d002c14:	3c079d01 	lui	a3,0x9d01
      if (n == 10) return false;  // only one dot allowed
9d002c18:	240b000a 	li	t3,10
  uint8_t n = 7;  // max index for part before dot
  uint8_t i = 0;
  // blank fill name and extension
  while (i < 11) name[i++] = ' ';
  i = 0;
  while ((c = *str++) != '\0') {
9d002c1c:	90860000 	lbu	a2,0(a0)
9d002c20:	10c00021 	beqz	a2,9d002ca8 <_ZN6SdFile10make83NameEPKcPh+0xbc>
9d002c24:	24840001 	addiu	a0,a0,1
    if (c == '.') {
9d002c28:	10c80008 	beq	a2,t0,9d002c4c <_ZN6SdFile10make83NameEPKcPh+0x60>
9d002c2c:	24e28824 	addiu	v0,a3,-30684
      i = 8;   // place for extension
    } else {
      // illegal FAT characters
      char* p = (char *)"|<>^+=?/[];,*\"\\";
      uint8_t b;
      while ((b = pgm_read_byte(p++))) if (b == c) return false;
9d002c30:	90430000 	lbu	v1,0(v0)
9d002c34:	10600009 	beqz	v1,9d002c5c <_ZN6SdFile10make83NameEPKcPh+0x70>
9d002c38:	24420001 	addiu	v0,v0,1
9d002c3c:	5466fffd 	bnel	v1,a2,9d002c34 <_ZN6SdFile10make83NameEPKcPh+0x48>
9d002c40:	90430000 	lbu	v1,0(v0)
      // check size and only allow ASCII printable characters
      if (i > n || c < 0X21 || c > 0X7E)return false;
9d002c44:	03e00008 	jr	ra
9d002c48:	00001021 	move	v0,zero
  // blank fill name and extension
  while (i < 11) name[i++] = ' ';
  i = 0;
  while ((c = *str++) != '\0') {
    if (c == '.') {
      if (n == 10) return false;  // only one dot allowed
9d002c4c:	114bfffd 	beq	t2,t3,9d002c44 <_ZN6SdFile10make83NameEPKcPh+0x58>
9d002c50:	24090008 	li	t1,8
      n = 10;  // max index for full 8.3 name
9d002c54:	0b400b07 	j	9d002c1c <_ZN6SdFile10make83NameEPKcPh+0x30>
9d002c58:	240a000a 	li	t2,10
      // illegal FAT characters
      char* p = (char *)"|<>^+=?/[];,*\"\\";
      uint8_t b;
      while ((b = pgm_read_byte(p++))) if (b == c) return false;
      // check size and only allow ASCII printable characters
      if (i > n || c < 0X21 || c > 0X7E)return false;
9d002c5c:	0149102b 	sltu	v0,t2,t1
9d002c60:	1440fff8 	bnez	v0,9d002c44 <_ZN6SdFile10make83NameEPKcPh+0x58>
9d002c64:	00000000 	nop
9d002c68:	2cc20021 	sltiu	v0,a2,33
9d002c6c:	1440fff5 	bnez	v0,9d002c44 <_ZN6SdFile10make83NameEPKcPh+0x58>
9d002c70:	00000000 	nop
9d002c74:	2cc2007f 	sltiu	v0,a2,127
9d002c78:	1040000f 	beqz	v0,9d002cb8 <_ZN6SdFile10make83NameEPKcPh+0xcc>
9d002c7c:	24c3ff9f 	addiu	v1,a2,-97
      // only upper case allowed in 8.3 names - convert lower to upper
      name[i++] = c < 'a' || c > 'z' ?  c : c + ('A' - 'a');
9d002c80:	306300ff 	andi	v1,v1,0xff
9d002c84:	2c63001a 	sltiu	v1,v1,26
9d002c88:	10600003 	beqz	v1,9d002c98 <_ZN6SdFile10make83NameEPKcPh+0xac>
9d002c8c:	00a91021 	addu	v0,a1,t1
9d002c90:	24c6ffe0 	addiu	a2,a2,-32
9d002c94:	30c600ff 	andi	a2,a2,0xff
9d002c98:	25290001 	addiu	t1,t1,1
9d002c9c:	a0460000 	sb	a2,0(v0)
9d002ca0:	0b400b07 	j	9d002c1c <_ZN6SdFile10make83NameEPKcPh+0x30>
9d002ca4:	312900ff 	andi	t1,t1,0xff
    }
  }
  // must have a file name, extension is optional
  return name[0] != ' ';
9d002ca8:	90a20000 	lbu	v0,0(a1)
9d002cac:	38420020 	xori	v0,v0,0x20
9d002cb0:	03e00008 	jr	ra
9d002cb4:	0002102b 	sltu	v0,zero,v0
}
9d002cb8:	03e00008 	jr	ra
9d002cbc:	00001021 	move	v0,zero

9d002cc0 <_ZN6SdFile8openRootEP8SdVolume>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 * Reasons for failure include the FAT volume has not been initialized
 * or it a FAT12 volume.
 */
uint8_t SdFile::openRoot(SdVolume* vol) {
9d002cc0:	27bdffe0 	addiu	sp,sp,-32
9d002cc4:	afb20018 	sw	s2,24(sp)
9d002cc8:	afb10014 	sw	s1,20(sp)
9d002ccc:	afb00010 	sw	s0,16(sp)
9d002cd0:	afbf001c 	sw	ra,28(sp)
  // error if file is already open
  if (isOpen()) return false;
9d002cd4:	90820005 	lbu	v0,5(a0)
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 * Reasons for failure include the FAT volume has not been initialized
 * or it a FAT12 volume.
 */
uint8_t SdFile::openRoot(SdVolume* vol) {
9d002cd8:	00808021 	move	s0,a0
9d002cdc:	00a09021 	move	s2,a1
  // error if file is already open
  if (isOpen()) return false;
9d002ce0:	14400007 	bnez	v0,9d002d00 <_ZN6SdFile8openRootEP8SdVolume+0x40>
9d002ce4:	00008821 	move	s1,zero
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(char* str) {
  write_P(str);
  println();
}
9d002ce8:	90a20020 	lbu	v0,32(a1)
 */
uint8_t SdFile::openRoot(SdVolume* vol) {
  // error if file is already open
  if (isOpen()) return false;

  if (vol->fatType() == 16) {
9d002cec:	24030010 	li	v1,16
9d002cf0:	1043000a 	beq	v0,v1,9d002d1c <_ZN6SdFile8openRootEP8SdVolume+0x5c>
9d002cf4:	24030020 	li	v1,32
    type_ = FAT_FILE_TYPE_ROOT16;
    firstCluster_ = 0;
    fileSize_ = 32 * vol->rootDirEntryCount();
  } else if (vol->fatType() == 32) {
9d002cf8:	1043001d 	beq	v0,v1,9d002d70 <_ZN6SdFile8openRootEP8SdVolume+0xb0>
9d002cfc:	24020003 	li	v0,3

  // root has no directory entry
  dirBlock_ = 0;
  dirIndex_ = 0;
  return true;
}
9d002d00:	8fbf001c 	lw	ra,28(sp)
9d002d04:	02201021 	move	v0,s1
9d002d08:	8fb20018 	lw	s2,24(sp)
9d002d0c:	8fb10014 	lw	s1,20(sp)
9d002d10:	8fb00010 	lw	s0,16(sp)
9d002d14:	03e00008 	jr	ra
9d002d18:	27bd0020 	addiu	sp,sp,32
uint8_t SdFile::openRoot(SdVolume* vol) {
  // error if file is already open
  if (isOpen()) return false;

  if (vol->fatType() == 16) {
    type_ = FAT_FILE_TYPE_ROOT16;
9d002d1c:	24020002 	li	v0,2
9d002d20:	a0820005 	sb	v0,5(a0)
  /** \return The logical block number for the start of the first FAT. */
  uint32_t fatStartBlock(void) const {return fatStartBlock_;}
  /** \return The FAT type of the volume. Values are 12, 16 or 32. */
  uint8_t fatType(void) const {return fatType_;}
  /** \return The number of entries in the root directory for FAT16 volumes. */
  uint32_t rootDirEntryCount(void) const {return rootDirEntryCount_;}
9d002d24:	94a20022 	lhu	v0,34(a1)
    firstCluster_ = 0;
9d002d28:	ac80001c 	sw	zero,28(a0)
    fileSize_ = 32 * vol->rootDirEntryCount();
9d002d2c:	00021140 	sll	v0,v0,0x5
9d002d30:	ac820018 	sw	v0,24(a0)
    // volume is not initialized or FAT12
    return false;
  }
  vol_ = vol;
  // read only
  flags_ = O_READ;
9d002d34:	24020001 	li	v0,1
9d002d38:	a2020004 	sb	v0,4(s0)
  curCluster_ = 0;
  curPosition_ = 0;

  // root has no directory entry
  dirBlock_ = 0;
  dirIndex_ = 0;
9d002d3c:	a2000014 	sb	zero,20(s0)
  return true;
}
9d002d40:	8fbf001c 	lw	ra,28(sp)
  curPosition_ = 0;

  // root has no directory entry
  dirBlock_ = 0;
  dirIndex_ = 0;
  return true;
9d002d44:	24110001 	li	s1,1
    if (!vol->chainSize(firstCluster_, &fileSize_)) return false;
  } else {
    // volume is not initialized or FAT12
    return false;
  }
  vol_ = vol;
9d002d48:	ae120020 	sw	s2,32(s0)

  // root has no directory entry
  dirBlock_ = 0;
  dirIndex_ = 0;
  return true;
}
9d002d4c:	02201021 	move	v0,s1
  vol_ = vol;
  // read only
  flags_ = O_READ;

  // set to start of file
  curCluster_ = 0;
9d002d50:	ae000008 	sw	zero,8(s0)
  curPosition_ = 0;
9d002d54:	ae00000c 	sw	zero,12(s0)

  // root has no directory entry
  dirBlock_ = 0;
9d002d58:	ae000010 	sw	zero,16(s0)
  dirIndex_ = 0;
  return true;
}
9d002d5c:	8fb20018 	lw	s2,24(sp)
9d002d60:	8fb10014 	lw	s1,20(sp)
9d002d64:	8fb00010 	lw	s0,16(sp)
9d002d68:	03e00008 	jr	ra
9d002d6c:	27bd0020 	addiu	sp,sp,32
  if (vol->fatType() == 16) {
    type_ = FAT_FILE_TYPE_ROOT16;
    firstCluster_ = 0;
    fileSize_ = 32 * vol->rootDirEntryCount();
  } else if (vol->fatType() == 32) {
    type_ = FAT_FILE_TYPE_ROOT32;
9d002d70:	a0820005 	sb	v0,5(a0)
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(char* str) {
  write_P(str);
  println();
}
9d002d74:	8ca50024 	lw	a1,36(a1)
    firstCluster_ = 0;
    fileSize_ = 32 * vol->rootDirEntryCount();
  } else if (vol->fatType() == 32) {
    type_ = FAT_FILE_TYPE_ROOT32;
    firstCluster_ = vol->rootDirStart();
    if (!vol->chainSize(firstCluster_, &fileSize_)) return false;
9d002d78:	02402021 	move	a0,s2
9d002d7c:	26060018 	addiu	a2,s0,24
9d002d80:	0f400fbe 	jal	9d003ef8 <_ZNK8SdVolume9chainSizeEmPm>
9d002d84:	ae05001c 	sw	a1,28(s0)
9d002d88:	1440ffeb 	bnez	v0,9d002d38 <_ZN6SdFile8openRootEP8SdVolume+0x78>
9d002d8c:	24020001 	li	v0,1

  // root has no directory entry
  dirBlock_ = 0;
  dirIndex_ = 0;
  return true;
}
9d002d90:	0b400b41 	j	9d002d04 <_ZN6SdFile8openRootEP8SdVolume+0x44>
9d002d94:	8fbf001c 	lw	ra,28(sp)

9d002d98 <_ZN6SdFile4readEPvt>:
 * if end of file is reached.
 * If an error occurs, read() returns -1.  Possible errors include
 * read() called before a file has been opened, corrupt file system
 * or an I/O error occurred.
 */
int16_t SdFile::read(void* buf, uint16_t nbyte) {
9d002d98:	27bdffb8 	addiu	sp,sp,-72
9d002d9c:	afb50034 	sw	s5,52(sp)
9d002da0:	afb3002c 	sw	s3,44(sp)
9d002da4:	afbf0044 	sw	ra,68(sp)
9d002da8:	afbe0040 	sw	s8,64(sp)
9d002dac:	afb7003c 	sw	s7,60(sp)
9d002db0:	afb60038 	sw	s6,56(sp)
9d002db4:	afb40030 	sw	s4,48(sp)
9d002db8:	afb20028 	sw	s2,40(sp)
9d002dbc:	afb10024 	sw	s1,36(sp)
9d002dc0:	afb00020 	sw	s0,32(sp)
9d002dc4:	0080a821 	move	s5,a0
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(char* str) {
  write_P(str);
  println();
}
9d002dc8:	90840005 	lbu	a0,5(a0)
 * if end of file is reached.
 * If an error occurs, read() returns -1.  Possible errors include
 * read() called before a file has been opened, corrupt file system
 * or an I/O error occurred.
 */
int16_t SdFile::read(void* buf, uint16_t nbyte) {
9d002dcc:	30d3ffff 	andi	s3,a2,0xffff
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);

  // error if not open or write only
  if (!isOpen() || !(flags_ & O_READ)) return -1;
9d002dd0:	1080006b 	beqz	a0,9d002f80 <_ZN6SdFile4readEPvt+0x1e8>
9d002dd4:	2402ffff 	li	v0,-1
9d002dd8:	92a30004 	lbu	v1,4(s5)
9d002ddc:	30630001 	andi	v1,v1,0x1
9d002de0:	50600068 	beqzl	v1,9d002f84 <_ZN6SdFile4readEPvt+0x1ec>
9d002de4:	8fbf0044 	lw	ra,68(sp)

  // max bytes left in file
  if (nbyte > (fileSize_ - curPosition_)) nbyte = fileSize_ - curPosition_;
9d002de8:	8ea20018 	lw	v0,24(s5)
9d002dec:	8eb7000c 	lw	s7,12(s5)
9d002df0:	00571023 	subu	v0,v0,s7
9d002df4:	0053182b 	sltu	v1,v0,s3
9d002df8:	3042ffff 	andi	v0,v0,0xffff
9d002dfc:	0043980b 	movn	s3,v0,v1

  // amount left to read
  uint16_t toRead = nbyte;
  while (toRead > 0) {
9d002e00:	1260005e 	beqz	s3,9d002f7c <_ZN6SdFile4readEPvt+0x1e4>
9d002e04:	3c12a000 	lui	s2,0xa000
    uint32_t block;  // raw device block number
    uint16_t offset = curPosition_ & 0X1FF;  // offset in block
    if (type_ == FAT_FILE_TYPE_ROOT16) {
9d002e08:	24110002 	li	s1,2
 * If an error occurs, read() returns -1.  Possible errors include
 * read() called before a file has been opened, corrupt file system
 * or an I/O error occurred.
 */
int16_t SdFile::read(void* buf, uint16_t nbyte) {
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
9d002e0c:	00a0f021 	move	s8,a1
9d002e10:	0260b021 	move	s6,s3
        if (curPosition_ == 0) {
          // use first cluster in file
          curCluster_ = firstCluster_;
        } else {
          // get next cluster from FAT
          if (!vol_->fatGet(curCluster_, &curCluster_)) return -1;
9d002e14:	26b40008 	addiu	s4,s5,8
      block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
    }
    uint16_t n = toRead;

    // amount to be read from current block
    if (n > (512 - offset)) n = 512 - offset;
9d002e18:	24100200 	li	s0,512
      if (!vol_->readData(block, offset, n, dst)) return -1;
      dst += n;
    } else {
      // read block to cache and copy data to caller
      if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) return -1;
      uint8_t* src = SdVolume::cacheBuffer_.data + offset;
9d002e1c:	26520aa4 	addiu	s2,s2,2724
  // amount left to read
  uint16_t toRead = nbyte;
  while (toRead > 0) {
    uint32_t block;  // raw device block number
    uint16_t offset = curPosition_ & 0X1FF;  // offset in block
    if (type_ == FAT_FILE_TYPE_ROOT16) {
9d002e20:	10910039 	beq	a0,s1,9d002f08 <_ZN6SdFile4readEPvt+0x170>
9d002e24:	32e301ff 	andi	v1,s7,0x1ff
      block = vol_->rootDirStart() + (curPosition_ >> 9);
    } else {
      uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
9d002e28:	8ea40020 	lw	a0,32(s5)
  uint16_t rootDirEntryCount_;  // number of entries in FAT16 root dir
  uint32_t rootDirStart_;       // root start block for FAT16, cluster for FAT32
  //----------------------------------------------------------------------------
  uint8_t allocContiguous(uint32_t count, uint32_t* curCluster);
  uint8_t blockOfCluster(uint32_t position) const {
          return (position >> 9) & (blocksPerCluster_ - 1);}
9d002e2c:	00171242 	srl	v0,s7,0x9
9d002e30:	90870004 	lbu	a3,4(a0)
9d002e34:	24e7ffff 	addiu	a3,a3,-1
9d002e38:	00473824 	and	a3,v0,a3
      if (offset == 0 && blockOfCluster == 0) {
9d002e3c:	14600064 	bnez	v1,9d002fd0 <_ZN6SdFile4readEPvt+0x238>
9d002e40:	30e700ff 	andi	a3,a3,0xff
9d002e44:	54e00005 	bnezl	a3,9d002e5c <_ZN6SdFile4readEPvt+0xc4>
9d002e48:	8ea20008 	lw	v0,8(s5)
        // start of new cluster
        if (curPosition_ == 0) {
9d002e4c:	56e00058 	bnezl	s7,9d002fb0 <_ZN6SdFile4readEPvt+0x218>
9d002e50:	8ea50008 	lw	a1,8(s5)
          // use first cluster in file
          curCluster_ = firstCluster_;
9d002e54:	8ea2001c 	lw	v0,28(s5)
9d002e58:	aea20008 	sw	v0,8(s5)
  uint32_t clusterStartBlock(uint32_t cluster) const {
           return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);}
9d002e5c:	90850010 	lbu	a1,16(a0)
9d002e60:	8c970014 	lw	s7,20(a0)
9d002e64:	2442fffe 	addiu	v0,v0,-2
9d002e68:	00a21004 	sllv	v0,v0,a1
   */
  uint8_t type(void) const {return type_;}
  uint8_t truncate(uint32_t size);
  /** \return Unbuffered read flag. */
  uint8_t unbufferedRead(void) const {
    return flags_ & F_FILE_UNBUFFERED_READ;
9d002e6c:	92a50004 	lbu	a1,4(s5)
  //----------------------------------------------------------------------------
  uint8_t allocContiguous(uint32_t count, uint32_t* curCluster);
  uint8_t blockOfCluster(uint32_t position) const {
          return (position >> 9) & (blocksPerCluster_ - 1);}
  uint32_t clusterStartBlock(uint32_t cluster) const {
           return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);}
9d002e70:	00f73821 	addu	a3,a3,s7
        } else {
          // get next cluster from FAT
          if (!vol_->fatGet(curCluster_, &curCluster_)) return -1;
        }
      }
      block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
9d002e74:	00e22021 	addu	a0,a3,v0
    }
    uint16_t n = toRead;

    // amount to be read from current block
    if (n > (512 - offset)) n = 512 - offset;
9d002e78:	02031023 	subu	v0,s0,v1
9d002e7c:	0056b82a 	slt	s7,v0,s6

    // no buffering needed if n == 512 or user requests no buffering
    if ((unbufferedRead() || n == 512) &&
9d002e80:	30a50040 	andi	a1,a1,0x40
      block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
    }
    uint16_t n = toRead;

    // amount to be read from current block
    if (n > (512 - offset)) n = 512 - offset;
9d002e84:	3042ffff 	andi	v0,v0,0xffff
9d002e88:	02d7100a 	movz	v0,s6,s7

    // no buffering needed if n == 512 or user requests no buffering
    if ((unbufferedRead() || n == 512) &&
9d002e8c:	30a500ff 	andi	a1,a1,0xff
9d002e90:	14a0002a 	bnez	a1,9d002f3c <_ZN6SdFile4readEPvt+0x1a4>
9d002e94:	0040b821 	move	s7,v0
9d002e98:	10500029 	beq	v0,s0,9d002f40 <_ZN6SdFile4readEPvt+0x1a8>
9d002e9c:	8f828010 	lw	v0,-32752(gp)
      block != SdVolume::cacheBlockNumber_) {
      if (!vol_->readData(block, offset, n, dst)) return -1;
      dst += n;
    } else {
      // read block to cache and copy data to caller
      if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) return -1;
9d002ea0:	00002821 	move	a1,zero
9d002ea4:	0f400f4b 	jal	9d003d2c <_ZN8SdVolume13cacheRawBlockEmh>
9d002ea8:	afa3001c 	sw	v1,28(sp)
9d002eac:	1040004a 	beqz	v0,9d002fd8 <_ZN6SdFile4readEPvt+0x240>
9d002eb0:	8fa3001c 	lw	v1,28(sp)
      uint8_t* src = SdVolume::cacheBuffer_.data + offset;
9d002eb4:	02431821 	addu	v1,s2,v1
      uint8_t* end = src + n;
9d002eb8:	00773021 	addu	a2,v1,s7
      while (src != end) *dst++ = *src++;
9d002ebc:	10660009 	beq	v1,a2,9d002ee4 <_ZN6SdFile4readEPvt+0x14c>
9d002ec0:	00601021 	move	v0,v1
9d002ec4:	03c02021 	move	a0,s8
9d002ec8:	90450000 	lbu	a1,0(v0)
9d002ecc:	24420001 	addiu	v0,v0,1
9d002ed0:	a0850000 	sb	a1,0(a0)
9d002ed4:	14c2fffc 	bne	a2,v0,9d002ec8 <_ZN6SdFile4readEPvt+0x130>
9d002ed8:	24840001 	addiu	a0,a0,1
 * if end of file is reached.
 * If an error occurs, read() returns -1.  Possible errors include
 * read() called before a file has been opened, corrupt file system
 * or an I/O error occurred.
 */
int16_t SdFile::read(void* buf, uint16_t nbyte) {
9d002edc:	00c31823 	subu	v1,a2,v1
    } else {
      // read block to cache and copy data to caller
      if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) return -1;
      uint8_t* src = SdVolume::cacheBuffer_.data + offset;
      uint8_t* end = src + n;
      while (src != end) *dst++ = *src++;
9d002ee0:	03c3f021 	addu	s8,s8,v1
    }
    curPosition_ += n;
9d002ee4:	8ea2000c 	lw	v0,12(s5)
    toRead -= n;
9d002ee8:	02d7b023 	subu	s6,s6,s7
9d002eec:	32d6ffff 	andi	s6,s6,0xffff
      if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) return -1;
      uint8_t* src = SdVolume::cacheBuffer_.data + offset;
      uint8_t* end = src + n;
      while (src != end) *dst++ = *src++;
    }
    curPosition_ += n;
9d002ef0:	02e2b821 	addu	s7,s7,v0
  // max bytes left in file
  if (nbyte > (fileSize_ - curPosition_)) nbyte = fileSize_ - curPosition_;

  // amount left to read
  uint16_t toRead = nbyte;
  while (toRead > 0) {
9d002ef4:	12c00021 	beqz	s6,9d002f7c <_ZN6SdFile4readEPvt+0x1e4>
9d002ef8:	aeb7000c 	sw	s7,12(s5)
9d002efc:	92a40005 	lbu	a0,5(s5)
    uint32_t block;  // raw device block number
    uint16_t offset = curPosition_ & 0X1FF;  // offset in block
    if (type_ == FAT_FILE_TYPE_ROOT16) {
9d002f00:	1491ffc9 	bne	a0,s1,9d002e28 <_ZN6SdFile4readEPvt+0x90>
9d002f04:	32e301ff 	andi	v1,s7,0x1ff
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(char* str) {
  write_P(str);
  println();
}
9d002f08:	8ea20020 	lw	v0,32(s5)
   */
  uint8_t type(void) const {return type_;}
  uint8_t truncate(uint32_t size);
  /** \return Unbuffered read flag. */
  uint8_t unbufferedRead(void) const {
    return flags_ & F_FILE_UNBUFFERED_READ;
9d002f0c:	92a50004 	lbu	a1,4(s5)
  uint16_t toRead = nbyte;
  while (toRead > 0) {
    uint32_t block;  // raw device block number
    uint16_t offset = curPosition_ & 0X1FF;  // offset in block
    if (type_ == FAT_FILE_TYPE_ROOT16) {
      block = vol_->rootDirStart() + (curPosition_ >> 9);
9d002f10:	0017ba42 	srl	s7,s7,0x9
9d002f14:	8c420024 	lw	v0,36(v0)

    // amount to be read from current block
    if (n > (512 - offset)) n = 512 - offset;

    // no buffering needed if n == 512 or user requests no buffering
    if ((unbufferedRead() || n == 512) &&
9d002f18:	30a50040 	andi	a1,a1,0x40
9d002f1c:	30a500ff 	andi	a1,a1,0xff
  uint16_t toRead = nbyte;
  while (toRead > 0) {
    uint32_t block;  // raw device block number
    uint16_t offset = curPosition_ & 0X1FF;  // offset in block
    if (type_ == FAT_FILE_TYPE_ROOT16) {
      block = vol_->rootDirStart() + (curPosition_ >> 9);
9d002f20:	02e22021 	addu	a0,s7,v0
      block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
    }
    uint16_t n = toRead;

    // amount to be read from current block
    if (n > (512 - offset)) n = 512 - offset;
9d002f24:	02031023 	subu	v0,s0,v1
9d002f28:	0056b82a 	slt	s7,v0,s6
9d002f2c:	3042ffff 	andi	v0,v0,0xffff
9d002f30:	02d7100a 	movz	v0,s6,s7

    // no buffering needed if n == 512 or user requests no buffering
    if ((unbufferedRead() || n == 512) &&
9d002f34:	10a0ffd8 	beqz	a1,9d002e98 <_ZN6SdFile4readEPvt+0x100>
9d002f38:	0040b821 	move	s7,v0
9d002f3c:	8f828010 	lw	v0,-32752(gp)
9d002f40:	1082ffd7 	beq	a0,v0,9d002ea0 <_ZN6SdFile4readEPvt+0x108>
9d002f44:	00802821 	move	a1,a0
  }
  uint8_t readBlock(uint32_t block, uint8_t* dst) {
    return sdCard_->readBlock(block, dst);}
  uint8_t readData(uint32_t block, uint16_t offset,
    uint16_t count, uint8_t* dst) {
      return sdCard_->readData(block, offset, count, dst);
9d002f48:	8f848030 	lw	a0,-32720(gp)
9d002f4c:	00603021 	move	a2,v1
9d002f50:	02e03821 	move	a3,s7
9d002f54:	0f4009cc 	jal	9d002730 <_ZN7Sd2Card8readDataEmttPh>
9d002f58:	afbe0010 	sw	s8,16(sp)
      block != SdVolume::cacheBlockNumber_) {
      if (!vol_->readData(block, offset, n, dst)) return -1;
9d002f5c:	1040001e 	beqz	v0,9d002fd8 <_ZN6SdFile4readEPvt+0x240>
9d002f60:	02d7b023 	subu	s6,s6,s7
      if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) return -1;
      uint8_t* src = SdVolume::cacheBuffer_.data + offset;
      uint8_t* end = src + n;
      while (src != end) *dst++ = *src++;
    }
    curPosition_ += n;
9d002f64:	8ea2000c 	lw	v0,12(s5)

    // no buffering needed if n == 512 or user requests no buffering
    if ((unbufferedRead() || n == 512) &&
      block != SdVolume::cacheBlockNumber_) {
      if (!vol_->readData(block, offset, n, dst)) return -1;
      dst += n;
9d002f68:	03d7f021 	addu	s8,s8,s7
      uint8_t* src = SdVolume::cacheBuffer_.data + offset;
      uint8_t* end = src + n;
      while (src != end) *dst++ = *src++;
    }
    curPosition_ += n;
    toRead -= n;
9d002f6c:	32d6ffff 	andi	s6,s6,0xffff
      if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) return -1;
      uint8_t* src = SdVolume::cacheBuffer_.data + offset;
      uint8_t* end = src + n;
      while (src != end) *dst++ = *src++;
    }
    curPosition_ += n;
9d002f70:	02e2b821 	addu	s7,s7,v0
  // max bytes left in file
  if (nbyte > (fileSize_ - curPosition_)) nbyte = fileSize_ - curPosition_;

  // amount left to read
  uint16_t toRead = nbyte;
  while (toRead > 0) {
9d002f74:	16c0ffe1 	bnez	s6,9d002efc <_ZN6SdFile4readEPvt+0x164>
9d002f78:	aeb7000c 	sw	s7,12(s5)
      while (src != end) *dst++ = *src++;
    }
    curPosition_ += n;
    toRead -= n;
  }
  return nbyte;
9d002f7c:	7c131620 	seh	v0,s3
}
9d002f80:	8fbf0044 	lw	ra,68(sp)
9d002f84:	8fbe0040 	lw	s8,64(sp)
9d002f88:	8fb7003c 	lw	s7,60(sp)
9d002f8c:	8fb60038 	lw	s6,56(sp)
9d002f90:	8fb50034 	lw	s5,52(sp)
9d002f94:	8fb40030 	lw	s4,48(sp)
9d002f98:	8fb3002c 	lw	s3,44(sp)
9d002f9c:	8fb20028 	lw	s2,40(sp)
9d002fa0:	8fb10024 	lw	s1,36(sp)
9d002fa4:	8fb00020 	lw	s0,32(sp)
9d002fa8:	03e00008 	jr	ra
9d002fac:	27bd0048 	addiu	sp,sp,72
        if (curPosition_ == 0) {
          // use first cluster in file
          curCluster_ = firstCluster_;
        } else {
          // get next cluster from FAT
          if (!vol_->fatGet(curCluster_, &curCluster_)) return -1;
9d002fb0:	02803021 	move	a2,s4
9d002fb4:	afa3001c 	sw	v1,28(sp)
9d002fb8:	0f400f89 	jal	9d003e24 <_ZNK8SdVolume6fatGetEmPm>
9d002fbc:	afa70018 	sw	a3,24(sp)
9d002fc0:	8fa3001c 	lw	v1,28(sp)
9d002fc4:	10400004 	beqz	v0,9d002fd8 <_ZN6SdFile4readEPvt+0x240>
9d002fc8:	8fa70018 	lw	a3,24(sp)
9d002fcc:	8ea40020 	lw	a0,32(s5)
9d002fd0:	0b400b97 	j	9d002e5c <_ZN6SdFile4readEPvt+0xc4>
9d002fd4:	8ea20008 	lw	v0,8(s5)
    }
    curPosition_ += n;
    toRead -= n;
  }
  return nbyte;
}
9d002fd8:	8fbf0044 	lw	ra,68(sp)
      block != SdVolume::cacheBlockNumber_) {
      if (!vol_->readData(block, offset, n, dst)) return -1;
      dst += n;
    } else {
      // read block to cache and copy data to caller
      if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) return -1;
9d002fdc:	2402ffff 	li	v0,-1
    }
    curPosition_ += n;
    toRead -= n;
  }
  return nbyte;
}
9d002fe0:	8fbe0040 	lw	s8,64(sp)
9d002fe4:	8fb7003c 	lw	s7,60(sp)
9d002fe8:	8fb60038 	lw	s6,56(sp)
9d002fec:	8fb50034 	lw	s5,52(sp)
9d002ff0:	8fb40030 	lw	s4,48(sp)
9d002ff4:	8fb3002c 	lw	s3,44(sp)
9d002ff8:	8fb20028 	lw	s2,40(sp)
9d002ffc:	8fb10024 	lw	s1,36(sp)
9d003000:	8fb00020 	lw	s0,32(sp)
9d003004:	03e00008 	jr	ra
9d003008:	27bd0048 	addiu	sp,sp,72

9d00300c <_ZN6SdFile12readDirCacheEv>:
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
dir_t* SdFile::readDirCache(void) {
  // error if not directory
  if (!isDir()) return NULL;
9d00300c:	90820005 	lbu	v0,5(a0)
  return n < 0 ? -1 : 0;
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
dir_t* SdFile::readDirCache(void) {
9d003010:	27bdffd8 	addiu	sp,sp,-40
9d003014:	afb20020 	sw	s2,32(sp)
  // error if not directory
  if (!isDir()) return NULL;
9d003018:	2c420002 	sltiu	v0,v0,2
  return n < 0 ? -1 : 0;
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
dir_t* SdFile::readDirCache(void) {
9d00301c:	afb1001c 	sw	s1,28(sp)
9d003020:	afbf0024 	sw	ra,36(sp)
9d003024:	afb00018 	sw	s0,24(sp)
9d003028:	00808821 	move	s1,a0
  // error if not directory
  if (!isDir()) return NULL;
9d00302c:	10400008 	beqz	v0,9d003050 <_ZN6SdFile12readDirCacheEv+0x44>
9d003030:	00009021 	move	s2,zero
  // advance to next entry
  curPosition_ += 31;

  // return pointer to entry
  return (SdVolume::cacheBuffer_.dir + i);
}
9d003034:	8fbf0024 	lw	ra,36(sp)
9d003038:	02401021 	move	v0,s2
9d00303c:	8fb20020 	lw	s2,32(sp)
9d003040:	8fb1001c 	lw	s1,28(sp)
9d003044:	8fb00018 	lw	s0,24(sp)
9d003048:	03e00008 	jr	ra
9d00304c:	27bd0028 	addiu	sp,sp,40
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int16_t read(void) {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
9d003050:	27a50010 	addiu	a1,sp,16
9d003054:	24060001 	li	a2,1
9d003058:	0f400b66 	jal	9d002d98 <_ZN6SdFile4readEPvt>
9d00305c:	8c90000c 	lw	s0,12(a0)
9d003060:	24030001 	li	v1,1
9d003064:	1443fff4 	bne	v0,v1,9d003038 <_ZN6SdFile12readDirCacheEv+0x2c>
9d003068:	8fbf0024 	lw	ra,36(sp)

  // use read to locate and cache block
  if (read() < 0) return NULL;

  // advance to next entry
  curPosition_ += 31;
9d00306c:	8e22000c 	lw	v0,12(s1)

  // return pointer to entry
  return (SdVolume::cacheBuffer_.dir + i);
9d003070:	3c12a000 	lui	s2,0xa000
9d003074:	321001e0 	andi	s0,s0,0x1e0

  // use read to locate and cache block
  if (read() < 0) return NULL;

  // advance to next entry
  curPosition_ += 31;
9d003078:	2442001f 	addiu	v0,v0,31

  // return pointer to entry
  return (SdVolume::cacheBuffer_.dir + i);
9d00307c:	26520aa4 	addiu	s2,s2,2724

  // use read to locate and cache block
  if (read() < 0) return NULL;

  // advance to next entry
  curPosition_ += 31;
9d003080:	ae22000c 	sw	v0,12(s1)

  // return pointer to entry
  return (SdVolume::cacheBuffer_.dir + i);
9d003084:	0b400c0d 	j	9d003034 <_ZN6SdFile12readDirCacheEv+0x28>
9d003088:	02509021 	addu	s2,s2,s0

9d00308c <_ZN6SdFile7seekSetEm>:
 * \param[in] pos The new position in bytes from the beginning of the file.
 *
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t SdFile::seekSet(uint32_t pos) {
9d00308c:	27bdffd8 	addiu	sp,sp,-40
9d003090:	afb2001c 	sw	s2,28(sp)
9d003094:	afb10018 	sw	s1,24(sp)
9d003098:	afbf0024 	sw	ra,36(sp)
9d00309c:	afb30020 	sw	s3,32(sp)
9d0030a0:	afb00014 	sw	s0,20(sp)
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(char* str) {
  write_P(str);
  println();
}
9d0030a4:	90830005 	lbu	v1,5(a0)
 * \param[in] pos The new position in bytes from the beginning of the file.
 *
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t SdFile::seekSet(uint32_t pos) {
9d0030a8:	00809021 	move	s2,a0
9d0030ac:	00a08821 	move	s1,a1
  // error if file not open or seek past end of file
  if (!isOpen() || pos > fileSize_) return false;
9d0030b0:	10600023 	beqz	v1,9d003140 <_ZN6SdFile7seekSetEm+0xb4>
9d0030b4:	00001021 	move	v0,zero
9d0030b8:	8c840018 	lw	a0,24(a0)
9d0030bc:	0085202b 	sltu	a0,a0,a1
9d0030c0:	54800020 	bnezl	a0,9d003144 <_ZN6SdFile7seekSetEm+0xb8>
9d0030c4:	8fbf0024 	lw	ra,36(sp)

  if (type_ == FAT_FILE_TYPE_ROOT16) {
9d0030c8:	24020002 	li	v0,2
9d0030cc:	5062001b 	beql	v1,v0,9d00313c <_ZN6SdFile7seekSetEm+0xb0>
9d0030d0:	ae51000c 	sw	s1,12(s2)
    curPosition_ = pos;
    return true;
  }
  if (pos == 0) {
9d0030d4:	12200023 	beqz	s1,9d003164 <_ZN6SdFile7seekSetEm+0xd8>
9d0030d8:	2624ffff 	addiu	a0,s1,-1
    curCluster_ = 0;
    curPosition_ = 0;
    return true;
  }
  // calculate cluster index for cur and new position
  uint32_t nCur = (curPosition_ - 1) >> (vol_->clusterSizeShift_ + 9);
9d0030dc:	8e430020 	lw	v1,32(s2)
9d0030e0:	8e42000c 	lw	v0,12(s2)
9d0030e4:	90730010 	lbu	s3,16(v1)
9d0030e8:	2443ffff 	addiu	v1,v0,-1
9d0030ec:	26730009 	addiu	s3,s3,9
9d0030f0:	02631806 	srlv	v1,v1,s3
  uint32_t nNew = (pos - 1) >> (vol_->clusterSizeShift_ + 9);
9d0030f4:	02649806 	srlv	s3,a0,s3

  if (nNew < nCur || curPosition_ == 0) {
9d0030f8:	0263202b 	sltu	a0,s3,v1
9d0030fc:	54800017 	bnezl	a0,9d00315c <_ZN6SdFile7seekSetEm+0xd0>
9d003100:	8e42001c 	lw	v0,28(s2)
9d003104:	50400015 	beqzl	v0,9d00315c <_ZN6SdFile7seekSetEm+0xd0>
9d003108:	8e42001c 	lw	v0,28(s2)
    // must follow chain from first cluster
    curCluster_ = firstCluster_;
  } else {
    // advance from curPosition
    nNew -= nCur;
9d00310c:	02639823 	subu	s3,s3,v1
  }
  while (nNew--) {
    if (!vol_->fatGet(curCluster_, &curCluster_)) return false;
9d003110:	0b400c4c 	j	9d003130 <_ZN6SdFile7seekSetEm+0xa4>
9d003114:	26500008 	addiu	s0,s2,8
9d003118:	8e440020 	lw	a0,32(s2)
9d00311c:	8e450008 	lw	a1,8(s2)
9d003120:	0f400f89 	jal	9d003e24 <_ZNK8SdVolume6fatGetEmPm>
9d003124:	2673ffff 	addiu	s3,s3,-1
9d003128:	10400018 	beqz	v0,9d00318c <_ZN6SdFile7seekSetEm+0x100>
9d00312c:	8fbf0024 	lw	ra,36(sp)
    curCluster_ = firstCluster_;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
9d003130:	1660fff9 	bnez	s3,9d003118 <_ZN6SdFile7seekSetEm+0x8c>
9d003134:	02003021 	move	a2,s0
    if (!vol_->fatGet(curCluster_, &curCluster_)) return false;
  }
  curPosition_ = pos;
9d003138:	ae51000c 	sw	s1,12(s2)
  return true;
9d00313c:	24020001 	li	v0,1
}
9d003140:	8fbf0024 	lw	ra,36(sp)
9d003144:	8fb30020 	lw	s3,32(sp)
9d003148:	8fb2001c 	lw	s2,28(sp)
9d00314c:	8fb10018 	lw	s1,24(sp)
9d003150:	8fb00014 	lw	s0,20(sp)
9d003154:	03e00008 	jr	ra
9d003158:	27bd0028 	addiu	sp,sp,40
  uint32_t nCur = (curPosition_ - 1) >> (vol_->clusterSizeShift_ + 9);
  uint32_t nNew = (pos - 1) >> (vol_->clusterSizeShift_ + 9);

  if (nNew < nCur || curPosition_ == 0) {
    // must follow chain from first cluster
    curCluster_ = firstCluster_;
9d00315c:	0b400c44 	j	9d003110 <_ZN6SdFile7seekSetEm+0x84>
9d003160:	ae420008 	sw	v0,8(s2)
  while (nNew--) {
    if (!vol_->fatGet(curCluster_, &curCluster_)) return false;
  }
  curPosition_ = pos;
  return true;
}
9d003164:	8fbf0024 	lw	ra,36(sp)
    curPosition_ = pos;
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    curCluster_ = 0;
9d003168:	ae400008 	sw	zero,8(s2)
    curPosition_ = 0;
9d00316c:	ae40000c 	sw	zero,12(s2)
    return true;
9d003170:	24020001 	li	v0,1
  while (nNew--) {
    if (!vol_->fatGet(curCluster_, &curCluster_)) return false;
  }
  curPosition_ = pos;
  return true;
}
9d003174:	8fb30020 	lw	s3,32(sp)
9d003178:	8fb2001c 	lw	s2,28(sp)
9d00317c:	8fb10018 	lw	s1,24(sp)
9d003180:	8fb00014 	lw	s0,20(sp)
9d003184:	03e00008 	jr	ra
9d003188:	27bd0028 	addiu	sp,sp,40
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (!vol_->fatGet(curCluster_, &curCluster_)) return false;
9d00318c:	00001021 	move	v0,zero
  }
  curPosition_ = pos;
  return true;
}
9d003190:	8fb30020 	lw	s3,32(sp)
9d003194:	8fb2001c 	lw	s2,28(sp)
9d003198:	8fb10018 	lw	s1,24(sp)
9d00319c:	8fb00014 	lw	s0,20(sp)
9d0031a0:	03e00008 	jr	ra
9d0031a4:	27bd0028 	addiu	sp,sp,40

9d0031a8 <_ZN6SdFile4syncEv>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 * Reasons for failure include a call to sync() before a file has been
 * opened or an I/O error.
 */
uint8_t SdFile::sync(void) {
9d0031a8:	27bdffe0 	addiu	sp,sp,-32
9d0031ac:	afb00018 	sw	s0,24(sp)
9d0031b0:	afbf001c 	sw	ra,28(sp)
  // only allow open files and directories
  if (!isOpen()) return false;
9d0031b4:	90820005 	lbu	v0,5(a0)
9d0031b8:	10400007 	beqz	v0,9d0031d8 <_ZN6SdFile4syncEv+0x30>
9d0031bc:	00808021 	move	s0,a0

  if (flags_ & F_FILE_DIR_DIRTY) {
9d0031c0:	80820004 	lb	v0,4(a0)
9d0031c4:	04400009 	bltz	v0,9d0031ec <_ZN6SdFile4syncEv+0x44>
9d0031c8:	8fbf001c 	lw	ra,28(sp)
    }
    // clear directory dirty
    flags_ &= ~F_FILE_DIR_DIRTY;
  }
  return SdVolume::cacheFlush();
}
9d0031cc:	8fb00018 	lw	s0,24(sp)
      d->lastAccessDate = d->lastWriteDate;
    }
    // clear directory dirty
    flags_ &= ~F_FILE_DIR_DIRTY;
  }
  return SdVolume::cacheFlush();
9d0031d0:	0b400f24 	j	9d003c90 <_ZN8SdVolume10cacheFlushEv>
9d0031d4:	27bd0020 	addiu	sp,sp,32
}
9d0031d8:	8fbf001c 	lw	ra,28(sp)
9d0031dc:	00001021 	move	v0,zero
9d0031e0:	8fb00018 	lw	s0,24(sp)
9d0031e4:	03e00008 	jr	ra
9d0031e8:	27bd0020 	addiu	sp,sp,32
uint8_t SdFile::sync(void) {
  // only allow open files and directories
  if (!isOpen()) return false;

  if (flags_ & F_FILE_DIR_DIRTY) {
    dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
9d0031ec:	0f400ae8 	jal	9d002ba0 <_ZN6SdFile13cacheDirEntryEh>
9d0031f0:	24050001 	li	a1,1
    if (!d) return false;
9d0031f4:	1040fff9 	beqz	v0,9d0031dc <_ZN6SdFile4syncEv+0x34>
9d0031f8:	8fbf001c 	lw	ra,28(sp)

    // do not set filesize for dir files
    if (!isDir()) d->fileSize = fileSize_;
9d0031fc:	92030005 	lbu	v1,5(s0)
9d003200:	2c630002 	sltiu	v1,v1,2
9d003204:	5460001f 	bnezl	v1,9d003284 <_ZN6SdFile4syncEv+0xdc>
9d003208:	8e030018 	lw	v1,24(s0)

    // update first cluster fields
    d->firstClusterLow = firstCluster_ & 0XFFFF;
9d00320c:	8e03001c 	lw	v1,28(s0)
9d003210:	3064ffff 	andi	a0,v1,0xffff
    d->firstClusterHigh = firstCluster_ >> 16;
9d003214:	00031c02 	srl	v1,v1,0x10
9d003218:	00032a02 	srl	a1,v1,0x8

    // do not set filesize for dir files
    if (!isDir()) d->fileSize = fileSize_;

    // update first cluster fields
    d->firstClusterLow = firstCluster_ & 0XFFFF;
9d00321c:	00043202 	srl	a2,a0,0x8
9d003220:	a044001a 	sb	a0,26(v0)
9d003224:	a046001b 	sb	a2,27(v0)
    d->firstClusterHigh = firstCluster_ >> 16;
9d003228:	a0430014 	sb	v1,20(v0)
9d00322c:	a0450015 	sb	a1,21(v0)

    // set modify time if user supplied a callback date/time function
    if (dateTime_) {
9d003230:	8f83802c 	lw	v1,-32724(gp)
9d003234:	1060000c 	beqz	v1,9d003268 <_ZN6SdFile4syncEv+0xc0>
9d003238:	24440018 	addiu	a0,v0,24
      dateTime_(&d->lastWriteDate, &d->lastWriteTime);
9d00323c:	24450016 	addiu	a1,v0,22
9d003240:	0060f809 	jalr	v1
9d003244:	afa20010 	sw	v0,16(sp)
      d->lastAccessDate = d->lastWriteDate;
9d003248:	8fa20010 	lw	v0,16(sp)
9d00324c:	90430019 	lbu	v1,25(v0)
9d003250:	90440018 	lbu	a0,24(v0)
9d003254:	00031a00 	sll	v1,v1,0x8
9d003258:	00641825 	or	v1,v1,a0
9d00325c:	00032202 	srl	a0,v1,0x8
9d003260:	a0430012 	sb	v1,18(v0)
9d003264:	a0440013 	sb	a0,19(v0)
    }
    // clear directory dirty
    flags_ &= ~F_FILE_DIR_DIRTY;
9d003268:	92020004 	lbu	v0,4(s0)
9d00326c:	3042007f 	andi	v0,v0,0x7f
9d003270:	a2020004 	sb	v0,4(s0)
  }
  return SdVolume::cacheFlush();
}
9d003274:	8fbf001c 	lw	ra,28(sp)
9d003278:	8fb00018 	lw	s0,24(sp)
      d->lastAccessDate = d->lastWriteDate;
    }
    // clear directory dirty
    flags_ &= ~F_FILE_DIR_DIRTY;
  }
  return SdVolume::cacheFlush();
9d00327c:	0b400f24 	j	9d003c90 <_ZN8SdVolume10cacheFlushEv>
9d003280:	27bd0020 	addiu	sp,sp,32
  if (flags_ & F_FILE_DIR_DIRTY) {
    dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
    if (!d) return false;

    // do not set filesize for dir files
    if (!isDir()) d->fileSize = fileSize_;
9d003284:	a843001f 	swl	v1,31(v0)
9d003288:	0b400c83 	j	9d00320c <_ZN6SdFile4syncEv+0x64>
9d00328c:	b843001c 	swr	v1,28(v0)

9d003290 <_ZN6SdFile5closeEv>:
 *
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 * Reasons for failure include no file is open or an I/O error.
 */
uint8_t SdFile::close(void) {
9d003290:	27bdffe8 	addiu	sp,sp,-24
9d003294:	afb00010 	sw	s0,16(sp)
9d003298:	afbf0014 	sw	ra,20(sp)
  if (!sync())return false;
9d00329c:	0f400c6a 	jal	9d0031a8 <_ZN6SdFile4syncEv>
9d0032a0:	00808021 	move	s0,a0
9d0032a4:	10400003 	beqz	v0,9d0032b4 <_ZN6SdFile5closeEv+0x24>
9d0032a8:	00001821 	move	v1,zero
  type_ = FAT_FILE_TYPE_CLOSED;
9d0032ac:	a2000005 	sb	zero,5(s0)
  return true;
9d0032b0:	24030001 	li	v1,1
}
9d0032b4:	8fbf0014 	lw	ra,20(sp)
9d0032b8:	00601021 	move	v0,v1
9d0032bc:	8fb00010 	lw	s0,16(sp)
9d0032c0:	03e00008 	jr	ra
9d0032c4:	27bd0018 	addiu	sp,sp,24

9d0032c8 <_ZN6SdFile8truncateEm>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 * Reasons for failure include file is read only, file is a directory,
 * \a length is greater than the current file size or an I/O error occurs.
 */
uint8_t SdFile::truncate(uint32_t length) {
9d0032c8:	27bdffd0 	addiu	sp,sp,-48
9d0032cc:	afb30028 	sw	s3,40(sp)
9d0032d0:	afb20024 	sw	s2,36(sp)
9d0032d4:	afb10020 	sw	s1,32(sp)
9d0032d8:	afbf002c 	sw	ra,44(sp)
9d0032dc:	afb0001c 	sw	s0,28(sp)
// error if not a normal file or read-only
  if (!isFile() || !(flags_ & O_WRITE)) return false;
9d0032e0:	90830005 	lbu	v1,5(a0)
9d0032e4:	24020001 	li	v0,1
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 * Reasons for failure include file is read only, file is a directory,
 * \a length is greater than the current file size or an I/O error occurs.
 */
uint8_t SdFile::truncate(uint32_t length) {
9d0032e8:	00808821 	move	s1,a0
9d0032ec:	00a09821 	move	s3,a1
// error if not a normal file or read-only
  if (!isFile() || !(flags_ & O_WRITE)) return false;
9d0032f0:	10620009 	beq	v1,v0,9d003318 <_ZN6SdFile8truncateEm+0x50>
9d0032f4:	00009021 	move	s2,zero

  if (!sync()) return false;

  // set file to correct position
  return seekSet(newPos);
}
9d0032f8:	8fbf002c 	lw	ra,44(sp)
9d0032fc:	02401021 	move	v0,s2
9d003300:	8fb30028 	lw	s3,40(sp)
9d003304:	8fb20024 	lw	s2,36(sp)
9d003308:	8fb10020 	lw	s1,32(sp)
9d00330c:	8fb0001c 	lw	s0,28(sp)
9d003310:	03e00008 	jr	ra
9d003314:	27bd0030 	addiu	sp,sp,48
 * Reasons for failure include file is read only, file is a directory,
 * \a length is greater than the current file size or an I/O error occurs.
 */
uint8_t SdFile::truncate(uint32_t length) {
// error if not a normal file or read-only
  if (!isFile() || !(flags_ & O_WRITE)) return false;
9d003318:	90820004 	lbu	v0,4(a0)
9d00331c:	30420002 	andi	v0,v0,0x2
9d003320:	1040fff6 	beqz	v0,9d0032fc <_ZN6SdFile8truncateEm+0x34>
9d003324:	8fbf002c 	lw	ra,44(sp)

  // error if length is greater than current size
  if (length > fileSize_) return false;
9d003328:	8c820018 	lw	v0,24(a0)
9d00332c:	0045182b 	sltu	v1,v0,a1
9d003330:	5460fff3 	bnezl	v1,9d003300 <_ZN6SdFile8truncateEm+0x38>
9d003334:	02401021 	move	v0,s2

  // fileSize and length are zero - nothing to do
  if (fileSize_ == 0) return true;
9d003338:	1040fff0 	beqz	v0,9d0032fc <_ZN6SdFile8truncateEm+0x34>
9d00333c:	24120001 	li	s2,1

  // remember position for seek after truncation
  uint32_t newPos = curPosition_ > length ? length : curPosition_;

  // position to last cluster in truncated file
  if (!seekSet(length)) return false;
9d003340:	0f400c23 	jal	9d00308c <_ZN6SdFile7seekSetEm>
9d003344:	8e30000c 	lw	s0,12(s1)
9d003348:	1040ffeb 	beqz	v0,9d0032f8 <_ZN6SdFile8truncateEm+0x30>
9d00334c:	00009021 	move	s2,zero

  if (length == 0) {
9d003350:	16600008 	bnez	s3,9d003374 <_ZN6SdFile8truncateEm+0xac>
9d003354:	8e240020 	lw	a0,32(s1)
    // free all clusters
    if (!vol_->freeChain(firstCluster_)) return false;
9d003358:	8e25001c 	lw	a1,28(s1)
9d00335c:	0f401096 	jal	9d004258 <_ZN8SdVolume9freeChainEm>
9d003360:	02609021 	move	s2,s3
9d003364:	1040ffe5 	beqz	v0,9d0032fc <_ZN6SdFile8truncateEm+0x34>
9d003368:	8fbf002c 	lw	ra,44(sp)
    firstCluster_ = 0;
9d00336c:	0b400ceb 	j	9d0033ac <_ZN6SdFile8truncateEm+0xe4>
9d003370:	ae20001c 	sw	zero,28(s1)
  } else {
    uint32_t toFree;
    if (!vol_->fatGet(curCluster_, &toFree)) return false;
9d003374:	8e250008 	lw	a1,8(s1)
9d003378:	0f400f89 	jal	9d003e24 <_ZNK8SdVolume6fatGetEmPm>
9d00337c:	27a60010 	addiu	a2,sp,16
9d003380:	1040ffdd 	beqz	v0,9d0032f8 <_ZN6SdFile8truncateEm+0x30>
9d003384:	24020010 	li	v0,16

    if (!vol_->isEOC(toFree)) {
9d003388:	8e240020 	lw	a0,32(s1)
  uint8_t fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
  }
  uint8_t freeChain(uint32_t cluster);
  uint8_t isEOC(uint32_t cluster) const {
    return  cluster >= (fatType_ == 16 ? FAT16EOC_MIN : FAT32EOC_MIN);
9d00338c:	90830020 	lbu	v1,32(a0)
9d003390:	10620023 	beq	v1,v0,9d003420 <_ZN6SdFile8truncateEm+0x158>
9d003394:	8fa50010 	lw	a1,16(sp)
9d003398:	3c020fff 	lui	v0,0xfff
9d00339c:	3442fff8 	ori	v0,v0,0xfff8
9d0033a0:	00a2102b 	sltu	v0,a1,v0
9d0033a4:	14400011 	bnez	v0,9d0033ec <_ZN6SdFile8truncateEm+0x124>
9d0033a8:	00000000 	nop
    }
  }
  fileSize_ = length;

  // need to update directory entry
  flags_ |= F_FILE_DIR_DIRTY;
9d0033ac:	92230004 	lbu	v1,4(s1)
9d0033b0:	2402ff80 	li	v0,-128

      // current cluster is end of chain
      if (!vol_->fatPutEOC(curCluster_)) return false;
    }
  }
  fileSize_ = length;
9d0033b4:	ae330018 	sw	s3,24(s1)

  // need to update directory entry
  flags_ |= F_FILE_DIR_DIRTY;
9d0033b8:	00621025 	or	v0,v1,v0
9d0033bc:	a2220004 	sb	v0,4(s1)

  if (!sync()) return false;
9d0033c0:	0f400c6a 	jal	9d0031a8 <_ZN6SdFile4syncEv>
9d0033c4:	02202021 	move	a0,s1
9d0033c8:	1040ffcb 	beqz	v0,9d0032f8 <_ZN6SdFile8truncateEm+0x30>
9d0033cc:	00009021 	move	s2,zero

  // set file to correct position
  return seekSet(newPos);
9d0033d0:	0213282b 	sltu	a1,s0,s3
9d0033d4:	0265800a 	movz	s0,s3,a1
9d0033d8:	02002821 	move	a1,s0
9d0033dc:	0f400c23 	jal	9d00308c <_ZN6SdFile7seekSetEm>
9d0033e0:	02202021 	move	a0,s1
9d0033e4:	0b400cbe 	j	9d0032f8 <_ZN6SdFile8truncateEm+0x30>
9d0033e8:	00409021 	move	s2,v0
    uint32_t toFree;
    if (!vol_->fatGet(curCluster_, &toFree)) return false;

    if (!vol_->isEOC(toFree)) {
      // free extra clusters
      if (!vol_->freeChain(toFree)) return false;
9d0033ec:	0f401096 	jal	9d004258 <_ZN8SdVolume9freeChainEm>
9d0033f0:	00009021 	move	s2,zero
9d0033f4:	1040ffc1 	beqz	v0,9d0032fc <_ZN6SdFile8truncateEm+0x34>
9d0033f8:	8fbf002c 	lw	ra,44(sp)
  static uint8_t cacheZeroBlock(uint32_t blockNumber);
  uint8_t chainSize(uint32_t beginCluster, uint32_t* size) const;
  uint8_t fatGet(uint32_t cluster, uint32_t* value) const;
  uint8_t fatPut(uint32_t cluster, uint32_t value);
  uint8_t fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
9d0033fc:	8e240020 	lw	a0,32(s1)
9d003400:	8e250008 	lw	a1,8(s1)
9d003404:	3c060fff 	lui	a2,0xfff
9d003408:	0f400ff2 	jal	9d003fc8 <_ZN8SdVolume6fatPutEmm>
9d00340c:	34c6ffff 	ori	a2,a2,0xffff

      // current cluster is end of chain
      if (!vol_->fatPutEOC(curCluster_)) return false;
9d003410:	5440ffe7 	bnezl	v0,9d0033b0 <_ZN6SdFile8truncateEm+0xe8>
9d003414:	92230004 	lbu	v1,4(s1)

  if (!sync()) return false;

  // set file to correct position
  return seekSet(newPos);
}
9d003418:	0b400cbf 	j	9d0032fc <_ZN6SdFile8truncateEm+0x34>
9d00341c:	8fbf002c 	lw	ra,44(sp)
  }
  uint8_t freeChain(uint32_t cluster);
  uint8_t isEOC(uint32_t cluster) const {
    return  cluster >= (fatType_ == 16 ? FAT16EOC_MIN : FAT32EOC_MIN);
9d003420:	0b400ce8 	j	9d0033a0 <_ZN6SdFile8truncateEm+0xd8>
9d003424:	3402fff8 	li	v0,0xfff8

9d003428 <_ZN6SdFile6removeEv>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 * Reasons for failure include the file read-only, is a directory,
 * or an I/O error occurred.
 */
uint8_t SdFile::remove(void) {
9d003428:	27bdffe8 	addiu	sp,sp,-24
  // free any clusters - will fail if read-only or directory
  if (!truncate(0)) return false;
9d00342c:	00002821 	move	a1,zero
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 * Reasons for failure include the file read-only, is a directory,
 * or an I/O error occurred.
 */
uint8_t SdFile::remove(void) {
9d003430:	afb00010 	sw	s0,16(sp)
9d003434:	afbf0014 	sw	ra,20(sp)
  // free any clusters - will fail if read-only or directory
  if (!truncate(0)) return false;
9d003438:	0f400cb2 	jal	9d0032c8 <_ZN6SdFile8truncateEm>
9d00343c:	00808021 	move	s0,a0
9d003440:	14400006 	bnez	v0,9d00345c <_ZN6SdFile6removeEv+0x34>
9d003444:	02002021 	move	a0,s0
  // set this SdFile closed
  type_ = FAT_FILE_TYPE_CLOSED;

  // write entry to SD
  return SdVolume::cacheFlush();
}
9d003448:	8fbf0014 	lw	ra,20(sp)
9d00344c:	00001021 	move	v0,zero
9d003450:	8fb00010 	lw	s0,16(sp)
9d003454:	03e00008 	jr	ra
9d003458:	27bd0018 	addiu	sp,sp,24
uint8_t SdFile::remove(void) {
  // free any clusters - will fail if read-only or directory
  if (!truncate(0)) return false;

  // cache directory entry
  dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
9d00345c:	0f400ae8 	jal	9d002ba0 <_ZN6SdFile13cacheDirEntryEh>
9d003460:	24050001 	li	a1,1
  if (!d) return false;
9d003464:	1040fff8 	beqz	v0,9d003448 <_ZN6SdFile6removeEv+0x20>
9d003468:	2403ffe5 	li	v1,-27

  // mark entry deleted
  d->name[0] = DIR_NAME_DELETED;
9d00346c:	a0430000 	sb	v1,0(v0)

  // set this SdFile closed
  type_ = FAT_FILE_TYPE_CLOSED;
9d003470:	a2000005 	sb	zero,5(s0)

  // write entry to SD
  return SdVolume::cacheFlush();
}
9d003474:	8fbf0014 	lw	ra,20(sp)
9d003478:	8fb00010 	lw	s0,16(sp)

  // set this SdFile closed
  type_ = FAT_FILE_TYPE_CLOSED;

  // write entry to SD
  return SdVolume::cacheFlush();
9d00347c:	0b400f24 	j	9d003c90 <_ZN8SdVolume10cacheFlushEv>
9d003480:	27bd0018 	addiu	sp,sp,24

9d003484 <_ZN6SdFile15openCachedEntryEhh>:
  // open cached entry
  return openCachedEntry(index & 0XF, oflag);
}
//------------------------------------------------------------------------------
// open a cached directory entry. Assumes vol_ is initializes
uint8_t SdFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
9d003484:	30a500ff 	andi	a1,a1,0xff
  // location of entry in cache
  dir_t* p = SdVolume::cacheBuffer_.dir + dirIndex;

  // write or truncate is an error for a directory or read-only file
  if (p->attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {
9d003488:	3c03a000 	lui	v1,0xa000
  // open cached entry
  return openCachedEntry(index & 0XF, oflag);
}
//------------------------------------------------------------------------------
// open a cached directory entry. Assumes vol_ is initializes
uint8_t SdFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
9d00348c:	27bdffe0 	addiu	sp,sp,-32
  // location of entry in cache
  dir_t* p = SdVolume::cacheBuffer_.dir + dirIndex;

  // write or truncate is an error for a directory or read-only file
  if (p->attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {
9d003490:	24630aa4 	addiu	v1,v1,2724
9d003494:	00051140 	sll	v0,a1,0x5
  // open cached entry
  return openCachedEntry(index & 0XF, oflag);
}
//------------------------------------------------------------------------------
// open a cached directory entry. Assumes vol_ is initializes
uint8_t SdFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
9d003498:	afb10014 	sw	s1,20(sp)
9d00349c:	afb00010 	sw	s0,16(sp)
9d0034a0:	afbf001c 	sw	ra,28(sp)
9d0034a4:	afb20018 	sw	s2,24(sp)
  // location of entry in cache
  dir_t* p = SdVolume::cacheBuffer_.dir + dirIndex;

  // write or truncate is an error for a directory or read-only file
  if (p->attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {
9d0034a8:	00623821 	addu	a3,v1,v0
9d0034ac:	90e7000b 	lbu	a3,11(a3)
  // open cached entry
  return openCachedEntry(index & 0XF, oflag);
}
//------------------------------------------------------------------------------
// open a cached directory entry. Assumes vol_ is initializes
uint8_t SdFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
9d0034b0:	00808021 	move	s0,a0
  // location of entry in cache
  dir_t* p = SdVolume::cacheBuffer_.dir + dirIndex;

  // write or truncate is an error for a directory or read-only file
  if (p->attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {
9d0034b4:	30e70011 	andi	a3,a3,0x11
9d0034b8:	10e00004 	beqz	a3,9d0034cc <_ZN6SdFile15openCachedEntryEhh+0x48>
9d0034bc:	30d100ff 	andi	s1,a2,0xff
    if (oflag & (O_WRITE | O_TRUNC)) return false;
9d0034c0:	32240042 	andi	a0,s1,0x42
9d0034c4:	14800032 	bnez	a0,9d003590 <_ZN6SdFile15openCachedEntryEhh+0x10c>
9d0034c8:	8fbf001c 	lw	ra,28(sp)
  }
  // remember location of directory entry on SD
  dirIndex_ = dirIndex;
9d0034cc:	a2050014 	sb	a1,20(s0)
  dirBlock_ = SdVolume::cacheBlockNumber_;

  // copy first cluster number for directory fields
  firstCluster_ = (uint32_t)p->firstClusterHigh << 16;
9d0034d0:	00621021 	addu	v0,v1,v0
  if (p->attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {
    if (oflag & (O_WRITE | O_TRUNC)) return false;
  }
  // remember location of directory entry on SD
  dirIndex_ = dirIndex;
  dirBlock_ = SdVolume::cacheBlockNumber_;
9d0034d4:	8f838010 	lw	v1,-32752(gp)
9d0034d8:	ae030010 	sw	v1,16(s0)

  // copy first cluster number for directory fields
  firstCluster_ = (uint32_t)p->firstClusterHigh << 16;
9d0034dc:	90430015 	lbu	v1,21(v0)
9d0034e0:	90440014 	lbu	a0,20(v0)
9d0034e4:	00031a00 	sll	v1,v1,0x8
9d0034e8:	00641825 	or	v1,v1,a0
9d0034ec:	00031c00 	sll	v1,v1,0x10
9d0034f0:	ae03001c 	sw	v1,28(s0)
  firstCluster_ |= p->firstClusterLow;
9d0034f4:	9045001b 	lbu	a1,27(v0)
9d0034f8:	9044001a 	lbu	a0,26(v0)
9d0034fc:	00052a00 	sll	a1,a1,0x8
9d003500:	00a42825 	or	a1,a1,a0
9d003504:	00652825 	or	a1,v1,a1
9d003508:	ae05001c 	sw	a1,28(s0)
}
/** Mask for file/subdirectory tests */
uint8_t const DIR_ATT_FILE_TYPE_MASK = (DIR_ATT_VOLUME_ID | DIR_ATT_DIRECTORY);
/** Directory entry is for a file */
static inline uint8_t DIR_IS_FILE(const dir_t* dir) {
  return (dir->attributes & DIR_ATT_FILE_TYPE_MASK) == 0;
9d00350c:	9043000b 	lbu	v1,11(v0)
9d003510:	30630018 	andi	v1,v1,0x18

  // make sure it is a normal file or subdirectory
  if (DIR_IS_FILE(p)) {
9d003514:	54600015 	bnezl	v1,9d00356c <_ZN6SdFile15openCachedEntryEhh+0xe8>
9d003518:	24020010 	li	v0,16
    fileSize_ = p->fileSize;
9d00351c:	8843001f 	lwl	v1,31(v0)
9d003520:	9843001c 	lwr	v1,28(v0)
    type_ = FAT_FILE_TYPE_NORMAL;
9d003524:	24020001 	li	v0,1
9d003528:	a2020005 	sb	v0,5(s0)
  firstCluster_ = (uint32_t)p->firstClusterHigh << 16;
  firstCluster_ |= p->firstClusterLow;

  // make sure it is a normal file or subdirectory
  if (DIR_IS_FILE(p)) {
    fileSize_ = p->fileSize;
9d00352c:	ae030018 	sw	v1,24(s0)
    type_ = FAT_FILE_TYPE_SUBDIR;
  } else {
    return false;
  }
  // save open flags for read/write
  flags_ = oflag & (O_ACCMODE | O_SYNC | O_APPEND);
9d003530:	3222000f 	andi	v0,s1,0xf
  // set to start of file
  curCluster_ = 0;
  curPosition_ = 0;

  // truncate file to zero length if requested
  if (oflag & O_TRUNC) return truncate(0);
9d003534:	32310040 	andi	s1,s1,0x40
    type_ = FAT_FILE_TYPE_SUBDIR;
  } else {
    return false;
  }
  // save open flags for read/write
  flags_ = oflag & (O_ACCMODE | O_SYNC | O_APPEND);
9d003538:	a2020004 	sb	v0,4(s0)

  // set to start of file
  curCluster_ = 0;
9d00353c:	ae000008 	sw	zero,8(s0)
  curPosition_ = 0;
9d003540:	ae00000c 	sw	zero,12(s0)

  // truncate file to zero length if requested
  if (oflag & O_TRUNC) return truncate(0);
9d003544:	1220000b 	beqz	s1,9d003574 <_ZN6SdFile15openCachedEntryEhh+0xf0>
9d003548:	24120001 	li	s2,1
9d00354c:	02002021 	move	a0,s0
  return true;
}
9d003550:	8fbf001c 	lw	ra,28(sp)
9d003554:	8fb20018 	lw	s2,24(sp)
9d003558:	8fb10014 	lw	s1,20(sp)
9d00355c:	8fb00010 	lw	s0,16(sp)
  // set to start of file
  curCluster_ = 0;
  curPosition_ = 0;

  // truncate file to zero length if requested
  if (oflag & O_TRUNC) return truncate(0);
9d003560:	00002821 	move	a1,zero
9d003564:	0b400cb2 	j	9d0032c8 <_ZN6SdFile8truncateEm>
9d003568:	27bd0020 	addiu	sp,sp,32

  // make sure it is a normal file or subdirectory
  if (DIR_IS_FILE(p)) {
    fileSize_ = p->fileSize;
    type_ = FAT_FILE_TYPE_NORMAL;
  } else if (DIR_IS_SUBDIR(p)) {
9d00356c:	1062000f 	beq	v1,v0,9d0035ac <_ZN6SdFile15openCachedEntryEhh+0x128>
9d003570:	00009021 	move	s2,zero
  curPosition_ = 0;

  // truncate file to zero length if requested
  if (oflag & O_TRUNC) return truncate(0);
  return true;
}
9d003574:	8fbf001c 	lw	ra,28(sp)
9d003578:	02401021 	move	v0,s2
9d00357c:	8fb20018 	lw	s2,24(sp)
9d003580:	8fb10014 	lw	s1,20(sp)
9d003584:	8fb00010 	lw	s0,16(sp)
9d003588:	03e00008 	jr	ra
9d00358c:	27bd0020 	addiu	sp,sp,32
  // location of entry in cache
  dir_t* p = SdVolume::cacheBuffer_.dir + dirIndex;

  // write or truncate is an error for a directory or read-only file
  if (p->attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {
    if (oflag & (O_WRITE | O_TRUNC)) return false;
9d003590:	00009021 	move	s2,zero
  curPosition_ = 0;

  // truncate file to zero length if requested
  if (oflag & O_TRUNC) return truncate(0);
  return true;
}
9d003594:	02401021 	move	v0,s2
9d003598:	8fb20018 	lw	s2,24(sp)
9d00359c:	8fb10014 	lw	s1,20(sp)
9d0035a0:	8fb00010 	lw	s0,16(sp)
9d0035a4:	03e00008 	jr	ra
9d0035a8:	27bd0020 	addiu	sp,sp,32
  // make sure it is a normal file or subdirectory
  if (DIR_IS_FILE(p)) {
    fileSize_ = p->fileSize;
    type_ = FAT_FILE_TYPE_NORMAL;
  } else if (DIR_IS_SUBDIR(p)) {
    if (!vol_->chainSize(firstCluster_, &fileSize_)) return false;
9d0035ac:	8e040020 	lw	a0,32(s0)
9d0035b0:	0f400fbe 	jal	9d003ef8 <_ZNK8SdVolume9chainSizeEmPm>
9d0035b4:	26060018 	addiu	a2,s0,24
9d0035b8:	1040ffee 	beqz	v0,9d003574 <_ZN6SdFile15openCachedEntryEhh+0xf0>
9d0035bc:	24020004 	li	v0,4
    type_ = FAT_FILE_TYPE_SUBDIR;
9d0035c0:	0b400d4c 	j	9d003530 <_ZN6SdFile15openCachedEntryEhh+0xac>
9d0035c4:	a2020005 	sb	v0,5(s0)

9d0035c8 <_ZN6SdFile4openEPS_PKch>:
 * the value zero, false, is returned for failure.
 * Reasons for failure include this SdFile is already open, \a difFile is not
 * a directory, \a fileName is invalid, the file does not exist
 * or can't be opened in the access mode specified by oflag.
 */
uint8_t SdFile::open(SdFile* dirFile, const char* fileName, uint8_t oflag) {
9d0035c8:	27bdffc0 	addiu	sp,sp,-64
9d0035cc:	afb50038 	sw	s5,56(sp)
9d0035d0:	afb40034 	sw	s4,52(sp)
9d0035d4:	afb2002c 	sw	s2,44(sp)
9d0035d8:	afbf003c 	sw	ra,60(sp)
9d0035dc:	afb30030 	sw	s3,48(sp)
9d0035e0:	afb10028 	sw	s1,40(sp)
9d0035e4:	afb00024 	sw	s0,36(sp)
    uint8_t dname[11];
    dir_t* p;

    // error if already open
    if (isOpen()) {
9d0035e8:	90820005 	lbu	v0,5(a0)
 * the value zero, false, is returned for failure.
 * Reasons for failure include this SdFile is already open, \a difFile is not
 * a directory, \a fileName is invalid, the file does not exist
 * or can't be opened in the access mode specified by oflag.
 */
uint8_t SdFile::open(SdFile* dirFile, const char* fileName, uint8_t oflag) {
9d0035ec:	00809021 	move	s2,a0
9d0035f0:	00a0a821 	move	s5,a1
    uint8_t dname[11];
    dir_t* p;

    // error if already open
    if (isOpen()) {
9d0035f4:	1040000e 	beqz	v0,9d003630 <_ZN6SdFile4openEPS_PKch+0x68>
9d0035f8:	30f400ff 	andi	s4,a3,0xff
        errno = 16;
9d0035fc:	24020010 	li	v0,16
9d003600:	a38280e0 	sb	v0,-32544(gp)
        return false;
9d003604:	00001821 	move	v1,zero
  }

  // open entry in cache
  errno = 0;
  return openCachedEntry(dirIndex_, oflag);
}
9d003608:	8fbf003c 	lw	ra,60(sp)
9d00360c:	00601021 	move	v0,v1
9d003610:	8fb50038 	lw	s5,56(sp)
9d003614:	8fb40034 	lw	s4,52(sp)
9d003618:	8fb30030 	lw	s3,48(sp)
9d00361c:	8fb2002c 	lw	s2,44(sp)
9d003620:	8fb10028 	lw	s1,40(sp)
9d003624:	8fb00024 	lw	s0,36(sp)
9d003628:	03e00008 	jr	ra
9d00362c:	27bd0040 	addiu	sp,sp,64
    if (isOpen()) {
        errno = 16;
        return false;
    }

  if (!make83Name(fileName, dname)) return false;
9d003630:	00c02021 	move	a0,a2
9d003634:	0f400afb 	jal	9d002bec <_ZN6SdFile10make83NameEPKcPh>
9d003638:	27a50010 	addiu	a1,sp,16
9d00363c:	1040fff2 	beqz	v0,9d003608 <_ZN6SdFile4openEPS_PKch+0x40>
9d003640:	00001821 	move	v1,zero
  vol_ = dirFile->vol_;
9d003644:	8ea20020 	lw	v0,32(s5)
  int8_t readDir(dir_t* dir);
  static uint8_t remove(SdFile* dirFile, const char* fileName);
  uint8_t remove(void);
  /** Set the file's current position to zero. */
  void rewind(void) {
    curPosition_ = curCluster_ = 0;
9d003648:	aea00008 	sw	zero,8(s5)
9d00364c:	aea0000c 	sw	zero,12(s5)
9d003650:	ae420020 	sw	v0,32(s2)
  dirFile->rewind();

  // bool for empty entry found
  uint8_t emptyFound = false;
9d003654:	00008021 	move	s0,zero

  // search for file
  while (dirFile->curPosition_ < dirFile->fileSize_) {
9d003658:	00001021 	move	v0,zero
    if (p == NULL) {
      errno = 5;
      return false;
    }

    if (p->name[0] == DIR_NAME_FREE || p->name[0] == DIR_NAME_DELETED) {
9d00365c:	241300e5 	li	s3,229

  // bool for empty entry found
  uint8_t emptyFound = false;

  // search for file
  while (dirFile->curPosition_ < dirFile->fileSize_) {
9d003660:	8ea30018 	lw	v1,24(s5)
    uint8_t index = 0XF & (dirFile->curPosition_ >> 5);
9d003664:	7c511940 	ext	s1,v0,0x5,0x4

  // bool for empty entry found
  uint8_t emptyFound = false;

  // search for file
  while (dirFile->curPosition_ < dirFile->fileSize_) {
9d003668:	0043102b 	sltu	v0,v0,v1
9d00366c:	1040001a 	beqz	v0,9d0036d8 <_ZN6SdFile4openEPS_PKch+0x110>
9d003670:	02a02021 	move	a0,s5
    uint8_t index = 0XF & (dirFile->curPosition_ >> 5);
    p = dirFile->readDirCache();
9d003674:	0f400c03 	jal	9d00300c <_ZN6SdFile12readDirCacheEv>
9d003678:	00000000 	nop
    if (p == NULL) {
9d00367c:	5040001d 	beqzl	v0,9d0036f4 <_ZN6SdFile4openEPS_PKch+0x12c>
9d003680:	24020005 	li	v0,5
      errno = 5;
      return false;
    }

    if (p->name[0] == DIR_NAME_FREE || p->name[0] == DIR_NAME_DELETED) {
9d003684:	90430000 	lbu	v1,0(v0)
9d003688:	1060000a 	beqz	v1,9d0036b4 <_ZN6SdFile4openEPS_PKch+0xec>
9d00368c:	27a40010 	addiu	a0,sp,16
        dirIndex_ = index;
        dirBlock_ = SdVolume::cacheBlockNumber_;
      }
      // done if no entries follow
      if (p->name[0] == DIR_NAME_FREE) break;
    } else if (!memcmp(dname, p->name, 11)) {
9d003690:	00402821 	move	a1,v0
    if (p == NULL) {
      errno = 5;
      return false;
    }

    if (p->name[0] == DIR_NAME_FREE || p->name[0] == DIR_NAME_DELETED) {
9d003694:	10730007 	beq	v1,s3,9d0036b4 <_ZN6SdFile4openEPS_PKch+0xec>
9d003698:	2406000b 	li	a2,11
        dirIndex_ = index;
        dirBlock_ = SdVolume::cacheBlockNumber_;
      }
      // done if no entries follow
      if (p->name[0] == DIR_NAME_FREE) break;
    } else if (!memcmp(dname, p->name, 11)) {
9d00369c:	0f401ebd 	jal	9d007af4 <memcmp>
9d0036a0:	00000000 	nop
9d0036a4:	10400016 	beqz	v0,9d003700 <_ZN6SdFile4openEPS_PKch+0x138>
9d0036a8:	32830030 	andi	v1,s4,0x30
	errno = 17;
	return false;
      }

      // open found file
      return openCachedEntry(0XF & index, oflag);
9d0036ac:	0b400d98 	j	9d003660 <_ZN6SdFile4openEPS_PKch+0x98>
9d0036b0:	8ea2000c 	lw	v0,12(s5)
      return false;
    }

    if (p->name[0] == DIR_NAME_FREE || p->name[0] == DIR_NAME_DELETED) {
      // remember first empty slot
      if (!emptyFound) {
9d0036b4:	16000005 	bnez	s0,9d0036cc <_ZN6SdFile4openEPS_PKch+0x104>
9d0036b8:	00000000 	nop
        emptyFound = true;
        dirIndex_ = index;
9d0036bc:	a2510014 	sb	s1,20(s2)
        dirBlock_ = SdVolume::cacheBlockNumber_;
9d0036c0:	8f838010 	lw	v1,-32752(gp)
9d0036c4:	ae430010 	sw	v1,16(s2)
9d0036c8:	90430000 	lbu	v1,0(v0)
      }
      // done if no entries follow
      if (p->name[0] == DIR_NAME_FREE) break;
9d0036cc:	1460fff7 	bnez	v1,9d0036ac <_ZN6SdFile4openEPS_PKch+0xe4>
9d0036d0:	24100001 	li	s0,1
9d0036d4:	24100001 	li	s0,1
      // open found file
      return openCachedEntry(0XF & index, oflag);
    }
  }
  // only create file if O_CREAT and O_WRITE
  if ((oflag & (O_CREAT | O_WRITE)) != (O_CREAT | O_WRITE)) {
9d0036d8:	32830012 	andi	v1,s4,0x12
9d0036dc:	24020012 	li	v0,18
9d0036e0:	1062000e 	beq	v1,v0,9d00371c <_ZN6SdFile4openEPS_PKch+0x154>
9d0036e4:	24020002 	li	v0,2
	errno = 2;
9d0036e8:	a38280e0 	sb	v0,-32544(gp)
	return false;
9d0036ec:	0b400d82 	j	9d003608 <_ZN6SdFile4openEPS_PKch+0x40>
9d0036f0:	00001821 	move	v1,zero
  p->lastWriteDate = p->creationDate;
  p->lastWriteTime = p->creationTime;

  // force write of entry to SD
  if (!SdVolume::cacheFlush()) {
	errno = 5;
9d0036f4:	a38280e0 	sb	v0,-32544(gp)
	return false;
9d0036f8:	0b400d82 	j	9d003608 <_ZN6SdFile4openEPS_PKch+0x40>
9d0036fc:	00001821 	move	v1,zero
      }
      // done if no entries follow
      if (p->name[0] == DIR_NAME_FREE) break;
    } else if (!memcmp(dname, p->name, 11)) {
      // don't open existing file if O_CREAT and O_EXCL
      if ((oflag & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL)) {
9d003700:	24020030 	li	v0,48
9d003704:	14620040 	bne	v1,v0,9d003808 <_ZN6SdFile4openEPS_PKch+0x240>
9d003708:	02402021 	move	a0,s2
	errno = 17;
9d00370c:	24020011 	li	v0,17
9d003710:	a38280e0 	sb	v0,-32544(gp)
	return false;
9d003714:	0b400d82 	j	9d003608 <_ZN6SdFile4openEPS_PKch+0x40>
9d003718:	00001821 	move	v1,zero
	errno = 2;
	return false;
  }

  // cache found slot or add cluster if end of file
  if (emptyFound) {
9d00371c:	1600003f 	bnez	s0,9d00381c <_ZN6SdFile4openEPS_PKch+0x254>
9d003720:	24020002 	li	v0,2
    if (!p) {
	errno = 12;
	return false;
    }
  } else {
    if (dirFile->type_ == FAT_FILE_TYPE_ROOT16) {
9d003724:	92a30005 	lbu	v1,5(s5)
9d003728:	10620045 	beq	v1,v0,9d003840 <_ZN6SdFile4openEPS_PKch+0x278>
9d00372c:	2402000e 	li	v0,14
	errno = 14;
	return false;
    }

    // add and zero cluster for dirFile - first cluster is in cache for write
    if (!dirFile->addDirCluster()) {
9d003730:	0f400ab7 	jal	9d002adc <_ZN6SdFile13addDirClusterEv>
9d003734:	02a02021 	move	a0,s5
9d003738:	10400044 	beqz	v0,9d00384c <_ZN6SdFile4openEPS_PKch+0x284>
9d00373c:	3c10a000 	lui	s0,0xa000
	errno = 28;
	return false;
    }

    // use first entry in cluster
    dirIndex_ = 0;
9d003740:	a2400014 	sb	zero,20(s2)
    p = SdVolume::cacheBuffer_.dir;
9d003744:	26100aa4 	addiu	s0,s0,2724
  }
  // initialize as empty file
  memset(p, 0, sizeof(dir_t));
9d003748:	02002021 	move	a0,s0
9d00374c:	00002821 	move	a1,zero
9d003750:	0f401ed5 	jal	9d007b54 <memset>
9d003754:	24060020 	li	a2,32
  memcpy(p->name, dname, 11);
9d003758:	8fa30010 	lw	v1,16(sp)
9d00375c:	8fa20014 	lw	v0,20(sp)
9d003760:	aa030003 	swl	v1,3(s0)
9d003764:	ba030000 	swr	v1,0(s0)
9d003768:	aa020007 	swl	v0,7(s0)
9d00376c:	ba020004 	swr	v0,4(s0)
9d003770:	93a20018 	lbu	v0,24(sp)
9d003774:	a2020008 	sb	v0,8(s0)
9d003778:	93a20019 	lbu	v0,25(sp)
9d00377c:	a2020009 	sb	v0,9(s0)
9d003780:	93a2001a 	lbu	v0,26(sp)
9d003784:	a202000a 	sb	v0,10(s0)

  // set timestamps
  if (dateTime_) {
9d003788:	8f82802c 	lw	v0,-32724(gp)
9d00378c:	10400033 	beqz	v0,9d00385c <_ZN6SdFile4openEPS_PKch+0x294>
9d003790:	26040010 	addiu	a0,s0,16
    // call user function
    dateTime_(&p->creationDate, &p->creationTime);
9d003794:	0040f809 	jalr	v0
9d003798:	2605000e 	addiu	a1,s0,14
9d00379c:	92030011 	lbu	v1,17(s0)
9d0037a0:	9202000f 	lbu	v0,15(s0)
9d0037a4:	92050010 	lbu	a1,16(s0)
9d0037a8:	9204000e 	lbu	a0,14(s0)
9d0037ac:	00031a00 	sll	v1,v1,0x8
9d0037b0:	00021200 	sll	v0,v0,0x8
9d0037b4:	00651825 	or	v1,v1,a1
9d0037b8:	00441025 	or	v0,v0,a0
  } else {
    // use default date/time
    p->creationDate = FAT_DEFAULT_DATE;
    p->creationTime = FAT_DEFAULT_TIME;
  }
  p->lastAccessDate = p->creationDate;
9d0037bc:	306400ff 	andi	a0,v1,0xff
  p->lastWriteDate = p->creationDate;
  p->lastWriteTime = p->creationTime;
9d0037c0:	00022a02 	srl	a1,v0,0x8
  } else {
    // use default date/time
    p->creationDate = FAT_DEFAULT_DATE;
    p->creationTime = FAT_DEFAULT_TIME;
  }
  p->lastAccessDate = p->creationDate;
9d0037c4:	00031a02 	srl	v1,v1,0x8
9d0037c8:	a2040012 	sb	a0,18(s0)
9d0037cc:	a2030013 	sb	v1,19(s0)
  p->lastWriteDate = p->creationDate;
9d0037d0:	a2040018 	sb	a0,24(s0)
9d0037d4:	a2030019 	sb	v1,25(s0)
  p->lastWriteTime = p->creationTime;
9d0037d8:	a2020016 	sb	v0,22(s0)

  // force write of entry to SD
  if (!SdVolume::cacheFlush()) {
9d0037dc:	0f400f24 	jal	9d003c90 <_ZN8SdVolume10cacheFlushEv>
9d0037e0:	a2050017 	sb	a1,23(s0)
9d0037e4:	1040ffc3 	beqz	v0,9d0036f4 <_ZN6SdFile4openEPS_PKch+0x12c>
9d0037e8:	24020005 	li	v0,5
	errno = 5;
	return false;
  }

  // open entry in cache
  errno = 0;
9d0037ec:	a38080e0 	sb	zero,-32544(gp)
  return openCachedEntry(dirIndex_, oflag);
9d0037f0:	92450014 	lbu	a1,20(s2)
9d0037f4:	02402021 	move	a0,s2
9d0037f8:	0f400d21 	jal	9d003484 <_ZN6SdFile15openCachedEntryEhh>
9d0037fc:	02803021 	move	a2,s4
9d003800:	0b400d82 	j	9d003608 <_ZN6SdFile4openEPS_PKch+0x40>
9d003804:	00401821 	move	v1,v0
	errno = 17;
	return false;
      }

      // open found file
      return openCachedEntry(0XF & index, oflag);
9d003808:	02202821 	move	a1,s1
9d00380c:	0f400d21 	jal	9d003484 <_ZN6SdFile15openCachedEntryEhh>
9d003810:	02803021 	move	a2,s4
9d003814:	0b400d82 	j	9d003608 <_ZN6SdFile4openEPS_PKch+0x40>
9d003818:	00401821 	move	v1,v0
	return false;
  }

  // cache found slot or add cluster if end of file
  if (emptyFound) {
    p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
9d00381c:	02402021 	move	a0,s2
9d003820:	0f400ae8 	jal	9d002ba0 <_ZN6SdFile13cacheDirEntryEh>
9d003824:	24050001 	li	a1,1
    if (!p) {
9d003828:	1440ffc7 	bnez	v0,9d003748 <_ZN6SdFile4openEPS_PKch+0x180>
9d00382c:	00408021 	move	s0,v0
	errno = 12;
9d003830:	2402000c 	li	v0,12
9d003834:	a38280e0 	sb	v0,-32544(gp)
	return false;
9d003838:	0b400d82 	j	9d003608 <_ZN6SdFile4openEPS_PKch+0x40>
9d00383c:	00001821 	move	v1,zero
    }
  } else {
    if (dirFile->type_ == FAT_FILE_TYPE_ROOT16) {
	errno = 14;
9d003840:	a38280e0 	sb	v0,-32544(gp)
	return false;
9d003844:	0b400d82 	j	9d003608 <_ZN6SdFile4openEPS_PKch+0x40>
9d003848:	00001821 	move	v1,zero
    }

    // add and zero cluster for dirFile - first cluster is in cache for write
    if (!dirFile->addDirCluster()) {
	errno = 28;
9d00384c:	2402001c 	li	v0,28
9d003850:	a38280e0 	sb	v0,-32544(gp)
	return false;
9d003854:	0b400d82 	j	9d003608 <_ZN6SdFile4openEPS_PKch+0x40>
9d003858:	00001821 	move	v1,zero
  if (dateTime_) {
    // call user function
    dateTime_(&p->creationDate, &p->creationTime);
  } else {
    // use default date/time
    p->creationDate = FAT_DEFAULT_DATE;
9d00385c:	24020021 	li	v0,33
9d003860:	a2020010 	sb	v0,16(s0)
9d003864:	24020028 	li	v0,40
9d003868:	a2020011 	sb	v0,17(s0)
    p->creationTime = FAT_DEFAULT_TIME;
9d00386c:	24020008 	li	v0,8
9d003870:	a202000f 	sb	v0,15(s0)
9d003874:	a200000e 	sb	zero,14(s0)
9d003878:	24020800 	li	v0,2048
9d00387c:	0b400def 	j	9d0037bc <_ZN6SdFile4openEPS_PKch+0x1f4>
9d003880:	24032821 	li	v1,10273

9d003884 <_ZN6SdFile6removeEPS_PKc>:
 * the value zero, false, is returned for failure.
 * Reasons for failure include the file is a directory, is read only,
 * \a dirFile is not a directory, \a fileName is not found
 * or an I/O error occurred.
 */
uint8_t SdFile::remove(SdFile* dirFile, const char* fileName) {
9d003884:	00801021 	move	v0,a0
9d003888:	27bdffc0 	addiu	sp,sp,-64
9d00388c:	00a03021 	move	a2,a1
  SdFile file;
  if (!file.open(dirFile, fileName, O_WRITE)) return false;
9d003890:	00402821 	move	a1,v0
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
9d003894:	3c029d01 	lui	v0,0x9d01
9d003898:	24428840 	addiu	v0,v0,-30656
9d00389c:	27a40010 	addiu	a0,sp,16
9d0038a0:	24070002 	li	a3,2
 * the value zero, false, is returned for failure.
 * Reasons for failure include the file is a directory, is read only,
 * \a dirFile is not a directory, \a fileName is not found
 * or an I/O error occurred.
 */
uint8_t SdFile::remove(SdFile* dirFile, const char* fileName) {
9d0038a4:	afbf003c 	sw	ra,60(sp)
9d0038a8:	afa20010 	sw	v0,16(sp)
  SdFile file;
  if (!file.open(dirFile, fileName, O_WRITE)) return false;
9d0038ac:	0f400d72 	jal	9d0035c8 <_ZN6SdFile4openEPS_PKch>
9d0038b0:	a3a00015 	sb	zero,21(sp)
9d0038b4:	10400004 	beqz	v0,9d0038c8 <_ZN6SdFile6removeEPS_PKc+0x44>
9d0038b8:	00001821 	move	v1,zero
  return file.remove();
9d0038bc:	0f400d0a 	jal	9d003428 <_ZN6SdFile6removeEv>
9d0038c0:	27a40010 	addiu	a0,sp,16
9d0038c4:	00401821 	move	v1,v0
}
9d0038c8:	8fbf003c 	lw	ra,60(sp)
9d0038cc:	00601021 	move	v0,v1
9d0038d0:	03e00008 	jr	ra
9d0038d4:	27bd0040 	addiu	sp,sp,64

9d0038d8 <_ZN6SdFile5writeEPKvt>:
 * \a nbyte.  If an error occurs, write() returns -1.  Possible errors
 * include write() is called before a file has been opened, write is called
 * for a read-only file, device is full, a corrupt file system or an I/O error.
 *
 */
size_t SdFile::write(const void* buf, uint16_t nbyte) {
9d0038d8:	27bdffb8 	addiu	sp,sp,-72
9d0038dc:	afbe0040 	sw	s8,64(sp)
9d0038e0:	afb3002c 	sw	s3,44(sp)
9d0038e4:	afb10024 	sw	s1,36(sp)
9d0038e8:	afb00020 	sw	s0,32(sp)
9d0038ec:	afbf0044 	sw	ra,68(sp)
9d0038f0:	afb7003c 	sw	s7,60(sp)
9d0038f4:	afb60038 	sw	s6,56(sp)
9d0038f8:	afb50034 	sw	s5,52(sp)
9d0038fc:	afb40030 	sw	s4,48(sp)
9d003900:	afb20028 	sw	s2,40(sp)

  // number of bytes left to write  -  must be before goto statements
  uint16_t nToWrite = nbyte;

  // error if not a normal file or is read-only
  if (!isFile() || !(flags_ & O_WRITE)) goto writeErrorReturn;
9d003904:	90820005 	lbu	v0,5(a0)
9d003908:	24030001 	li	v1,1
 * \a nbyte.  If an error occurs, write() returns -1.  Possible errors
 * include write() is called before a file has been opened, write is called
 * for a read-only file, device is full, a corrupt file system or an I/O error.
 *
 */
size_t SdFile::write(const void* buf, uint16_t nbyte) {
9d00390c:	00809821 	move	s3,a0
9d003910:	00a0f021 	move	s8,a1
9d003914:	30d1ffff 	andi	s1,a2,0xffff

  // number of bytes left to write  -  must be before goto statements
  uint16_t nToWrite = nbyte;

  // error if not a normal file or is read-only
  if (!isFile() || !(flags_ & O_WRITE)) goto writeErrorReturn;
9d003918:	1043000e 	beq	v0,v1,9d003954 <_ZN6SdFile5writeEPKvt+0x7c>
9d00391c:	00008021 	move	s0,zero
 writeErrorReturn:
  // return for write error
  //writeError = true;
  //setWriteError();
  return 0;
}
9d003920:	8fbf0044 	lw	ra,68(sp)
9d003924:	02001021 	move	v0,s0
9d003928:	8fbe0040 	lw	s8,64(sp)
9d00392c:	8fb7003c 	lw	s7,60(sp)
9d003930:	8fb60038 	lw	s6,56(sp)
9d003934:	8fb50034 	lw	s5,52(sp)
9d003938:	8fb40030 	lw	s4,48(sp)
9d00393c:	8fb3002c 	lw	s3,44(sp)
9d003940:	8fb20028 	lw	s2,40(sp)
9d003944:	8fb10024 	lw	s1,36(sp)
9d003948:	8fb00020 	lw	s0,32(sp)
9d00394c:	03e00008 	jr	ra
9d003950:	27bd0048 	addiu	sp,sp,72

  // number of bytes left to write  -  must be before goto statements
  uint16_t nToWrite = nbyte;

  // error if not a normal file or is read-only
  if (!isFile() || !(flags_ & O_WRITE)) goto writeErrorReturn;
9d003954:	90820004 	lbu	v0,4(a0)
9d003958:	30430002 	andi	v1,v0,0x2
9d00395c:	1060fff1 	beqz	v1,9d003924 <_ZN6SdFile5writeEPKvt+0x4c>
9d003960:	8fbf0044 	lw	ra,68(sp)

  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
9d003964:	30420004 	andi	v0,v0,0x4
9d003968:	10400009 	beqz	v0,9d003990 <_ZN6SdFile5writeEPKvt+0xb8>
9d00396c:	8e76000c 	lw	s6,12(s3)
9d003970:	8e650018 	lw	a1,24(s3)
9d003974:	12c50006 	beq	s6,a1,9d003990 <_ZN6SdFile5writeEPKvt+0xb8>
9d003978:	00000000 	nop
  }
  /**
   *  Set the files current position to end of file.  Useful to position
   *  a file for append. See seekSet().
   */
  uint8_t seekEnd(void) {return seekSet(fileSize_);}
9d00397c:	0f400c23 	jal	9d00308c <_ZN6SdFile7seekSetEm>
9d003980:	00000000 	nop
    if (!seekEnd()) goto writeErrorReturn;
9d003984:	1040ffe7 	beqz	v0,9d003924 <_ZN6SdFile5writeEPKvt+0x4c>
9d003988:	8fbf0044 	lw	ra,68(sp)
9d00398c:	8e76000c 	lw	s6,12(s3)
  }

  while (nToWrite > 0) {
9d003990:	52200032 	beqzl	s1,9d003a5c <_ZN6SdFile5writeEPKvt+0x184>
9d003994:	8e620018 	lw	v0,24(s3)
  uint8_t fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
  }
  uint8_t freeChain(uint32_t cluster);
  uint8_t isEOC(uint32_t cluster) const {
    return  cluster >= (fatType_ == 16 ? FAT16EOC_MIN : FAT32EOC_MIN);
9d003998:	3c120fff 	lui	s2,0xfff
        // rewrite part of block
        if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) {
          goto writeErrorReturn;
        }
      }
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
9d00399c:	3c10a000 	lui	s0,0xa000
 * for a read-only file, device is full, a corrupt file system or an I/O error.
 *
 */
size_t SdFile::write(const void* buf, uint16_t nbyte) {
  // convert void* to uint8_t*  -  must be before goto statements
  const uint8_t* src = reinterpret_cast<const uint8_t*>(buf);
9d0039a0:	0220a821 	move	s5,s1
9d0039a4:	3652fff8 	ori	s2,s2,0xfff8
        // rewrite part of block
        if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) {
          goto writeErrorReturn;
        }
      }
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
9d0039a8:	26100aa4 	addiu	s0,s0,2724
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    if (!seekEnd()) goto writeErrorReturn;
  }

  while (nToWrite > 0) {
    uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
9d0039ac:	8e640020 	lw	a0,32(s3)
  uint16_t rootDirEntryCount_;  // number of entries in FAT16 root dir
  uint32_t rootDirStart_;       // root start block for FAT16, cluster for FAT32
  //----------------------------------------------------------------------------
  uint8_t allocContiguous(uint32_t count, uint32_t* curCluster);
  uint8_t blockOfCluster(uint32_t position) const {
          return (position >> 9) & (blocksPerCluster_ - 1);}
9d0039b0:	00161242 	srl	v0,s6,0x9
9d0039b4:	90970004 	lbu	s7,4(a0)
9d0039b8:	26f7ffff 	addiu	s7,s7,-1
9d0039bc:	0057b824 	and	s7,v0,s7
9d0039c0:	32f700ff 	andi	s7,s7,0xff
    uint16_t blockOffset = curPosition_ & 0X1FF;
    if (blockOfCluster == 0 && blockOffset == 0) {
9d0039c4:	16e0004e 	bnez	s7,9d003b00 <_ZN6SdFile5writeEPKvt+0x228>
9d0039c8:	32d601ff 	andi	s6,s6,0x1ff
9d0039cc:	56c0004d 	bnezl	s6,9d003b04 <_ZN6SdFile5writeEPKvt+0x22c>
9d0039d0:	24020200 	li	v0,512
      // start of new cluster
      if (curCluster_ == 0) {
9d0039d4:	8e650008 	lw	a1,8(s3)
9d0039d8:	14a00038 	bnez	a1,9d003abc <_ZN6SdFile5writeEPKvt+0x1e4>
9d0039dc:	00000000 	nop
        if (firstCluster_ == 0) {
9d0039e0:	8e63001c 	lw	v1,28(s3)
9d0039e4:	10600041 	beqz	v1,9d003aec <_ZN6SdFile5writeEPKvt+0x214>
9d0039e8:	24020200 	li	v0,512
          curCluster_ = next;
        }
      }
    }
    // max space in block
    uint16_t n = 512 - blockOffset;
9d0039ec:	0056a023 	subu	s4,v0,s6
9d0039f0:	3294ffff 	andi	s4,s4,0xffff

    // lesser of space and amount to write
    if (n > nToWrite) n = nToWrite;
9d0039f4:	02b4282b 	sltu	a1,s5,s4
9d0039f8:	14a00047 	bnez	a1,9d003b18 <_ZN6SdFile5writeEPKvt+0x240>
9d0039fc:	ae630008 	sw	v1,8(s3)
  uint32_t clusterStartBlock(uint32_t cluster) const {
           return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);}
9d003a00:	8c850014 	lw	a1,20(a0)
9d003a04:	90840010 	lbu	a0,16(a0)
9d003a08:	2463fffe 	addiu	v1,v1,-2
9d003a0c:	02e5b821 	addu	s7,s7,a1
9d003a10:	00831804 	sllv	v1,v1,a0

    // block for data write
    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
    if (n == 512) {
9d003a14:	16820047 	bne	s4,v0,9d003b34 <_ZN6SdFile5writeEPKvt+0x25c>
9d003a18:	02e32821 	addu	a1,s7,v1
      // full block - don't need to use cache
      // invalidate cache if block is in cache
      if (SdVolume::cacheBlockNumber_ == block) {
9d003a1c:	8f828010 	lw	v0,-32752(gp)
9d003a20:	1045006c 	beq	v0,a1,9d003bd4 <_ZN6SdFile5writeEPKvt+0x2fc>
9d003a24:	2402ffff 	li	v0,-1
  uint8_t readData(uint32_t block, uint16_t offset,
    uint16_t count, uint8_t* dst) {
      return sdCard_->readData(block, offset, count, dst);
  }
  uint8_t writeBlock(uint32_t block, const uint8_t* dst) {
    return sdCard_->writeBlock(block, dst);
9d003a28:	8f848030 	lw	a0,-32720(gp)
9d003a2c:	0f400a66 	jal	9d002998 <_ZN7Sd2Card10writeBlockEmPKh>
9d003a30:	03c03021 	move	a2,s8
        SdVolume::cacheBlockNumber_ = 0XFFFFFFFF;
      }
      if (!vol_->writeBlock(block, src)) goto writeErrorReturn;
9d003a34:	10400069 	beqz	v0,9d003bdc <_ZN6SdFile5writeEPKvt+0x304>
9d003a38:	27de0200 	addiu	s8,s8,512
      src += 512;
9d003a3c:	24160200 	li	s6,512
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
      uint8_t* end = dst + n;
      while (dst != end) *dst++ = *src++;
    }
    nToWrite -= n;
    curPosition_ += n;
9d003a40:	8e62000c 	lw	v0,12(s3)
      }
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
      uint8_t* end = dst + n;
      while (dst != end) *dst++ = *src++;
    }
    nToWrite -= n;
9d003a44:	02b4a823 	subu	s5,s5,s4
9d003a48:	32b5ffff 	andi	s5,s5,0xffff
    curPosition_ += n;
9d003a4c:	02c2b021 	addu	s6,s6,v0
  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    if (!seekEnd()) goto writeErrorReturn;
  }

  while (nToWrite > 0) {
9d003a50:	16a0ffd6 	bnez	s5,9d0039ac <_ZN6SdFile5writeEPKvt+0xd4>
9d003a54:	ae76000c 	sw	s6,12(s3)
      while (dst != end) *dst++ = *src++;
    }
    nToWrite -= n;
    curPosition_ += n;
  }
  if (curPosition_ > fileSize_) {
9d003a58:	8e620018 	lw	v0,24(s3)
9d003a5c:	0056102b 	sltu	v0,v0,s6
9d003a60:	1040006c 	beqz	v0,9d003c14 <_ZN6SdFile5writeEPKvt+0x33c>
9d003a64:	8f82802c 	lw	v0,-32724(gp)
    // update fileSize and insure sync will update dir entry
    fileSize_ = curPosition_;
    flags_ |= F_FILE_DIR_DIRTY;
9d003a68:	92620004 	lbu	v0,4(s3)
    nToWrite -= n;
    curPosition_ += n;
  }
  if (curPosition_ > fileSize_) {
    // update fileSize and insure sync will update dir entry
    fileSize_ = curPosition_;
9d003a6c:	ae760018 	sw	s6,24(s3)
    flags_ |= F_FILE_DIR_DIRTY;
9d003a70:	3042007f 	andi	v0,v0,0x7f
9d003a74:	34420080 	ori	v0,v0,0x80
9d003a78:	a2620004 	sb	v0,4(s3)
  } else if (dateTime_ && nbyte) {
    // insure sync will update modified date and time
    flags_ |= F_FILE_DIR_DIRTY;
  }

  if (flags_ & O_SYNC) {
9d003a7c:	30420008 	andi	v0,v0,0x8
9d003a80:	14400045 	bnez	v0,9d003b98 <_ZN6SdFile5writeEPKvt+0x2c0>
9d003a84:	02208021 	move	s0,s1
 writeErrorReturn:
  // return for write error
  //writeError = true;
  //setWriteError();
  return 0;
}
9d003a88:	8fbf0044 	lw	ra,68(sp)
9d003a8c:	02001021 	move	v0,s0
9d003a90:	8fbe0040 	lw	s8,64(sp)
9d003a94:	8fb7003c 	lw	s7,60(sp)
9d003a98:	8fb60038 	lw	s6,56(sp)
9d003a9c:	8fb50034 	lw	s5,52(sp)
9d003aa0:	8fb40030 	lw	s4,48(sp)
9d003aa4:	8fb3002c 	lw	s3,44(sp)
9d003aa8:	8fb20028 	lw	s2,40(sp)
9d003aac:	8fb10024 	lw	s1,36(sp)
9d003ab0:	8fb00020 	lw	s0,32(sp)
9d003ab4:	03e00008 	jr	ra
9d003ab8:	27bd0048 	addiu	sp,sp,72
        } else {
          curCluster_ = firstCluster_;
        }
      } else {
        uint32_t next;
        if (!vol_->fatGet(curCluster_, &next)) return false;
9d003abc:	0f400f89 	jal	9d003e24 <_ZNK8SdVolume6fatGetEmPm>
9d003ac0:	27a60010 	addiu	a2,sp,16
9d003ac4:	10400045 	beqz	v0,9d003bdc <_ZN6SdFile5writeEPKvt+0x304>
9d003ac8:	8fa30010 	lw	v1,16(sp)
        if (vol_->isEOC(next)) {
9d003acc:	8e640020 	lw	a0,32(s3)
  uint8_t fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
  }
  uint8_t freeChain(uint32_t cluster);
  uint8_t isEOC(uint32_t cluster) const {
    return  cluster >= (fatType_ == 16 ? FAT16EOC_MIN : FAT32EOC_MIN);
9d003ad0:	3402fff8 	li	v0,0xfff8
9d003ad4:	90850020 	lbu	a1,32(a0)
9d003ad8:	38a50010 	xori	a1,a1,0x10
9d003adc:	0245100b 	movn	v0,s2,a1
9d003ae0:	0062102b 	sltu	v0,v1,v0
9d003ae4:	1440ffc1 	bnez	v0,9d0039ec <_ZN6SdFile5writeEPKvt+0x114>
9d003ae8:	24020200 	li	v0,512
          // add cluster if at end of chain
          if (!addCluster()) goto writeErrorReturn;
9d003aec:	0f400a9f 	jal	9d002a7c <_ZN6SdFile10addClusterEv>
9d003af0:	02602021 	move	a0,s3
9d003af4:	1040003a 	beqz	v0,9d003be0 <_ZN6SdFile5writeEPKvt+0x308>
9d003af8:	8fbf0044 	lw	ra,68(sp)
9d003afc:	8e640020 	lw	a0,32(s3)
          curCluster_ = next;
        }
      }
    }
    // max space in block
    uint16_t n = 512 - blockOffset;
9d003b00:	24020200 	li	v0,512
9d003b04:	0056a023 	subu	s4,v0,s6
9d003b08:	3294ffff 	andi	s4,s4,0xffff

    // lesser of space and amount to write
    if (n > nToWrite) n = nToWrite;
9d003b0c:	02b4282b 	sltu	a1,s5,s4
9d003b10:	10a0ffbb 	beqz	a1,9d003a00 <_ZN6SdFile5writeEPKvt+0x128>
9d003b14:	8e630008 	lw	v1,8(s3)
  //----------------------------------------------------------------------------
  uint8_t allocContiguous(uint32_t count, uint32_t* curCluster);
  uint8_t blockOfCluster(uint32_t position) const {
          return (position >> 9) & (blocksPerCluster_ - 1);}
  uint32_t clusterStartBlock(uint32_t cluster) const {
           return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);}
9d003b18:	8c850014 	lw	a1,20(a0)
9d003b1c:	90820010 	lbu	v0,16(a0)
9d003b20:	2463fffe 	addiu	v1,v1,-2
9d003b24:	02e5b821 	addu	s7,s7,a1
9d003b28:	00431804 	sllv	v1,v1,v0

    // block for data write
    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
9d003b2c:	02e32821 	addu	a1,s7,v1
9d003b30:	02a0a021 	move	s4,s5
        SdVolume::cacheBlockNumber_ = 0XFFFFFFFF;
      }
      if (!vol_->writeBlock(block, src)) goto writeErrorReturn;
      src += 512;
    } else {
      if (blockOffset == 0 && curPosition_ >= fileSize_) {
9d003b34:	16c00006 	bnez	s6,9d003b50 <_ZN6SdFile5writeEPKvt+0x278>
9d003b38:	00a02021 	move	a0,a1
9d003b3c:	8e63000c 	lw	v1,12(s3)
9d003b40:	8e620018 	lw	v0,24(s3)
9d003b44:	0062102b 	sltu	v0,v1,v0
9d003b48:	10400019 	beqz	v0,9d003bb0 <_ZN6SdFile5writeEPKvt+0x2d8>
9d003b4c:	00000000 	nop
        if (!SdVolume::cacheFlush()) goto writeErrorReturn;
        SdVolume::cacheBlockNumber_ = block;
        SdVolume::cacheSetDirty();
      } else {
        // rewrite part of block
        if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) {
9d003b50:	0f400f4b 	jal	9d003d2c <_ZN8SdVolume13cacheRawBlockEmh>
9d003b54:	24050001 	li	a1,1
9d003b58:	10400021 	beqz	v0,9d003be0 <_ZN6SdFile5writeEPKvt+0x308>
9d003b5c:	8fbf0044 	lw	ra,68(sp)
          goto writeErrorReturn;
        }
      }
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
9d003b60:	02163021 	addu	a2,s0,s6
      uint8_t* end = dst + n;
9d003b64:	00d42821 	addu	a1,a2,s4
      while (dst != end) *dst++ = *src++;
9d003b68:	10c5ffb5 	beq	a2,a1,9d003a40 <_ZN6SdFile5writeEPKvt+0x168>
9d003b6c:	0280b021 	move	s6,s4
9d003b70:	00c01021 	move	v0,a2
9d003b74:	03c01821 	move	v1,s8
9d003b78:	90640000 	lbu	a0,0(v1)
9d003b7c:	a0440000 	sb	a0,0(v0)
9d003b80:	24420001 	addiu	v0,v0,1
9d003b84:	14a2fffc 	bne	a1,v0,9d003b78 <_ZN6SdFile5writeEPKvt+0x2a0>
9d003b88:	24630001 	addiu	v1,v1,1
 * \a nbyte.  If an error occurs, write() returns -1.  Possible errors
 * include write() is called before a file has been opened, write is called
 * for a read-only file, device is full, a corrupt file system or an I/O error.
 *
 */
size_t SdFile::write(const void* buf, uint16_t nbyte) {
9d003b8c:	00a62823 	subu	a1,a1,a2
          goto writeErrorReturn;
        }
      }
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
      uint8_t* end = dst + n;
      while (dst != end) *dst++ = *src++;
9d003b90:	0b400e90 	j	9d003a40 <_ZN6SdFile5writeEPKvt+0x168>
9d003b94:	03c5f021 	addu	s8,s8,a1
    // insure sync will update modified date and time
    flags_ |= F_FILE_DIR_DIRTY;
  }

  if (flags_ & O_SYNC) {
    if (!sync()) goto writeErrorReturn;
9d003b98:	0f400c6a 	jal	9d0031a8 <_ZN6SdFile4syncEv>
9d003b9c:	02602021 	move	a0,s3
9d003ba0:	1040ff5f 	beqz	v0,9d003920 <_ZN6SdFile5writeEPKvt+0x48>
9d003ba4:	00008021 	move	s0,zero
  }
  return nbyte;
9d003ba8:	0b400ea2 	j	9d003a88 <_ZN6SdFile5writeEPKvt+0x1b0>
9d003bac:	02208021 	move	s0,s1
      if (!vol_->writeBlock(block, src)) goto writeErrorReturn;
      src += 512;
    } else {
      if (blockOffset == 0 && curPosition_ >= fileSize_) {
        // start of new block don't need to read into cache
        if (!SdVolume::cacheFlush()) goto writeErrorReturn;
9d003bb0:	0f400f24 	jal	9d003c90 <_ZN8SdVolume10cacheFlushEv>
9d003bb4:	afa50018 	sw	a1,24(sp)
9d003bb8:	10400008 	beqz	v0,9d003bdc <_ZN6SdFile5writeEPKvt+0x304>
9d003bbc:	8fa50018 	lw	a1,24(sp)
  uint32_t blockNumber(uint32_t cluster, uint32_t position) const {
           return clusterStartBlock(cluster) + blockOfCluster(position);}
  static uint8_t cacheFlush(void);
  static uint8_t cacheRawBlock(uint32_t blockNumber, uint8_t action);
  static void cacheSetDirty(void) {cacheDirty_ |= CACHE_FOR_WRITE;}
9d003bc0:	93828034 	lbu	v0,-32716(gp)
        SdVolume::cacheBlockNumber_ = block;
9d003bc4:	af858010 	sw	a1,-32752(gp)
9d003bc8:	34420001 	ori	v0,v0,0x1
9d003bcc:	0b400ed8 	j	9d003b60 <_ZN6SdFile5writeEPKvt+0x288>
9d003bd0:	a3828034 	sb	v0,-32716(gp)
    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
    if (n == 512) {
      // full block - don't need to use cache
      // invalidate cache if block is in cache
      if (SdVolume::cacheBlockNumber_ == block) {
        SdVolume::cacheBlockNumber_ = 0XFFFFFFFF;
9d003bd4:	0b400e8a 	j	9d003a28 <_ZN6SdFile5writeEPKvt+0x150>
9d003bd8:	af828010 	sw	v0,-32752(gp)
 writeErrorReturn:
  // return for write error
  //writeError = true;
  //setWriteError();
  return 0;
}
9d003bdc:	8fbf0044 	lw	ra,68(sp)

 writeErrorReturn:
  // return for write error
  //writeError = true;
  //setWriteError();
  return 0;
9d003be0:	00008021 	move	s0,zero
}
9d003be4:	02001021 	move	v0,s0
9d003be8:	8fbe0040 	lw	s8,64(sp)
9d003bec:	8fb7003c 	lw	s7,60(sp)
9d003bf0:	8fb60038 	lw	s6,56(sp)
9d003bf4:	8fb50034 	lw	s5,52(sp)
9d003bf8:	8fb40030 	lw	s4,48(sp)
9d003bfc:	8fb3002c 	lw	s3,44(sp)
9d003c00:	8fb20028 	lw	s2,40(sp)
9d003c04:	8fb10024 	lw	s1,36(sp)
9d003c08:	8fb00020 	lw	s0,32(sp)
9d003c0c:	03e00008 	jr	ra
9d003c10:	27bd0048 	addiu	sp,sp,72
  }
  if (curPosition_ > fileSize_) {
    // update fileSize and insure sync will update dir entry
    fileSize_ = curPosition_;
    flags_ |= F_FILE_DIR_DIRTY;
  } else if (dateTime_ && nbyte) {
9d003c14:	1040ff99 	beqz	v0,9d003a7c <_ZN6SdFile5writeEPKvt+0x1a4>
9d003c18:	92620004 	lbu	v0,4(s3)
9d003c1c:	1220ff97 	beqz	s1,9d003a7c <_ZN6SdFile5writeEPKvt+0x1a4>
9d003c20:	00000000 	nop
    // insure sync will update modified date and time
    flags_ |= F_FILE_DIR_DIRTY;
9d003c24:	3042007f 	andi	v0,v0,0x7f
9d003c28:	34420080 	ori	v0,v0,0x80
9d003c2c:	0b400e9f 	j	9d003a7c <_ZN6SdFile5writeEPKvt+0x1a4>
9d003c30:	a2620004 	sb	v0,4(s3)

9d003c34 <_ZN6SdFile5writeEPKc>:
/**
 * Write a string to a file. Used by the Arduino Print class.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::write(const char* str) {
9d003c34:	27bdffe0 	addiu	sp,sp,-32
9d003c38:	afb00018 	sw	s0,24(sp)
9d003c3c:	00808021 	move	s0,a0
  //return 
  write(str, strlen(str));
9d003c40:	00a02021 	move	a0,a1
/**
 * Write a string to a file. Used by the Arduino Print class.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::write(const char* str) {
9d003c44:	afbf001c 	sw	ra,28(sp)
  //return 
  write(str, strlen(str));
9d003c48:	0f401f18 	jal	9d007c60 <strlen>
9d003c4c:	afa50010 	sw	a1,16(sp)
9d003c50:	8fa50010 	lw	a1,16(sp)
9d003c54:	02002021 	move	a0,s0
}
9d003c58:	8fbf001c 	lw	ra,28(sp)
9d003c5c:	8fb00018 	lw	s0,24(sp)
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::write(const char* str) {
  //return 
  write(str, strlen(str));
9d003c60:	3046ffff 	andi	a2,v0,0xffff
9d003c64:	0b400e36 	j	9d0038d8 <_ZN6SdFile5writeEPKvt>
9d003c68:	27bd0020 	addiu	sp,sp,32

9d003c6c <_ZN6SdFile5writeEh>:
/**
 * Write a byte to a file. Required by the Arduino Print class.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::write(uint8_t b) {
9d003c6c:	27bdffe8 	addiu	sp,sp,-24
9d003c70:	a3a5001c 	sb	a1,28(sp)
  //return 
  write(&b, 1);
9d003c74:	24060001 	li	a2,1
/**
 * Write a byte to a file. Required by the Arduino Print class.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::write(uint8_t b) {
9d003c78:	afbf0014 	sw	ra,20(sp)
  //return 
  write(&b, 1);
9d003c7c:	0f400e36 	jal	9d0038d8 <_ZN6SdFile5writeEPKvt>
9d003c80:	27a5001c 	addiu	a1,sp,28
}
9d003c84:	8fbf0014 	lw	ra,20(sp)
9d003c88:	03e00008 	jr	ra
9d003c8c:	27bd0018 	addiu	sp,sp,24

9d003c90 <_ZN8SdVolume10cacheFlushEv>:

  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheFlush(void) {
  if (cacheDirty_) {
9d003c90:	93828034 	lbu	v0,-32716(gp)
  if (setStart) allocSearchStart_ = bgnCluster + 1;

  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheFlush(void) {
9d003c94:	27bdffe0 	addiu	sp,sp,-32
9d003c98:	afb00014 	sw	s0,20(sp)
9d003c9c:	afbf001c 	sw	ra,28(sp)
9d003ca0:	afb10018 	sw	s1,24(sp)
  if (cacheDirty_) {
9d003ca4:	14400007 	bnez	v0,9d003cc4 <_ZN8SdVolume10cacheFlushEv+0x34>
9d003ca8:	24100001 	li	s0,1
      cacheMirrorBlock_ = 0;
    }
    cacheDirty_ = 0;
  }
  return true;
}
9d003cac:	8fbf001c 	lw	ra,28(sp)
9d003cb0:	02001021 	move	v0,s0
9d003cb4:	8fb10018 	lw	s1,24(sp)
9d003cb8:	8fb00014 	lw	s0,20(sp)
9d003cbc:	03e00008 	jr	ra
9d003cc0:	27bd0020 	addiu	sp,sp,32
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheFlush(void) {
  if (cacheDirty_) {
    if (!sdCard_->writeBlock(cacheBlockNumber_, cacheBuffer_.data)) {
9d003cc4:	8f848030 	lw	a0,-32720(gp)
9d003cc8:	8f858010 	lw	a1,-32752(gp)
9d003ccc:	3c11a000 	lui	s1,0xa000
9d003cd0:	0f400a66 	jal	9d002998 <_ZN7Sd2Card10writeBlockEmPKh>
9d003cd4:	26260aa4 	addiu	a2,s1,2724
9d003cd8:	1040fff4 	beqz	v0,9d003cac <_ZN8SdVolume10cacheFlushEv+0x1c>
9d003cdc:	00008021 	move	s0,zero
      return false;
    }
    // mirror FAT tables
    if (cacheMirrorBlock_) {
9d003ce0:	8f858038 	lw	a1,-32712(gp)
9d003ce4:	14a00009 	bnez	a1,9d003d0c <_ZN8SdVolume10cacheFlushEv+0x7c>
9d003ce8:	8f848030 	lw	a0,-32720(gp)
      if (!sdCard_->writeBlock(cacheMirrorBlock_, cacheBuffer_.data)) {
        return false;
      }
      cacheMirrorBlock_ = 0;
    }
    cacheDirty_ = 0;
9d003cec:	a3808034 	sb	zero,-32716(gp)
  }
  return true;
9d003cf0:	24100001 	li	s0,1
}
9d003cf4:	8fbf001c 	lw	ra,28(sp)
9d003cf8:	02001021 	move	v0,s0
9d003cfc:	8fb10018 	lw	s1,24(sp)
9d003d00:	8fb00014 	lw	s0,20(sp)
9d003d04:	03e00008 	jr	ra
9d003d08:	27bd0020 	addiu	sp,sp,32
    if (!sdCard_->writeBlock(cacheBlockNumber_, cacheBuffer_.data)) {
      return false;
    }
    // mirror FAT tables
    if (cacheMirrorBlock_) {
      if (!sdCard_->writeBlock(cacheMirrorBlock_, cacheBuffer_.data)) {
9d003d0c:	0f400a66 	jal	9d002998 <_ZN7Sd2Card10writeBlockEmPKh>
9d003d10:	26260aa4 	addiu	a2,s1,2724
9d003d14:	1040ffe6 	beqz	v0,9d003cb0 <_ZN8SdVolume10cacheFlushEv+0x20>
9d003d18:	8fbf001c 	lw	ra,28(sp)
        return false;
      }
      cacheMirrorBlock_ = 0;
9d003d1c:	af808038 	sw	zero,-32712(gp)
    }
    cacheDirty_ = 0;
9d003d20:	a3808034 	sb	zero,-32716(gp)
  }
  return true;
9d003d24:	0b400f3d 	j	9d003cf4 <_ZN8SdVolume10cacheFlushEv+0x64>
9d003d28:	24100001 	li	s0,1

9d003d2c <_ZN8SdVolume13cacheRawBlockEmh>:
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheRawBlock(uint32_t blockNumber, uint8_t action) {
  if (cacheBlockNumber_ != blockNumber) {
9d003d2c:	8f828010 	lw	v0,-32752(gp)
    cacheDirty_ = 0;
  }
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheRawBlock(uint32_t blockNumber, uint8_t action) {
9d003d30:	27bdffe0 	addiu	sp,sp,-32
9d003d34:	afb20018 	sw	s2,24(sp)
9d003d38:	afb00010 	sw	s0,16(sp)
9d003d3c:	afbf001c 	sw	ra,28(sp)
9d003d40:	afb10014 	sw	s1,20(sp)
9d003d44:	00808021 	move	s0,a0
  if (cacheBlockNumber_ != blockNumber) {
9d003d48:	10440013 	beq	v0,a0,9d003d98 <_ZN8SdVolume13cacheRawBlockEmh+0x6c>
9d003d4c:	30b200ff 	andi	s2,a1,0xff
    if (!cacheFlush()) return false;
9d003d50:	0f400f24 	jal	9d003c90 <_ZN8SdVolume10cacheFlushEv>
9d003d54:	00008821 	move	s1,zero
9d003d58:	14400008 	bnez	v0,9d003d7c <_ZN8SdVolume13cacheRawBlockEmh+0x50>
9d003d5c:	8f848030 	lw	a0,-32720(gp)
    }
    cacheBlockNumber_ = blockNumber;
  }
  cacheDirty_ |= action;
  return true;
}
9d003d60:	8fbf001c 	lw	ra,28(sp)
9d003d64:	02201021 	move	v0,s1
9d003d68:	8fb20018 	lw	s2,24(sp)
9d003d6c:	8fb10014 	lw	s1,20(sp)
9d003d70:	8fb00010 	lw	s0,16(sp)
9d003d74:	03e00008 	jr	ra
9d003d78:	27bd0020 	addiu	sp,sp,32
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheRawBlock(uint32_t blockNumber, uint8_t action) {
  if (cacheBlockNumber_ != blockNumber) {
    if (!cacheFlush()) return false;
    if (!sdCard_->readBlock(blockNumber, cacheBuffer_.data)) {
9d003d7c:	3c06a000 	lui	a2,0xa000
9d003d80:	02002821 	move	a1,s0
9d003d84:	0f400a2d 	jal	9d0028b4 <_ZN7Sd2Card9readBlockEmPh>
9d003d88:	24c60aa4 	addiu	a2,a2,2724
9d003d8c:	1040fff5 	beqz	v0,9d003d64 <_ZN8SdVolume13cacheRawBlockEmh+0x38>
9d003d90:	8fbf001c 	lw	ra,28(sp)
        return false;
    }
    cacheBlockNumber_ = blockNumber;
9d003d94:	af908010 	sw	s0,-32752(gp)
  }
  cacheDirty_ |= action;
9d003d98:	93828034 	lbu	v0,-32716(gp)
  return true;
}
9d003d9c:	8fbf001c 	lw	ra,28(sp)
        return false;
    }
    cacheBlockNumber_ = blockNumber;
  }
  cacheDirty_ |= action;
  return true;
9d003da0:	24110001 	li	s1,1
    if (!sdCard_->readBlock(blockNumber, cacheBuffer_.data)) {
        return false;
    }
    cacheBlockNumber_ = blockNumber;
  }
  cacheDirty_ |= action;
9d003da4:	02429025 	or	s2,s2,v0
9d003da8:	a3928034 	sb	s2,-32716(gp)
  return true;
}
9d003dac:	02201021 	move	v0,s1
9d003db0:	8fb20018 	lw	s2,24(sp)
9d003db4:	8fb10014 	lw	s1,20(sp)
9d003db8:	8fb00010 	lw	s0,16(sp)
9d003dbc:	03e00008 	jr	ra
9d003dc0:	27bd0020 	addiu	sp,sp,32

9d003dc4 <_ZN8SdVolume14cacheZeroBlockEm>:
//------------------------------------------------------------------------------
// cache a zero block for blockNumber
uint8_t SdVolume::cacheZeroBlock(uint32_t blockNumber) {
9d003dc4:	27bdffe0 	addiu	sp,sp,-32
  if (!cacheFlush()) return false;
9d003dc8:	afa40010 	sw	a0,16(sp)
  cacheDirty_ |= action;
  return true;
}
//------------------------------------------------------------------------------
// cache a zero block for blockNumber
uint8_t SdVolume::cacheZeroBlock(uint32_t blockNumber) {
9d003dcc:	afbf001c 	sw	ra,28(sp)
  if (!cacheFlush()) return false;
9d003dd0:	0f400f24 	jal	9d003c90 <_ZN8SdVolume10cacheFlushEv>
9d003dd4:	00000000 	nop
9d003dd8:	00001821 	move	v1,zero
9d003ddc:	1040000d 	beqz	v0,9d003e14 <_ZN8SdVolume14cacheZeroBlockEm+0x50>
9d003de0:	8fa40010 	lw	a0,16(sp)
9d003de4:	3c02a000 	lui	v0,0xa000
9d003de8:	24420aa4 	addiu	v0,v0,2724
  cacheDirty_ |= action;
  return true;
}
//------------------------------------------------------------------------------
// cache a zero block for blockNumber
uint8_t SdVolume::cacheZeroBlock(uint32_t blockNumber) {
9d003dec:	24430200 	addiu	v1,v0,512
  if (!cacheFlush()) return false;

  // loop take less flash than memset(cacheBuffer_.data, 0, 512);
  for (uint16_t i = 0; i < 512; i++) {
    cacheBuffer_.data[i] = 0;
9d003df0:	a0400000 	sb	zero,0(v0)
9d003df4:	24420001 	addiu	v0,v0,1
// cache a zero block for blockNumber
uint8_t SdVolume::cacheZeroBlock(uint32_t blockNumber) {
  if (!cacheFlush()) return false;

  // loop take less flash than memset(cacheBuffer_.data, 0, 512);
  for (uint16_t i = 0; i < 512; i++) {
9d003df8:	5443fffe 	bnel	v0,v1,9d003df4 <_ZN8SdVolume14cacheZeroBlockEm+0x30>
9d003dfc:	a0400000 	sb	zero,0(v0)
9d003e00:	93828034 	lbu	v0,-32716(gp)
    cacheBuffer_.data[i] = 0;
  }
  cacheBlockNumber_ = blockNumber;
9d003e04:	af848010 	sw	a0,-32752(gp)
  cacheSetDirty();
  return true;
9d003e08:	24030001 	li	v1,1
9d003e0c:	34420001 	ori	v0,v0,0x1
9d003e10:	a3828034 	sb	v0,-32716(gp)
}
9d003e14:	8fbf001c 	lw	ra,28(sp)
9d003e18:	00601021 	move	v0,v1
9d003e1c:	03e00008 	jr	ra
9d003e20:	27bd0020 	addiu	sp,sp,32

9d003e24 <_ZNK8SdVolume6fatGetEmPm>:
  return true;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
  if (cluster > (clusterCount_ + 1)) return false;
9d003e24:	8c82000c 	lw	v0,12(a0)
  *size = s;
  return true;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
9d003e28:	27bdffd8 	addiu	sp,sp,-40
9d003e2c:	afb20020 	sw	s2,32(sp)
  if (cluster > (clusterCount_ + 1)) return false;
9d003e30:	24420001 	addiu	v0,v0,1
9d003e34:	0045102b 	sltu	v0,v0,a1
  *size = s;
  return true;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
9d003e38:	afb1001c 	sw	s1,28(sp)
9d003e3c:	afb00018 	sw	s0,24(sp)
9d003e40:	afbf0024 	sw	ra,36(sp)
9d003e44:	00808821 	move	s1,a0
9d003e48:	00a08021 	move	s0,a1
  if (cluster > (clusterCount_ + 1)) return false;
9d003e4c:	1440001b 	bnez	v0,9d003ebc <_ZNK8SdVolume6fatGetEmPm+0x98>
9d003e50:	00009021 	move	s2,zero
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
9d003e54:	90830020 	lbu	v1,32(a0)
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
  if (cluster > (clusterCount_ + 1)) return false;
  uint32_t lba = fatStartBlock_;
9d003e58:	8c84001c 	lw	a0,28(a0)
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
9d003e5c:	00051202 	srl	v0,a1,0x8
9d003e60:	38670010 	xori	a3,v1,0x10
9d003e64:	000529c2 	srl	a1,a1,0x7
9d003e68:	00a7100b 	movn	v0,a1,a3
9d003e6c:	00442021 	addu	a0,v0,a0
  if (lba != cacheBlockNumber_) {
9d003e70:	8f828010 	lw	v0,-32752(gp)
9d003e74:	10820006 	beq	a0,v0,9d003e90 <_ZNK8SdVolume6fatGetEmPm+0x6c>
9d003e78:	00002821 	move	a1,zero
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
9d003e7c:	0f400f4b 	jal	9d003d2c <_ZN8SdVolume13cacheRawBlockEmh>
9d003e80:	afa60010 	sw	a2,16(sp)
9d003e84:	1040000d 	beqz	v0,9d003ebc <_ZNK8SdVolume6fatGetEmPm+0x98>
9d003e88:	8fa60010 	lw	a2,16(sp)
9d003e8c:	92230020 	lbu	v1,32(s1)
  }
  if (fatType_ == 16) {
9d003e90:	24020010 	li	v0,16
9d003e94:	10620010 	beq	v1,v0,9d003ed8 <_ZNK8SdVolume6fatGetEmPm+0xb4>
9d003e98:	3c02a000 	lui	v0,0xa000
    *value = cacheBuffer_.fat16[cluster & 0XFF];
  } else {
    *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;
9d003e9c:	3210007f 	andi	s0,s0,0x7f
9d003ea0:	24420aa4 	addiu	v0,v0,2724
9d003ea4:	00108080 	sll	s0,s0,0x2
9d003ea8:	02028021 	addu	s0,s0,v0
9d003eac:	8e020000 	lw	v0,0(s0)
  }
  return true;
9d003eb0:	24120001 	li	s2,1
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
  }
  if (fatType_ == 16) {
    *value = cacheBuffer_.fat16[cluster & 0XFF];
  } else {
    *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;
9d003eb4:	7c42d800 	ext	v0,v0,0x0,0x1c
9d003eb8:	acc20000 	sw	v0,0(a2)
  }
  return true;
}
9d003ebc:	8fbf0024 	lw	ra,36(sp)
9d003ec0:	02401021 	move	v0,s2
9d003ec4:	8fb20020 	lw	s2,32(sp)
9d003ec8:	8fb1001c 	lw	s1,28(sp)
9d003ecc:	8fb00018 	lw	s0,24(sp)
9d003ed0:	03e00008 	jr	ra
9d003ed4:	27bd0028 	addiu	sp,sp,40
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
  if (lba != cacheBlockNumber_) {
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
  }
  if (fatType_ == 16) {
    *value = cacheBuffer_.fat16[cluster & 0XFF];
9d003ed8:	321000ff 	andi	s0,s0,0xff
9d003edc:	24420aa4 	addiu	v0,v0,2724
9d003ee0:	00108040 	sll	s0,s0,0x1
9d003ee4:	02028021 	addu	s0,s0,v0
9d003ee8:	96020000 	lhu	v0,0(s0)
  } else {
    *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;
  }
  return true;
9d003eec:	24120001 	li	s2,1
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
  if (lba != cacheBlockNumber_) {
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
  }
  if (fatType_ == 16) {
    *value = cacheBuffer_.fat16[cluster & 0XFF];
9d003ef0:	0b400faf 	j	9d003ebc <_ZNK8SdVolume6fatGetEmPm+0x98>
9d003ef4:	acc20000 	sw	v0,0(a2)

9d003ef8 <_ZNK8SdVolume9chainSizeEmPm>:
  cacheSetDirty();
  return true;
}
//------------------------------------------------------------------------------
// return the size in bytes of a cluster chain
uint8_t SdVolume::chainSize(uint32_t cluster, uint32_t* size) const {
9d003ef8:	27bdffd0 	addiu	sp,sp,-48
9d003efc:	afb2001c 	sw	s2,28(sp)
  uint8_t fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
  }
  uint8_t freeChain(uint32_t cluster);
  uint8_t isEOC(uint32_t cluster) const {
    return  cluster >= (fatType_ == 16 ? FAT16EOC_MIN : FAT32EOC_MIN);
9d003f00:	3c120fff 	lui	s2,0xfff
9d003f04:	afb50028 	sw	s5,40(sp)
9d003f08:	afb40024 	sw	s4,36(sp)
9d003f0c:	afb30020 	sw	s3,32(sp)
9d003f10:	afb10018 	sw	s1,24(sp)
9d003f14:	afb00014 	sw	s0,20(sp)
9d003f18:	afbf002c 	sw	ra,44(sp)
9d003f1c:	0080a021 	move	s4,a0
9d003f20:	afa50034 	sw	a1,52(sp)
9d003f24:	00c09821 	move	s3,a2
  uint32_t s = 0;
9d003f28:	0000a821 	move	s5,zero
  do {
    if (!fatGet(cluster, &cluster)) return false;
    s += 512UL << clusterSizeShift_;
9d003f2c:	24110200 	li	s1,512
9d003f30:	24100010 	li	s0,16
9d003f34:	0b400fd8 	j	9d003f60 <_ZNK8SdVolume9chainSizeEmPm+0x68>
9d003f38:	3652fff8 	ori	s2,s2,0xfff8
9d003f3c:	92840020 	lbu	a0,32(s4)
9d003f40:	92820010 	lbu	v0,16(s4)
  } while (!isEOC(cluster));
9d003f44:	8fa50034 	lw	a1,52(sp)
9d003f48:	00902026 	xor	a0,a0,s0
9d003f4c:	0244180b 	movn	v1,s2,a0
// return the size in bytes of a cluster chain
uint8_t SdVolume::chainSize(uint32_t cluster, uint32_t* size) const {
  uint32_t s = 0;
  do {
    if (!fatGet(cluster, &cluster)) return false;
    s += 512UL << clusterSizeShift_;
9d003f50:	00511004 	sllv	v0,s1,v0
}
//------------------------------------------------------------------------------
// return the size in bytes of a cluster chain
uint8_t SdVolume::chainSize(uint32_t cluster, uint32_t* size) const {
  uint32_t s = 0;
  do {
9d003f54:	00a3182b 	sltu	v1,a1,v1
9d003f58:	10600010 	beqz	v1,9d003f9c <_ZNK8SdVolume9chainSizeEmPm+0xa4>
9d003f5c:	02a2a821 	addu	s5,s5,v0
    if (!fatGet(cluster, &cluster)) return false;
9d003f60:	02802021 	move	a0,s4
9d003f64:	0f400f89 	jal	9d003e24 <_ZNK8SdVolume6fatGetEmPm>
9d003f68:	27a60034 	addiu	a2,sp,52
9d003f6c:	1440fff3 	bnez	v0,9d003f3c <_ZNK8SdVolume9chainSizeEmPm+0x44>
9d003f70:	3403fff8 	li	v1,0xfff8
    s += 512UL << clusterSizeShift_;
  } while (!isEOC(cluster));
  *size = s;
  return true;
}
9d003f74:	8fbf002c 	lw	ra,44(sp)
//------------------------------------------------------------------------------
// return the size in bytes of a cluster chain
uint8_t SdVolume::chainSize(uint32_t cluster, uint32_t* size) const {
  uint32_t s = 0;
  do {
    if (!fatGet(cluster, &cluster)) return false;
9d003f78:	00001021 	move	v0,zero
    s += 512UL << clusterSizeShift_;
  } while (!isEOC(cluster));
  *size = s;
  return true;
}
9d003f7c:	8fb50028 	lw	s5,40(sp)
9d003f80:	8fb40024 	lw	s4,36(sp)
9d003f84:	8fb30020 	lw	s3,32(sp)
9d003f88:	8fb2001c 	lw	s2,28(sp)
9d003f8c:	8fb10018 	lw	s1,24(sp)
9d003f90:	8fb00014 	lw	s0,20(sp)
9d003f94:	03e00008 	jr	ra
9d003f98:	27bd0030 	addiu	sp,sp,48
9d003f9c:	8fbf002c 	lw	ra,44(sp)
  uint32_t s = 0;
  do {
    if (!fatGet(cluster, &cluster)) return false;
    s += 512UL << clusterSizeShift_;
  } while (!isEOC(cluster));
  *size = s;
9d003fa0:	ae750000 	sw	s5,0(s3)
  return true;
9d003fa4:	24020001 	li	v0,1
}
9d003fa8:	8fb50028 	lw	s5,40(sp)
9d003fac:	8fb40024 	lw	s4,36(sp)
9d003fb0:	8fb30020 	lw	s3,32(sp)
9d003fb4:	8fb2001c 	lw	s2,28(sp)
9d003fb8:	8fb10018 	lw	s1,24(sp)
9d003fbc:	8fb00014 	lw	s0,20(sp)
9d003fc0:	03e00008 	jr	ra
9d003fc4:	27bd0030 	addiu	sp,sp,48

9d003fc8 <_ZN8SdVolume6fatPutEmm>:
  }
  return true;
}
//------------------------------------------------------------------------------
// Store a FAT entry
uint8_t SdVolume::fatPut(uint32_t cluster, uint32_t value) {
9d003fc8:	27bdffd0 	addiu	sp,sp,-48
  // error if reserved cluster
  if (cluster < 2) return false;
9d003fcc:	2ca20002 	sltiu	v0,a1,2
  }
  return true;
}
//------------------------------------------------------------------------------
// Store a FAT entry
uint8_t SdVolume::fatPut(uint32_t cluster, uint32_t value) {
9d003fd0:	afb20024 	sw	s2,36(sp)
9d003fd4:	afb10020 	sw	s1,32(sp)
9d003fd8:	afb0001c 	sw	s0,28(sp)
9d003fdc:	afbf002c 	sw	ra,44(sp)
9d003fe0:	afb30028 	sw	s3,40(sp)
9d003fe4:	00a08021 	move	s0,a1
9d003fe8:	00808821 	move	s1,a0
  // error if reserved cluster
  if (cluster < 2) return false;
9d003fec:	14400027 	bnez	v0,9d00408c <_ZN8SdVolume6fatPutEmm+0xc4>
9d003ff0:	00009021 	move	s2,zero

  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) return false;
9d003ff4:	8c82000c 	lw	v0,12(a0)
9d003ff8:	24420001 	addiu	v0,v0,1
9d003ffc:	0045102b 	sltu	v0,v0,a1
9d004000:	14400022 	bnez	v0,9d00408c <_ZN8SdVolume6fatPutEmm+0xc4>
9d004004:	00051202 	srl	v0,a1,0x8

  // calculate block address for entry
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
9d004008:	90830020 	lbu	v1,32(a0)

  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) return false;

  // calculate block address for entry
  uint32_t lba = fatStartBlock_;
9d00400c:	8c93001c 	lw	s3,28(a0)
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
9d004010:	000521c2 	srl	a0,a1,0x7
9d004014:	38650010 	xori	a1,v1,0x10
9d004018:	0085100b 	movn	v0,a0,a1
9d00401c:	00539821 	addu	s3,v0,s3

  if (lba != cacheBlockNumber_) {
9d004020:	8f828010 	lw	v0,-32752(gp)
9d004024:	12620007 	beq	s3,v0,9d004044 <_ZN8SdVolume6fatPutEmm+0x7c>
9d004028:	02602021 	move	a0,s3
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
9d00402c:	00002821 	move	a1,zero
9d004030:	0f400f4b 	jal	9d003d2c <_ZN8SdVolume13cacheRawBlockEmh>
9d004034:	afa60010 	sw	a2,16(sp)
9d004038:	10400014 	beqz	v0,9d00408c <_ZN8SdVolume6fatPutEmm+0xc4>
9d00403c:	8fa60010 	lw	a2,16(sp)
9d004040:	92230020 	lbu	v1,32(s1)
  }
  // store entry
  if (fatType_ == 16) {
9d004044:	24020010 	li	v0,16
9d004048:	10620018 	beq	v1,v0,9d0040ac <_ZN8SdVolume6fatPutEmm+0xe4>
9d00404c:	3c02a000 	lui	v0,0xa000
    cacheBuffer_.fat16[cluster & 0XFF] = value;
  } else {
    cacheBuffer_.fat32[cluster & 0X7F] = value;
9d004050:	3210007f 	andi	s0,s0,0x7f
9d004054:	00108080 	sll	s0,s0,0x2
9d004058:	24420aa4 	addiu	v0,v0,2724
9d00405c:	02028021 	addu	s0,s0,v0
9d004060:	ae060000 	sw	a2,0(s0)
           return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);}
  uint32_t blockNumber(uint32_t cluster, uint32_t position) const {
           return clusterStartBlock(cluster) + blockOfCluster(position);}
  static uint8_t cacheFlush(void);
  static uint8_t cacheRawBlock(uint32_t blockNumber, uint8_t action);
  static void cacheSetDirty(void) {cacheDirty_ |= CACHE_FOR_WRITE;}
9d004064:	93828034 	lbu	v0,-32716(gp)
9d004068:	34420001 	ori	v0,v0,0x1
9d00406c:	a3828034 	sb	v0,-32716(gp)
  }
  cacheSetDirty();

  // mirror second FAT
  if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
9d004070:	92220018 	lbu	v0,24(s1)
9d004074:	2c420002 	sltiu	v0,v0,2
9d004078:	14400004 	bnez	v0,9d00408c <_ZN8SdVolume6fatPutEmm+0xc4>
9d00407c:	24120001 	li	s2,1
9d004080:	8e220008 	lw	v0,8(s1)
9d004084:	02629821 	addu	s3,s3,v0
9d004088:	af938038 	sw	s3,-32712(gp)
  return true;
}
9d00408c:	8fbf002c 	lw	ra,44(sp)
9d004090:	02401021 	move	v0,s2
9d004094:	8fb30028 	lw	s3,40(sp)
9d004098:	8fb20024 	lw	s2,36(sp)
9d00409c:	8fb10020 	lw	s1,32(sp)
9d0040a0:	8fb0001c 	lw	s0,28(sp)
9d0040a4:	03e00008 	jr	ra
9d0040a8:	27bd0030 	addiu	sp,sp,48
  if (lba != cacheBlockNumber_) {
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
  }
  // store entry
  if (fatType_ == 16) {
    cacheBuffer_.fat16[cluster & 0XFF] = value;
9d0040ac:	321000ff 	andi	s0,s0,0xff
9d0040b0:	00108040 	sll	s0,s0,0x1
9d0040b4:	24420aa4 	addiu	v0,v0,2724
9d0040b8:	02028021 	addu	s0,s0,v0
9d0040bc:	0b401019 	j	9d004064 <_ZN8SdVolume6fatPutEmm+0x9c>
9d0040c0:	a6060000 	sh	a2,0(s0)

9d0040c4 <_ZN8SdVolume15allocContiguousEmPm>:
Sd2Card* SdVolume::sdCard_;          // pointer to SD card object
uint8_t  SdVolume::cacheDirty_ = 0;  // cacheFlush() will write block if true
uint32_t SdVolume::cacheMirrorBlock_ = 0;  // mirror  block for second FAT
//------------------------------------------------------------------------------
// find a contiguous group of clusters
uint8_t SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
9d0040c4:	27bdffc0 	addiu	sp,sp,-64
9d0040c8:	afb40028 	sw	s4,40(sp)

  // flag to save place to start next search
  uint8_t setStart;

  // set search start cluster
  if (*curCluster) {
9d0040cc:	8cd40000 	lw	s4,0(a2)
Sd2Card* SdVolume::sdCard_;          // pointer to SD card object
uint8_t  SdVolume::cacheDirty_ = 0;  // cacheFlush() will write block if true
uint32_t SdVolume::cacheMirrorBlock_ = 0;  // mirror  block for second FAT
//------------------------------------------------------------------------------
// find a contiguous group of clusters
uint8_t SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
9d0040d0:	afb70034 	sw	s7,52(sp)
9d0040d4:	afb20020 	sw	s2,32(sp)
9d0040d8:	afb1001c 	sw	s1,28(sp)
9d0040dc:	afbf003c 	sw	ra,60(sp)
9d0040e0:	afbe0038 	sw	s8,56(sp)
9d0040e4:	afb60030 	sw	s6,48(sp)
9d0040e8:	afb5002c 	sw	s5,44(sp)
9d0040ec:	afb30024 	sw	s3,36(sp)
9d0040f0:	afb00018 	sw	s0,24(sp)
9d0040f4:	00c09021 	move	s2,a2
9d0040f8:	0080b821 	move	s7,a0

  // flag to save place to start next search
  uint8_t setStart;

  // set search start cluster
  if (*curCluster) {
9d0040fc:	12800043 	beqz	s4,9d00420c <_ZN8SdVolume15allocContiguousEmPm+0x148>
9d004100:	00a08821 	move	s1,a1
    // try to make file contiguous
    bgnCluster = *curCluster + 1;
9d004104:	26940001 	addiu	s4,s4,1

    // don't save new start location
    setStart = false;
9d004108:	00009821 	move	s3,zero
  }
  // end of group
  uint32_t endCluster = bgnCluster;

  // last cluster of FAT
  uint32_t fatEnd = clusterCount_ + 1;
9d00410c:	8ee2000c 	lw	v0,12(s7)

  // search the FAT for free clusters
  for (uint32_t n = 0;; n++, endCluster++) {
    // can't find space checked all clusters
    if (n >= clusterCount_) return false;
9d004110:	00001821 	move	v1,zero
9d004114:	10400030 	beqz	v0,9d0041d8 <_ZN8SdVolume15allocContiguousEmPm+0x114>
9d004118:	24500001 	addiu	s0,v0,1
9d00411c:	02801821 	move	v1,s4
9d004120:	0000b021 	move	s6,zero

    // past end - start from beginning of FAT
    if (endCluster > fatEnd) {
9d004124:	0b401050 	j	9d004140 <_ZN8SdVolume15allocContiguousEmPm+0x7c>
9d004128:	241e0002 	li	s8,2
  uint32_t fatEnd = clusterCount_ + 1;

  // search the FAT for free clusters
  for (uint32_t n = 0;; n++, endCluster++) {
    // can't find space checked all clusters
    if (n >= clusterCount_) return false;
9d00412c:	8ee2000c 	lw	v0,12(s7)

  // last cluster of FAT
  uint32_t fatEnd = clusterCount_ + 1;

  // search the FAT for free clusters
  for (uint32_t n = 0;; n++, endCluster++) {
9d004130:	26d60001 	addiu	s6,s6,1
    // can't find space checked all clusters
    if (n >= clusterCount_) return false;
9d004134:	02c2102b 	sltu	v0,s6,v0
9d004138:	50400027 	beqzl	v0,9d0041d8 <_ZN8SdVolume15allocContiguousEmPm+0x114>
9d00413c:	00001821 	move	v1,zero

    // past end - start from beginning of FAT
    if (endCluster > fatEnd) {
9d004140:	0203102b 	sltu	v0,s0,v1
9d004144:	03c0a821 	move	s5,s8
9d004148:	0062a80a 	movz	s5,v1,v0
      bgnCluster = endCluster = 2;
    }
    uint32_t f;
    if (!fatGet(endCluster, &f)) return false;
9d00414c:	02e02021 	move	a0,s7
9d004150:	02a02821 	move	a1,s5
9d004154:	27a60010 	addiu	a2,sp,16
9d004158:	0f400f89 	jal	9d003e24 <_ZNK8SdVolume6fatGetEmPm>
9d00415c:	03c2a00b 	movn	s4,s8,v0

    if (f != 0) {
      // cluster in use try next cluster as bgnCluster
      bgnCluster = endCluster + 1;
    } else if ((endCluster - bgnCluster + 1) == count) {
9d004160:	26a30001 	addiu	v1,s5,1
    // past end - start from beginning of FAT
    if (endCluster > fatEnd) {
      bgnCluster = endCluster = 2;
    }
    uint32_t f;
    if (!fatGet(endCluster, &f)) return false;
9d004164:	1040001b 	beqz	v0,9d0041d4 <_ZN8SdVolume15allocContiguousEmPm+0x110>
9d004168:	00742023 	subu	a0,v1,s4

    if (f != 0) {
9d00416c:	8fa20010 	lw	v0,16(sp)
9d004170:	5440ffee 	bnezl	v0,9d00412c <_ZN8SdVolume15allocContiguousEmPm+0x68>
9d004174:	0060a021 	move	s4,v1
      // cluster in use try next cluster as bgnCluster
      bgnCluster = endCluster + 1;
    } else if ((endCluster - bgnCluster + 1) == count) {
9d004178:	5491ffed 	bnel	a0,s1,9d004130 <_ZN8SdVolume15allocContiguousEmPm+0x6c>
9d00417c:	8ee2000c 	lw	v0,12(s7)
  static uint8_t cacheZeroBlock(uint32_t blockNumber);
  uint8_t chainSize(uint32_t beginCluster, uint32_t* size) const;
  uint8_t fatGet(uint32_t cluster, uint32_t* value) const;
  uint8_t fatPut(uint32_t cluster, uint32_t value);
  uint8_t fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
9d004180:	3c060fff 	lui	a2,0xfff
9d004184:	02e02021 	move	a0,s7
9d004188:	02a02821 	move	a1,s5
9d00418c:	0f400ff2 	jal	9d003fc8 <_ZN8SdVolume6fatPutEmm>
9d004190:	34c6ffff 	ori	a2,a2,0xffff
      // done - found space
      break;
    }
  }
  // mark end of chain
  if (!fatPutEOC(endCluster)) return false;
9d004194:	10400010 	beqz	v0,9d0041d8 <_ZN8SdVolume15allocContiguousEmPm+0x114>
9d004198:	00001821 	move	v1,zero

  // link clusters
  while (endCluster > bgnCluster) {
9d00419c:	0295102b 	sltu	v0,s4,s5
9d0041a0:	14400005 	bnez	v0,9d0041b8 <_ZN8SdVolume15allocContiguousEmPm+0xf4>
9d0041a4:	26a2ffff 	addiu	v0,s5,-1
    if (!fatPut(endCluster - 1, endCluster)) return false;
    endCluster--;
  }
  if (*curCluster != 0) {
9d0041a8:	0b401088 	j	9d004220 <_ZN8SdVolume15allocContiguousEmPm+0x15c>
9d0041ac:	8e450000 	lw	a1,0(s2)
  }
  // mark end of chain
  if (!fatPutEOC(endCluster)) return false;

  // link clusters
  while (endCluster > bgnCluster) {
9d0041b0:	1060001a 	beqz	v1,9d00421c <_ZN8SdVolume15allocContiguousEmPm+0x158>
9d0041b4:	26a2ffff 	addiu	v0,s5,-1
    if (!fatPut(endCluster - 1, endCluster)) return false;
9d0041b8:	02a03021 	move	a2,s5
9d0041bc:	02e02021 	move	a0,s7
9d0041c0:	00402821 	move	a1,v0
9d0041c4:	0f400ff2 	jal	9d003fc8 <_ZN8SdVolume6fatPutEmm>
9d0041c8:	0040a821 	move	s5,v0
9d0041cc:	1440fff8 	bnez	v0,9d0041b0 <_ZN8SdVolume15allocContiguousEmPm+0xec>
9d0041d0:	0295182b 	sltu	v1,s4,s5
9d0041d4:	00001821 	move	v1,zero

  // remember possible next free cluster
  if (setStart) allocSearchStart_ = bgnCluster + 1;

  return true;
}
9d0041d8:	8fbf003c 	lw	ra,60(sp)
9d0041dc:	00601021 	move	v0,v1
9d0041e0:	8fbe0038 	lw	s8,56(sp)
9d0041e4:	8fb70034 	lw	s7,52(sp)
9d0041e8:	8fb60030 	lw	s6,48(sp)
9d0041ec:	8fb5002c 	lw	s5,44(sp)
9d0041f0:	8fb40028 	lw	s4,40(sp)
9d0041f4:	8fb30024 	lw	s3,36(sp)
9d0041f8:	8fb20020 	lw	s2,32(sp)
9d0041fc:	8fb1001c 	lw	s1,28(sp)
9d004200:	8fb00018 	lw	s0,24(sp)
9d004204:	03e00008 	jr	ra
9d004208:	27bd0040 	addiu	sp,sp,64
  } else {
    // start at likely place for free cluster
    bgnCluster = allocSearchStart_;

    // save next search start if one cluster
    setStart = 1 == count;
9d00420c:	38b30001 	xori	s3,a1,0x1

    // don't save new start location
    setStart = false;
  } else {
    // start at likely place for free cluster
    bgnCluster = allocSearchStart_;
9d004210:	8c940000 	lw	s4,0(a0)

    // save next search start if one cluster
    setStart = 1 == count;
9d004214:	0b401043 	j	9d00410c <_ZN8SdVolume15allocContiguousEmPm+0x48>
9d004218:	2e730001 	sltiu	s3,s3,1
  // link clusters
  while (endCluster > bgnCluster) {
    if (!fatPut(endCluster - 1, endCluster)) return false;
    endCluster--;
  }
  if (*curCluster != 0) {
9d00421c:	8e450000 	lw	a1,0(s2)
9d004220:	14a00007 	bnez	a1,9d004240 <_ZN8SdVolume15allocContiguousEmPm+0x17c>
9d004224:	02e02021 	move	a0,s7
    // connect chains
    if (!fatPut(*curCluster, bgnCluster)) return false;
  }
  // return first cluster number to caller
  *curCluster = bgnCluster;
9d004228:	ae540000 	sw	s4,0(s2)

  // remember possible next free cluster
  if (setStart) allocSearchStart_ = bgnCluster + 1;
9d00422c:	1260ffea 	beqz	s3,9d0041d8 <_ZN8SdVolume15allocContiguousEmPm+0x114>
9d004230:	24030001 	li	v1,1
9d004234:	26940001 	addiu	s4,s4,1
9d004238:	0b401076 	j	9d0041d8 <_ZN8SdVolume15allocContiguousEmPm+0x114>
9d00423c:	aef40000 	sw	s4,0(s7)
    if (!fatPut(endCluster - 1, endCluster)) return false;
    endCluster--;
  }
  if (*curCluster != 0) {
    // connect chains
    if (!fatPut(*curCluster, bgnCluster)) return false;
9d004240:	0f400ff2 	jal	9d003fc8 <_ZN8SdVolume6fatPutEmm>
9d004244:	02803021 	move	a2,s4
9d004248:	1440fff7 	bnez	v0,9d004228 <_ZN8SdVolume15allocContiguousEmPm+0x164>
9d00424c:	00001821 	move	v1,zero

  // remember possible next free cluster
  if (setStart) allocSearchStart_ = bgnCluster + 1;

  return true;
}
9d004250:	0b401077 	j	9d0041dc <_ZN8SdVolume15allocContiguousEmPm+0x118>
9d004254:	8fbf003c 	lw	ra,60(sp)

9d004258 <_ZN8SdVolume9freeChainEm>:
  if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
  return true;
}
//------------------------------------------------------------------------------
// free a cluster chain
uint8_t SdVolume::freeChain(uint32_t cluster) {
9d004258:	27bdffd0 	addiu	sp,sp,-48
9d00425c:	afb20024 	sw	s2,36(sp)
  // clear free cluster location
  allocSearchStart_ = 2;
9d004260:	24020002 	li	v0,2
  }
  uint8_t freeChain(uint32_t cluster);
  uint8_t isEOC(uint32_t cluster) const {
    return  cluster >= (fatType_ == 16 ? FAT16EOC_MIN : FAT32EOC_MIN);
9d004264:	3c120fff 	lui	s2,0xfff
  if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
  return true;
}
//------------------------------------------------------------------------------
// free a cluster chain
uint8_t SdVolume::freeChain(uint32_t cluster) {
9d004268:	afb30028 	sw	s3,40(sp)
9d00426c:	afb10020 	sw	s1,32(sp)
9d004270:	afb0001c 	sw	s0,28(sp)
9d004274:	afbf002c 	sw	ra,44(sp)
9d004278:	00808021 	move	s0,a0
9d00427c:	00a09821 	move	s3,a1
  // clear free cluster location
  allocSearchStart_ = 2;
9d004280:	ac820000 	sw	v0,0(a0)
9d004284:	24110010 	li	s1,16
9d004288:	0b4010af 	j	9d0042bc <_ZN8SdVolume9freeChainEm+0x64>
9d00428c:	3652fff8 	ori	s2,s2,0xfff8
  do {
    uint32_t next;
    if (!fatGet(cluster, &next)) return false;

    // free cluster
    if (!fatPut(cluster, 0)) return false;
9d004290:	0f400ff2 	jal	9d003fc8 <_ZN8SdVolume6fatPutEmm>
9d004294:	00000000 	nop
9d004298:	10400010 	beqz	v0,9d0042dc <_ZN8SdVolume9freeChainEm+0x84>
9d00429c:	3403fff8 	li	v1,0xfff8
9d0042a0:	92020020 	lbu	v0,32(s0)

    cluster = next;
9d0042a4:	8fb30010 	lw	s3,16(sp)
9d0042a8:	00511026 	xor	v0,v0,s1
9d0042ac:	0242180b 	movn	v1,s2,v0
// free a cluster chain
uint8_t SdVolume::freeChain(uint32_t cluster) {
  // clear free cluster location
  allocSearchStart_ = 2;

  do {
9d0042b0:	0263182b 	sltu	v1,s3,v1
9d0042b4:	10600011 	beqz	v1,9d0042fc <_ZN8SdVolume9freeChainEm+0xa4>
9d0042b8:	8fbf002c 	lw	ra,44(sp)
    uint32_t next;
    if (!fatGet(cluster, &next)) return false;
9d0042bc:	02602821 	move	a1,s3
9d0042c0:	02002021 	move	a0,s0
9d0042c4:	0f400f89 	jal	9d003e24 <_ZNK8SdVolume6fatGetEmPm>
9d0042c8:	27a60010 	addiu	a2,sp,16

    // free cluster
    if (!fatPut(cluster, 0)) return false;
9d0042cc:	02602821 	move	a1,s3
9d0042d0:	02002021 	move	a0,s0
  // clear free cluster location
  allocSearchStart_ = 2;

  do {
    uint32_t next;
    if (!fatGet(cluster, &next)) return false;
9d0042d4:	1440ffee 	bnez	v0,9d004290 <_ZN8SdVolume9freeChainEm+0x38>
9d0042d8:	00003021 	move	a2,zero

    cluster = next;
  } while (!isEOC(cluster));

  return true;
}
9d0042dc:	8fbf002c 	lw	ra,44(sp)
  do {
    uint32_t next;
    if (!fatGet(cluster, &next)) return false;

    // free cluster
    if (!fatPut(cluster, 0)) return false;
9d0042e0:	00001021 	move	v0,zero

    cluster = next;
  } while (!isEOC(cluster));

  return true;
}
9d0042e4:	8fb30028 	lw	s3,40(sp)
9d0042e8:	8fb20024 	lw	s2,36(sp)
9d0042ec:	8fb10020 	lw	s1,32(sp)
9d0042f0:	8fb0001c 	lw	s0,28(sp)
9d0042f4:	03e00008 	jr	ra
9d0042f8:	27bd0030 	addiu	sp,sp,48
    if (!fatPut(cluster, 0)) return false;

    cluster = next;
  } while (!isEOC(cluster));

  return true;
9d0042fc:	24020001 	li	v0,1
}
9d004300:	8fb30028 	lw	s3,40(sp)
9d004304:	8fb20024 	lw	s2,36(sp)
9d004308:	8fb10020 	lw	s1,32(sp)
9d00430c:	8fb0001c 	lw	s0,28(sp)
9d004310:	03e00008 	jr	ra
9d004314:	27bd0030 	addiu	sp,sp,48

9d004318 <_ZN8SdVolume4initEP7Sd2Cardh>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.  Reasons for
 * failure include not finding a valid partition, not finding a valid
 * FAT file system in the specified partition or an I/O error.
 */
uint8_t SdVolume::init(Sd2Card* dev, uint8_t part) {
9d004318:	27bdffe0 	addiu	sp,sp,-32
9d00431c:	afb00010 	sw	s0,16(sp)
9d004320:	30d000ff 	andi	s0,a2,0xff
9d004324:	afb20018 	sw	s2,24(sp)
9d004328:	afbf001c 	sw	ra,28(sp)
9d00432c:	afb10014 	sw	s1,20(sp)
9d004330:	00809021 	move	s2,a0
  uint32_t volumeStartBlock = 0;
  sdCard_ = dev;
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
9d004334:	12000025 	beqz	s0,9d0043cc <_ZN8SdVolume4initEP7Sd2Cardh+0xb4>
9d004338:	af858030 	sw	a1,-32720(gp)
    if (part > 4)return false;
9d00433c:	2e020005 	sltiu	v0,s0,5
9d004340:	14400008 	bnez	v0,9d004364 <_ZN8SdVolume4initEP7Sd2Cardh+0x4c>
9d004344:	00008821 	move	s1,zero
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
    fatType_ = 32;
  }
  return true;
}
9d004348:	8fbf001c 	lw	ra,28(sp)
9d00434c:	02201021 	move	v0,s1
9d004350:	8fb20018 	lw	s2,24(sp)
9d004354:	8fb10014 	lw	s1,20(sp)
9d004358:	8fb00010 	lw	s0,16(sp)
9d00435c:	03e00008 	jr	ra
9d004360:	27bd0020 	addiu	sp,sp,32
  sdCard_ = dev;
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
9d004364:	00002021 	move	a0,zero
9d004368:	0f400f4b 	jal	9d003d2c <_ZN8SdVolume13cacheRawBlockEmh>
9d00436c:	00002821 	move	a1,zero
9d004370:	1040fff5 	beqz	v0,9d004348 <_ZN8SdVolume4initEP7Sd2Cardh+0x30>
9d004374:	2602ffff 	addiu	v0,s0,-1
    part_t* p = &cacheBuffer_.mbr.part[part-1];
    if ((p->boot & 0X7F) !=0  ||
9d004378:	3c03a000 	lui	v1,0xa000
9d00437c:	00021100 	sll	v0,v0,0x4
9d004380:	24630aa4 	addiu	v1,v1,2724
9d004384:	00431021 	addu	v0,v0,v1
9d004388:	904201be 	lbu	v0,446(v0)
9d00438c:	3042007f 	andi	v0,v0,0x7f
9d004390:	1440ffed 	bnez	v0,9d004348 <_ZN8SdVolume4initEP7Sd2Cardh+0x30>
9d004394:	2602001b 	addiu	v0,s0,27
9d004398:	00021100 	sll	v0,v0,0x4
9d00439c:	00431021 	addu	v0,v0,v1
9d0043a0:	8843000d 	lwl	v1,13(v0)
9d0043a4:	9843000a 	lwr	v1,10(v0)
9d0043a8:	2c630064 	sltiu	v1,v1,100
9d0043ac:	1460ffe7 	bnez	v1,9d00434c <_ZN8SdVolume4initEP7Sd2Cardh+0x34>
9d0043b0:	8fbf001c 	lw	ra,28(sp)
9d0043b4:	88500009 	lwl	s0,9(v0)
9d0043b8:	98500006 	lwr	s0,6(v0)
9d0043bc:	16000005 	bnez	s0,9d0043d4 <_ZN8SdVolume4initEP7Sd2Cardh+0xbc>
9d0043c0:	02002021 	move	a0,s0
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
    fatType_ = 32;
  }
  return true;
}
9d0043c4:	0b4010d4 	j	9d004350 <_ZN8SdVolume4initEP7Sd2Cardh+0x38>
9d0043c8:	02201021 	move	v0,s1
 * the value zero, false, is returned for failure.  Reasons for
 * failure include not finding a valid partition, not finding a valid
 * FAT file system in the specified partition or an I/O error.
 */
uint8_t SdVolume::init(Sd2Card* dev, uint8_t part) {
  uint32_t volumeStartBlock = 0;
9d0043cc:	00008021 	move	s0,zero
      // not a valid partition
      return false;
    }
    volumeStartBlock = p->firstSector;
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
9d0043d0:	02002021 	move	a0,s0
9d0043d4:	0f400f4b 	jal	9d003d2c <_ZN8SdVolume13cacheRawBlockEmh>
9d0043d8:	00002821 	move	a1,zero
9d0043dc:	1040ffda 	beqz	v0,9d004348 <_ZN8SdVolume4initEP7Sd2Cardh+0x30>
9d0043e0:	00008821 	move	s1,zero
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
9d0043e4:	3c02a000 	lui	v0,0xa000
9d0043e8:	24420aa4 	addiu	v0,v0,2724
9d0043ec:	9044000c 	lbu	a0,12(v0)
9d0043f0:	9043000b 	lbu	v1,11(v0)
9d0043f4:	00042200 	sll	a0,a0,0x8
9d0043f8:	00832025 	or	a0,a0,v1
9d0043fc:	24030200 	li	v1,512
9d004400:	1483ffd2 	bne	a0,v1,9d00434c <_ZN8SdVolume4initEP7Sd2Cardh+0x34>
9d004404:	8fbf001c 	lw	ra,28(sp)
9d004408:	90430010 	lbu	v1,16(v0)
9d00440c:	5060ffd0 	beqzl	v1,9d004350 <_ZN8SdVolume4initEP7Sd2Cardh+0x38>
9d004410:	02201021 	move	v0,s1
9d004414:	9444000e 	lhu	a0,14(v0)
9d004418:	5080ffcd 	beqzl	a0,9d004350 <_ZN8SdVolume4initEP7Sd2Cardh+0x38>
9d00441c:	02201021 	move	v0,s1
9d004420:	9046000d 	lbu	a2,13(v0)
9d004424:	10c0ffc9 	beqz	a2,9d00434c <_ZN8SdVolume4initEP7Sd2Cardh+0x34>
9d004428:	00002021 	move	a0,zero
    bpb->reservedSectorCount == 0 ||
    bpb->sectorsPerCluster == 0) {
       // not valid FAT volume
      return false;
  }
  fatCount_ = bpb->fatCount;
9d00442c:	a2430018 	sb	v1,24(s2)
  blocksPerCluster_ = bpb->sectorsPerCluster;
9d004430:	a2460004 	sb	a2,4(s2)

  // determine shift that is same as multiply by blocksPerCluster_
  clusterSizeShift_ = 0;
9d004434:	a2400010 	sb	zero,16(s2)
  while (blocksPerCluster_ != (1 << clusterSizeShift_)) {
9d004438:	00001821 	move	v1,zero
9d00443c:	24070001 	li	a3,1
9d004440:	0b401115 	j	9d004454 <_ZN8SdVolume4initEP7Sd2Cardh+0x13c>
9d004444:	24080009 	li	t0,9
    // error if not power of 2
    if (clusterSizeShift_++ > 7) return false;
9d004448:	24630001 	addiu	v1,v1,1
9d00444c:	1068002e 	beq	v1,t0,9d004508 <_ZN8SdVolume4initEP7Sd2Cardh+0x1f0>
9d004450:	a2440010 	sb	a0,16(s2)
9d004454:	24840001 	addiu	a0,a0,1
  fatCount_ = bpb->fatCount;
  blocksPerCluster_ = bpb->sectorsPerCluster;

  // determine shift that is same as multiply by blocksPerCluster_
  clusterSizeShift_ = 0;
  while (blocksPerCluster_ != (1 << clusterSizeShift_)) {
9d004458:	00672804 	sllv	a1,a3,v1
9d00445c:	14a6fffa 	bne	a1,a2,9d004448 <_ZN8SdVolume4initEP7Sd2Cardh+0x130>
9d004460:	308400ff 	andi	a0,a0,0xff
    // error if not power of 2
    if (clusterSizeShift_++ > 7) return false;
  }
  blocksPerFat_ = bpb->sectorsPerFat16 ?
                    bpb->sectorsPerFat16 : bpb->sectorsPerFat32;
9d004464:	94450016 	lhu	a1,22(v0)
9d004468:	50a00001 	beqzl	a1,9d004470 <_ZN8SdVolume4initEP7Sd2Cardh+0x158>
9d00446c:	8c450024 	lw	a1,36(v0)
9d004470:	ae450008 	sw	a1,8(s2)

  // count for FAT16 zero for FAT32
  rootDirEntryCount_ = bpb->rootDirEntryCount;

  // directory start for FAT16 dataStart for FAT32
  rootDirStart_ = fatStartBlock_ + bpb->fatCount * blocksPerFat_;
9d004474:	90460010 	lbu	a2,16(v0)
    if (clusterSizeShift_++ > 7) return false;
  }
  blocksPerFat_ = bpb->sectorsPerFat16 ?
                    bpb->sectorsPerFat16 : bpb->sectorsPerFat32;

  fatStartBlock_ = volumeStartBlock + bpb->reservedSectorCount;
9d004478:	9444000e 	lhu	a0,14(v0)

  // count for FAT16 zero for FAT32
  rootDirEntryCount_ = bpb->rootDirEntryCount;

  // directory start for FAT16 dataStart for FAT32
  rootDirStart_ = fatStartBlock_ + bpb->fatCount * blocksPerFat_;
9d00447c:	70a63802 	mul	a3,a1,a2
    if (clusterSizeShift_++ > 7) return false;
  }
  blocksPerFat_ = bpb->sectorsPerFat16 ?
                    bpb->sectorsPerFat16 : bpb->sectorsPerFat32;

  fatStartBlock_ = volumeStartBlock + bpb->reservedSectorCount;
9d004480:	02042021 	addu	a0,s0,a0
9d004484:	ae44001c 	sw	a0,28(s2)

  // count for FAT16 zero for FAT32
  rootDirEntryCount_ = bpb->rootDirEntryCount;
9d004488:	8c460010 	lw	a2,16(v0)
9d00448c:	7cc67a00 	ext	a2,a2,0x8,0x10
9d004490:	a6460022 	sh	a2,34(s2)

  // directory start for FAT16 dataStart for FAT32
  rootDirStart_ = fatStartBlock_ + bpb->fatCount * blocksPerFat_;
9d004494:	00e42821 	addu	a1,a3,a0
                    bpb->sectorsPerFat16 : bpb->sectorsPerFat32;

  fatStartBlock_ = volumeStartBlock + bpb->reservedSectorCount;

  // count for FAT16 zero for FAT32
  rootDirEntryCount_ = bpb->rootDirEntryCount;
9d004498:	30c4ffff 	andi	a0,a2,0xffff

  // directory start for FAT16 dataStart for FAT32
  rootDirStart_ = fatStartBlock_ + bpb->fatCount * blocksPerFat_;

  // data start for FAT16 and FAT32
  dataStartBlock_ = rootDirStart_ + ((32 * bpb->rootDirEntryCount + 511)/512);
9d00449c:	00042140 	sll	a0,a0,0x5
9d0044a0:	248401ff 	addiu	a0,a0,511
9d0044a4:	00042243 	sra	a0,a0,0x9
9d0044a8:	00a42021 	addu	a0,a1,a0

  // count for FAT16 zero for FAT32
  rootDirEntryCount_ = bpb->rootDirEntryCount;

  // directory start for FAT16 dataStart for FAT32
  rootDirStart_ = fatStartBlock_ + bpb->fatCount * blocksPerFat_;
9d0044ac:	ae450024 	sw	a1,36(s2)

  // data start for FAT16 and FAT32
  dataStartBlock_ = rootDirStart_ + ((32 * bpb->rootDirEntryCount + 511)/512);
9d0044b0:	ae440014 	sw	a0,20(s2)

  // total blocks for FAT16 or FAT32
  uint32_t totalBlocks = bpb->totalSectors16 ?
                           bpb->totalSectors16 : bpb->totalSectors32;
9d0044b4:	90450014 	lbu	a1,20(v0)
9d0044b8:	90460013 	lbu	a2,19(v0)
9d0044bc:	00052a00 	sll	a1,a1,0x8
9d0044c0:	00a62825 	or	a1,a1,a2
9d0044c4:	50a00001 	beqzl	a1,9d0044cc <_ZN8SdVolume4initEP7Sd2Cardh+0x1b4>
9d0044c8:	8c450020 	lw	a1,32(v0)
  // total data blocks
  clusterCount_ = totalBlocks - (dataStartBlock_ - volumeStartBlock);
9d0044cc:	02042023 	subu	a0,s0,a0
9d0044d0:	00852021 	addu	a0,a0,a1

  // divide by cluster size to get cluster count
  clusterCount_ >>= clusterSizeShift_;
9d0044d4:	00641806 	srlv	v1,a0,v1

  // FAT type is determined by cluster count
  if (clusterCount_ < 4085) {
9d0044d8:	2c640ff5 	sltiu	a0,v1,4085
9d0044dc:	1480000c 	bnez	a0,9d004510 <_ZN8SdVolume4initEP7Sd2Cardh+0x1f8>
9d0044e0:	ae43000c 	sw	v1,12(s2)
    fatType_ = 12;
  } else if (clusterCount_ < 65525) {
9d0044e4:	3404fff5 	li	a0,0xfff5
9d0044e8:	0064182b 	sltu	v1,v1,a0
9d0044ec:	1460000c 	bnez	v1,9d004520 <_ZN8SdVolume4initEP7Sd2Cardh+0x208>
9d0044f0:	24030020 	li	v1,32
    fatType_ = 16;
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
9d0044f4:	8c42002c 	lw	v0,44(v0)
    fatType_ = 32;
9d0044f8:	a2430020 	sb	v1,32(s2)
  if (clusterCount_ < 4085) {
    fatType_ = 12;
  } else if (clusterCount_ < 65525) {
    fatType_ = 16;
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
9d0044fc:	ae420024 	sw	v0,36(s2)
    fatType_ = 32;
  }
  return true;
9d004500:	0b4010d2 	j	9d004348 <_ZN8SdVolume4initEP7Sd2Cardh+0x30>
9d004504:	24110001 	li	s1,1

  // determine shift that is same as multiply by blocksPerCluster_
  clusterSizeShift_ = 0;
  while (blocksPerCluster_ != (1 << clusterSizeShift_)) {
    // error if not power of 2
    if (clusterSizeShift_++ > 7) return false;
9d004508:	0b4010d2 	j	9d004348 <_ZN8SdVolume4initEP7Sd2Cardh+0x30>
9d00450c:	00008821 	move	s1,zero
  // divide by cluster size to get cluster count
  clusterCount_ >>= clusterSizeShift_;

  // FAT type is determined by cluster count
  if (clusterCount_ < 4085) {
    fatType_ = 12;
9d004510:	2402000c 	li	v0,12
9d004514:	a2420020 	sb	v0,32(s2)
    fatType_ = 16;
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
    fatType_ = 32;
  }
  return true;
9d004518:	0b4010d2 	j	9d004348 <_ZN8SdVolume4initEP7Sd2Cardh+0x30>
9d00451c:	24110001 	li	s1,1

  // FAT type is determined by cluster count
  if (clusterCount_ < 4085) {
    fatType_ = 12;
  } else if (clusterCount_ < 65525) {
    fatType_ = 16;
9d004520:	24020010 	li	v0,16
9d004524:	a2420020 	sb	v0,32(s2)
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
    fatType_ = 32;
  }
  return true;
9d004528:	0b4010d2 	j	9d004348 <_ZN8SdVolume4initEP7Sd2Cardh+0x30>
9d00452c:	24110001 	li	s1,1

9d004530 <_ZN4DSPI8setSpeedEm>:

	uint16_t	brg;

	/* Compute the baud rate divider for this frequency.
	*/
	brg = (uint16_t)((F_CPU / (2 * spd)) - 1);
9d004530:	3c0204c4 	lui	v0,0x4c4
9d004534:	3442b400 	ori	v0,v0,0xb400
9d004538:	00052840 	sll	a1,a1,0x1
9d00453c:	0045001b 	divu	zero,v0,a1
9d004540:	00a001f4 	teq	a1,zero,0x7

	/* That the baud rate value is in the correct range.
	*/
	if (brg == 0xFFFF) {
9d004544:	3403ffff 	li	v1,0xffff

	uint16_t	brg;

	/* Compute the baud rate divider for this frequency.
	*/
	brg = (uint16_t)((F_CPU / (2 * spd)) - 1);
9d004548:	00001012 	mflo	v0
9d00454c:	2442ffff 	addiu	v0,v0,-1
9d004550:	3042ffff 	andi	v0,v0,0xffff

	/* That the baud rate value is in the correct range.
	*/
	if (brg == 0xFFFF) {
9d004554:	1043000a 	beq	v0,v1,9d004580 <_ZN4DSPI8setSpeedEm+0x50>
9d004558:	2c430200 	sltiu	v1,v0,512
		** Set it to the highest supported frequency.
		*/
		brg = 0;
	}

	if (brg > 0x1FF) {
9d00455c:	14600009 	bnez	v1,9d004584 <_ZN4DSPI8setSpeedEm+0x54>
9d004560:	240501ff 	li	a1,511

	/* Write the value to the SPI baud rate register. Section 23. SPI
	** of the PIC32 Family Reference Manual says to disable the SPI
	** controller before writing to the baud register
	*/
	pspi->sxCon.clr = (1 << _SPICON_ON);	// disable SPI
9d004564:	8c820020 	lw	v0,32(a0)
9d004568:	34038000 	li	v1,0x8000
9d00456c:	ac430004 	sw	v1,4(v0)
	pspi->sxBrg.reg = brg;
9d004570:	ac450030 	sw	a1,48(v0)
	pspi->sxCon.set = (1 << _SPICON_ON);	// enable SPI
9d004574:	ac430008 	sw	v1,8(v0)

}
9d004578:	03e00008 	jr	ra
9d00457c:	00000000 	nop
	*/
	if (brg == 0xFFFF) {
		/* The user tried to set a frequency that is too high to support.
		** Set it to the highest supported frequency.
		*/
		brg = 0;
9d004580:	00001021 	move	v0,zero
	}

	if (brg > 0x1FF) {
9d004584:	00402821 	move	a1,v0

	/* Write the value to the SPI baud rate register. Section 23. SPI
	** of the PIC32 Family Reference Manual says to disable the SPI
	** controller before writing to the baud register
	*/
	pspi->sxCon.clr = (1 << _SPICON_ON);	// disable SPI
9d004588:	8c820020 	lw	v0,32(a0)
9d00458c:	34038000 	li	v1,0x8000
9d004590:	ac430004 	sw	v1,4(v0)
	pspi->sxBrg.reg = brg;
9d004594:	ac450030 	sw	a1,48(v0)
	pspi->sxCon.set = (1 << _SPICON_ON);	// enable SPI
9d004598:	ac430008 	sw	v1,8(v0)

}
9d00459c:	03e00008 	jr	ra
9d0045a0:	00000000 	nop

9d0045a4 <_ZN4DSPI12setPinSelectEh>:
**		pin be an output driving high. This pin will then be use
**		by the setSelect method.
*/

void
DSPI::setPinSelect(uint8_t pin) {
9d0045a4:	27bdffe8 	addiu	sp,sp,-24
9d0045a8:	afb00010 	sw	s0,16(sp)
9d0045ac:	30a200ff 	andi	v0,a1,0xff
9d0045b0:	00808021 	move	s0,a0
9d0045b4:	afbf0014 	sw	ra,20(sp)

	pinSS = pin;

	pinMode(pinSS, OUTPUT);
9d0045b8:	00402021 	move	a0,v0
9d0045bc:	24050001 	li	a1,1
9d0045c0:	0f401387 	jal	9d004e1c <pinMode>
9d0045c4:	a202002a 	sb	v0,42(s0)
	digitalWrite(pinSS, HIGH);
9d0045c8:	9204002a 	lbu	a0,42(s0)

}
9d0045cc:	8fbf0014 	lw	ra,20(sp)
9d0045d0:	8fb00010 	lw	s0,16(sp)
DSPI::setPinSelect(uint8_t pin) {

	pinSS = pin;

	pinMode(pinSS, OUTPUT);
	digitalWrite(pinSS, HIGH);
9d0045d4:	24050001 	li	a1,1
9d0045d8:	0b4013cf 	j	9d004f3c <digitalWrite>
9d0045dc:	27bd0018 	addiu	sp,sp,24

9d0045e0 <_ZN4DSPI5beginEh>:
**		will set the clock rate to the default speed and the
**		pin for SS to the specified pin.
*/

void
DSPI::begin(uint8_t pinT) {
9d0045e0:	27bdffe0 	addiu	sp,sp,-32
9d0045e4:	afbf001c 	sw	ra,28(sp)
9d0045e8:	afb10018 	sw	s1,24(sp)
9d0045ec:	afb00014 	sw	s0,20(sp)
9d0045f0:	00808021 	move	s0,a0
9d0045f4:	30b100ff 	andi	s1,a1,0xff
	*/
    mapPps(pinMOSI, ppsMOSI);
#endif

    // set up the interrupt handler 
    setIntVector(vec, isr);
9d0045f8:	90840028 	lbu	a0,40(a0)
9d0045fc:	0f4012bf 	jal	9d004afc <setIntVector>
9d004600:	8e050024 	lw	a1,36(s0)
/* Initialize the pins. The pin directions for SDO, SDI and SCK
	** are set automatically when the SPI controller is enabled. The
	** SS pin isn't explicitly used by the SPI controller when in
	** master mode, so we need to initialize it ourselves.
	*/
	setPinSelect(pinT);
9d004604:	02002021 	move	a0,s0
9d004608:	0f401169 	jal	9d0045a4 <_ZN4DSPI12setPinSelectEh>
9d00460c:	02202821 	move	a1,s1

	/* Disable interrupts on this SPI controller.
	*/
	pregIec->clr = bitErr + bitRx + bitTx;
9d004610:	8e07000c 	lw	a3,12(s0)
9d004614:	8e030008 	lw	v1,8(s0)
9d004618:	8e060010 	lw	a2,16(s0)
9d00461c:	8e050004 	lw	a1,4(s0)

	/* Disable and reset the SPI controller.
	*/
	pspi->sxCon.reg = 0;
9d004620:	8e020020 	lw	v0,32(s0)
	*/
	bTmp = pspi->sxBuf.reg;

	/* Clear all SPI interrupt flags.
	*/
	pregIfs->clr = bitErr + bitRx + bitTx;
9d004624:	8e040000 	lw	a0,0(s0)
	*/
	setPinSelect(pinT);

	/* Disable interrupts on this SPI controller.
	*/
	pregIec->clr = bitErr + bitRx + bitTx;
9d004628:	00e31821 	addu	v1,a3,v1
9d00462c:	00661821 	addu	v1,v1,a2
9d004630:	aca30004 	sw	v1,4(a1)

	/* Disable and reset the SPI controller.
	*/
	pspi->sxCon.reg = 0;
9d004634:	ac400000 	sw	zero,0(v0)

	/* Clear the receive buffer.
	*/
	bTmp = pspi->sxBuf.reg;
9d004638:	8c450020 	lw	a1,32(v0)

	/* Clear all SPI interrupt flags.
	*/
	pregIfs->clr = bitErr + bitRx + bitTx;
9d00463c:	ac830004 	sw	v1,4(a0)

	/* Compute the address of the interrupt priority control register
	** used by this SPI controller.
	*/
	pregIpc = ((p32_regset *)&IPC0) + (vec / 4);	// interrupt priority control register
9d004640:	92040028 	lbu	a0,40(s0)
9d004644:	3c03bf88 	lui	v1,0xbf88
9d004648:	24631090 	addiu	v1,v1,4240
9d00464c:	00042882 	srl	a1,a0,0x2
9d004650:	00052900 	sll	a1,a1,0x4

	/* Compute the bit position of the interrupt priority bits for
	** this interrupt vector.
	*/
	bnVec = 8 * (vec % 4);
9d004654:	30840003 	andi	a0,a0,0x3
	pregIfs->clr = bitErr + bitRx + bitTx;

	/* Compute the address of the interrupt priority control register
	** used by this SPI controller.
	*/
	pregIpc = ((p32_regset *)&IPC0) + (vec / 4);	// interrupt priority control register
9d004658:	00651821 	addu	v1,v1,a1

	/* Compute the bit position of the interrupt priority bits for
	** this interrupt vector.
	*/
	bnVec = 8 * (vec % 4);
9d00465c:	000420c0 	sll	a0,a0,0x3
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	pregIpc->clr = (0x1F << bnVec);
9d004660:	2405001f 	li	a1,31
9d004664:	00852804 	sllv	a1,a1,a0
9d004668:	ac650004 	sw	a1,4(v1)
	pregIpc->set = ipl << bnVec;
9d00466c:	92050029 	lbu	a1,41(s0)
9d004670:	00852004 	sllv	a0,a1,a0
9d004674:	ac640008 	sw	a0,8(v1)

	/* Set the default baud rate.
	*/
	brg = (uint16_t)((F_CPU / (2 * _DSPI_SPD_DEFAULT)) - 1);
	pspi->sxBrg.reg = brg;
9d004678:	24030027 	li	v1,39
9d00467c:	ac430030 	sw	v1,48(v0)

	/* Clear the receive overflow bit and receive overflow error flag
	*/
	pspi->sxStat.clr = (1 << _SPISTAT_SPIROV);
9d004680:	24030040 	li	v1,64
9d004684:	ac430014 	sw	v1,20(v0)
	fRov = 0;
9d004688:	a200001f 	sb	zero,31(s0)
	** the SS pin MUST be kept as OUTPUT.
	*/
	pspi->sxCon.reg = 0;
	pspi->sxCon.set = (1 << _SPICON_ON) + (1 << _SPICON_MSTEN) + DSPI_MODE0;

}	
9d00468c:	8fbf001c 	lw	ra,28(sp)
	** Warning: if the SS pin ever becomes a LOW INPUT then SPI 
	** automatically switches to Slave, so the data direction of 
	** the SS pin MUST be kept as OUTPUT.
	*/
	pspi->sxCon.reg = 0;
	pspi->sxCon.set = (1 << _SPICON_ON) + (1 << _SPICON_MSTEN) + DSPI_MODE0;
9d004690:	34038120 	li	v1,0x8120
	/* Enable the SPI controller.
	** Warning: if the SS pin ever becomes a LOW INPUT then SPI 
	** automatically switches to Slave, so the data direction of 
	** the SS pin MUST be kept as OUTPUT.
	*/
	pspi->sxCon.reg = 0;
9d004694:	ac400000 	sw	zero,0(v0)
	pspi->sxCon.set = (1 << _SPICON_ON) + (1 << _SPICON_MSTEN) + DSPI_MODE0;

}	
9d004698:	8fb10018 	lw	s1,24(sp)
9d00469c:	8fb00014 	lw	s0,20(sp)
	** Warning: if the SS pin ever becomes a LOW INPUT then SPI 
	** automatically switches to Slave, so the data direction of 
	** the SS pin MUST be kept as OUTPUT.
	*/
	pspi->sxCon.reg = 0;
	pspi->sxCon.set = (1 << _SPICON_ON) + (1 << _SPICON_MSTEN) + DSPI_MODE0;
9d0046a0:	ac430008 	sw	v1,8(v0)

}	
9d0046a4:	03e00008 	jr	ra
9d0046a8:	27bd0020 	addiu	sp,sp,32

9d0046ac <_ZN4DSPI5beginEv>:
void
DSPI::begin() {

	/* Use the default pin specified in the constructor.
	*/
	begin(pinSS);
9d0046ac:	0b401178 	j	9d0045e0 <_ZN4DSPI5beginEh>
9d0046b0:	9085002a 	lbu	a1,42(a0)

9d0046b4 <_ZN4DSPI8transferEm>:
**		Send the specified byte to the SPI slave device, returning
**		the byte received from the slave device.
*/

uint32_t
DSPI::transfer(uint32_t bVal) {
9d0046b4:	8c820020 	lw	v0,32(a0)

	while ((pspi->sxStat.reg & (1 << _SPISTAT_SPITBE)) == 0) {
9d0046b8:	8c430010 	lw	v1,16(v0)
9d0046bc:	30630008 	andi	v1,v1,0x8
9d0046c0:	1060fffd 	beqz	v1,9d0046b8 <_ZN4DSPI8transferEm+0x4>
9d0046c4:	00000000 	nop
	}
	pspi->sxBuf.reg = bVal;
9d0046c8:	ac450020 	sw	a1,32(v0)

	while ((pspi->sxStat.reg & (1 << _SPISTAT_SPIRBF)) == 0) {
9d0046cc:	8c430010 	lw	v1,16(v0)
9d0046d0:	30630001 	andi	v1,v1,0x1
9d0046d4:	1060fffd 	beqz	v1,9d0046cc <_ZN4DSPI8transferEm+0x18>
9d0046d8:	00000000 	nop
	}

	return pspi->sxBuf.reg;
9d0046dc:	8c420020 	lw	v0,32(v0)

}
9d0046e0:	03e00008 	jr	ra
9d0046e4:	00000000 	nop

9d0046e8 <_ZN4DSPI8transferEtPh>:
*/

void
DSPI::transfer(uint16_t cbReq, uint8_t * pbSnd) {
#ifdef _SPI1ACON_ENHBUF_POSITION
    pspi->sxCon.clr = 1<<_SPI1ACON_ON_POSITION;
9d0046e8:	8c820020 	lw	v0,32(a0)
9d0046ec:	34038000 	li	v1,0x8000
    pspi->sxCon.set = 1<<_SPI1ACON_ENHBUF_POSITION;
9d0046f0:	3c040001 	lui	a0,0x1
**		slave device, discarding the bytes received from the
**		slave.
*/

void
DSPI::transfer(uint16_t cbReq, uint8_t * pbSnd) {
9d0046f4:	30a5ffff 	andi	a1,a1,0xffff
#ifdef _SPI1ACON_ENHBUF_POSITION
    pspi->sxCon.clr = 1<<_SPI1ACON_ON_POSITION;
9d0046f8:	ac430004 	sw	v1,4(v0)
    pspi->sxCon.set = 1<<_SPI1ACON_ENHBUF_POSITION;
9d0046fc:	ac440008 	sw	a0,8(v0)
    pspi->sxCon.set = 1<<_SPI1ACON_ON_POSITION;
9d004700:	ac430008 	sw	v1,8(v0)
    uint16_t toWrite = cbReq;
    uint16_t toRead = cbReq;
    uint16_t wPos = 0;

    while (toWrite > 0 && toRead > 0) {
9d004704:	10a0001c 	beqz	a1,9d004778 <_ZN4DSPI8transferEtPh+0x90>
9d004708:	34038000 	li	v1,0x8000
9d00470c:	00a01821 	move	v1,a1
9d004710:	00002021 	move	a0,zero
        if (toWrite > 0) {
9d004714:	1060000b 	beqz	v1,9d004744 <_ZN4DSPI8transferEtPh+0x5c>
9d004718:	00000000 	nop
            if ((pspi->sxStat.reg & 1<<_SPI1ASTAT_SPITBF_POSITION) == 0) {
9d00471c:	8c470010 	lw	a3,16(v0)
                pspi->sxBuf.reg = pbSnd[wPos++];
9d004720:	00c45021 	addu	t2,a2,a0
9d004724:	24880001 	addiu	t0,a0,1
    uint16_t toRead = cbReq;
    uint16_t wPos = 0;

    while (toWrite > 0 && toRead > 0) {
        if (toWrite > 0) {
            if ((pspi->sxStat.reg & 1<<_SPI1ASTAT_SPITBF_POSITION) == 0) {
9d004728:	30e70002 	andi	a3,a3,0x2
9d00472c:	14e00005 	bnez	a3,9d004744 <_ZN4DSPI8transferEtPh+0x5c>
9d004730:	2469ffff 	addiu	t1,v1,-1
                pspi->sxBuf.reg = pbSnd[wPos++];
9d004734:	91470000 	lbu	a3,0(t2)
                toWrite--;
9d004738:	3123ffff 	andi	v1,t1,0xffff
    uint16_t wPos = 0;

    while (toWrite > 0 && toRead > 0) {
        if (toWrite > 0) {
            if ((pspi->sxStat.reg & 1<<_SPI1ASTAT_SPITBF_POSITION) == 0) {
                pspi->sxBuf.reg = pbSnd[wPos++];
9d00473c:	3104ffff 	andi	a0,t0,0xffff
9d004740:	ac470020 	sw	a3,32(v0)
                toWrite--;
            }
        }
        if (toRead > 0) {
9d004744:	10a00007 	beqz	a1,9d004764 <_ZN4DSPI8transferEtPh+0x7c>
9d004748:	00000000 	nop
            if ((pspi->sxStat.reg & 1<<_SPI1ASTAT_SPIRBE_POSITION) == 0) {
9d00474c:	8c470010 	lw	a3,16(v0)
9d004750:	30e70020 	andi	a3,a3,0x20
9d004754:	14e00003 	bnez	a3,9d004764 <_ZN4DSPI8transferEtPh+0x7c>
9d004758:	24a8ffff 	addiu	t0,a1,-1
                (void) pspi->sxBuf.reg;
9d00475c:	8c450020 	lw	a1,32(v0)
                toRead--;
9d004760:	3105ffff 	andi	a1,t0,0xffff
    pspi->sxCon.set = 1<<_SPI1ACON_ON_POSITION;
    uint16_t toWrite = cbReq;
    uint16_t toRead = cbReq;
    uint16_t wPos = 0;

    while (toWrite > 0 && toRead > 0) {
9d004764:	50600004 	beqzl	v1,9d004778 <_ZN4DSPI8transferEtPh+0x90>
9d004768:	34038000 	li	v1,0x8000
9d00476c:	14a0ffe9 	bnez	a1,9d004714 <_ZN4DSPI8transferEtPh+0x2c>
9d004770:	00000000 	nop
                (void) pspi->sxBuf.reg;
                toRead--;
            }
        }
    }
    pspi->sxCon.clr = 1<<_SPI1ACON_ON_POSITION;
9d004774:	34038000 	li	v1,0x8000
    pspi->sxCon.clr = 1<<_SPI1ACON_ENHBUF_POSITION;
9d004778:	3c040001 	lui	a0,0x1
                (void) pspi->sxBuf.reg;
                toRead--;
            }
        }
    }
    pspi->sxCon.clr = 1<<_SPI1ACON_ON_POSITION;
9d00477c:	ac430004 	sw	v1,4(v0)
    pspi->sxCon.clr = 1<<_SPI1ACON_ENHBUF_POSITION;
9d004780:	ac440004 	sw	a0,4(v0)
    pspi->sxCon.set = 1<<_SPI1ACON_ON_POSITION;
9d004784:	ac430008 	sw	v1,8(v0)

	for (cbCur = cbReq; cbCur > 0; cbCur--) {
		transfer(*pbSnd++);
	}
#endif
}
9d004788:	03e00008 	jr	ra
9d00478c:	00000000 	nop

9d004790 <_ZN4DSPI8transferEthPh>:
*/

void
DSPI::transfer(uint16_t cbReq, uint8_t bPad, uint8_t * pbRcv) {
#ifdef _SPI1ACON_ENHBUF_POSITION
    pspi->sxCon.clr = 1<<_SPI1ACON_ON_POSITION;
9d004790:	8c820020 	lw	v0,32(a0)
9d004794:	34038000 	li	v1,0x8000
    pspi->sxCon.set = 1<<_SPI1ACON_ENHBUF_POSITION;
9d004798:	3c080001 	lui	t0,0x1
**		from the slave. The given pad byte will be sent to the
**		slave to cause the received bytes to be sent.
*/

void
DSPI::transfer(uint16_t cbReq, uint8_t bPad, uint8_t * pbRcv) {
9d00479c:	30a5ffff 	andi	a1,a1,0xffff
#ifdef _SPI1ACON_ENHBUF_POSITION
    pspi->sxCon.clr = 1<<_SPI1ACON_ON_POSITION;
9d0047a0:	ac430004 	sw	v1,4(v0)
**		from the slave. The given pad byte will be sent to the
**		slave to cause the received bytes to be sent.
*/

void
DSPI::transfer(uint16_t cbReq, uint8_t bPad, uint8_t * pbRcv) {
9d0047a4:	30c600ff 	andi	a2,a2,0xff
#ifdef _SPI1ACON_ENHBUF_POSITION
    pspi->sxCon.clr = 1<<_SPI1ACON_ON_POSITION;
    pspi->sxCon.set = 1<<_SPI1ACON_ENHBUF_POSITION;
9d0047a8:	ac480008 	sw	t0,8(v0)
    pspi->sxCon.set = 1<<_SPI1ACON_ON_POSITION;
9d0047ac:	ac430008 	sw	v1,8(v0)
    uint16_t toWrite = cbReq;
    uint16_t toRead = cbReq;
    uint16_t rPos = 0;

    while (toWrite > 0 && toRead > 0) {
9d0047b0:	10a0001d 	beqz	a1,9d004828 <_ZN4DSPI8transferEthPh+0x98>
9d0047b4:	34038000 	li	v1,0x8000
9d0047b8:	00a01821 	move	v1,a1
9d0047bc:	00004021 	move	t0,zero
        if (toWrite > 0) {
9d0047c0:	10600007 	beqz	v1,9d0047e0 <_ZN4DSPI8transferEthPh+0x50>
9d0047c4:	00000000 	nop
            if ((pspi->sxStat.reg & 1<<_SPI1ASTAT_SPITBF_POSITION) == 0) {
9d0047c8:	8c490010 	lw	t1,16(v0)
9d0047cc:	31290002 	andi	t1,t1,0x2
9d0047d0:	15200003 	bnez	t1,9d0047e0 <_ZN4DSPI8transferEthPh+0x50>
9d0047d4:	246affff 	addiu	t2,v1,-1
                pspi->sxBuf.reg = bPad;
9d0047d8:	ac460020 	sw	a2,32(v0)
                toWrite--;
9d0047dc:	3143ffff 	andi	v1,t2,0xffff
            }
        }
        if (toRead > 0) {
9d0047e0:	10a0000c 	beqz	a1,9d004814 <_ZN4DSPI8transferEthPh+0x84>
9d0047e4:	00000000 	nop
            if ((pspi->sxStat.reg & 1<<_SPI1ASTAT_SPIRBE_POSITION) == 0) {
9d0047e8:	8c490010 	lw	t1,16(v0)
                pbRcv[rPos++] = pspi->sxBuf.reg;
9d0047ec:	00e85021 	addu	t2,a3,t0
9d0047f0:	250b0001 	addiu	t3,t0,1
                pspi->sxBuf.reg = bPad;
                toWrite--;
            }
        }
        if (toRead > 0) {
            if ((pspi->sxStat.reg & 1<<_SPI1ASTAT_SPIRBE_POSITION) == 0) {
9d0047f4:	31290020 	andi	t1,t1,0x20
9d0047f8:	15200006 	bnez	t1,9d004814 <_ZN4DSPI8transferEthPh+0x84>
9d0047fc:	24acffff 	addiu	t4,a1,-1
                pbRcv[rPos++] = pspi->sxBuf.reg;
9d004800:	8c420020 	lw	v0,32(v0)
                toRead--;
9d004804:	3185ffff 	andi	a1,t4,0xffff
                toWrite--;
            }
        }
        if (toRead > 0) {
            if ((pspi->sxStat.reg & 1<<_SPI1ASTAT_SPIRBE_POSITION) == 0) {
                pbRcv[rPos++] = pspi->sxBuf.reg;
9d004808:	3168ffff 	andi	t0,t3,0xffff
9d00480c:	a1420000 	sb	v0,0(t2)
                toRead--;
9d004810:	8c820020 	lw	v0,32(a0)
    pspi->sxCon.set = 1<<_SPI1ACON_ON_POSITION;
    uint16_t toWrite = cbReq;
    uint16_t toRead = cbReq;
    uint16_t rPos = 0;

    while (toWrite > 0 && toRead > 0) {
9d004814:	50600004 	beqzl	v1,9d004828 <_ZN4DSPI8transferEthPh+0x98>
9d004818:	34038000 	li	v1,0x8000
9d00481c:	14a0ffe8 	bnez	a1,9d0047c0 <_ZN4DSPI8transferEthPh+0x30>
9d004820:	00000000 	nop
                pbRcv[rPos++] = pspi->sxBuf.reg;
                toRead--;
            }
        }
    }
    pspi->sxCon.clr = 1<<_SPI1ACON_ON_POSITION;
9d004824:	34038000 	li	v1,0x8000
    pspi->sxCon.clr = 1<<_SPI1ACON_ENHBUF_POSITION;
9d004828:	3c040001 	lui	a0,0x1
                pbRcv[rPos++] = pspi->sxBuf.reg;
                toRead--;
            }
        }
    }
    pspi->sxCon.clr = 1<<_SPI1ACON_ON_POSITION;
9d00482c:	ac430004 	sw	v1,4(v0)
    pspi->sxCon.clr = 1<<_SPI1ACON_ENHBUF_POSITION;
9d004830:	ac440004 	sw	a0,4(v0)
    pspi->sxCon.set = 1<<_SPI1ACON_ON_POSITION;
9d004834:	ac430008 	sw	v1,8(v0)

	for (cbCur = cbReq; cbCur > 0; cbCur--) {
		*pbRcv++ = transfer(bPad);
	}
#endif
}
9d004838:	03e00008 	jr	ra
9d00483c:	00000000 	nop

9d004840 <_ZN4DSPI15doDspiInterruptEv>:
	uint8_t		bTmp;
	uint32_t	regIfs;

	/* Get the interrupt flag status.
	*/
	regIfs = pregIfs->reg;
9d004840:	8c820000 	lw	v0,0(a0)

	/* Check for and handle overrun error interrupt.
	*/
	if ((regIfs & bitErr) != 0) {
9d004844:	8c830008 	lw	v1,8(a0)
	uint8_t		bTmp;
	uint32_t	regIfs;

	/* Get the interrupt flag status.
	*/
	regIfs = pregIfs->reg;
9d004848:	8c450000 	lw	a1,0(v0)

	/* Check for and handle overrun error interrupt.
	*/
	if ((regIfs & bitErr) != 0) {
9d00484c:	00653024 	and	a2,v1,a1
9d004850:	50c00008 	beqzl	a2,9d004874 <_ZN4DSPI15doDspiInterruptEv+0x34>
9d004854:	8c83000c 	lw	v1,12(a0)
		fRov = 1;				// set the receive overflow error flag;
		pspi->sxStat.clr = (1 << _SPISTAT_SPIROV);	//clear status bit
9d004858:	8c860020 	lw	a2,32(a0)
	regIfs = pregIfs->reg;

	/* Check for and handle overrun error interrupt.
	*/
	if ((regIfs & bitErr) != 0) {
		fRov = 1;				// set the receive overflow error flag;
9d00485c:	24070001 	li	a3,1
9d004860:	a087001f 	sb	a3,31(a0)
		pspi->sxStat.clr = (1 << _SPISTAT_SPIROV);	//clear status bit
9d004864:	24070040 	li	a3,64
9d004868:	acc70014 	sw	a3,20(a2)
		pregIfs->clr = bitErr;
9d00486c:	ac430004 	sw	v1,4(v0)
	}

	/* Check for and handle receive interrupt.
	*/
	if ((regIfs & bitRx) != 0) {
9d004870:	8c83000c 	lw	v1,12(a0)
9d004874:	00a32824 	and	a1,a1,v1
9d004878:	10a0001d 	beqz	a1,9d0048f0 <_ZN4DSPI15doDspiInterruptEv+0xb0>
9d00487c:	00000000 	nop

		/* Get the received character.
		*/
		bTmp = pspi->sxBuf.reg;		//read next byte from SPI controller
9d004880:	8c860020 	lw	a2,32(a0)
		cbCur -= 1;					//count this byte as received

		/* Are we storing it? pbRcvCur is 0 if we are sending only
		** and ignoring the received data.
		*/
		if (pbRcvCur != 0) {
9d004884:	8c850018 	lw	a1,24(a0)
	*/
	if ((regIfs & bitRx) != 0) {

		/* Get the received character.
		*/
		bTmp = pspi->sxBuf.reg;		//read next byte from SPI controller
9d004888:	8cc70020 	lw	a3,32(a2)
		cbCur -= 1;					//count this byte as received
9d00488c:	9486001c 	lhu	a2,28(a0)
9d004890:	24c6ffff 	addiu	a2,a2,-1
9d004894:	30c6ffff 	andi	a2,a2,0xffff
9d004898:	a486001c 	sh	a2,28(a0)

		/* Are we storing it? pbRcvCur is 0 if we are sending only
		** and ignoring the received data.
		*/
		if (pbRcvCur != 0) {
9d00489c:	10a00006 	beqz	a1,9d0048b8 <_ZN4DSPI15doDspiInterruptEv+0x78>
9d0048a0:	30e700ff 	andi	a3,a3,0xff
			*pbRcvCur++ = bTmp;		//store the received byte into output buffer
9d0048a4:	a0a70000 	sb	a3,0(a1)
9d0048a8:	8c820000 	lw	v0,0(a0)
9d0048ac:	8c83000c 	lw	v1,12(a0)
9d0048b0:	24a50001 	addiu	a1,a1,1
9d0048b4:	ac850018 	sw	a1,24(a0)
		}

		/* Send the next byte to the slave. pbSndCur is 0 if we are
		** receiving only. In this case send the pad byte.
		*/
		if (cbCur > 0) {
9d0048b8:	9485001c 	lhu	a1,28(a0)
9d0048bc:	30a5ffff 	andi	a1,a1,0xffff
9d0048c0:	10a0000a 	beqz	a1,9d0048ec <_ZN4DSPI15doDspiInterruptEv+0xac>
9d0048c4:	00000000 	nop
			bTmp = (pbSndCur != 0) ? *pbSndCur++ : bPad;
9d0048c8:	8c850014 	lw	a1,20(a0)
9d0048cc:	50a0000a 	beqzl	a1,9d0048f8 <_ZN4DSPI15doDspiInterruptEv+0xb8>
9d0048d0:	9085001e 	lbu	a1,30(a0)
9d0048d4:	90a60000 	lbu	a2,0(a1)
9d0048d8:	24a50001 	addiu	a1,a1,1
9d0048dc:	ac850014 	sw	a1,20(a0)
			pspi->sxBuf.reg = bTmp;
9d0048e0:	8c840020 	lw	a0,32(a0)

		/* Send the next byte to the slave. pbSndCur is 0 if we are
		** receiving only. In this case send the pad byte.
		*/
		if (cbCur > 0) {
			bTmp = (pbSndCur != 0) ? *pbSndCur++ : bPad;
9d0048e4:	30c500ff 	andi	a1,a2,0xff
			pspi->sxBuf.reg = bTmp;
9d0048e8:	ac850020 	sw	a1,32(a0)
		}

		pregIfs->clr = bitRx;		//clear the receive interrupt flag
9d0048ec:	ac430004 	sw	v1,4(v0)
9d0048f0:	03e00008 	jr	ra
9d0048f4:	00000000 	nop
		/* Send the next byte to the slave. pbSndCur is 0 if we are
		** receiving only. In this case send the pad byte.
		*/
		if (cbCur > 0) {
			bTmp = (pbSndCur != 0) ? *pbSndCur++ : bPad;
			pspi->sxBuf.reg = bTmp;
9d0048f8:	8c840020 	lw	a0,32(a0)
9d0048fc:	ac850020 	sw	a1,32(a0)
9d004900:	0b40123b 	j	9d0048ec <_ZN4DSPI15doDspiInterruptEv+0xac>
9d004904:	00000000 	nop

9d004908 <IntDspi0Handler>:
**		logical SPI port DSPI0
*/
#if defined(_DSPI0_VECTOR)

void __attribute__((interrupt(), nomips16)) IntDspi0Handler(void)
{
9d004908:	415de800 	rdpgpr	sp,sp
9d00490c:	401b7000 	mfc0	k1,c0_epc
9d004910:	401a6002 	mfc0	k0,c0_srsctl
9d004914:	27bdff90 	addiu	sp,sp,-112
9d004918:	afbb006c 	sw	k1,108(sp)
9d00491c:	401b6000 	mfc0	k1,c0_status
9d004920:	afba0068 	sw	k0,104(sp)
9d004924:	401a6800 	mfc0	k0,c0_cause
9d004928:	001ad282 	srl	k0,k0,0xa
9d00492c:	afbb0064 	sw	k1,100(sp)
9d004930:	7f5b7a84 	ins	k1,k0,0xa,0x6
9d004934:	7c1b2044 	ins	k1,zero,0x1,0x4
9d004938:	409b6000 	mtc0	k1,c0_status
9d00493c:	afa30018 	sw	v1,24(sp)
9d004940:	8fa30068 	lw	v1,104(sp)
9d004944:	3063000f 	andi	v1,v1,0xf
9d004948:	14600011 	bnez	v1,9d004990 <IntDspi0Handler+0x88>
9d00494c:	afa20014 	sw	v0,20(sp)
9d004950:	afbf0054 	sw	ra,84(sp)
9d004954:	afb90050 	sw	t9,80(sp)
9d004958:	afb8004c 	sw	t8,76(sp)
9d00495c:	afaf0048 	sw	t7,72(sp)
9d004960:	afae0044 	sw	t6,68(sp)
9d004964:	afad0040 	sw	t5,64(sp)
9d004968:	afac003c 	sw	t4,60(sp)
9d00496c:	afab0038 	sw	t3,56(sp)
9d004970:	afaa0034 	sw	t2,52(sp)
9d004974:	afa90030 	sw	t1,48(sp)
9d004978:	afa8002c 	sw	t0,44(sp)
9d00497c:	afa70028 	sw	a3,40(sp)
9d004980:	afa60024 	sw	a2,36(sp)
9d004984:	afa50020 	sw	a1,32(sp)
9d004988:	afa4001c 	sw	a0,28(sp)
9d00498c:	afa10010 	sw	at,16(sp)
	if (pdspi0 != 0) {
9d004990:	8f84803c 	lw	a0,-32708(gp)
**		logical SPI port DSPI0
*/
#if defined(_DSPI0_VECTOR)

void __attribute__((interrupt(), nomips16)) IntDspi0Handler(void)
{
9d004994:	00001012 	mflo	v0
9d004998:	afa2005c 	sw	v0,92(sp)
9d00499c:	00001810 	mfhi	v1
	if (pdspi0 != 0) {
9d0049a0:	10800003 	beqz	a0,9d0049b0 <IntDspi0Handler+0xa8>
9d0049a4:	afa30058 	sw	v1,88(sp)
		pdspi0->doDspiInterrupt();
9d0049a8:	0f401210 	jal	9d004840 <_ZN4DSPI15doDspiInterruptEv>
9d0049ac:	00000000 	nop
	}
}
9d0049b0:	8fa2005c 	lw	v0,92(sp)
9d0049b4:	8fa30058 	lw	v1,88(sp)
9d0049b8:	00400013 	mtlo	v0
9d0049bc:	8fa20068 	lw	v0,104(sp)
9d0049c0:	3042000f 	andi	v0,v0,0xf
9d0049c4:	14400013 	bnez	v0,9d004a14 <IntDspi0Handler+0x10c>
9d0049c8:	00600011 	mthi	v1
9d0049cc:	8fbf0054 	lw	ra,84(sp)
9d0049d0:	8fb90050 	lw	t9,80(sp)
9d0049d4:	8fb8004c 	lw	t8,76(sp)
9d0049d8:	8faf0048 	lw	t7,72(sp)
9d0049dc:	8fae0044 	lw	t6,68(sp)
9d0049e0:	8fad0040 	lw	t5,64(sp)
9d0049e4:	8fac003c 	lw	t4,60(sp)
9d0049e8:	8fab0038 	lw	t3,56(sp)
9d0049ec:	8faa0034 	lw	t2,52(sp)
9d0049f0:	8fa90030 	lw	t1,48(sp)
9d0049f4:	8fa8002c 	lw	t0,44(sp)
9d0049f8:	8fa70028 	lw	a3,40(sp)
9d0049fc:	8fa60024 	lw	a2,36(sp)
9d004a00:	8fa50020 	lw	a1,32(sp)
9d004a04:	8fa4001c 	lw	a0,28(sp)
9d004a08:	8fa30018 	lw	v1,24(sp)
9d004a0c:	8fa20014 	lw	v0,20(sp)
9d004a10:	8fa10010 	lw	at,16(sp)
9d004a14:	41606000 	di
9d004a18:	000000c0 	ehb
9d004a1c:	8fba006c 	lw	k0,108(sp)
9d004a20:	8fbb0064 	lw	k1,100(sp)
9d004a24:	409a7000 	mtc0	k0,c0_epc
9d004a28:	8fba0068 	lw	k0,104(sp)
9d004a2c:	27bd0070 	addiu	sp,sp,112
9d004a30:	409a6002 	mtc0	k0,c0_srsctl
9d004a34:	41dde800 	wrpgpr	sp,sp
9d004a38:	409b6000 	mtc0	k1,c0_status
9d004a3c:	42000018 	eret

9d004a40 <_ZN5DSPI0C1Ev>:
#else
DSPI0::DSPI0() 
#endif
{

	pspi = (p32_spi *) _DSPI0_BASE;
9d004a40:	3c02bf80 	lui	v0,0xbf80
9d004a44:	24425a00 	addiu	v0,v0,23040
9d004a48:	ac820020 	sw	v0,32(a0)
	vec = _DSPI0_VECTOR;
9d004a4c:	2402001f 	li	v0,31
9d004a50:	a0820028 	sb	v0,40(a0)
	ipl = ((_DSPI0_IPL & 0x07) << 2) + (_DSPI0_SPL & 0x03);
9d004a54:	24020008 	li	v0,8
9d004a58:	a0820029 	sb	v0,41(a0)
	pinSS = PIN_DSPI0_SS;
9d004a5c:	24020069 	li	v0,105
9d004a60:	a082002a 	sb	v0,42(a0)
	** and IEC register. For each IFS register, there is a SET, CLR,
	** and INV register, so the distance (in dwords) from IFS0 to IFS1
	** is 4. This code assumes that all of the enable control and flag
	** bits for an SPI controller are in the same IEC and IFS registers.
	*/
	pregIec = ((p32_regset *)&IEC0) + (irqErr / 32);	// interrupt enable control register
9d004a64:	3c02bf88 	lui	v0,0xbf88
9d004a68:	24421070 	addiu	v0,v0,4208
9d004a6c:	ac820004 	sw	v0,4(a0)
	pregIfs = ((p32_regset *)&IFS0) + (irqErr / 32);	// interrupt flag register
9d004a70:	3c02bf88 	lui	v0,0xbf88
9d004a74:	24421040 	addiu	v0,v0,4160
9d004a78:	ac820000 	sw	v0,0(a0)

	bitErr = 1 << (irqErr % 32);	// error interrupt flag/enable bit
9d004a7c:	24020020 	li	v0,32
9d004a80:	ac820008 	sw	v0,8(a0)
	bitRx  = 1 << (irqRx % 32);		// rx interrupt flag/enable bit
9d004a84:	24020040 	li	v0,64
9d004a88:	ac82000c 	sw	v0,12(a0)
	bitTx  = 1 << (irqTx % 32);		// tx interrupt flag/enable bit
9d004a8c:	24020080 	li	v0,128
9d004a90:	ac820010 	sw	v0,16(a0)

    isr = isrHandler;
9d004a94:	3c029d00 	lui	v0,0x9d00
9d004a98:	24424908 	addiu	v0,v0,18696
DSPI::DSPI()
#endif
 {

	pspi = 0;
	cbCur = 0;
9d004a9c:	a480001c 	sh	zero,28(a0)
	vec = _DSPI0_VECTOR;
	ipl = ((_DSPI0_IPL & 0x07) << 2) + (_DSPI0_SPL & 0x03);
	pinSS = PIN_DSPI0_SS;

	init(_DSPI0_ERR_IRQ, _DSPI0_RX_IRQ, _DSPI0_TX_IRQ, IntDspi0Handler);
}
9d004aa0:	03e00008 	jr	ra
9d004aa4:	ac820024 	sw	v0,36(a0)

9d004aa8 <initIntVector>:
*/
void initIntVector(void)
{
    const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    int i = 0;
    void * pvOrgIntVec = (void *)pImageHeader->pOrgVector0;
9d004aa8:	3c029d01 	lui	v0,0x9d01
9d004aac:	244286d0 	addiu	v0,v0,-31024
9d004ab0:	88430043 	lwl	v1,67(v0)
9d004ab4:	8846004b 	lwl	a2,75(v0)
    {
        // If a compiler installed interrupt handler exits, pre-load it
        // and don't fool with the priority
        if(*((uint32_t *) pvOrgIntVec) != 0xFFFFFFFF)
        {
            _isr_primary_install[i] = (isrFunc) pvOrgIntVec;
9d004ab8:	3c08a000 	lui	t0,0xa000
*/
void initIntVector(void)
{
    const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    int i = 0;
    void * pvOrgIntVec = (void *)pImageHeader->pOrgVector0;
9d004abc:	98430040 	lwr	v1,64(v0)
9d004ac0:	98460048 	lwr	a2,72(v0)

    for(i=0; i<NUM_INT_VECTOR; i++)
    {
        // If a compiler installed interrupt handler exits, pre-load it
        // and don't fool with the priority
        if(*((uint32_t *) pvOrgIntVec) != 0xFFFFFFFF)
9d004ac4:	2409ffff 	li	t1,-1
{
    const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    int i = 0;
    void * pvOrgIntVec = (void *)pImageHeader->pOrgVector0;

    for(i=0; i<NUM_INT_VECTOR; i++)
9d004ac8:	00001021 	move	v0,zero
    {
        // If a compiler installed interrupt handler exits, pre-load it
        // and don't fool with the priority
        if(*((uint32_t *) pvOrgIntVec) != 0xFFFFFFFF)
        {
            _isr_primary_install[i] = (isrFunc) pvOrgIntVec;
9d004acc:	25080008 	addiu	t0,t0,8
{
    const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    int i = 0;
    void * pvOrgIntVec = (void *)pImageHeader->pOrgVector0;

    for(i=0; i<NUM_INT_VECTOR; i++)
9d004ad0:	24070034 	li	a3,52
    {
        // If a compiler installed interrupt handler exits, pre-load it
        // and don't fool with the priority
        if(*((uint32_t *) pvOrgIntVec) != 0xFFFFFFFF)
9d004ad4:	8c640000 	lw	a0,0(v1)
        {
            _isr_primary_install[i] = (isrFunc) pvOrgIntVec;
9d004ad8:	00022880 	sll	a1,v0,0x2
9d004adc:	00a82821 	addu	a1,a1,t0

    for(i=0; i<NUM_INT_VECTOR; i++)
    {
        // If a compiler installed interrupt handler exits, pre-load it
        // and don't fool with the priority
        if(*((uint32_t *) pvOrgIntVec) != 0xFFFFFFFF)
9d004ae0:	10890002 	beq	a0,t1,9d004aec <initIntVector+0x44>
9d004ae4:	24420001 	addiu	v0,v0,1
        {
            _isr_primary_install[i] = (isrFunc) pvOrgIntVec;
9d004ae8:	aca30000 	sw	v1,0(a1)
{
    const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    int i = 0;
    void * pvOrgIntVec = (void *)pImageHeader->pOrgVector0;

    for(i=0; i<NUM_INT_VECTOR; i++)
9d004aec:	1447fff9 	bne	v0,a3,9d004ad4 <initIntVector+0x2c>
9d004af0:	00661821 	addu	v1,v1,a2
9d004af4:	03e00008 	jr	ra
9d004af8:	00000000 	nop

9d004afc <setIntVector>:
isrFunc setIntVector(int vec, isrFunc func)
{
 //   const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    isrFunc t = 0;

    if (vec < NUM_INT_VECTOR)
9d004afc:	28830034 	slti	v1,a0,52
9d004b00:	10600007 	beqz	v1,9d004b20 <setIntVector+0x24>
9d004b04:	00001021 	move	v0,zero
    {
        t = _isr_primary_install[vec];
9d004b08:	3c02a000 	lui	v0,0xa000
9d004b0c:	24420008 	addiu	v0,v0,8
9d004b10:	00042080 	sll	a0,a0,0x2
9d004b14:	00822021 	addu	a0,a0,v0
9d004b18:	8c820000 	lw	v0,0(a0)
        _isr_primary_install[vec] = func;       
9d004b1c:	ac850000 	sw	a1,0(a0)
    }

    return t;
}
9d004b20:	03e00008 	jr	ra
9d004b24:	00000000 	nop

9d004b28 <setIntEnable>:
uint32_t setIntEnable(int irq)
{
	p32_regset *	iec;
	uint32_t		st;

	iec = ((p32_regset *)&IEC0) + (irq / 32);
9d004b28:	28830000 	slti	v1,a0,0
9d004b2c:	2482001f 	addiu	v0,a0,31
9d004b30:	0083100a 	movz	v0,a0,v1
9d004b34:	00021143 	sra	v0,v0,0x5
9d004b38:	3c03bf88 	lui	v1,0xbf88
9d004b3c:	00021100 	sll	v0,v0,0x4
	st = iec->reg;
	iec->set = 1 << (irq % 32);
9d004b40:	24050001 	li	a1,1
uint32_t setIntEnable(int irq)
{
	p32_regset *	iec;
	uint32_t		st;

	iec = ((p32_regset *)&IEC0) + (irq / 32);
9d004b44:	24631060 	addiu	v1,v1,4192
9d004b48:	00621821 	addu	v1,v1,v0
	st = iec->reg;
	iec->set = 1 << (irq % 32);
9d004b4c:	00852004 	sllv	a0,a1,a0
{
	p32_regset *	iec;
	uint32_t		st;

	iec = ((p32_regset *)&IEC0) + (irq / 32);
	st = iec->reg;
9d004b50:	8c620000 	lw	v0,0(v1)
	iec->set = 1 << (irq % 32);
9d004b54:	ac640008 	sw	a0,8(v1)
	return st;
}
9d004b58:	03e00008 	jr	ra
9d004b5c:	00000000 	nop

9d004b60 <setIntPriority>:
	ipc = ((p32_regset *)&IPC0) + (vec / 4);

	/* Compute the number of bit positions to shift to get to the
	** correct position for the priority bits for this vector.
	*/
	bn = 8 * (vec % 4);
9d004b60:	000417c3 	sra	v0,a0,0x1f
9d004b64:	00021782 	srl	v0,v0,0x1e
9d004b68:	00821821 	addu	v1,a0,v0
	int				bn;

	/* Compute the address of the interrupt priority control register used
	** by this interrupt vector
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);
9d004b6c:	24870003 	addiu	a3,a0,3
9d004b70:	28880000 	slti	t0,a0,0

	/* Compute the number of bit positions to shift to get to the
	** correct position for the priority bits for this vector.
	*/
	bn = 8 * (vec % 4);
9d004b74:	30630003 	andi	v1,v1,0x3
	int				bn;

	/* Compute the address of the interrupt priority control register used
	** by this interrupt vector
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);
9d004b78:	00e8200b 	movn	a0,a3,t0

	/* Compute the number of bit positions to shift to get to the
	** correct position for the priority bits for this vector.
	*/
	bn = 8 * (vec % 4);
9d004b7c:	00621023 	subu	v0,v1,v0
	int				bn;

	/* Compute the address of the interrupt priority control register used
	** by this interrupt vector
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);
9d004b80:	00042083 	sra	a0,a0,0x2
9d004b84:	3c03bf88 	lui	v1,0xbf88
9d004b88:	24631090 	addiu	v1,v1,4240
	bn = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = (0x1F << bn);
	ipc->set = ((ipl << 2) + spl) << bn;
9d004b8c:	00052880 	sll	a1,a1,0x2
	int				bn;

	/* Compute the address of the interrupt priority control register used
	** by this interrupt vector
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);
9d004b90:	00042100 	sll	a0,a0,0x4
9d004b94:	00642021 	addu	a0,v1,a0

	/* Compute the number of bit positions to shift to get to the
	** correct position for the priority bits for this vector.
	*/
	bn = 8 * (vec % 4);
9d004b98:	000210c0 	sll	v0,v0,0x3

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = (0x1F << bn);
	ipc->set = ((ipl << 2) + spl) << bn;
9d004b9c:	00c52821 	addu	a1,a2,a1
	*/
	bn = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = (0x1F << bn);
9d004ba0:	2403001f 	li	v1,31
9d004ba4:	00431804 	sllv	v1,v1,v0
	ipc->set = ((ipl << 2) + spl) << bn;
9d004ba8:	00451004 	sllv	v0,a1,v0
	*/
	bn = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = (0x1F << bn);
9d004bac:	ac830004 	sw	v1,4(a0)
	ipc->set = ((ipl << 2) + spl) << bn;
9d004bb0:	ac820008 	sw	v0,8(a0)
}
9d004bb4:	03e00008 	jr	ra
9d004bb8:	00000000 	nop

9d004bbc <getPeripheralClock>:
uint32_t getPeripheralClock()
{
	uint32_t	clkPb;

    clkPb = F_CPU;
    clkPb >>= OSCCONbits.PBDIV;
9d004bbc:	3c02bf81 	lui	v0,0xbf81
9d004bc0:	8c43f000 	lw	v1,-4096(v0)

    return clkPb;

}
9d004bc4:	3c0204c4 	lui	v0,0x4c4
9d004bc8:	3442b400 	ori	v0,v0,0xb400
uint32_t getPeripheralClock()
{
	uint32_t	clkPb;

    clkPb = F_CPU;
    clkPb >>= OSCCONbits.PBDIV;
9d004bcc:	7c630cc0 	ext	v1,v1,0x13,0x2

    return clkPb;

}
9d004bd0:	03e00008 	jr	ra
9d004bd4:	00621006 	srlv	v0,v0,v1

9d004bd8 <_configSystem>:

uint32_t __attribute__((nomips16)) disableInterrupts(void)
{
    uint32_t status = 0;

    asm volatile("di    %0" : "=r"(status));
9d004bd8:	41686000 	di	t0

	stInt = disableInterrupts();

	/* Disable wait states in data ram.
	*/
	BMXCONCLR = (1 << _BMXCON_BMXWSDRM_POSITION);
9d004bdc:	24030040 	li	v1,64
9d004be0:	3c02bf88 	lui	v0,0xbf88
9d004be4:	ac432004 	sw	v1,8196(v0)

#ifdef _PCACHE

	stCache = CHECON;
9d004be8:	3c07bf88 	lui	a3,0xbf88
9d004bec:	8ce94000 	lw	t1,16384(a3)
    stCache |= (3 << _CHECON_PREFEN_POSITION);

	/* Turn on caching for KSEG0
	*/
	asm("mfc0 %0,$16,0" :  "=r"(tmp));
	tmp = (tmp & ~7) | 3;
9d004bf0:	2402fff8 	li	v0,-8
	*/
    stCache |= (3 << _CHECON_PREFEN_POSITION);

	/* Turn on caching for KSEG0
	*/
	asm("mfc0 %0,$16,0" :  "=r"(tmp));
9d004bf4:	40038000 	mfc0	v1,c0_config
	tmp = (tmp & ~7) | 3;
9d004bf8:	00621024 	and	v0,v1,v0
	stCache = CHECON;

	/* Configure predictive prefetch caching for both cached and
	** non-cached memory regions.
	*/
    stCache |= (3 << _CHECON_PREFEN_POSITION);
9d004bfc:	35290030 	ori	t1,t1,0x30

	/* Turn on caching for KSEG0
	*/
	asm("mfc0 %0,$16,0" :  "=r"(tmp));
	tmp = (tmp & ~7) | 3;
9d004c00:	34420003 	ori	v0,v0,0x3
	asm("mtc0 %0,$16,0" :: "r" (tmp));
9d004c04:	40828000 	mtc0	v0,c0_config

	/* Configure the number of wait states in the program flash
	*/
    wait = 0;

    while(clk > FLASH_SPEED_HZ)
9d004c08:	3c0501c9 	lui	a1,0x1c9
9d004c0c:	34a5c381 	ori	a1,a1,0xc381
9d004c10:	0085182b 	sltu	v1,a0,a1
9d004c14:	14600007 	bnez	v1,9d004c34 <_configSystem+0x5c>
9d004c18:	00001021 	move	v0,zero
    {
        wait += 1;
        clk -= FLASH_SPEED_HZ;
9d004c1c:	3c06fe36 	lui	a2,0xfe36
9d004c20:	24c63c80 	addiu	a2,a2,15488
9d004c24:	00862021 	addu	a0,a0,a2

	/* Configure the number of wait states in the program flash
	*/
    wait = 0;

    while(clk > FLASH_SPEED_HZ)
9d004c28:	0085182b 	sltu	v1,a0,a1
9d004c2c:	1060fffd 	beqz	v1,9d004c24 <_configSystem+0x4c>
9d004c30:	24420001 	addiu	v0,v0,1
    {
        wait += 1;
        clk -= FLASH_SPEED_HZ;
    }

    stCache &= ~_CHECON_PFMWS_MASK;
9d004c34:	2404fff8 	li	a0,-8
9d004c38:	01241824 	and	v1,t1,a0
	stCache |= (wait << _CHECON_PFMWS_POSITION);
9d004c3c:	00431025 	or	v0,v0,v1
**		enableInterrupts() or disableInterrupts().
*/

void __attribute__((nomips16))  restoreInterrupts(uint32_t st)
{
    if (st & 0x00000001)
9d004c40:	31030001 	andi	v1,t0,0x1
    }

    stCache &= ~_CHECON_PFMWS_MASK;
	stCache |= (wait << _CHECON_PFMWS_POSITION);

	CHECON = stCache;
9d004c44:	14600003 	bnez	v1,9d004c54 <_configSystem+0x7c>
**		enableInterrupts() or disableInterrupts().
*/

void __attribute__((nomips16))  restoreInterrupts(uint32_t st)
{
    if (st & 0x00000001)
9d004c48:	ace24000 	sw	v0,16384(a3)
	{
        asm volatile("ei");
	}
    else
	{
        asm volatile("di");
9d004c4c:	03e00008 	jr	ra
9d004c50:	41606000 	di

void __attribute__((nomips16))  restoreInterrupts(uint32_t st)
{
    if (st & 0x00000001)
	{
        asm volatile("ei");
9d004c54:	03e00008 	jr	ra
9d004c58:	41606020 	ei

9d004c5c <_enableMultiVectorInterrupts>:
    unsigned int val;

    /* Set the CP0 bit so that interrupt exceptions use the
	** special interrupt vector and not the general exception vector.
	*/
    asm volatile("mfc0   %0,$13" : "=r"(val));
9d004c5c:	40036800 	mfc0	v1,c0_cause
    val |= 0x00800000;
9d004c60:	3c020080 	lui	v0,0x80
9d004c64:	00621025 	or	v0,v1,v0
    asm volatile("mtc0   %0,$13" : "+r"(val));
9d004c68:	40826800 	mtc0	v0,c0_cause

	/* Turn on multi-vectored interrupts.
	*/
    INTCONSET = _INTCON_MVEC_MASK;
9d004c6c:	24031000 	li	v1,4096
9d004c70:	3c02bf88 	lui	v0,0xbf88
9d004c74:	ac431008 	sw	v1,4104(v0)

uint32_t __attribute__((nomips16))  enableInterrupts(void)
{
    uint32_t status = 0;

    asm volatile("ei    %0" : "=r"(status));
9d004c78:	03e00008 	jr	ra

    /* Enable interrupts.
	*/
    enableInterrupts();

}
9d004c7c:	41626020 	ei	v0

9d004c80 <_initCoreTimer>:

void __attribute__((nomips16)) _initCoreTimer(uint32_t prd)
{
	/* Clear the core timer counter
	*/
    asm volatile("mtc0   $0,$9");
9d004c80:	40804800 	mtc0	zero,c0_count

    /* Store the requested value in the compare register
	*/
    asm volatile("mtc0   %0,$11" : "+r"(prd));
9d004c84:	03e00008 	jr	ra
}
9d004c88:	40845800 	mtc0	a0,c0_compare

9d004c8c <shiftIn>:
  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
*/

#include "wiring_private.h"

uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
9d004c8c:	27bdffd0 	addiu	sp,sp,-48
9d004c90:	afb60028 	sw	s6,40(sp)
9d004c94:	afb50024 	sw	s5,36(sp)
9d004c98:	afb40020 	sw	s4,32(sp)
9d004c9c:	afb3001c 	sw	s3,28(sp)
9d004ca0:	afb20018 	sw	s2,24(sp)
9d004ca4:	afb10014 	sw	s1,20(sp)
9d004ca8:	afb00010 	sw	s0,16(sp)
9d004cac:	afbf002c 	sw	ra,44(sp)
9d004cb0:	309300ff 	andi	s3,a0,0xff
9d004cb4:	30b100ff 	andi	s1,a1,0xff
9d004cb8:	30d400ff 	andi	s4,a2,0xff
9d004cbc:	24100007 	li	s0,7
	uint8_t value = 0;
9d004cc0:	00009021 	move	s2,zero
  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
*/

#include "wiring_private.h"

uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
9d004cc4:	24160007 	li	s6,7
	uint8_t value = 0;
	uint8_t i;

	for (i = 0; i < 8; ++i) {
9d004cc8:	0b401340 	j	9d004d00 <shiftIn+0x74>
9d004ccc:	2415ffff 	li	s5,-1
		digitalWrite(clockPin, HIGH);
		if (bitOrder == LSBFIRST)
			value |= digitalRead(dataPin) << i;
9d004cd0:	0f401402 	jal	9d005008 <digitalRead>
9d004cd4:	00000000 	nop
  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
*/

#include "wiring_private.h"

uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
9d004cd8:	02d01823 	subu	v1,s6,s0
	uint8_t i;

	for (i = 0; i < 8; ++i) {
		digitalWrite(clockPin, HIGH);
		if (bitOrder == LSBFIRST)
			value |= digitalRead(dataPin) << i;
9d004cdc:	00621804 	sllv	v1,v0,v1
9d004ce0:	00729025 	or	s2,v1,s2
		else
			value |= digitalRead(dataPin) << (7 - i);
		digitalWrite(clockPin, LOW);
9d004ce4:	2610ffff 	addiu	s0,s0,-1
9d004ce8:	02202021 	move	a0,s1
9d004cec:	00002821 	move	a1,zero
9d004cf0:	0f4013cf 	jal	9d004f3c <digitalWrite>
9d004cf4:	325200ff 	andi	s2,s2,0xff

uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
	uint8_t value = 0;
	uint8_t i;

	for (i = 0; i < 8; ++i) {
9d004cf8:	12150012 	beq	s0,s5,9d004d44 <shiftIn+0xb8>
9d004cfc:	8fbf002c 	lw	ra,44(sp)
		digitalWrite(clockPin, HIGH);
9d004d00:	02202021 	move	a0,s1
9d004d04:	0f4013cf 	jal	9d004f3c <digitalWrite>
9d004d08:	24050001 	li	a1,1
		if (bitOrder == LSBFIRST)
9d004d0c:	1280fff0 	beqz	s4,9d004cd0 <shiftIn+0x44>
9d004d10:	02602021 	move	a0,s3
			value |= digitalRead(dataPin) << i;
		else
			value |= digitalRead(dataPin) << (7 - i);
9d004d14:	0f401402 	jal	9d005008 <digitalRead>
9d004d18:	02602021 	move	a0,s3
9d004d1c:	02021004 	sllv	v0,v0,s0
9d004d20:	00529025 	or	s2,v0,s2
		digitalWrite(clockPin, LOW);
9d004d24:	2610ffff 	addiu	s0,s0,-1
9d004d28:	02202021 	move	a0,s1
9d004d2c:	00002821 	move	a1,zero
9d004d30:	0f4013cf 	jal	9d004f3c <digitalWrite>
9d004d34:	325200ff 	andi	s2,s2,0xff

uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
	uint8_t value = 0;
	uint8_t i;

	for (i = 0; i < 8; ++i) {
9d004d38:	1615fff2 	bne	s0,s5,9d004d04 <shiftIn+0x78>
9d004d3c:	02202021 	move	a0,s1
		else
			value |= digitalRead(dataPin) << (7 - i);
		digitalWrite(clockPin, LOW);
	}
	return value;
}
9d004d40:	8fbf002c 	lw	ra,44(sp)
9d004d44:	02401021 	move	v0,s2
9d004d48:	8fb60028 	lw	s6,40(sp)
9d004d4c:	8fb50024 	lw	s5,36(sp)
9d004d50:	8fb40020 	lw	s4,32(sp)
9d004d54:	8fb3001c 	lw	s3,28(sp)
9d004d58:	8fb20018 	lw	s2,24(sp)
9d004d5c:	8fb10014 	lw	s1,20(sp)
9d004d60:	8fb00010 	lw	s0,16(sp)
9d004d64:	03e00008 	jr	ra
9d004d68:	27bd0030 	addiu	sp,sp,48

9d004d6c <shiftOut>:

void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
{
9d004d6c:	27bdffd0 	addiu	sp,sp,-48
9d004d70:	afb60028 	sw	s6,40(sp)
9d004d74:	afb50024 	sw	s5,36(sp)
9d004d78:	afb40020 	sw	s4,32(sp)
9d004d7c:	afb3001c 	sw	s3,28(sp)
9d004d80:	afb20018 	sw	s2,24(sp)
9d004d84:	afb10014 	sw	s1,20(sp)
9d004d88:	afb00010 	sw	s0,16(sp)
9d004d8c:	afbf002c 	sw	ra,44(sp)
9d004d90:	309100ff 	andi	s1,a0,0xff
9d004d94:	30b000ff 	andi	s0,a1,0xff
9d004d98:	30d600ff 	andi	s6,a2,0xff
9d004d9c:	30f300ff 	andi	s3,a3,0xff
9d004da0:	24120007 	li	s2,7
		digitalWrite(clockPin, LOW);
	}
	return value;
}

void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
9d004da4:	24140007 	li	s4,7
{
	uint8_t i;

	for (i = 0; i < 8; i++)  {
9d004da8:	2415ffff 	li	s5,-1
		digitalWrite(clockPin, LOW);
	}
	return value;
}

void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
9d004dac:	02922823 	subu	a1,s4,s2
{
	uint8_t i;

	for (i = 0; i < 8; i++)  {
		if (bitOrder == LSBFIRST)
			digitalWrite(dataPin, !!(val & (1 << i)));
9d004db0:	00b32807 	srav	a1,s3,a1
		else	
			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
9d004db4:	02531007 	srav	v0,s3,s2
{
	uint8_t i;

	for (i = 0; i < 8; i++)  {
		if (bitOrder == LSBFIRST)
			digitalWrite(dataPin, !!(val & (1 << i)));
9d004db8:	02202021 	move	a0,s1
void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
{
	uint8_t i;

	for (i = 0; i < 8; i++)  {
		if (bitOrder == LSBFIRST)
9d004dbc:	12c00003 	beqz	s6,9d004dcc <shiftOut+0x60>
9d004dc0:	30a50001 	andi	a1,a1,0x1
			digitalWrite(dataPin, !!(val & (1 << i)));
		else	
			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
9d004dc4:	02202021 	move	a0,s1
9d004dc8:	30450001 	andi	a1,v0,0x1
9d004dcc:	0f4013cf 	jal	9d004f3c <digitalWrite>
9d004dd0:	2652ffff 	addiu	s2,s2,-1
			
		digitalWrite(clockPin, HIGH);
9d004dd4:	24050001 	li	a1,1
9d004dd8:	0f4013cf 	jal	9d004f3c <digitalWrite>
9d004ddc:	02002021 	move	a0,s0
		digitalWrite(clockPin, LOW);		
9d004de0:	02002021 	move	a0,s0
9d004de4:	0f4013cf 	jal	9d004f3c <digitalWrite>
9d004de8:	00002821 	move	a1,zero

void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
{
	uint8_t i;

	for (i = 0; i < 8; i++)  {
9d004dec:	5655fff0 	bnel	s2,s5,9d004db0 <shiftOut+0x44>
9d004df0:	02922823 	subu	a1,s4,s2
			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
			
		digitalWrite(clockPin, HIGH);
		digitalWrite(clockPin, LOW);		
	}
}
9d004df4:	8fbf002c 	lw	ra,44(sp)
9d004df8:	8fb60028 	lw	s6,40(sp)
9d004dfc:	8fb50024 	lw	s5,36(sp)
9d004e00:	8fb40020 	lw	s4,32(sp)
9d004e04:	8fb3001c 	lw	s3,28(sp)
9d004e08:	8fb20018 	lw	s2,24(sp)
9d004e0c:	8fb10014 	lw	s1,20(sp)
9d004e10:	8fb00010 	lw	s0,16(sp)
9d004e14:	03e00008 	jr	ra
9d004e18:	27bd0030 	addiu	sp,sp,48

9d004e1c <pinMode>:
#include "wiring_private.h"
#include "pins_arduino.h"

//************************************************************************
void pinMode(uint8_t pin, uint8_t mode)
{
9d004e1c:	308400ff 	andi	a0,a0,0xff
9d004e20:	27bdffe0 	addiu	sp,sp,-32
uint32_t                cn;
#endif

	/* Check if pin number is in valid range.
	*/
	if (pin >= NUM_DIGITAL_PINS_EXTENDED)
9d004e24:	2c82002d 	sltiu	v0,a0,45
#include "wiring_private.h"
#include "pins_arduino.h"

//************************************************************************
void pinMode(uint8_t pin, uint8_t mode)
{
9d004e28:	afbf001c 	sw	ra,28(sp)
9d004e2c:	afb10018 	sw	s1,24(sp)
9d004e30:	afb00014 	sw	s0,20(sp)
uint32_t                cn;
#endif

	/* Check if pin number is in valid range.
	*/
	if (pin >= NUM_DIGITAL_PINS_EXTENDED)
9d004e34:	10400022 	beqz	v0,9d004ec0 <pinMode+0xa4>
9d004e38:	30a500ff 	andi	a1,a1,0xff
		return;
	}
#endif	// OPT_BOARD_DIGITAL_IO

	//* Get the port number for this pin.
	if ((port = digitalPinToPort(pin)) == NOT_A_PIN)
9d004e3c:	3c029d01 	lui	v0,0x9d01
9d004e40:	24428874 	addiu	v0,v0,-30604
9d004e44:	00441021 	addu	v0,v0,a0
9d004e48:	90420000 	lbu	v0,0(v0)
9d004e4c:	1040001c 	beqz	v0,9d004ec0 <pinMode+0xa4>
9d004e50:	00021880 	sll	v1,v0,0x2
	{
		return;
	}

	//* Obtain pointer to the registers for this io port.
	iop = (p32_ioport *)portRegisters(port);
9d004e54:	3c069d01 	lui	a2,0x9d01
9d004e58:	24c68850 	addiu	a2,a2,-30640
9d004e5c:	00663021 	addu	a2,v1,a2

	//* Obtain bit mask for the specific bit for this pin.
	bit = digitalPinToBitMask(pin);
9d004e60:	3c039d01 	lui	v1,0x9d01
9d004e64:	00042040 	sll	a0,a0,0x1
9d004e68:	246388a4 	addiu	v1,v1,-30556
9d004e6c:	00641821 	addu	v1,v1,a0
9d004e70:	94700000 	lhu	s0,0(v1)
	// analog input capable pins.
	// Clear the bit in the ANSELx register to ensure that the pin is in
	// digital input mode.
	iop->ansel.clr = bit;
#else
	if (port == _IOPORT_PB)
9d004e74:	24030002 	li	v1,2
9d004e78:	10430026 	beq	v0,v1,9d004f14 <pinMode+0xf8>
9d004e7c:	8cd10000 	lw	s1,0(a2)

	}
#endif	// defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)

	// Set the pin to the requested mode.
    switch (mode) {
9d004e80:	24020002 	li	v0,2
9d004e84:	10a2001c 	beq	a1,v0,9d004ef8 <pinMode+0xdc>
9d004e88:	2ca20003 	sltiu	v0,a1,3
9d004e8c:	50400011 	beqzl	v0,9d004ed4 <pinMode+0xb8>
9d004e90:	2ca50006 	sltiu	a1,a1,6
9d004e94:	14a00012 	bnez	a1,9d004ee0 <pinMode+0xc4>
9d004e98:	8fbf001c 	lw	ra,28(sp)
            }
#endif
            // continue into INPUT case
            //* Determine if this is an output compare pin. If so,
            //* we need to make sure PWM output is off.
            timer = digitalPinToTimerOC(pin) >> _BN_TIMER_OC;
9d004e9c:	3c029d01 	lui	v0,0x9d01
9d004ea0:	24428900 	addiu	v0,v0,-30464
9d004ea4:	00442021 	addu	a0,v0,a0
9d004ea8:	90840000 	lbu	a0,0(a0)
9d004eac:	3084000f 	andi	a0,a0,0xf
            if (timer != NOT_ON_TIMER)
9d004eb0:	1480001c 	bnez	a0,9d004f24 <pinMode+0x108>
9d004eb4:	00000000 	nop
            }

            //*	May  1,	2011
            //*	according to item #26 in PIC32MX5XX-6XX-7XX Errata.pdf 
            //*	if we are setting to input, set the data bit to zero first
            iop->lat.clr  = bit;	//clear to output bit		
9d004eb8:	ae300024 	sw	s0,36(s1)
            iop->tris.set = bit;	//make the pin an input
9d004ebc:	ae300008 	sw	s0,8(s1)
            } 
#endif
            iop->tris.clr = bit;	//make the pin an output
            iop->odc.clr  = bit;	//make sure it isn't open drain
	}
}
9d004ec0:	8fbf001c 	lw	ra,28(sp)
9d004ec4:	8fb10018 	lw	s1,24(sp)
9d004ec8:	8fb00014 	lw	s0,20(sp)
9d004ecc:	03e00008 	jr	ra
9d004ed0:	27bd0020 	addiu	sp,sp,32

	}
#endif	// defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)

	// Set the pin to the requested mode.
    switch (mode) {
9d004ed4:	14a0fff2 	bnez	a1,9d004ea0 <pinMode+0x84>
9d004ed8:	3c029d01 	lui	v0,0x9d01
            } 
#endif
            iop->tris.clr = bit;	//make the pin an output
            iop->odc.clr  = bit;	//make sure it isn't open drain
	}
}
9d004edc:	8fbf001c 	lw	ra,28(sp)
            cn = digitalPinToCN(pin);
            if (cn != NOT_CN_PIN) {
                CNPUECLR = cn;
            } 
#endif
            iop->tris.clr = bit;	//make the pin an output
9d004ee0:	ae300004 	sw	s0,4(s1)
            iop->odc.clr  = bit;	//make sure it isn't open drain
9d004ee4:	ae300034 	sw	s0,52(s1)
	}
}
9d004ee8:	8fb10018 	lw	s1,24(sp)
9d004eec:	8fb00014 	lw	s0,20(sp)
9d004ef0:	03e00008 	jr	ra
9d004ef4:	27bd0020 	addiu	sp,sp,32
9d004ef8:	8fbf001c 	lw	ra,28(sp)
            //*	if we are setting to input, set the data bit to zero first
            iop->lat.clr  = bit;	//clear to output bit		
            iop->tris.set = bit;	//make the pin an input
            break;
        case OPEN:
            iop->tris.clr = bit;	//OPEN implies output, make the pin an output
9d004efc:	ae300004 	sw	s0,4(s1)
            iop->odc.set  = bit;	//make the pin open drain
9d004f00:	ae300038 	sw	s0,56(s1)
            } 
#endif
            iop->tris.clr = bit;	//make the pin an output
            iop->odc.clr  = bit;	//make sure it isn't open drain
	}
}
9d004f04:	8fb10018 	lw	s1,24(sp)
9d004f08:	8fb00014 	lw	s0,20(sp)
9d004f0c:	03e00008 	jr	ra
9d004f10:	27bd0020 	addiu	sp,sp,32
		//	You have to set the bit in the AD1PCFG for an analog pin to be used as a 
		//	digital input. They come up after reset as analog input with the digital 
		//	input disabled. For the PORTB pins you switch between analog input and 
		//	digital input using AD1PCFG.

		AD1PCFGSET = bit;
9d004f14:	3c02bf81 	lui	v0,0xbf81
9d004f18:	ac509068 	sw	s0,-28568(v0)

	}
#endif	// defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)

	// Set the pin to the requested mode.
    switch (mode) {
9d004f1c:	0b4013a1 	j	9d004e84 <pinMode+0x68>
9d004f20:	24020002 	li	v0,2
            //* Determine if this is an output compare pin. If so,
            //* we need to make sure PWM output is off.
            timer = digitalPinToTimerOC(pin) >> _BN_TIMER_OC;
            if (timer != NOT_ON_TIMER)
            {
                turnOffPWM(timer);
9d004f24:	0f401421 	jal	9d005084 <turnOffPWM>
9d004f28:	00000000 	nop
            }

            //*	May  1,	2011
            //*	according to item #26 in PIC32MX5XX-6XX-7XX Errata.pdf 
            //*	if we are setting to input, set the data bit to zero first
            iop->lat.clr  = bit;	//clear to output bit		
9d004f2c:	ae300024 	sw	s0,36(s1)
            iop->tris.set = bit;	//make the pin an input
9d004f30:	ae300008 	sw	s0,8(s1)
            } 
#endif
            iop->tris.clr = bit;	//make the pin an output
            iop->odc.clr  = bit;	//make sure it isn't open drain
	}
}
9d004f34:	0b4013b1 	j	9d004ec4 <pinMode+0xa8>
9d004f38:	8fbf001c 	lw	ra,28(sp)

9d004f3c <digitalWrite>:
//*	Reading from PORT gives you a snapshot of the actual pins state regardless of how, 
//*	if at all, the PIC is trying to drive them.  
//*	Reading from LAT gives you the values last written to the pins, whether thru LAT or PORT.
//************************************************************************
void digitalWrite(uint8_t pin, uint8_t val)
{
9d004f3c:	308400ff 	andi	a0,a0,0xff
9d004f40:	27bdffd8 	addiu	sp,sp,-40
uint32_t                cn;
#endif

	/* Check if pin number is in valid range.
	*/
	if (pin >= NUM_DIGITAL_PINS_EXTENDED)
9d004f44:	2c82002d 	sltiu	v0,a0,45
//*	Reading from PORT gives you a snapshot of the actual pins state regardless of how, 
//*	if at all, the PIC is trying to drive them.  
//*	Reading from LAT gives you the values last written to the pins, whether thru LAT or PORT.
//************************************************************************
void digitalWrite(uint8_t pin, uint8_t val)
{
9d004f48:	afbf0024 	sw	ra,36(sp)
9d004f4c:	afb10020 	sw	s1,32(sp)
9d004f50:	afb0001c 	sw	s0,28(sp)
uint32_t                cn;
#endif

	/* Check if pin number is in valid range.
	*/
	if (pin >= NUM_DIGITAL_PINS_EXTENDED)
9d004f54:	1040001d 	beqz	v0,9d004fcc <digitalWrite+0x90>
9d004f58:	30a500ff 	andi	a1,a1,0xff
		return;
	}
#endif		// OPT_BOARD_DIGITAL_IO

	//* Get the port number for this pin.
	if ((port = digitalPinToPort(pin)) == NOT_A_PIN)
9d004f5c:	3c029d01 	lui	v0,0x9d01
9d004f60:	24428874 	addiu	v0,v0,-30604
9d004f64:	00821021 	addu	v0,a0,v0
9d004f68:	90420000 	lbu	v0,0(v0)
9d004f6c:	10400017 	beqz	v0,9d004fcc <digitalWrite+0x90>
9d004f70:	3c039d01 	lui	v1,0x9d01
	{
		return;
	}

	//* Obtain pointer to the registers for this io port.
	iop = (p32_ioport *)portRegisters(port);
9d004f74:	24638850 	addiu	v1,v1,-30640
9d004f78:	00021080 	sll	v0,v0,0x2
9d004f7c:	00431021 	addu	v0,v0,v1
9d004f80:	8c500000 	lw	s0,0(v0)

	//* Obtain bit mask for the specific bit for this pin.
	bit = digitalPinToBitMask(pin);
9d004f84:	3c039d01 	lui	v1,0x9d01
9d004f88:	00042040 	sll	a0,a0,0x1
9d004f8c:	246388a4 	addiu	v1,v1,-30556
9d004f90:	00831821 	addu	v1,a0,v1

    //* If the port is in input mode and we write a value to it
    //* we must be enabling or disabling the internal pull-up
    //* resistor.  Only works for pins that have an associated
    //* change notification pin.
    if (iop->tris.reg & bit) {
9d004f94:	8e020000 	lw	v0,0(s0)
9d004f98:	94710000 	lhu	s1,0(v1)
9d004f9c:	02221024 	and	v0,s1,v0
9d004fa0:	1440000a 	bnez	v0,9d004fcc <digitalWrite+0x90>
9d004fa4:	3c029d01 	lui	v0,0x9d01
#endif

    } else {
        //* Determine if this is an output compare pin. If so,
        //* we need to make sure PWM output is off.
        timer = digitalPinToTimerOC(pin);
9d004fa8:	24428900 	addiu	v0,v0,-30464
9d004fac:	00822021 	addu	a0,a0,v0
9d004fb0:	90840000 	lbu	a0,0(a0)
9d004fb4:	3084000f 	andi	a0,a0,0xf
        if (timer != NOT_ON_TIMER)
9d004fb8:	1480000c 	bnez	a0,9d004fec <digitalWrite+0xb0>
9d004fbc:	00000000 	nop
        {
            turnOffPWM(timer);
        }

        //* Set the pin state
        if (val == LOW)
9d004fc0:	10a00007 	beqz	a1,9d004fe0 <digitalWrite+0xa4>
9d004fc4:	00000000 	nop
        {
            iop->lat.clr = bit;
        }
        else
        {
            iop->lat.set = bit;
9d004fc8:	ae110028 	sw	s1,40(s0)
        }
    }
}
9d004fcc:	8fbf0024 	lw	ra,36(sp)
9d004fd0:	8fb10020 	lw	s1,32(sp)
9d004fd4:	8fb0001c 	lw	s0,28(sp)
9d004fd8:	03e00008 	jr	ra
9d004fdc:	27bd0028 	addiu	sp,sp,40
        }

        //* Set the pin state
        if (val == LOW)
        {
            iop->lat.clr = bit;
9d004fe0:	ae110024 	sw	s1,36(s0)
        else
        {
            iop->lat.set = bit;
        }
    }
}
9d004fe4:	0b4013f4 	j	9d004fd0 <digitalWrite+0x94>
9d004fe8:	8fbf0024 	lw	ra,36(sp)
        //* Determine if this is an output compare pin. If so,
        //* we need to make sure PWM output is off.
        timer = digitalPinToTimerOC(pin);
        if (timer != NOT_ON_TIMER)
        {
            turnOffPWM(timer);
9d004fec:	0f401421 	jal	9d005084 <turnOffPWM>
9d004ff0:	afa50010 	sw	a1,16(sp)
9d004ff4:	8fa50010 	lw	a1,16(sp)
        }

        //* Set the pin state
        if (val == LOW)
9d004ff8:	14a0fff3 	bnez	a1,9d004fc8 <digitalWrite+0x8c>
9d004ffc:	00000000 	nop
9d005000:	0b4013f8 	j	9d004fe0 <digitalWrite+0xa4>
9d005004:	00000000 	nop

9d005008 <digitalRead>:
    }
}

//************************************************************************
int digitalRead(uint8_t pin)
{
9d005008:	308400ff 	andi	a0,a0,0xff
uint8_t					port;
int						highLow;

	/* Check if pin number is in valid range.
	*/
	if (pin >= NUM_DIGITAL_PINS_EXTENDED)
9d00500c:	2c83002d 	sltiu	v1,a0,45
9d005010:	10600017 	beqz	v1,9d005070 <digitalRead+0x68>
9d005014:	00001021 	move	v0,zero
		return tmp;
	}
#endif		// OPT_BOARD_DIGITAL_IO

	//* Get the port number for this pin.
	if ((port = digitalPinToPort(pin)) == NOT_A_PIN)
9d005018:	3c039d01 	lui	v1,0x9d01
9d00501c:	24638874 	addiu	v1,v1,-30604
9d005020:	00831821 	addu	v1,a0,v1
9d005024:	90630000 	lbu	v1,0(v1)
9d005028:	10600011 	beqz	v1,9d005070 <digitalRead+0x68>
9d00502c:	00000000 	nop
	{
		return LOW;
	}

	//* Obtain pointer to the registers for this io port.
	iop = (p32_ioport *)portRegisters(port);
9d005030:	3c029d01 	lui	v0,0x9d01
9d005034:	00032880 	sll	a1,v1,0x2
9d005038:	24428850 	addiu	v0,v0,-30640
9d00503c:	00a21021 	addu	v0,a1,v0

	//* Obtain bit mask for the specific bit for this pin.
	bit = digitalPinToBitMask(pin);
9d005040:	3c059d01 	lui	a1,0x9d01
9d005044:	24a588a4 	addiu	a1,a1,-30556
9d005048:	00042040 	sll	a0,a0,0x1
9d00504c:	00852021 	addu	a0,a0,a1
	{
		return LOW;
	}

	//* Obtain pointer to the registers for this io port.
	iop = (p32_ioport *)portRegisters(port);
9d005050:	8c450000 	lw	a1,0(v0)

	//* Obtain bit mask for the specific bit for this pin.
	bit = digitalPinToBitMask(pin);
9d005054:	94820000 	lhu	v0,0(a0)
	// analog input capable pins.
	// Clear the bit in the ANSELx register to ensure that the pin is in
	// digital input mode.
	iop->ansel.clr = bit;
#else
	if (port == _IOPORT_PB)
9d005058:	24040002 	li	a0,2
9d00505c:	10640006 	beq	v1,a0,9d005078 <digitalRead+0x70>
9d005060:	3c03bf81 	lui	v1,0xbf81

	}
#endif	// defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)

	//* Get the pin state.
	if ((iop->port.reg & bit) != 0) 
9d005064:	8ca30010 	lw	v1,16(a1)
9d005068:	00431024 	and	v0,v0,v1

	/* Check if pin number is in valid range.
	*/
	if (pin >= NUM_DIGITAL_PINS_EXTENDED)
	{
		return 0;
9d00506c:	0002102b 	sltu	v0,zero,v0
	{
		highLow	=	LOW;
	}

	return(highLow);
}
9d005070:	03e00008 	jr	ra
9d005074:	00000000 	nop
		//	You have to set the bit in the AD1PCFG for an analog pin to be used as a 
		//	digital input. They come up after reset as analog input with the digital 
		//	input disabled. For the PORTB pins you switch between analog input and 
		//	digital input using AD1PCFG.

		AD1PCFGSET = bit;
9d005078:	ac629068 	sw	v0,-28568(v1)
9d00507c:	0b401419 	j	9d005064 <digitalRead+0x5c>
9d005080:	00000000 	nop

9d005084 <turnOffPWM>:
}


//************************************************************************
void turnOffPWM(uint8_t timer)
{
9d005084:	308400ff 	andi	a0,a0,0xff
	*/
	ocp = (p32_oc *)(_OCMP1_BASE_ADDRESS + (0x200 * (timer - (_TIMER_OC1 >> _BN_TIMER_OC))));
	ocp->ocxCon.clr = OCCON_ON;

	// Turn off the bit saying that this PWM is active.
	pwm_active &= ~(1 << (timer - (_TIMER_OC1 >> _BN_TIMER_OC)));
9d005088:	2482ffff 	addiu	v0,a0,-1
9d00508c:	24030001 	li	v1,1
9d005090:	93858040 	lbu	a1,-32704(gp)
9d005094:	00431004 	sllv	v0,v1,v0
{
	p32_oc *	ocp;

	/* Disable the output compare.
	*/
	ocp = (p32_oc *)(_OCMP1_BASE_ADDRESS + (0x200 * (timer - (_TIMER_OC1 >> _BN_TIMER_OC))));
9d005098:	3c03005f 	lui	v1,0x5f
9d00509c:	3463c017 	ori	v1,v1,0xc017
9d0050a0:	00832021 	addu	a0,a0,v1
	ocp->ocxCon.clr = OCCON_ON;

	// Turn off the bit saying that this PWM is active.
	pwm_active &= ~(1 << (timer - (_TIMER_OC1 >> _BN_TIMER_OC)));
9d0050a4:	00021027 	nor	v0,zero,v0
{
	p32_oc *	ocp;

	/* Disable the output compare.
	*/
	ocp = (p32_oc *)(_OCMP1_BASE_ADDRESS + (0x200 * (timer - (_TIMER_OC1 >> _BN_TIMER_OC))));
9d0050a8:	00042240 	sll	a0,a0,0x9
	ocp->ocxCon.clr = OCCON_ON;
9d0050ac:	34038000 	li	v1,0x8000

	// Turn off the bit saying that this PWM is active.
	pwm_active &= ~(1 << (timer - (_TIMER_OC1 >> _BN_TIMER_OC)));
9d0050b0:	00451024 	and	v0,v0,a1
	p32_oc *	ocp;

	/* Disable the output compare.
	*/
	ocp = (p32_oc *)(_OCMP1_BASE_ADDRESS + (0x200 * (timer - (_TIMER_OC1 >> _BN_TIMER_OC))));
	ocp->ocxCon.clr = OCCON_ON;
9d0050b4:	ac830004 	sw	v1,4(a0)

	// Turn off the bit saying that this PWM is active.
	pwm_active &= ~(1 << (timer - (_TIMER_OC1 >> _BN_TIMER_OC)));

	// If no PWM are active, turn off the timer.
	if (pwm_active == 0)
9d0050b8:	14400003 	bnez	v0,9d0050c8 <turnOffPWM+0x44>
9d0050bc:	a3828040 	sb	v0,-32704(gp)
	{
    	T2CONCLR = TBCON_ON;
9d0050c0:	3c02bf80 	lui	v0,0xbf80
9d0050c4:	ac430804 	sw	v1,2052(v0)
9d0050c8:	03e00008 	jr	ra
9d0050cc:	00000000 	nop

9d0050d0 <millisecondCoreTimerService>:
*/
uint32_t millisecondCoreTimerService(uint32_t curTime)
{
    static int nextInt = 0;
    uint32_t relWait = 0;
    uint32_t relTime = curTime - nextInt;
9d0050d0:	8f858050 	lw	a1,-32688(gp)
    uint32_t millisLocal = gTimer0_millis;  // defeat volatility
9d0050d4:	8f838044 	lw	v1,-32700(gp)
**
*/
uint32_t millisecondCoreTimerService(uint32_t curTime)
{
    static int nextInt = 0;
    uint32_t relWait = 0;
9d0050d8:	00001021 	move	v0,zero
    uint32_t relTime = curTime - nextInt;
9d0050dc:	00852023 	subu	a0,a0,a1

    // catch-up up to current time; we may have fallen behind due to interrupts being diabled.
    while(relWait <= relTime)
    {
        millisLocal++;                      // add a ms to our time
        relWait += CORE_TICK_RATE;          // add a ms to our next ISR time
9d0050e0:	34079c40 	li	a3,0x9c40
9d0050e4:	00471021 	addu	v0,v0,a3
    uint32_t relWait = 0;
    uint32_t relTime = curTime - nextInt;
    uint32_t millisLocal = gTimer0_millis;  // defeat volatility

    // catch-up up to current time; we may have fallen behind due to interrupts being diabled.
    while(relWait <= relTime)
9d0050e8:	0082302b 	sltu	a2,a0,v0
9d0050ec:	10c0fffd 	beqz	a2,9d0050e4 <millisecondCoreTimerService+0x14>
9d0050f0:	24630001 	addiu	v1,v1,1
        millisLocal++;                      // add a ms to our time
        relWait += CORE_TICK_RATE;          // add a ms to our next ISR time
     }

    // set when we want to be called again
    nextInt += relWait;                     // calculate the absolute interrupt time we want.
9d0050f4:	00451021 	addu	v0,v0,a1

    // we want to sync gCore_timer_last_val with the last millisecond "count" value
    // curTime may not be exactly on a millisecond boundary, but we know where that is
    // we know nextInt is our next millisecond boundary, so less 1 CORE_TICK_RATE will be our last one
    // gCore_timer_last_val = curTime;         // This is the original bogus code
    gCore_timer_last_val =  nextInt - CORE_TICK_RATE;
9d0050f8:	34049c40 	li	a0,0x9c40
9d0050fc:	00442023 	subu	a0,v0,a0
9d005100:	af848048 	sw	a0,-32696(gp)
        millisLocal++;                      // add a ms to our time
        relWait += CORE_TICK_RATE;          // add a ms to our next ISR time
     }

    // set when we want to be called again
    nextInt += relWait;                     // calculate the absolute interrupt time we want.
9d005104:	af828050 	sw	v0,-32688(gp)
    // we know nextInt is our next millisecond boundary, so less 1 CORE_TICK_RATE will be our last one
    // gCore_timer_last_val = curTime;         // This is the original bogus code
    gCore_timer_last_val =  nextInt - CORE_TICK_RATE;

    // update the global millisecond counter.
    gTimer0_millis = millisLocal;           // Total number of ms
9d005108:	af838044 	sw	v1,-32700(gp)

    return(nextInt);
}
9d00510c:	03e00008 	jr	ra
9d005110:	00000000 	nop

9d005114 <CoreTimerHandler>:
**      each service's logical compare values. And then the next and soonest logical compare value is searched for and set as
**      the real compare value to be interrupted to notify the Serivces when count hits that value.
**
*/
void __attribute__((interrupt(),nomips16)) CoreTimerHandler(void)
{
9d005114:	415de800 	rdpgpr	sp,sp
9d005118:	401b7000 	mfc0	k1,c0_epc
9d00511c:	401a6002 	mfc0	k0,c0_srsctl
9d005120:	27bdff58 	addiu	sp,sp,-168
9d005124:	afbb00a4 	sw	k1,164(sp)
9d005128:	401b6000 	mfc0	k1,c0_status
9d00512c:	afba00a0 	sw	k0,160(sp)
9d005130:	401a6800 	mfc0	k0,c0_cause
9d005134:	001ad282 	srl	k0,k0,0xa
9d005138:	afbb009c 	sw	k1,156(sp)
9d00513c:	7f5b7a84 	ins	k1,k0,0xa,0x6
9d005140:	7c1b2044 	ins	k1,zero,0x1,0x4
9d005144:	409b6000 	mtc0	k1,c0_status
9d005148:	afa3002c 	sw	v1,44(sp)
9d00514c:	8fa300a0 	lw	v1,160(sp)
9d005150:	3063000f 	andi	v1,v1,0xf
9d005154:	1460001a 	bnez	v1,9d0051c0 <CoreTimerHandler+0xac>
9d005158:	afa20028 	sw	v0,40(sp)
9d00515c:	afbf008c 	sw	ra,140(sp)
9d005160:	afbe0088 	sw	s8,136(sp)
9d005164:	afb90084 	sw	t9,132(sp)
9d005168:	afb80080 	sw	t8,128(sp)
9d00516c:	afb7007c 	sw	s7,124(sp)
9d005170:	afb60078 	sw	s6,120(sp)
9d005174:	afb50074 	sw	s5,116(sp)
9d005178:	afb40070 	sw	s4,112(sp)
9d00517c:	afb3006c 	sw	s3,108(sp)
9d005180:	afb20068 	sw	s2,104(sp)
9d005184:	afb10064 	sw	s1,100(sp)
9d005188:	afb00060 	sw	s0,96(sp)
9d00518c:	afaf005c 	sw	t7,92(sp)
9d005190:	afae0058 	sw	t6,88(sp)
9d005194:	afad0054 	sw	t5,84(sp)
9d005198:	afac0050 	sw	t4,80(sp)
9d00519c:	afab004c 	sw	t3,76(sp)
9d0051a0:	afaa0048 	sw	t2,72(sp)
9d0051a4:	afa90044 	sw	t1,68(sp)
9d0051a8:	afa80040 	sw	t0,64(sp)
9d0051ac:	afa7003c 	sw	a3,60(sp)
9d0051b0:	afa60038 	sw	a2,56(sp)
9d0051b4:	afa50034 	sw	a1,52(sp)
9d0051b8:	afa40030 	sw	a0,48(sp)
9d0051bc:	afa10024 	sw	at,36(sp)
9d0051c0:	00001012 	mflo	v0
9d0051c4:	afa20094 	sw	v0,148(sp)
9d0051c8:	00001810 	mfhi	v1
9d0051cc:	afa30090 	sw	v1,144(sp)

    // we know that count >= compare, otherwise we would not have been interrupted
    // we also know that count and compare >= gLastBaseCount as this was our last count value.

    // get our current time; this will establish our next base
    read_count(curTime); 
9d0051d0:	40134800 	mfc0	s3,c0_count
    relCurTime = curTime - gLastBaseCount;
9d0051d4:	8f9e804c 	lw	s8,-32692(gp)
9d0051d8:	3c10a000 	lui	s0,0xa000
        {
            // if the serivce exists
            if(gCoreTimerInfo[i].serivce != NULL)
            {
                // if their time has come up
                relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d0051dc:	3c05a000 	lui	a1,0xa000
    // we know that count >= compare, otherwise we would not have been interrupted
    // we also know that count and compare >= gLastBaseCount as this was our last count value.

    // get our current time; this will establish our next base
    read_count(curTime); 
    relCurTime = curTime - gLastBaseCount;
9d0051e0:	027ef023 	subu	s8,s3,s8

    // we know that count >= compare, otherwise we would not have been interrupted
    // we also know that count and compare >= gLastBaseCount as this was our last count value.

    // get our current time; this will establish our next base
    read_count(curTime); 
9d0051e4:	02603021 	move	a2,s3
9d0051e8:	261000dc 	addiu	s0,s0,220
9d0051ec:	3c12bf88 	lui	s2,0xbf88
        {
            // if the serivce exists
            if(gCoreTimerInfo[i].serivce != NULL)
            {
                // if their time has come up
                relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d0051f0:	24a500d8 	addiu	a1,a1,216
    {
        // make sure we find the lowest int to set
        relNextInt = 0xFFFFFFFF;

        // check to see who all we need to call
        for(i=0; i<MaxNbrOfCoreTimerServices; i++)
9d0051f4:	24030003 	li	v1,3
        // we need to apply our base to convert from relative values to an absolute time.
        compare = relNextInt + gLastBaseCount;
        write_comp(compare); 

        // clear the CT flag
        mCTClearIntFlag();
9d0051f8:	24110001 	li	s1,1
    // we know that count >= compare, otherwise we would not have been interrupted
    // we also know that count and compare >= gLastBaseCount as this was our last count value.

    // get our current time; this will establish our next base
    read_count(curTime); 
    relCurTime = curTime - gLastBaseCount;
9d0051fc:	0200b021 	move	s6,s0
    {
        // make sure we find the lowest int to set
        relNextInt = 0xFFFFFFFF;

        // check to see who all we need to call
        for(i=0; i<MaxNbrOfCoreTimerServices; i++)
9d005200:	0000a021 	move	s4,zero
    nextBase = curTime;

    do
    {
        // make sure we find the lowest int to set
        relNextInt = 0xFFFFFFFF;
9d005204:	2415ffff 	li	s5,-1

        // check to see who all we need to call
        for(i=0; i<MaxNbrOfCoreTimerServices; i++)
        {
            // if the serivce exists
            if(gCoreTimerInfo[i].serivce != NULL)
9d005208:	8ec20000 	lw	v0,0(s6)
            {
                // if their time has come up
                relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d00520c:	0014b8c0 	sll	s7,s4,0x3
9d005210:	02e5b821 	addu	s7,s7,a1
    {
        // make sure we find the lowest int to set
        relNextInt = 0xFFFFFFFF;

        // check to see who all we need to call
        for(i=0; i<MaxNbrOfCoreTimerServices; i++)
9d005214:	26940001 	addiu	s4,s4,1
        {
            // if the serivce exists
            if(gCoreTimerInfo[i].serivce != NULL)
9d005218:	10400009 	beqz	v0,9d005240 <CoreTimerHandler+0x12c>
9d00521c:	26d60008 	addiu	s6,s6,8
            {
                // if their time has come up
                relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d005220:	8ee70000 	lw	a3,0(s7)
9d005224:	8f84804c 	lw	a0,-32692(gp)
9d005228:	00e42023 	subu	a0,a3,a0
                if(relInt <= relCurTime)
9d00522c:	03c4382b 	sltu	a3,s8,a0
9d005230:	50e0003d 	beqzl	a3,9d005328 <CoreTimerHandler+0x214>
9d005234:	00c02021 	move	a0,a2
                    relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
                }

                // see if this is the next interrupt we want to set
                // we are looking for the closest/lowest int to set.
                if(relInt < relNextInt)
9d005238:	0095102b 	sltu	v0,a0,s5
9d00523c:	0082a80b 	movn	s5,a0,v0
    {
        // make sure we find the lowest int to set
        relNextInt = 0xFFFFFFFF;

        // check to see who all we need to call
        for(i=0; i<MaxNbrOfCoreTimerServices; i++)
9d005240:	5683fff2 	bnel	s4,v1,9d00520c <CoreTimerHandler+0xf8>
9d005244:	8ec20000 	lw	v0,0(s6)
        // other service may cause the compare value to be set for an earlier time; but we always know there will be a compare time
        // to set, so we know that relNextInt has a value other than 0xFFFFFFFF in it.

        // Go ahead and set the compare register to the next interrupt we want.
        // we need to apply our base to convert from relative values to an absolute time.
        compare = relNextInt + gLastBaseCount;
9d005248:	8f82804c 	lw	v0,-32692(gp)
9d00524c:	02a21021 	addu	v0,s5,v0
        write_comp(compare); 
9d005250:	40825800 	mtc0	v0,c0_compare

        // clear the CT flag
        mCTClearIntFlag();
9d005254:	ae511034 	sw	s1,4148(s2)

        // read the count after the CT flag has been set so we can make sure count has not passed compare
        // during our processing of this int
        read_count(curTime); 
9d005258:	40064800 	mfc0	a2,c0_count

        // get the relative time so we can operate in the linear portion of our uint32.
        relCurTime = curTime - gLastBaseCount;
9d00525c:	8f9e804c 	lw	s8,-32692(gp)
9d005260:	00def023 	subu	s8,a2,s8

        // if the current time has passed our interrupt time, then we basically hit the interrupt again
        // so we probabaly missed the CT flag being set and we need to reprocess this interrupt and find the next one to set.
    } while(relNextInt <= relCurTime);
9d005264:	03d5a82b 	sltu	s5,s8,s5
9d005268:	52a0ffe5 	beqzl	s5,9d005200 <CoreTimerHandler+0xec>
9d00526c:	0200b021 	move	s6,s0
    // otherwise the next interrupt time (compare time) is after the current time and CT will catch it when count == compare.
    // we can safely exit the ISR.

    // but first we must set our new base so the next time we come into this routine we
    // have a valid lower base to shift our times to for comparisons.
    gLastBaseCount = nextBase;
9d005270:	af93804c 	sw	s3,-32692(gp)
}
9d005274:	8fa20094 	lw	v0,148(sp)
9d005278:	8fa30090 	lw	v1,144(sp)
9d00527c:	00400013 	mtlo	v0
9d005280:	8fa200a0 	lw	v0,160(sp)
9d005284:	3042000f 	andi	v0,v0,0xf
9d005288:	1440001c 	bnez	v0,9d0052fc <CoreTimerHandler+0x1e8>
9d00528c:	00600011 	mthi	v1
9d005290:	8fbf008c 	lw	ra,140(sp)
9d005294:	8fbe0088 	lw	s8,136(sp)
9d005298:	8fb90084 	lw	t9,132(sp)
9d00529c:	8fb80080 	lw	t8,128(sp)
9d0052a0:	8fb7007c 	lw	s7,124(sp)
9d0052a4:	8fb60078 	lw	s6,120(sp)
9d0052a8:	8fb50074 	lw	s5,116(sp)
9d0052ac:	8fb40070 	lw	s4,112(sp)
9d0052b0:	8fb3006c 	lw	s3,108(sp)
9d0052b4:	8fb20068 	lw	s2,104(sp)
9d0052b8:	8fb10064 	lw	s1,100(sp)
9d0052bc:	8fb00060 	lw	s0,96(sp)
9d0052c0:	8faf005c 	lw	t7,92(sp)
9d0052c4:	8fae0058 	lw	t6,88(sp)
9d0052c8:	8fad0054 	lw	t5,84(sp)
9d0052cc:	8fac0050 	lw	t4,80(sp)
9d0052d0:	8fab004c 	lw	t3,76(sp)
9d0052d4:	8faa0048 	lw	t2,72(sp)
9d0052d8:	8fa90044 	lw	t1,68(sp)
9d0052dc:	8fa80040 	lw	t0,64(sp)
9d0052e0:	8fa7003c 	lw	a3,60(sp)
9d0052e4:	8fa60038 	lw	a2,56(sp)
9d0052e8:	8fa50034 	lw	a1,52(sp)
9d0052ec:	8fa40030 	lw	a0,48(sp)
9d0052f0:	8fa3002c 	lw	v1,44(sp)
9d0052f4:	8fa20028 	lw	v0,40(sp)
9d0052f8:	8fa10024 	lw	at,36(sp)
9d0052fc:	41606000 	di
9d005300:	000000c0 	ehb
9d005304:	8fba00a4 	lw	k0,164(sp)
9d005308:	8fbb009c 	lw	k1,156(sp)
9d00530c:	409a7000 	mtc0	k0,c0_epc
9d005310:	8fba00a0 	lw	k0,160(sp)
9d005314:	27bd00a8 	addiu	sp,sp,168
9d005318:	409a6002 	mtc0	k0,c0_srsctl
9d00531c:	41dde800 	wrpgpr	sp,sp
9d005320:	409b6000 	mtc0	k1,c0_status
9d005324:	42000018 	eret
                // if their time has come up
                relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
                if(relInt <= relCurTime)
                {
                    // call their routine to get their next interrupt time
                    gCoreTimerInfo[i].nextInt = gCoreTimerInfo[i].serivce(curTime);
9d005328:	afa30018 	sw	v1,24(sp)
9d00532c:	afa50014 	sw	a1,20(sp)
9d005330:	0040f809 	jalr	v0
9d005334:	afa60010 	sw	a2,16(sp)
9d005338:	aee20000 	sw	v0,0(s7)

                    // recalculate the relative time of thier next int
                    // so we can see if this is the next int we need to set
                    relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d00533c:	8ee40000 	lw	a0,0(s7)
9d005340:	8f82804c 	lw	v0,-32692(gp)
9d005344:	8fa60010 	lw	a2,16(sp)
9d005348:	8fa50014 	lw	a1,20(sp)
9d00534c:	00822023 	subu	a0,a0,v0
                }

                // see if this is the next interrupt we want to set
                // we are looking for the closest/lowest int to set.
                if(relInt < relNextInt)
9d005350:	0095102b 	sltu	v0,a0,s5
                    // call their routine to get their next interrupt time
                    gCoreTimerInfo[i].nextInt = gCoreTimerInfo[i].serivce(curTime);

                    // recalculate the relative time of thier next int
                    // so we can see if this is the next int we need to set
                    relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d005354:	8fa30018 	lw	v1,24(sp)
                }

                // see if this is the next interrupt we want to set
                // we are looking for the closest/lowest int to set.
                if(relInt < relNextInt)
9d005358:	0b401490 	j	9d005240 <CoreTimerHandler+0x12c>
9d00535c:	0082a80b 	movn	s5,a0,v0

9d005360 <millis>:
uint8_t ppsGlobalLock = false;

//************************************************************************
unsigned long millis()
{
	return(gTimer0_millis);
9d005360:	8f828044 	lw	v0,-32700(gp)
}
9d005364:	03e00008 	jr	ra
9d005368:	00000000 	nop

9d00536c <delay>:
}

//************************************************************************
// Delay for a given number of milliseconds.
void delay(unsigned long ms)
{
9d00536c:	27bdffe0 	addiu	sp,sp,-32
9d005370:	afb10018 	sw	s1,24(sp)
unsigned long	startMillis;

	startMillis	=	gTimer0_millis;
9d005374:	8f918044 	lw	s1,-32700(gp)
	while ((gTimer0_millis - startMillis) < ms)
9d005378:	8f828044 	lw	v0,-32700(gp)
}

//************************************************************************
// Delay for a given number of milliseconds.
void delay(unsigned long ms)
{
9d00537c:	afb00014 	sw	s0,20(sp)
9d005380:	afbf001c 	sw	ra,28(sp)
unsigned long	startMillis;

	startMillis	=	gTimer0_millis;
	while ((gTimer0_millis - startMillis) < ms)
9d005384:	00511023 	subu	v0,v0,s1
9d005388:	0044102b 	sltu	v0,v0,a0
9d00538c:	10400008 	beqz	v0,9d0053b0 <delay+0x44>
9d005390:	00808021 	move	s0,a0
	{
		_scheduleTask();
9d005394:	0f40152c 	jal	9d0054b0 <_scheduleTask>
9d005398:	00000000 	nop
void delay(unsigned long ms)
{
unsigned long	startMillis;

	startMillis	=	gTimer0_millis;
	while ((gTimer0_millis - startMillis) < ms)
9d00539c:	8f828044 	lw	v0,-32700(gp)
9d0053a0:	00511023 	subu	v0,v0,s1
9d0053a4:	0050102b 	sltu	v0,v0,s0
9d0053a8:	1440fffa 	bnez	v0,9d005394 <delay+0x28>
9d0053ac:	00000000 	nop
	{
		_scheduleTask();
	}
}
9d0053b0:	8fbf001c 	lw	ra,28(sp)
9d0053b4:	8fb10018 	lw	s1,24(sp)
9d0053b8:	8fb00014 	lw	s0,20(sp)
9d0053bc:	03e00008 	jr	ra
9d0053c0:	27bd0020 	addiu	sp,sp,32

9d0053c4 <init>:
	__PIC32_pbClk	=	SYSTEMConfigPerformance(F_CPU);
#endif
#endif

	// Configure the processor for the proper number of wait states and caching.
	_configSystem(F_CPU);
9d0053c4:	3c0404c4 	lui	a0,0x4c4
}


//************************************************************************
void init()
{
9d0053c8:	27bdffe8 	addiu	sp,sp,-24
9d0053cc:	afbf0014 	sw	ra,20(sp)
	__PIC32_pbClk	=	SYSTEMConfigPerformance(F_CPU);
#endif
#endif

	// Configure the processor for the proper number of wait states and caching.
	_configSystem(F_CPU);
9d0053d0:	0f4012f6 	jal	9d004bd8 <_configSystem>
9d0053d4:	3484b400 	ori	a0,a0,0xb400

	// Enable multi-vector interrupts
	_enableMultiVectorInterrupts();
9d0053d8:	0f401317 	jal	9d004c5c <_enableMultiVectorInterrupts>
9d0053dc:	00000000 	nop

	// Initialize the core timer for use to maintain the system timer tick.
	_initCoreTimer(CORE_TICK_RATE);
9d0053e0:	0f401320 	jal	9d004c80 <_initCoreTimer>
9d0053e4:	34049c40 	li	a0,0x9c40

    initIntVector();
9d0053e8:	0f4012aa 	jal	9d004aa8 <initIntVector>
9d0053ec:	00000000 	nop

	setIntPriority(_CORE_TIMER_VECTOR, _CT_IPL_IPC, _CT_SPL_IPC);
9d0053f0:	00003021 	move	a2,zero
9d0053f4:	00002021 	move	a0,zero
9d0053f8:	0f4012d8 	jal	9d004b60 <setIntPriority>
9d0053fc:	24050007 	li	a1,7
	setIntVector(_CORE_TIMER_VECTOR, CoreTimerHandler);
9d005400:	3c059d00 	lui	a1,0x9d00
9d005404:	24a55114 	addiu	a1,a1,20756
9d005408:	0f4012bf 	jal	9d004afc <setIntVector>
9d00540c:	00002021 	move	a0,zero
	setIntEnable(_CORE_TIMER_IRQ);
9d005410:	0f4012ca 	jal	9d004b28 <setIntEnable>
9d005414:	00002021 	move	a0,zero

	// Save the peripheral bus frequency for later use.
	__PIC32_pbClk = getPeripheralClock();
9d005418:	0f4012ef 	jal	9d004bbc <getPeripheralClock>
9d00541c:	00000000 	nop

   // allow for debugging, this will stop the core timer when the debugger takes control
    _CP0_BIC_DEBUG(_CP0_DEBUG_COUNTDM_MASK); 
9d005420:	3c030200 	lui	v1,0x200
	setIntPriority(_CORE_TIMER_VECTOR, _CT_IPL_IPC, _CT_SPL_IPC);
	setIntVector(_CORE_TIMER_VECTOR, CoreTimerHandler);
	setIntEnable(_CORE_TIMER_IRQ);

	// Save the peripheral bus frequency for later use.
	__PIC32_pbClk = getPeripheralClock();
9d005424:	af8280c8 	sw	v0,-32568(gp)

   // allow for debugging, this will stop the core timer when the debugger takes control
    _CP0_BIC_DEBUG(_CP0_DEBUG_COUNTDM_MASK); 
9d005428:	4002b800 	mfc0	v0,c0_debug
9d00542c:	00031827 	nor	v1,zero,v1
9d005430:	00431824 	and	v1,v0,v1
9d005434:	4083b800 	mtc0	v1,c0_debug
9d005438:	000000c0 	ehb
	RtccSetTimeDate(0x10073000, 0x10101701);
	// please note that the rsvd field has to be 0 in the time field!
#endif
#endif

	delay(50);
9d00543c:	0f4014db 	jal	9d00536c <delay>
9d005440:	24040032 	li	a0,50
#if defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)
	CFGCONbits.JTAGEN = 0;
	//CFGCONbits.TDOEN = 0;
	//OSCCONbits.SOSCEN = 0;
#else
	DDPCONbits.JTAGEN	=	0;
9d005444:	3c02bf81 	lui	v0,0xbf81
9d005448:	8c43f200 	lw	v1,-3584(v0)
9d00544c:	7c0318c4 	ins	v1,zero,0x3,0x1
9d005450:	ac43f200 	sw	v1,-3584(v0)
#endif


#if (OPT_BOARD_INIT != 0)
void	_board_init(void);
	_board_init();
9d005454:	0f40159a 	jal	9d005668 <_board_init>
9d005458:	00000000 	nop
#endif

	//* Initialize the periodic task manager
	_initTaskManager();
9d00545c:	0f40151f 	jal	9d00547c <_initTaskManager>
9d005460:	00000000 	nop
#if defined(_SER0_BASE)
	p32_uart *	uart;
	uart = (p32_uart *)_SER0_BASE;
	uart->uxMode.clr = (1 << _UARTMODE_ON);
#endif
}
9d005464:	8fbf0014 	lw	ra,20(sp)
	//*	Issue #84
	//*	disable the uart so that the pins can be used as general purpose I/O
#if defined(_SER0_BASE)
	p32_uart *	uart;
	uart = (p32_uart *)_SER0_BASE;
	uart->uxMode.clr = (1 << _UARTMODE_ON);
9d005468:	34038000 	li	v1,0x8000
9d00546c:	3c02bf80 	lui	v0,0xbf80
9d005470:	ac436004 	sw	v1,24580(v0)
#endif
}
9d005474:	03e00008 	jr	ra
9d005478:	27bd0018 	addiu	sp,sp,24

9d00547c <_initTaskManager>:
void
_initTaskManager() {
	int		id;

	for (id = 0; id < NUM_TASKS; id++) {
		rgtaskTable[id].pfnTask = 0;
9d00547c:	3c03a000 	lui	v1,0xa000
9d005480:	24620ca4 	addiu	v0,v1,3236
9d005484:	ac600ca4 	sw	zero,3236(v1)
9d005488:	ac400014 	sw	zero,20(v0)
9d00548c:	ac400028 	sw	zero,40(v0)
9d005490:	ac40003c 	sw	zero,60(v0)
9d005494:	ac400050 	sw	zero,80(v0)
9d005498:	ac400064 	sw	zero,100(v0)
9d00549c:	ac400078 	sw	zero,120(v0)
9d0054a0:	ac40008c 	sw	zero,140(v0)
	}

	tmsLastEvent = 0;
9d0054a4:	af80805c 	sw	zero,-32676(gp)
	tmsNextEvent = 0;

}
9d0054a8:	03e00008 	jr	ra
9d0054ac:	af808058 	sw	zero,-32680(gp)

9d0054b0 <_scheduleTask>:
	unsigned long	tmsCur;		//current system time
	unsigned long	tmsNxt;		//time for next event for this task
	unsigned long	dtmsNext;
	unsigned long	dtms;

	if (cntActiveTask == 0) {
9d0054b0:	8f828054 	lw	v0,-32684(gp)
**	xxxN..C..........................................Lxx
**		current time and next time have wrapped: (N < L) && (C >= N)
*/

void
_scheduleTask() {
9d0054b4:	27bdffc8 	addiu	sp,sp,-56
9d0054b8:	afbf0034 	sw	ra,52(sp)
9d0054bc:	afb50030 	sw	s5,48(sp)
9d0054c0:	afb4002c 	sw	s4,44(sp)
9d0054c4:	afb30028 	sw	s3,40(sp)
9d0054c8:	afb20024 	sw	s2,36(sp)
9d0054cc:	afb10020 	sw	s1,32(sp)
	unsigned long	tmsCur;		//current system time
	unsigned long	tmsNxt;		//time for next event for this task
	unsigned long	dtmsNext;
	unsigned long	dtms;

	if (cntActiveTask == 0) {
9d0054d0:	1440000a 	bnez	v0,9d0054fc <_scheduleTask+0x4c>
9d0054d4:	afb0001c 	sw	s0,28(sp)

	/* Compute when the next event time will be by adding the event
	** time delta to the current time.
	*/
	tmsNextEvent = tmsCur + dtmsNext;
}
9d0054d8:	8fbf0034 	lw	ra,52(sp)
9d0054dc:	8fb50030 	lw	s5,48(sp)
9d0054e0:	8fb4002c 	lw	s4,44(sp)
9d0054e4:	8fb30028 	lw	s3,40(sp)
9d0054e8:	8fb20024 	lw	s2,36(sp)
9d0054ec:	8fb10020 	lw	s1,32(sp)
9d0054f0:	8fb0001c 	lw	s0,28(sp)
9d0054f4:	03e00008 	jr	ra
9d0054f8:	27bd0038 	addiu	sp,sp,56

	if (cntActiveTask == 0) {
		return;
	}

	tmsCur = millis();
9d0054fc:	0f4014d8 	jal	9d005360 <millis>
9d005500:	00000000 	nop

	/* The system millisecond timer will overflow every 49.71 days. The complexity of
	** this conditional is to account for the cases where either the next event time has
	** wrapped around or the current time has wrapped around.
	*/
	if ( ((tmsNextEvent >= tmsLastEvent) &&
9d005504:	8f848058 	lw	a0,-32680(gp)
9d005508:	8f83805c 	lw	v1,-32676(gp)
9d00550c:	0083282b 	sltu	a1,a0,v1
9d005510:	14a00048 	bnez	a1,9d005634 <_scheduleTask+0x184>
9d005514:	0043182b 	sltu	v1,v0,v1
9d005518:	14600004 	bnez	v1,9d00552c <_scheduleTask+0x7c>
9d00551c:	3c10a000 	lui	s0,0xa000
				((tmsCur >= tmsLastEvent) && (tmsCur < tmsNextEvent))) ||
9d005520:	0044202b 	sltu	a0,v0,a0
9d005524:	1480ffec 	bnez	a0,9d0054d8 <_scheduleTask+0x28>
9d005528:	3c10a000 	lui	s0,0xa000
9d00552c:	26100cb4 	addiu	s0,s0,3252
**	xxxN..C..........................................Lxx
**		current time and next time have wrapped: (N < L) && (C >= N)
*/

void
_scheduleTask() {
9d005530:	2413ffff 	li	s3,-1
9d005534:	00008821 	move	s1,zero

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
			(*rgtaskTable[id].pfnTask)(id, rgtaskTable[id].varTask);
			rgtaskTable[id].fsFlags &= ~fsBusy;
9d005538:	2415fffe 	li	s5,-2

			/* Decrement the repeat count.
			*/
			if ((rgtaskTable[id].stTask > 0) &&
9d00553c:	3414fffe 	li	s4,0xfffe
	** the table for all events that have elapsed and call their
	** associated functions, update their next event timers, and then
	** figure out when the next event time is.
	*/
	dtmsNext = 0xFFFFFFFF;
	for (id = 0; id < NUM_TASKS; id++) {
9d005540:	24120008 	li	s2,8
		/* If this isn't an active task, go to the next one.
		*/
		if ((rgtaskTable[id].pfnTask == 0) || 
9d005544:	8e03fff0 	lw	v1,-16(s0)
9d005548:	5060002c 	beqzl	v1,9d0055fc <_scheduleTask+0x14c>
9d00554c:	26310001 	addiu	s1,s1,1
9d005550:	96040000 	lhu	a0,0(s0)
9d005554:	50800029 	beqzl	a0,9d0055fc <_scheduleTask+0x14c>
9d005558:	26310001 	addiu	s1,s1,1
		** occur if a user task function calls delay() or any other
		** function that causes _scheduleTask to be called recursively.
		** This prevents the task function from being called recursively
		** until the system crashes.
		*/
		if ((rgtaskTable[id].fsFlags & fsBusy) != 0) {
9d00555c:	96040002 	lhu	a0,2(s0)
9d005560:	30840001 	andi	a0,a0,0x1
9d005564:	54800025 	bnezl	a0,9d0055fc <_scheduleTask+0x14c>
9d005568:	26310001 	addiu	s1,s1,1
			continue;
		}

		/* Check if this task's period has timed out.
		*/
		tmsNxt = rgtaskTable[id].tmsNext;
9d00556c:	8e04fff8 	lw	a0,-8(s0)
		if ( ((tmsNxt >= tmsLastEvent) && 
9d005570:	8f85805c 	lw	a1,-32676(gp)
9d005574:	0085302b 	sltu	a2,a0,a1
9d005578:	10c00032 	beqz	a2,9d005644 <_scheduleTask+0x194>
9d00557c:	0044302b 	sltu	a2,v0,a0
						((tmsCur >= tmsNxt) || (tmsCur < tmsLastEvent))) ||
			 ((tmsNxt <  tmsLastEvent) && 
9d005580:	54c0001b 	bnezl	a2,9d0055f0 <_scheduleTask+0x140>
9d005584:	00822023 	subu	a0,a0,v0
						((tmsCur >= tmsNxt) && (tmsCur < tmsLastEvent))) ) {
9d005588:	0045282b 	sltu	a1,v0,a1
9d00558c:	50a00018 	beqzl	a1,9d0055f0 <_scheduleTask+0x140>
9d005590:	00822023 	subu	a0,a0,v0
			*/
			rgtaskTable[id].tmsNext += rgtaskTable[id].tmsPeriod;

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
9d005594:	96060002 	lhu	a2,2(s0)
						((tmsCur >= tmsNxt) && (tmsCur < tmsLastEvent))) ) {

			/* This task event has timed out. Update the event time for the
			** next event on this task.
			*/
			rgtaskTable[id].tmsNext += rgtaskTable[id].tmsPeriod;
9d005598:	8e07fff4 	lw	a3,-12(s0)

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
			(*rgtaskTable[id].pfnTask)(id, rgtaskTable[id].varTask);
9d00559c:	8e05fffc 	lw	a1,-4(s0)
			*/
			rgtaskTable[id].tmsNext += rgtaskTable[id].tmsPeriod;

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
9d0055a0:	34c60001 	ori	a2,a2,0x1
						((tmsCur >= tmsNxt) && (tmsCur < tmsLastEvent))) ) {

			/* This task event has timed out. Update the event time for the
			** next event on this task.
			*/
			rgtaskTable[id].tmsNext += rgtaskTable[id].tmsPeriod;
9d0055a4:	00e42021 	addu	a0,a3,a0
9d0055a8:	ae04fff8 	sw	a0,-8(s0)

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
			(*rgtaskTable[id].pfnTask)(id, rgtaskTable[id].varTask);
9d0055ac:	afa20010 	sw	v0,16(sp)
9d0055b0:	02202021 	move	a0,s1
9d0055b4:	0060f809 	jalr	v1
9d0055b8:	a6060002 	sh	a2,2(s0)
			rgtaskTable[id].fsFlags &= ~fsBusy;

			/* Decrement the repeat count.
			*/
			if ((rgtaskTable[id].stTask > 0) &&
9d0055bc:	96030000 	lhu	v1,0(s0)

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
			(*rgtaskTable[id].pfnTask)(id, rgtaskTable[id].varTask);
			rgtaskTable[id].fsFlags &= ~fsBusy;
9d0055c0:	96050002 	lhu	a1,2(s0)

			/* Decrement the repeat count.
			*/
			if ((rgtaskTable[id].stTask > 0) &&
9d0055c4:	8fa20010 	lw	v0,16(sp)
9d0055c8:	2463ffff 	addiu	v1,v1,-1
9d0055cc:	3063ffff 	andi	v1,v1,0xffff

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
			(*rgtaskTable[id].pfnTask)(id, rgtaskTable[id].varTask);
			rgtaskTable[id].fsFlags &= ~fsBusy;
9d0055d0:	00b52824 	and	a1,a1,s5

			/* Decrement the repeat count.
			*/
			if ((rgtaskTable[id].stTask > 0) &&
9d0055d4:	0074202b 	sltu	a0,v1,s4
9d0055d8:	10800003 	beqz	a0,9d0055e8 <_scheduleTask+0x138>
9d0055dc:	a6050002 	sh	a1,2(s0)
				rgtaskTable[id].stTask -= 1;

				/* The task state counter has gone to 0. This task is now
				** disabled.
				*/
				if (rgtaskTable[id].stTask == 0) {
9d0055e0:	1060001c 	beqz	v1,9d005654 <_scheduleTask+0x1a4>
9d0055e4:	a6030000 	sh	v1,0(s0)
9d0055e8:	8e04fff8 	lw	a0,-8(s0)
		}

		/* Compute delta of this event time from the current time and
		** remember it if it is less than the current delta.
		*/
		dtms = rgtaskTable[id].tmsNext - tmsCur;
9d0055ec:	00822023 	subu	a0,a0,v0
		if (dtms < dtmsNext) {
9d0055f0:	0093182b 	sltu	v1,a0,s3
9d0055f4:	0083980b 	movn	s3,a0,v1
	** the table for all events that have elapsed and call their
	** associated functions, update their next event timers, and then
	** figure out when the next event time is.
	*/
	dtmsNext = 0xFFFFFFFF;
	for (id = 0; id < NUM_TASKS; id++) {
9d0055f8:	26310001 	addiu	s1,s1,1
9d0055fc:	1632ffd1 	bne	s1,s2,9d005544 <_scheduleTask+0x94>
9d005600:	26100014 	addiu	s0,s0,20

	/* Compute when the next event time will be by adding the event
	** time delta to the current time.
	*/
	tmsNextEvent = tmsCur + dtmsNext;
}
9d005604:	8fbf0034 	lw	ra,52(sp)
	tmsLastEvent = tmsCur;

	/* Compute when the next event time will be by adding the event
	** time delta to the current time.
	*/
	tmsNextEvent = tmsCur + dtmsNext;
9d005608:	02629821 	addu	s3,s3,v0
9d00560c:	af938058 	sw	s3,-32680(gp)
}
9d005610:	8fb50030 	lw	s5,48(sp)
9d005614:	8fb4002c 	lw	s4,44(sp)
9d005618:	8fb30028 	lw	s3,40(sp)
9d00561c:	8fb20024 	lw	s2,36(sp)
9d005620:	8fb10020 	lw	s1,32(sp)
9d005624:	8fb0001c 	lw	s0,28(sp)
	}

	/* All done with event tasks. Update the last event time with
	** the current time.
	*/
	tmsLastEvent = tmsCur;
9d005628:	af82805c 	sw	v0,-32676(gp)

	/* Compute when the next event time will be by adding the event
	** time delta to the current time.
	*/
	tmsNextEvent = tmsCur + dtmsNext;
}
9d00562c:	03e00008 	jr	ra
9d005630:	27bd0038 	addiu	sp,sp,56
	** this conditional is to account for the cases where either the next event time has
	** wrapped around or the current time has wrapped around.
	*/
	if ( ((tmsNextEvent >= tmsLastEvent) &&
				((tmsCur >= tmsLastEvent) && (tmsCur < tmsNextEvent))) ||
		 ((tmsNextEvent < tmsLastEvent) &&
9d005634:	5460ffbb 	bnezl	v1,9d005524 <_scheduleTask+0x74>
9d005638:	0044202b 	sltu	a0,v0,a0

	/* Compute when the next event time will be by adding the event
	** time delta to the current time.
	*/
	tmsNextEvent = tmsCur + dtmsNext;
}
9d00563c:	0b401537 	j	9d0054dc <_scheduleTask+0x2c>
9d005640:	8fbf0034 	lw	ra,52(sp)
		}

		/* Check if this task's period has timed out.
		*/
		tmsNxt = rgtaskTable[id].tmsNext;
		if ( ((tmsNxt >= tmsLastEvent) && 
9d005644:	50c0ffd4 	beqzl	a2,9d005598 <_scheduleTask+0xe8>
9d005648:	96060002 	lhu	a2,2(s0)
						((tmsCur >= tmsNxt) || (tmsCur < tmsLastEvent))) ||
			 ((tmsNxt <  tmsLastEvent) && 
						((tmsCur >= tmsNxt) && (tmsCur < tmsLastEvent))) ) {
9d00564c:	0b401563 	j	9d00558c <_scheduleTask+0xdc>
9d005650:	0045282b 	sltu	a1,v0,a1
				/* The task state counter has gone to 0. This task is now
				** disabled.
				*/
				if (rgtaskTable[id].stTask == 0) {
					rgtaskTable[id].tmsNext = 0;
					cntActiveTask -= 1;
9d005654:	8f838054 	lw	v1,-32684(gp)

				/* The task state counter has gone to 0. This task is now
				** disabled.
				*/
				if (rgtaskTable[id].stTask == 0) {
					rgtaskTable[id].tmsNext = 0;
9d005658:	ae00fff8 	sw	zero,-8(s0)
					cntActiveTask -= 1;
9d00565c:	2463ffff 	addiu	v1,v1,-1
					continue;
9d005660:	0b40157e 	j	9d0055f8 <_scheduleTask+0x148>
9d005664:	af838054 	sw	v1,-32684(gp)

9d005668 <_board_init>:

void _board_init(void) {

	/*	Turn off Secondary oscillator so pins can be used as GPIO
	*/
	OSCCONCLR	=	_OSCCON_SOSCEN_MASK;
9d005668:	24030002 	li	v1,2
9d00566c:	3c02bf81 	lui	v0,0xbf81
9d005670:	ac43f004 	sw	v1,-4092(v0)

}
9d005674:	03e00008 	jr	ra
9d005678:	00000000 	nop

9d00567c <main>:
__attribute__((section(".comment"))) void (*__use_force_isr_install)(void) = &__use_isr_install;
}

//************************************************************************
int main(void)
{
9d00567c:	27bdffe8 	addiu	sp,sp,-24
9d005680:	afbf0014 	sw	ra,20(sp)
	init();
9d005684:	0f4014f1 	jal	9d0053c4 <init>
9d005688:	00000000 	nop

	setup();
9d00568c:	0f4004d6 	jal	9d001358 <setup>
9d005690:	00000000 	nop

	while (1)
	{
		_scheduleTask();
9d005694:	0f40152c 	jal	9d0054b0 <_scheduleTask>
9d005698:	00000000 	nop
		loop();
9d00569c:	0f4005b0 	jal	9d0016c0 <loop>
9d0056a0:	00000000 	nop
9d0056a4:	0b4015a5 	j	9d005694 <main+0x18>
9d0056a8:	00000000 	nop

9d0056ac <_ZN5Print5writeEPKc>:

//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const char *str)
{
9d0056ac:	27bdffe0 	addiu	sp,sp,-32
9d0056b0:	afb10018 	sw	s1,24(sp)
9d0056b4:	afb00014 	sw	s0,20(sp)
9d0056b8:	afbf001c 	sw	ra,28(sp)
9d0056bc:	00a08021 	move	s0,a1
	while (*str)
9d0056c0:	80a50000 	lb	a1,0(a1)
9d0056c4:	10a0000a 	beqz	a1,9d0056f0 <_ZN5Print5writeEPKc+0x44>
9d0056c8:	00808821 	move	s1,a0
	{
		write(*str++);
9d0056cc:	8e220000 	lw	v0,0(s1)
9d0056d0:	30a500ff 	andi	a1,a1,0xff
9d0056d4:	26100001 	addiu	s0,s0,1
9d0056d8:	8c420000 	lw	v0,0(v0)
9d0056dc:	0040f809 	jalr	v0
9d0056e0:	02202021 	move	a0,s1
//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const char *str)
{
	while (*str)
9d0056e4:	82050000 	lb	a1,0(s0)
9d0056e8:	54a0fff9 	bnezl	a1,9d0056d0 <_ZN5Print5writeEPKc+0x24>
9d0056ec:	8e220000 	lw	v0,0(s1)
	{
		write(*str++);
	}
}
9d0056f0:	8fbf001c 	lw	ra,28(sp)
9d0056f4:	8fb10018 	lw	s1,24(sp)
9d0056f8:	8fb00014 	lw	s0,20(sp)
9d0056fc:	03e00008 	jr	ra
9d005700:	27bd0020 	addiu	sp,sp,32

9d005704 <_ZN5Print5writeEPKhm>:

//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const uint8_t *buffer, size_t size)
{
9d005704:	27bdffe0 	addiu	sp,sp,-32
9d005708:	afb20018 	sw	s2,24(sp)
9d00570c:	afb10014 	sw	s1,20(sp)
9d005710:	afb00010 	sw	s0,16(sp)
9d005714:	afbf001c 	sw	ra,28(sp)
9d005718:	00c08021 	move	s0,a2
9d00571c:	00809021 	move	s2,a0
	while (size--)
9d005720:	10c0000a 	beqz	a2,9d00574c <_ZN5Print5writeEPKhm+0x48>
9d005724:	00a08821 	move	s1,a1
	{
		write(*buffer++);
9d005728:	8e420000 	lw	v0,0(s2)
9d00572c:	92250000 	lbu	a1,0(s1)
9d005730:	2610ffff 	addiu	s0,s0,-1
9d005734:	8c420000 	lw	v0,0(v0)
9d005738:	02402021 	move	a0,s2
9d00573c:	0040f809 	jalr	v0
9d005740:	26310001 	addiu	s1,s1,1
//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const uint8_t *buffer, size_t size)
{
	while (size--)
9d005744:	5600fff9 	bnezl	s0,9d00572c <_ZN5Print5writeEPKhm+0x28>
9d005748:	8e420000 	lw	v0,0(s2)
	{
		write(*buffer++);
	}
}
9d00574c:	8fbf001c 	lw	ra,28(sp)
9d005750:	8fb20018 	lw	s2,24(sp)
9d005754:	8fb10014 	lw	s1,20(sp)
9d005758:	8fb00010 	lw	s0,16(sp)
9d00575c:	03e00008 	jr	ra
9d005760:	27bd0020 	addiu	sp,sp,32

9d005764 <_ZN5Print5printEPKc>:
	}
}
//************************************************************************
void Print::print(const char str[])
{
	write(str);
9d005764:	8c820000 	lw	v0,0(a0)
9d005768:	8c590004 	lw	t9,4(v0)
9d00576c:	03200008 	jr	t9
9d005770:	00000000 	nop

9d005774 <_ZN5Print11printNumberEmh>:

// Private Methods /////////////////////////////////////////////////////////////

//************************************************************************
void Print::printNumber(unsigned long n, uint8_t base)
{
9d005774:	27bdffc0 	addiu	sp,sp,-64
9d005778:	afb10038 	sw	s1,56(sp)
9d00577c:	afb00034 	sw	s0,52(sp)
9d005780:	afbf003c 	sw	ra,60(sp)
9d005784:	00808021 	move	s0,a0
9d005788:	30c600ff 	andi	a2,a2,0xff
unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars.
unsigned long i = 0;

	if (n == 0)
9d00578c:	10a00020 	beqz	a1,9d005810 <_ZN5Print11printNumberEmh+0x9c>
9d005790:	00008821 	move	s1,zero
		return;
	}

	while (n > 0)
	{
		buf[i++] = n % base;
9d005794:	00a6001b 	divu	zero,a1,a2
9d005798:	00c001f4 	teq	a2,zero,0x7
}

// Private Methods /////////////////////////////////////////////////////////////

//************************************************************************
void Print::printNumber(unsigned long n, uint8_t base)
9d00579c:	27a40010 	addiu	a0,sp,16
9d0057a0:	00911021 	addu	v0,a0,s1
		return;
	}

	while (n > 0)
	{
		buf[i++] = n % base;
9d0057a4:	26310001 	addiu	s1,s1,1
9d0057a8:	00001810 	mfhi	v1
9d0057ac:	00002812 	mflo	a1
	{
		print('0');
		return;
	}

	while (n > 0)
9d0057b0:	14a0fff8 	bnez	a1,9d005794 <_ZN5Print11printNumberEmh+0x20>
9d0057b4:	a0430000 	sb	v1,0(v0)
	{
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
9d0057b8:	12200011 	beqz	s1,9d005800 <_ZN5Print11printNumberEmh+0x8c>
9d0057bc:	8fbf003c 	lw	ra,60(sp)
}

// Private Methods /////////////////////////////////////////////////////////////

//************************************************************************
void Print::printNumber(unsigned long n, uint8_t base)
9d0057c0:	27a30010 	addiu	v1,sp,16
9d0057c4:	00711021 	addu	v0,v1,s1
		n /= base;
	}

	for (; i > 0; i--)
	{
		print((char) (buf[i - 1] < 10 ?
9d0057c8:	9042ffff 	lbu	v0,-1(v0)
					'0' + buf[i - 1] :
					'A' + buf[i - 1] - 10));
9d0057cc:	24450030 	addiu	a1,v0,48
9d0057d0:	2c43000a 	sltiu	v1,v0,10
9d0057d4:	7c052c20 	seb	a1,a1
9d0057d8:	14600002 	bnez	v1,9d0057e4 <_ZN5Print11printNumberEmh+0x70>
9d0057dc:	24420037 	addiu	v0,v0,55
9d0057e0:	7c022c20 	seb	a1,v0
	{
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
9d0057e4:	2631ffff 	addiu	s1,s1,-1
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d0057e8:	02002021 	move	a0,s0
9d0057ec:	0f401612 	jal	9d005848 <_ZN5Print5printEli>
9d0057f0:	00003021 	move	a2,zero
	{
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
9d0057f4:	1620fff3 	bnez	s1,9d0057c4 <_ZN5Print11printNumberEmh+0x50>
9d0057f8:	27a30010 	addiu	v1,sp,16
	{
		print((char) (buf[i - 1] < 10 ?
					'0' + buf[i - 1] :
					'A' + buf[i - 1] - 10));
	}
}
9d0057fc:	8fbf003c 	lw	ra,60(sp)
9d005800:	8fb10038 	lw	s1,56(sp)
9d005804:	8fb00034 	lw	s0,52(sp)
9d005808:	03e00008 	jr	ra
9d00580c:	27bd0040 	addiu	sp,sp,64
9d005810:	8fbf003c 	lw	ra,60(sp)
9d005814:	8fb10038 	lw	s1,56(sp)
9d005818:	8fb00034 	lw	s0,52(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d00581c:	24050030 	li	a1,48
9d005820:	00003021 	move	a2,zero
9d005824:	0b401612 	j	9d005848 <_ZN5Print5printEli>
9d005828:	27bd0040 	addiu	sp,sp,64

9d00582c <_ZN5Print5printEmi>:
}

//************************************************************************
void Print::print(unsigned long n, int base)
{
	if (base == 0)
9d00582c:	50c00003 	beqzl	a2,9d00583c <_ZN5Print5printEmi+0x10>
9d005830:	8c830000 	lw	v1,0(a0)
	{
		write(n);
	}
	else
	{
		printNumber(n, base);
9d005834:	0b4015dd 	j	9d005774 <_ZN5Print11printNumberEmh>
9d005838:	30c600ff 	andi	a2,a2,0xff
//************************************************************************
void Print::print(unsigned long n, int base)
{
	if (base == 0)
	{
		write(n);
9d00583c:	8c790000 	lw	t9,0(v1)
9d005840:	03200008 	jr	t9
9d005844:	30a500ff 	andi	a1,a1,0xff

9d005848 <_ZN5Print5printEli>:
	print((unsigned long) n, base);
}

//************************************************************************
void Print::print(long n, int base)
{
9d005848:	27bdffe0 	addiu	sp,sp,-32
9d00584c:	afb10018 	sw	s1,24(sp)
9d005850:	afb00014 	sw	s0,20(sp)
9d005854:	afbf001c 	sw	ra,28(sp)
9d005858:	00808821 	move	s1,a0
	if (base == 0)
9d00585c:	10c00013 	beqz	a2,9d0058ac <_ZN5Print5printEli+0x64>
9d005860:	00a08021 	move	s0,a1
	{
		write(n);
	}
	else if (base == 10)
9d005864:	2402000a 	li	v0,10
9d005868:	10c20006 	beq	a2,v0,9d005884 <_ZN5Print5printEli+0x3c>
9d00586c:	8fbf001c 	lw	ra,28(sp)
	}
	else
	{
		printNumber(n, base);
	}
}
9d005870:	8fb10018 	lw	s1,24(sp)
9d005874:	8fb00014 	lw	s0,20(sp)
		}
		printNumber(n, 10);
	}
	else
	{
		printNumber(n, base);
9d005878:	30c600ff 	andi	a2,a2,0xff
9d00587c:	0b4015dd 	j	9d005774 <_ZN5Print11printNumberEmh>
9d005880:	27bd0020 	addiu	sp,sp,32
	{
		write(n);
	}
	else if (base == 10)
	{
		if (n < 0)
9d005884:	04a00011 	bltz	a1,9d0058cc <_ZN5Print5printEli+0x84>
9d005888:	2405002d 	li	a1,45
		{
			print('-');
			n = -n;
		}
		printNumber(n, 10);
9d00588c:	02202021 	move	a0,s1
9d005890:	02002821 	move	a1,s0
	}
	else
	{
		printNumber(n, base);
	}
}
9d005894:	8fbf001c 	lw	ra,28(sp)
9d005898:	8fb10018 	lw	s1,24(sp)
9d00589c:	8fb00014 	lw	s0,20(sp)
		if (n < 0)
		{
			print('-');
			n = -n;
		}
		printNumber(n, 10);
9d0058a0:	2406000a 	li	a2,10
	}
	else
	{
		printNumber(n, base);
9d0058a4:	0b4015dd 	j	9d005774 <_ZN5Print11printNumberEmh>
9d0058a8:	27bd0020 	addiu	sp,sp,32
//************************************************************************
void Print::print(long n, int base)
{
	if (base == 0)
	{
		write(n);
9d0058ac:	8c820000 	lw	v0,0(a0)
	}
	else
	{
		printNumber(n, base);
	}
}
9d0058b0:	8fbf001c 	lw	ra,28(sp)
9d0058b4:	8fb10018 	lw	s1,24(sp)
//************************************************************************
void Print::print(long n, int base)
{
	if (base == 0)
	{
		write(n);
9d0058b8:	8c590000 	lw	t9,0(v0)
	}
	else
	{
		printNumber(n, base);
	}
}
9d0058bc:	8fb00014 	lw	s0,20(sp)
//************************************************************************
void Print::print(long n, int base)
{
	if (base == 0)
	{
		write(n);
9d0058c0:	30a500ff 	andi	a1,a1,0xff
9d0058c4:	03200008 	jr	t9
9d0058c8:	27bd0020 	addiu	sp,sp,32
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d0058cc:	0f401612 	jal	9d005848 <_ZN5Print5printEli>
9d0058d0:	00003021 	move	a2,zero
	else if (base == 10)
	{
		if (n < 0)
		{
			print('-');
			n = -n;
9d0058d4:	0b401623 	j	9d00588c <_ZN5Print5printEli+0x44>
9d0058d8:	00108023 	negu	s0,s0

9d0058dc <_ZN5Print7printlnEv>:
	printFloat(n, digits);
}

//************************************************************************
void Print::println(void)
{
9d0058dc:	27bdffe8 	addiu	sp,sp,-24
9d0058e0:	afb00010 	sw	s0,16(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d0058e4:	2405000d 	li	a1,13
	printFloat(n, digits);
}

//************************************************************************
void Print::println(void)
{
9d0058e8:	00808021 	move	s0,a0
9d0058ec:	afbf0014 	sw	ra,20(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d0058f0:	0f401612 	jal	9d005848 <_ZN5Print5printEli>
9d0058f4:	00003021 	move	a2,zero
9d0058f8:	02002021 	move	a0,s0
//************************************************************************
void Print::println(void)
{
	print('\r');
	print('\n');
}
9d0058fc:	8fbf0014 	lw	ra,20(sp)
9d005900:	8fb00010 	lw	s0,16(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d005904:	2405000a 	li	a1,10
9d005908:	00003021 	move	a2,zero
9d00590c:	0b401612 	j	9d005848 <_ZN5Print5printEli>
9d005910:	27bd0018 	addiu	sp,sp,24

9d005914 <_ZN5Print7printlnEPKc>:
	}
}
//************************************************************************
void Print::print(const char str[])
{
	write(str);
9d005914:	8c820000 	lw	v0,0(a0)
	print(argString);
	println();
}
//************************************************************************
void Print::println(const char c[])
{
9d005918:	27bdffe8 	addiu	sp,sp,-24
9d00591c:	afbf0014 	sw	ra,20(sp)
	}
}
//************************************************************************
void Print::print(const char str[])
{
	write(str);
9d005920:	8c420004 	lw	v0,4(v0)
	print(argString);
	println();
}
//************************************************************************
void Print::println(const char c[])
{
9d005924:	afb00010 	sw	s0,16(sp)
	}
}
//************************************************************************
void Print::print(const char str[])
{
	write(str);
9d005928:	0040f809 	jalr	v0
9d00592c:	00808021 	move	s0,a0
}
//************************************************************************
void Print::println(const char c[])
{
	print(c);
	println();
9d005930:	02002021 	move	a0,s0
}
9d005934:	8fbf0014 	lw	ra,20(sp)
9d005938:	8fb00010 	lw	s0,16(sp)
}
//************************************************************************
void Print::println(const char c[])
{
	print(c);
	println();
9d00593c:	0b401637 	j	9d0058dc <_ZN5Print7printlnEv>
9d005940:	27bd0018 	addiu	sp,sp,24

9d005944 <_ZN14HardwareSerial9availableEv>:
**		receive buffer.
*/

int HardwareSerial::available(void)
{
	return (RX_BUFFER_SIZE + rx_buffer.head - rx_buffer.tail) % RX_BUFFER_SIZE;
9d005944:	8c820224 	lw	v0,548(a0)
9d005948:	8c830228 	lw	v1,552(a0)
9d00594c:	24420200 	addiu	v0,v0,512
9d005950:	00431023 	subu	v0,v0,v1
9d005954:	00021fc3 	sra	v1,v0,0x1f
9d005958:	00031dc2 	srl	v1,v1,0x17
9d00595c:	00431021 	addu	v0,v0,v1
9d005960:	304201ff 	andi	v0,v0,0x1ff
}
9d005964:	03e00008 	jr	ra
9d005968:	00431023 	subu	v0,v0,v1

9d00596c <_ZN14HardwareSerial4peekEv>:
**		removing it from the buffer, or -1 if no characters are in the buffer.
*/

int HardwareSerial::peek()
{
	if (rx_buffer.head == rx_buffer.tail)
9d00596c:	8c830228 	lw	v1,552(a0)
9d005970:	8c850224 	lw	a1,548(a0)
9d005974:	10a30003 	beq	a1,v1,9d005984 <_ZN14HardwareSerial4peekEv+0x18>
9d005978:	2402ffff 	li	v0,-1
	{
		return -1;
	}
	else
	{
		return rx_buffer.buffer[rx_buffer.tail];
9d00597c:	00832021 	addu	a0,a0,v1
9d005980:	90820024 	lbu	v0,36(a0)
	}
}
9d005984:	03e00008 	jr	ra
9d005988:	00000000 	nop

9d00598c <_ZN14HardwareSerial4readEv>:
int HardwareSerial::read(void)
{
	unsigned char theChar;

	// if the head isn't ahead of the tail, we don't have any characters
	if (rx_buffer.head == rx_buffer.tail)
9d00598c:	8c830228 	lw	v1,552(a0)
9d005990:	8c850224 	lw	a1,548(a0)
9d005994:	10a3000a 	beq	a1,v1,9d0059c0 <_ZN14HardwareSerial4readEv+0x34>
9d005998:	2402ffff 	li	v0,-1
		return -1;
	}
	else
	{
		theChar			= rx_buffer.buffer[rx_buffer.tail];
		rx_buffer.tail	= (rx_buffer.tail + 1) % RX_BUFFER_SIZE;
9d00599c:	24660001 	addiu	a2,v1,1
9d0059a0:	00062fc3 	sra	a1,a2,0x1f
9d0059a4:	00052dc2 	srl	a1,a1,0x17
9d0059a8:	00c53021 	addu	a2,a2,a1
	{
		return -1;
	}
	else
	{
		theChar			= rx_buffer.buffer[rx_buffer.tail];
9d0059ac:	00831821 	addu	v1,a0,v1
		rx_buffer.tail	= (rx_buffer.tail + 1) % RX_BUFFER_SIZE;
9d0059b0:	30c601ff 	andi	a2,a2,0x1ff
	{
		return -1;
	}
	else
	{
		theChar			= rx_buffer.buffer[rx_buffer.tail];
9d0059b4:	90620024 	lbu	v0,36(v1)
		rx_buffer.tail	= (rx_buffer.tail + 1) % RX_BUFFER_SIZE;
9d0059b8:	00c52823 	subu	a1,a2,a1
9d0059bc:	ac850228 	sw	a1,552(a0)
		return (theChar);
	}
}
9d0059c0:	03e00008 	jr	ra
9d0059c4:	00000000 	nop

9d0059c8 <_ZN14HardwareSerial5flushEv>:
**	Description:
**		Empty the send buffer by waiting for the
**		fifo to empty and the transmitter to become idle
*/
void HardwareSerial::flush()
{
9d0059c8:	8c830004 	lw	v1,4(a0)
	while ((uart->uxSta.reg & (1 << _UARTSTA_TMRT)) == 0)	//check the TRMT bit
9d0059cc:	8c620010 	lw	v0,16(v1)
9d0059d0:	30420100 	andi	v0,v0,0x100
9d0059d4:	1040fffd 	beqz	v0,9d0059cc <_ZN14HardwareSerial5flushEv+0x4>
9d0059d8:	00000000 	nop
	{
		//* wait for the transmitter to be clear
	}
}
9d0059dc:	03e00008 	jr	ra
9d0059e0:	00000000 	nop

9d0059e4 <_ZN14HardwareSerial5purgeEv>:
	// don't reverse this or there may be problems if the RX interrupt
	// occurs after reading the value of rx_buffer_head but before writing
	// the value to rx_buffer_tail; the previous value of rx_buffer_head
	// may be written to rx_buffer_tail, making it appear as if the buffer
	// were full, not empty.
	rx_buffer.head = rx_buffer.tail;
9d0059e4:	8c820228 	lw	v0,552(a0)
}
9d0059e8:	03e00008 	jr	ra
9d0059ec:	ac820224 	sw	v0,548(a0)

9d0059f0 <_ZN14HardwareSerial5writeEh>:
**		Wait until the transmitter is idle, and then transmit the
**		specified character.
*/

void HardwareSerial::write(uint8_t theChar)
{
9d0059f0:	8c820004 	lw	v0,4(a0)
9d0059f4:	30a500ff 	andi	a1,a1,0xff

	while ((uart->uxSta.reg & (1 << _UARTSTA_UTXBF)) != 0)	//check the UTXBF bit
9d0059f8:	8c430010 	lw	v1,16(v0)
9d0059fc:	30630200 	andi	v1,v1,0x200
9d005a00:	1460fffd 	bnez	v1,9d0059f8 <_ZN14HardwareSerial5writeEh+0x8>
9d005a04:	00000000 	nop
  {
		//* wait for the transmitter buffer to have room
	}

	uart->uxTx.reg = theChar;
9d005a08:	ac450020 	sw	a1,32(v0)
}
9d005a0c:	03e00008 	jr	ra
9d005a10:	00000000 	nop

9d005a14 <_Z15USBresetRoutinev>:

//****************************************************************
void	USBresetRoutine(void)
{
	
}
9d005a14:	03e00008 	jr	ra
9d005a18:	00000000 	nop

9d005a1c <_Z19USBstoreDataRoutinePKhi>:
boolean	USBstoreDataRoutine(const byte *buffer, int length)
{
    int	i;

    // Put each byte into the serial recieve buffer
    for (i=0; i<length; i++)
9d005a1c:	18a00020 	blez	a1,9d005aa0 <_Z19USBstoreDataRoutinePKhi+0x84>
9d005a20:	3c02a000 	lui	v0,0xa000
9d005a24:	3c0aa000 	lui	t2,0xa000
9d005a28:	254a0d44 	addiu	t2,t2,3396
9d005a2c:	8d4b0204 	lw	t3,516(t2)
9d005a30:	8d480200 	lw	t0,512(t2)
9d005a34:	00001021 	move	v0,zero
inline boolean store_char(unsigned char theChar, ring_buffer *rx_buffer)
{
int	bufIndex;

    // Compute the place where we want to store this byte - one beyond the head
	bufIndex	= (rx_buffer->head + 1) % RX_BUFFER_SIZE;
9d005a38:	25070001 	addiu	a3,t0,1
9d005a3c:	000737c3 	sra	a2,a3,0x1f
9d005a40:	000635c2 	srl	a2,a2,0x17
9d005a44:	00e61821 	addu	v1,a3,a2
9d005a48:	306301ff 	andi	v1,v1,0x1ff
	
}

//****************************************************************
// Need to return FALSE if we need USB to hold off for awhile
boolean	USBstoreDataRoutine(const byte *buffer, int length)
9d005a4c:	00824821 	addu	t1,a0,v0
inline boolean store_char(unsigned char theChar, ring_buffer *rx_buffer)
{
int	bufIndex;

    // Compute the place where we want to store this byte - one beyond the head
	bufIndex	= (rx_buffer->head + 1) % RX_BUFFER_SIZE;
9d005a50:	00661823 	subu	v1,v1,a2
boolean	USBstoreDataRoutine(const byte *buffer, int length)
{
    int	i;

    // Put each byte into the serial recieve buffer
    for (i=0; i<length; i++)
9d005a54:	24420001 	addiu	v0,v0,1
    // we would overflow the buffer if we put our character there. This is because
    // if head = tail, the buffer is empty. If head = tail-1, then the buffer
    // is full. So only write into the buffer if we are not writing at the tail.
	if (bufIndex != rx_buffer->tail)
	{
		rx_buffer->buffer[rx_buffer->head]	=	theChar;
9d005a58:	01483021 	addu	a2,t2,t0

    // If the place where we are about to store the character is the tail, then
    // we would overflow the buffer if we put our character there. This is because
    // if head = tail, the buffer is empty. If head = tail-1, then the buffer
    // is full. So only write into the buffer if we are not writing at the tail.
	if (bufIndex != rx_buffer->tail)
9d005a5c:	106b0004 	beq	v1,t3,9d005a70 <_Z19USBstoreDataRoutinePKhi+0x54>
9d005a60:	91270000 	lbu	a3,0(t1)
	{
		rx_buffer->buffer[rx_buffer->head]	=	theChar;
		rx_buffer->head	=	bufIndex;
9d005a64:	ad430200 	sw	v1,512(t2)
    // we would overflow the buffer if we put our character there. This is because
    // if head = tail, the buffer is empty. If head = tail-1, then the buffer
    // is full. So only write into the buffer if we are not writing at the tail.
	if (bufIndex != rx_buffer->tail)
	{
		rx_buffer->buffer[rx_buffer->head]	=	theChar;
9d005a68:	a0c70000 	sb	a3,0(a2)
		rx_buffer->head	=	bufIndex;
9d005a6c:	00604021 	move	t0,v1
boolean	USBstoreDataRoutine(const byte *buffer, int length)
{
    int	i;

    // Put each byte into the serial recieve buffer
    for (i=0; i<length; i++)
9d005a70:	1445fff2 	bne	v0,a1,9d005a3c <_Z19USBstoreDataRoutinePKhi+0x20>
9d005a74:	25070001 	addiu	a3,t0,1
	{
        store_char(buffer[i], &rx_bufferUSB);
	}
    // If there isn't going to be enough space for a whole nother buffer, then return
    // false so USB will NAK and we won't get any more data.
    if (USBSerialBufferFree() < USB_SERIAL_MIN_BUFFER_FREE)
9d005a78:	256b01ff 	addiu	t3,t3,511
9d005a7c:	01684023 	subu	t0,t3,t0
9d005a80:	000817c3 	sra	v0,t0,0x1f
9d005a84:	000215c2 	srl	v0,v0,0x17
9d005a88:	01024021 	addu	t0,t0,v0
9d005a8c:	310801ff 	andi	t0,t0,0x1ff
9d005a90:	01021023 	subu	v0,t0,v0
    {
        return(false);
9d005a94:	28420080 	slti	v0,v0,128
    }
    else
    {
        return(true);
    }
}
9d005a98:	03e00008 	jr	ra
9d005a9c:	38420001 	xori	v0,v0,0x1
boolean	USBstoreDataRoutine(const byte *buffer, int length)
{
    int	i;

    // Put each byte into the serial recieve buffer
    for (i=0; i<length; i++)
9d005aa0:	24420d44 	addiu	v0,v0,3396
9d005aa4:	8c4b0204 	lw	t3,516(v0)
9d005aa8:	0b40169e 	j	9d005a78 <_Z19USBstoreDataRoutinePKhi+0x5c>
9d005aac:	8c480200 	lw	t0,512(v0)

9d005ab0 <_ZN9USBSerial9availableEv>:
}

//*******************************************************************************************
int USBSerial::available(void)
{
	return (RX_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) % RX_BUFFER_SIZE;
9d005ab0:	8c830004 	lw	v1,4(a0)
9d005ab4:	8c620200 	lw	v0,512(v1)
9d005ab8:	8c630204 	lw	v1,516(v1)
9d005abc:	24420200 	addiu	v0,v0,512
9d005ac0:	00431023 	subu	v0,v0,v1
9d005ac4:	00021fc3 	sra	v1,v0,0x1f
9d005ac8:	00031dc2 	srl	v1,v1,0x17
9d005acc:	00431021 	addu	v0,v0,v1
9d005ad0:	304201ff 	andi	v0,v0,0x1ff
}
9d005ad4:	03e00008 	jr	ra
9d005ad8:	00431023 	subu	v0,v0,v1

9d005adc <_ZN9USBSerial4peekEv>:

//*******************************************************************************************
int USBSerial::peek()
{
	if (_rx_buffer->head == _rx_buffer->tail)
9d005adc:	8c830004 	lw	v1,4(a0)
9d005ae0:	8c640204 	lw	a0,516(v1)
9d005ae4:	8c650200 	lw	a1,512(v1)
9d005ae8:	10a40003 	beq	a1,a0,9d005af8 <_ZN9USBSerial4peekEv+0x1c>
9d005aec:	2402ffff 	li	v0,-1
	{
		return -1;
	}
	else
	{
		return _rx_buffer->buffer[_rx_buffer->tail];
9d005af0:	00641821 	addu	v1,v1,a0
9d005af4:	90620000 	lbu	v0,0(v1)
	}
}
9d005af8:	03e00008 	jr	ra
9d005afc:	00000000 	nop

9d005b00 <_ZN9USBSerial5flushEv>:
	// don't reverse this or there may be problems if the RX interrupt
	// occurs after reading the value of rx_buffer_head but before writing
	// the value to rx_buffer_tail; the previous value of rx_buffer_head
	// may be written to rx_buffer_tail, making it appear as if the buffer
	// were full, not empty.
	_rx_buffer->head	=	_rx_buffer->tail;
9d005b00:	8c820004 	lw	v0,4(a0)
9d005b04:	8c430204 	lw	v1,516(v0)
}
9d005b08:	03e00008 	jr	ra
9d005b0c:	ac430200 	sw	v1,512(v0)

9d005b10 <_ZN9USBSerial5writeEPKc>:
	}
}

//*******************************************************************************************
void USBSerial::write(const char *str)
{
9d005b10:	27bdffe0 	addiu	sp,sp,-32
9d005b14:	afb00018 	sw	s0,24(sp)
9d005b18:	00808021 	move	s0,a0
size_t size;

	size	=	strlen(str);
9d005b1c:	00a02021 	move	a0,a1
	}
}

//*******************************************************************************************
void USBSerial::write(const char *str)
{
9d005b20:	afbf001c 	sw	ra,28(sp)
size_t size;

	size	=	strlen(str);
9d005b24:	0f401f18 	jal	9d007c60 <strlen>
9d005b28:	afa50010 	sw	a1,16(sp)
	write((const uint8_t *)str, size);
9d005b2c:	8e030000 	lw	v1,0(s0)
9d005b30:	8fa50010 	lw	a1,16(sp)
9d005b34:	02002021 	move	a0,s0
9d005b38:	8c790008 	lw	t9,8(v1)
}
9d005b3c:	8fbf001c 	lw	ra,28(sp)
9d005b40:	8fb00018 	lw	s0,24(sp)
void USBSerial::write(const char *str)
{
size_t size;

	size	=	strlen(str);
	write((const uint8_t *)str, size);
9d005b44:	00403021 	move	a2,v0
9d005b48:	03200008 	jr	t9
9d005b4c:	27bd0020 	addiu	sp,sp,32

9d005b50 <_ZN9USBSerial5writeEPKhm>:
//*	testing showed 63 gave better speed results than 64

#define	kMaxUSBxmitPkt	63
//*******************************************************************************************
void USBSerial::write(const uint8_t *buffer, size_t size)
{
9d005b50:	27bdff98 	addiu	sp,sp,-104

	if (size < kMaxUSBxmitPkt)
9d005b54:	2cc2003f 	sltiu	v0,a2,63
//*	testing showed 63 gave better speed results than 64

#define	kMaxUSBxmitPkt	63
//*******************************************************************************************
void USBSerial::write(const uint8_t *buffer, size_t size)
{
9d005b58:	afb20060 	sw	s2,96(sp)
9d005b5c:	afb1005c 	sw	s1,92(sp)
9d005b60:	afbf0064 	sw	ra,100(sp)
9d005b64:	afb00058 	sw	s0,88(sp)
9d005b68:	00c08821 	move	s1,a2

	if (size < kMaxUSBxmitPkt)
9d005b6c:	1440002a 	bnez	v0,9d005c18 <_ZN9USBSerial5writeEPKhm+0xc8>
9d005b70:	00a09021 	move	s2,a1
	size_t 			packetSize;
	
		packetSize	=	0;
		for (ii=0; ii<size; ii++)
		{
			usbBuffer[packetSize++]	=	buffer[ii];
9d005b74:	90a20000 	lbu	v0,0(a1)
9d005b78:	00008021 	move	s0,zero
9d005b7c:	24050001 	li	a1,1
9d005b80:	a3a20010 	sb	v0,16(sp)
	unsigned char	usbBuffer[kMaxUSBxmitPkt + 2];
	unsigned short	ii;
	size_t 			packetSize;
	
		packetSize	=	0;
		for (ii=0; ii<size; ii++)
9d005b84:	26100001 	addiu	s0,s0,1
9d005b88:	3210ffff 	andi	s0,s0,0xffff
		{
			usbBuffer[packetSize++]	=	buffer[ii];
9d005b8c:	27a20010 	addiu	v0,sp,16
9d005b90:	00451821 	addu	v1,v0,a1
	unsigned char	usbBuffer[kMaxUSBxmitPkt + 2];
	unsigned short	ii;
	size_t 			packetSize;
	
		packetSize	=	0;
		for (ii=0; ii<size; ii++)
9d005b94:	0211102b 	sltu	v0,s0,s1
9d005b98:	10400010 	beqz	v0,9d005bdc <_ZN9USBSerial5writeEPKhm+0x8c>
9d005b9c:	02502021 	addu	a0,s2,s0
		{
			usbBuffer[packetSize++]	=	buffer[ii];
9d005ba0:	90840000 	lbu	a0,0(a0)
9d005ba4:	24a50001 	addiu	a1,a1,1
			if (packetSize >= kMaxUSBxmitPkt)
9d005ba8:	2ca2003f 	sltiu	v0,a1,63
9d005bac:	1440fff5 	bnez	v0,9d005b84 <_ZN9USBSerial5writeEPKhm+0x34>
9d005bb0:	a0640000 	sb	a0,0(v1)
			{
				cdcacm_print(usbBuffer, packetSize);
9d005bb4:	27a40010 	addiu	a0,sp,16
9d005bb8:	0f401c2d 	jal	9d0070b4 <cdcacm_print>
9d005bbc:	26100001 	addiu	s0,s0,1
	unsigned char	usbBuffer[kMaxUSBxmitPkt + 2];
	unsigned short	ii;
	size_t 			packetSize;
	
		packetSize	=	0;
		for (ii=0; ii<size; ii++)
9d005bc0:	3210ffff 	andi	s0,s0,0xffff
		{
			usbBuffer[packetSize++]	=	buffer[ii];
9d005bc4:	27a20010 	addiu	v0,sp,16
			if (packetSize >= kMaxUSBxmitPkt)
			{
				cdcacm_print(usbBuffer, packetSize);
				packetSize	=	0;
9d005bc8:	00002821 	move	a1,zero
	size_t 			packetSize;
	
		packetSize	=	0;
		for (ii=0; ii<size; ii++)
		{
			usbBuffer[packetSize++]	=	buffer[ii];
9d005bcc:	00451821 	addu	v1,v0,a1
	unsigned char	usbBuffer[kMaxUSBxmitPkt + 2];
	unsigned short	ii;
	size_t 			packetSize;
	
		packetSize	=	0;
		for (ii=0; ii<size; ii++)
9d005bd0:	0211102b 	sltu	v0,s0,s1
9d005bd4:	1440fff2 	bnez	v0,9d005ba0 <_ZN9USBSerial5writeEPKhm+0x50>
9d005bd8:	02502021 	addu	a0,s2,s0
			{
				cdcacm_print(usbBuffer, packetSize);
				packetSize	=	0;
			}
		}
		if (packetSize > 0)
9d005bdc:	14a00006 	bnez	a1,9d005bf8 <_ZN9USBSerial5writeEPKhm+0xa8>
9d005be0:	8fbf0064 	lw	ra,100(sp)
		{
			cdcacm_print(usbBuffer, packetSize);
		}
	}
}
9d005be4:	8fb20060 	lw	s2,96(sp)
9d005be8:	8fb1005c 	lw	s1,92(sp)
9d005bec:	8fb00058 	lw	s0,88(sp)
9d005bf0:	03e00008 	jr	ra
9d005bf4:	27bd0068 	addiu	sp,sp,104
				packetSize	=	0;
			}
		}
		if (packetSize > 0)
		{
			cdcacm_print(usbBuffer, packetSize);
9d005bf8:	0f401c2d 	jal	9d0070b4 <cdcacm_print>
9d005bfc:	27a40010 	addiu	a0,sp,16
		}
	}
}
9d005c00:	8fbf0064 	lw	ra,100(sp)
9d005c04:	8fb20060 	lw	s2,96(sp)
9d005c08:	8fb1005c 	lw	s1,92(sp)
9d005c0c:	8fb00058 	lw	s0,88(sp)
9d005c10:	03e00008 	jr	ra
9d005c14:	27bd0068 	addiu	sp,sp,104
{

	if (size < kMaxUSBxmitPkt)
	{
		//*	it will fit in one transmit packet
		cdcacm_print(buffer, size);
9d005c18:	00a02021 	move	a0,a1
9d005c1c:	0f401c2d 	jal	9d0070b4 <cdcacm_print>
9d005c20:	00c02821 	move	a1,a2
		if (packetSize > 0)
		{
			cdcacm_print(usbBuffer, packetSize);
		}
	}
}
9d005c24:	8fbf0064 	lw	ra,100(sp)
9d005c28:	8fb20060 	lw	s2,96(sp)
9d005c2c:	8fb1005c 	lw	s1,92(sp)
9d005c30:	8fb00058 	lw	s0,88(sp)
9d005c34:	03e00008 	jr	ra
9d005c38:	27bd0068 	addiu	sp,sp,104

9d005c3c <_ZN9USBSerial5writeEh>:
	_rx_buffer->head	=	_rx_buffer->tail;
}

//*******************************************************************************************
void USBSerial::write(uint8_t theChar)
{
9d005c3c:	27bdffe0 	addiu	sp,sp,-32
unsigned char	usbBuf[4];

	usbBuf[0]	=	theChar;
9d005c40:	a3a50010 	sb	a1,16(sp)
	
	cdcacm_print(usbBuf, 1);
9d005c44:	27a40010 	addiu	a0,sp,16
	_rx_buffer->head	=	_rx_buffer->tail;
}

//*******************************************************************************************
void USBSerial::write(uint8_t theChar)
{
9d005c48:	afbf001c 	sw	ra,28(sp)
unsigned char	usbBuf[4];

	usbBuf[0]	=	theChar;
	
	cdcacm_print(usbBuf, 1);
9d005c4c:	0f401c2d 	jal	9d0070b4 <cdcacm_print>
9d005c50:	24050001 	li	a1,1
}
9d005c54:	8fbf001c 	lw	ra,28(sp)
9d005c58:	03e00008 	jr	ra
9d005c5c:	27bd0020 	addiu	sp,sp,32

9d005c60 <_ZN9USBSerial4readEv>:
int USBSerial::read(void)
{
	unsigned char theChar;

	// If the head = tail, then the buffer is empty, so nothing to read
	if (_rx_buffer->head == _rx_buffer->tail)
9d005c60:	8c830004 	lw	v1,4(a0)
	}
}

//*******************************************************************************************
int USBSerial::read(void)
{
9d005c64:	27bdffe0 	addiu	sp,sp,-32
9d005c68:	afbf001c 	sw	ra,28(sp)
	unsigned char theChar;

	// If the head = tail, then the buffer is empty, so nothing to read
	if (_rx_buffer->head == _rx_buffer->tail)
9d005c6c:	8c640204 	lw	a0,516(v1)
9d005c70:	8c650200 	lw	a1,512(v1)
9d005c74:	10a40017 	beq	a1,a0,9d005cd4 <_ZN9USBSerial4readEv+0x74>
9d005c78:	2402ffff 	li	v0,-1
		return -1;
	}
	else
	{
		theChar				=	_rx_buffer->buffer[_rx_buffer->tail];
		_rx_buffer->tail	=	(_rx_buffer->tail + 1) % RX_BUFFER_SIZE;
9d005c7c:	24850001 	addiu	a1,a0,1
9d005c80:	000517c3 	sra	v0,a1,0x1f
9d005c84:	000215c2 	srl	v0,v0,0x17
9d005c88:	00a22821 	addu	a1,a1,v0
9d005c8c:	30a501ff 	andi	a1,a1,0x1ff
9d005c90:	00a22823 	subu	a1,a1,v0
        
        // If we just made enough room for the next packet to fit into our buffer,
        // start the packets flowing from the PC again
        if (USBSerialBufferFree() >= USB_SERIAL_MIN_BUFFER_FREE)
9d005c94:	3c02a000 	lui	v0,0xa000
9d005c98:	24420d44 	addiu	v0,v0,3396
		return -1;
	}
	else
	{
		theChar				=	_rx_buffer->buffer[_rx_buffer->tail];
		_rx_buffer->tail	=	(_rx_buffer->tail + 1) % RX_BUFFER_SIZE;
9d005c9c:	ac650204 	sw	a1,516(v1)
        
        // If we just made enough room for the next packet to fit into our buffer,
        // start the packets flowing from the PC again
        if (USBSerialBufferFree() >= USB_SERIAL_MIN_BUFFER_FREE)
9d005ca0:	8c450204 	lw	a1,516(v0)
9d005ca4:	8c420200 	lw	v0,512(v0)
	{
		return -1;
	}
	else
	{
		theChar				=	_rx_buffer->buffer[_rx_buffer->tail];
9d005ca8:	00641821 	addu	v1,v1,a0
		_rx_buffer->tail	=	(_rx_buffer->tail + 1) % RX_BUFFER_SIZE;
        
        // If we just made enough room for the next packet to fit into our buffer,
        // start the packets flowing from the PC again
        if (USBSerialBufferFree() >= USB_SERIAL_MIN_BUFFER_FREE)
9d005cac:	24a501ff 	addiu	a1,a1,511
9d005cb0:	00a22823 	subu	a1,a1,v0
9d005cb4:	000517c3 	sra	v0,a1,0x1f
9d005cb8:	000215c2 	srl	v0,v0,0x17
9d005cbc:	00a22821 	addu	a1,a1,v0
9d005cc0:	30a501ff 	andi	a1,a1,0x1ff
9d005cc4:	00a22823 	subu	a1,a1,v0
9d005cc8:	28a50080 	slti	a1,a1,128
9d005ccc:	10a00004 	beqz	a1,9d005ce0 <_ZN9USBSerial4readEv+0x80>
9d005cd0:	90620000 	lbu	v0,0(v1)
            cdcacm_command_ack();
        }
        
		return (theChar);
	}
}
9d005cd4:	8fbf001c 	lw	ra,28(sp)
9d005cd8:	03e00008 	jr	ra
9d005cdc:	27bd0020 	addiu	sp,sp,32
        
        // If we just made enough room for the next packet to fit into our buffer,
        // start the packets flowing from the PC again
        if (USBSerialBufferFree() >= USB_SERIAL_MIN_BUFFER_FREE)
        {
            cdcacm_command_ack();
9d005ce0:	0f401cd3 	jal	9d00734c <cdcacm_command_ack>
9d005ce4:	afa20010 	sw	v0,16(sp)
        }
        
		return (theChar);
	}
}
9d005ce8:	8fbf001c 	lw	ra,28(sp)
        
        // If we just made enough room for the next packet to fit into our buffer,
        // start the packets flowing from the PC again
        if (USBSerialBufferFree() >= USB_SERIAL_MIN_BUFFER_FREE)
        {
            cdcacm_command_ack();
9d005cec:	8fa20010 	lw	v0,16(sp)
        }
        
		return (theChar);
	}
}
9d005cf0:	03e00008 	jr	ra
9d005cf4:	27bd0020 	addiu	sp,sp,32

9d005cf8 <_ZN14HardwareSerial11doSerialIntEv>:
	uint8_t	ch;

	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
9d005cf8:	8c820010 	lw	v0,16(a0)
9d005cfc:	8c83001c 	lw	v1,28(a0)
9d005d00:	8c450000 	lw	a1,0(v0)
9d005d04:	00652824 	and	a1,v1,a1
9d005d08:	10a00010 	beqz	a1,9d005d4c <_ZN14HardwareSerial11doSerialIntEv+0x54>
9d005d0c:	00000000 	nop
	{
		ch = uart->uxRx.reg;
		bufIndex	= (rx_buffer.head + 1) % RX_BUFFER_SIZE;
9d005d10:	8c870224 	lw	a3,548(a0)
	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
9d005d14:	8c890004 	lw	t1,4(a0)
		/* If we should be storing the received character into the location
		** just before the tail (meaning that the head would advance to the
		** current location of the tail), we're about to overflow the buffer
		** and so we don't write the character or advance the head.
		*/
		if (bufIndex != rx_buffer.tail)
9d005d18:	8c880228 	lw	t0,552(a0)
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
		bufIndex	= (rx_buffer.head + 1) % RX_BUFFER_SIZE;
9d005d1c:	24e60001 	addiu	a2,a3,1
9d005d20:	00062fc3 	sra	a1,a2,0x1f
9d005d24:	00052dc2 	srl	a1,a1,0x17
9d005d28:	00c53021 	addu	a2,a2,a1
9d005d2c:	30c601ff 	andi	a2,a2,0x1ff
9d005d30:	00c52823 	subu	a1,a2,a1
	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
9d005d34:	8d260030 	lw	a2,48(t1)
		/* If we should be storing the received character into the location
		** just before the tail (meaning that the head would advance to the
		** current location of the tail), we're about to overflow the buffer
		** and so we don't write the character or advance the head.
		*/
		if (bufIndex != rx_buffer.tail)
9d005d38:	11050003 	beq	t0,a1,9d005d48 <_ZN14HardwareSerial11doSerialIntEv+0x50>
9d005d3c:	00873821 	addu	a3,a0,a3
	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
9d005d40:	a0e60024 	sb	a2,36(a3)
		** and so we don't write the character or advance the head.
		*/
		if (bufIndex != rx_buffer.tail)
		{
			rx_buffer.buffer[rx_buffer.head] = ch;
			rx_buffer.head = bufIndex;
9d005d44:	ac850224 	sw	a1,548(a0)
		}

		/* Clear the interrupt flag.
		*/
		ifs->clr = bit_rx;
9d005d48:	ac430004 	sw	v1,4(v0)
	}

	/* If it's a transmit interrupt, ignore it, as we don't current
	** have interrupt driven i/o on the transmit side.
	*/
	if ((ifs->reg & bit_tx) != 0)
9d005d4c:	8c450000 	lw	a1,0(v0)
9d005d50:	8c830020 	lw	v1,32(a0)
9d005d54:	00652024 	and	a0,v1,a1
9d005d58:	54800001 	bnezl	a0,9d005d60 <_ZN14HardwareSerial11doSerialIntEv+0x68>
9d005d5c:	ac430004 	sw	v1,4(v0)
9d005d60:	03e00008 	jr	ra
9d005d64:	00000000 	nop

9d005d68 <IntSer1Handler>:
**		serial port 1.
*/
#if defined(_SER1_VECTOR)

void __attribute__((interrupt(), nomips16)) IntSer1Handler(void)
{
9d005d68:	415de800 	rdpgpr	sp,sp
9d005d6c:	401b7000 	mfc0	k1,c0_epc
9d005d70:	401a6002 	mfc0	k0,c0_srsctl
9d005d74:	27bdff90 	addiu	sp,sp,-112
9d005d78:	afbb006c 	sw	k1,108(sp)
9d005d7c:	401b6000 	mfc0	k1,c0_status
9d005d80:	afba0068 	sw	k0,104(sp)
9d005d84:	401a6800 	mfc0	k0,c0_cause
9d005d88:	001ad282 	srl	k0,k0,0xa
9d005d8c:	afbb0064 	sw	k1,100(sp)
9d005d90:	7f5b7a84 	ins	k1,k0,0xa,0x6
9d005d94:	7c1b2044 	ins	k1,zero,0x1,0x4
9d005d98:	409b6000 	mtc0	k1,c0_status
9d005d9c:	afa30018 	sw	v1,24(sp)
9d005da0:	8fa30068 	lw	v1,104(sp)
9d005da4:	3063000f 	andi	v1,v1,0xf
9d005da8:	14600011 	bnez	v1,9d005df0 <IntSer1Handler+0x88>
9d005dac:	afa20014 	sw	v0,20(sp)
9d005db0:	afbf0054 	sw	ra,84(sp)
9d005db4:	afb90050 	sw	t9,80(sp)
9d005db8:	afb8004c 	sw	t8,76(sp)
9d005dbc:	afaf0048 	sw	t7,72(sp)
9d005dc0:	afae0044 	sw	t6,68(sp)
9d005dc4:	afad0040 	sw	t5,64(sp)
9d005dc8:	afac003c 	sw	t4,60(sp)
9d005dcc:	afab0038 	sw	t3,56(sp)
9d005dd0:	afaa0034 	sw	t2,52(sp)
9d005dd4:	afa90030 	sw	t1,48(sp)
9d005dd8:	afa8002c 	sw	t0,44(sp)
9d005ddc:	afa70028 	sw	a3,40(sp)
9d005de0:	afa60024 	sw	a2,36(sp)
9d005de4:	afa50020 	sw	a1,32(sp)
9d005de8:	afa4001c 	sw	a0,28(sp)
9d005dec:	afa10010 	sw	at,16(sp)
	Serial1.doSerialInt();
9d005df0:	3c04a000 	lui	a0,0xa000
**		serial port 1.
*/
#if defined(_SER1_VECTOR)

void __attribute__((interrupt(), nomips16)) IntSer1Handler(void)
{
9d005df4:	00001012 	mflo	v0
	Serial1.doSerialInt();
9d005df8:	24841178 	addiu	a0,a0,4472
**		serial port 1.
*/
#if defined(_SER1_VECTOR)

void __attribute__((interrupt(), nomips16)) IntSer1Handler(void)
{
9d005dfc:	afa2005c 	sw	v0,92(sp)
9d005e00:	00001810 	mfhi	v1
	Serial1.doSerialInt();
9d005e04:	0f40173e 	jal	9d005cf8 <_ZN14HardwareSerial11doSerialIntEv>
9d005e08:	afa30058 	sw	v1,88(sp)
}
9d005e0c:	8fa2005c 	lw	v0,92(sp)
9d005e10:	8fa30058 	lw	v1,88(sp)
9d005e14:	00400013 	mtlo	v0
9d005e18:	8fa20068 	lw	v0,104(sp)
9d005e1c:	3042000f 	andi	v0,v0,0xf
9d005e20:	14400013 	bnez	v0,9d005e70 <IntSer1Handler+0x108>
9d005e24:	00600011 	mthi	v1
9d005e28:	8fbf0054 	lw	ra,84(sp)
9d005e2c:	8fb90050 	lw	t9,80(sp)
9d005e30:	8fb8004c 	lw	t8,76(sp)
9d005e34:	8faf0048 	lw	t7,72(sp)
9d005e38:	8fae0044 	lw	t6,68(sp)
9d005e3c:	8fad0040 	lw	t5,64(sp)
9d005e40:	8fac003c 	lw	t4,60(sp)
9d005e44:	8fab0038 	lw	t3,56(sp)
9d005e48:	8faa0034 	lw	t2,52(sp)
9d005e4c:	8fa90030 	lw	t1,48(sp)
9d005e50:	8fa8002c 	lw	t0,44(sp)
9d005e54:	8fa70028 	lw	a3,40(sp)
9d005e58:	8fa60024 	lw	a2,36(sp)
9d005e5c:	8fa50020 	lw	a1,32(sp)
9d005e60:	8fa4001c 	lw	a0,28(sp)
9d005e64:	8fa30018 	lw	v1,24(sp)
9d005e68:	8fa20014 	lw	v0,20(sp)
9d005e6c:	8fa10010 	lw	at,16(sp)
9d005e70:	41606000 	di
9d005e74:	000000c0 	ehb
9d005e78:	8fba006c 	lw	k0,108(sp)
9d005e7c:	8fbb0064 	lw	k1,100(sp)
9d005e80:	409a7000 	mtc0	k0,c0_epc
9d005e84:	8fba0068 	lw	k0,104(sp)
9d005e88:	27bd0070 	addiu	sp,sp,112
9d005e8c:	409a6002 	mtc0	k0,c0_srsctl
9d005e90:	41dde800 	wrpgpr	sp,sp
9d005e94:	409b6000 	mtc0	k1,c0_status
9d005e98:	42000018 	eret

9d005e9c <IntSer0Handler>:
**		serial port 0.
*/
#if defined(_SER0_VECTOR)

void __attribute__((interrupt(), nomips16)) IntSer0Handler(void)
{
9d005e9c:	415de800 	rdpgpr	sp,sp
9d005ea0:	401b7000 	mfc0	k1,c0_epc
9d005ea4:	401a6002 	mfc0	k0,c0_srsctl
9d005ea8:	27bdff90 	addiu	sp,sp,-112
9d005eac:	afbb006c 	sw	k1,108(sp)
9d005eb0:	401b6000 	mfc0	k1,c0_status
9d005eb4:	afba0068 	sw	k0,104(sp)
9d005eb8:	401a6800 	mfc0	k0,c0_cause
9d005ebc:	001ad282 	srl	k0,k0,0xa
9d005ec0:	afbb0064 	sw	k1,100(sp)
9d005ec4:	7f5b7a84 	ins	k1,k0,0xa,0x6
9d005ec8:	7c1b2044 	ins	k1,zero,0x1,0x4
9d005ecc:	409b6000 	mtc0	k1,c0_status
9d005ed0:	afa30018 	sw	v1,24(sp)
9d005ed4:	8fa30068 	lw	v1,104(sp)
9d005ed8:	3063000f 	andi	v1,v1,0xf
9d005edc:	14600011 	bnez	v1,9d005f24 <IntSer0Handler+0x88>
9d005ee0:	afa20014 	sw	v0,20(sp)
9d005ee4:	afbf0054 	sw	ra,84(sp)
9d005ee8:	afb90050 	sw	t9,80(sp)
9d005eec:	afb8004c 	sw	t8,76(sp)
9d005ef0:	afaf0048 	sw	t7,72(sp)
9d005ef4:	afae0044 	sw	t6,68(sp)
9d005ef8:	afad0040 	sw	t5,64(sp)
9d005efc:	afac003c 	sw	t4,60(sp)
9d005f00:	afab0038 	sw	t3,56(sp)
9d005f04:	afaa0034 	sw	t2,52(sp)
9d005f08:	afa90030 	sw	t1,48(sp)
9d005f0c:	afa8002c 	sw	t0,44(sp)
9d005f10:	afa70028 	sw	a3,40(sp)
9d005f14:	afa60024 	sw	a2,36(sp)
9d005f18:	afa50020 	sw	a1,32(sp)
9d005f1c:	afa4001c 	sw	a0,28(sp)
9d005f20:	afa10010 	sw	at,16(sp)
#if defined(_USB) && defined(_USE_USB_FOR_SERIAL_)
	Serial0.doSerialInt();
9d005f24:	3c04a000 	lui	a0,0xa000
**		serial port 0.
*/
#if defined(_SER0_VECTOR)

void __attribute__((interrupt(), nomips16)) IntSer0Handler(void)
{
9d005f28:	00001012 	mflo	v0
#if defined(_USB) && defined(_USE_USB_FOR_SERIAL_)
	Serial0.doSerialInt();
9d005f2c:	24840f4c 	addiu	a0,a0,3916
**		serial port 0.
*/
#if defined(_SER0_VECTOR)

void __attribute__((interrupt(), nomips16)) IntSer0Handler(void)
{
9d005f30:	afa2005c 	sw	v0,92(sp)
9d005f34:	00001810 	mfhi	v1
#if defined(_USB) && defined(_USE_USB_FOR_SERIAL_)
	Serial0.doSerialInt();
9d005f38:	0f40173e 	jal	9d005cf8 <_ZN14HardwareSerial11doSerialIntEv>
9d005f3c:	afa30058 	sw	v1,88(sp)
#else
	Serial.doSerialInt();
#endif
}
9d005f40:	8fa2005c 	lw	v0,92(sp)
9d005f44:	8fa30058 	lw	v1,88(sp)
9d005f48:	00400013 	mtlo	v0
9d005f4c:	8fa20068 	lw	v0,104(sp)
9d005f50:	3042000f 	andi	v0,v0,0xf
9d005f54:	14400013 	bnez	v0,9d005fa4 <IntSer0Handler+0x108>
9d005f58:	00600011 	mthi	v1
9d005f5c:	8fbf0054 	lw	ra,84(sp)
9d005f60:	8fb90050 	lw	t9,80(sp)
9d005f64:	8fb8004c 	lw	t8,76(sp)
9d005f68:	8faf0048 	lw	t7,72(sp)
9d005f6c:	8fae0044 	lw	t6,68(sp)
9d005f70:	8fad0040 	lw	t5,64(sp)
9d005f74:	8fac003c 	lw	t4,60(sp)
9d005f78:	8fab0038 	lw	t3,56(sp)
9d005f7c:	8faa0034 	lw	t2,52(sp)
9d005f80:	8fa90030 	lw	t1,48(sp)
9d005f84:	8fa8002c 	lw	t0,44(sp)
9d005f88:	8fa70028 	lw	a3,40(sp)
9d005f8c:	8fa60024 	lw	a2,36(sp)
9d005f90:	8fa50020 	lw	a1,32(sp)
9d005f94:	8fa4001c 	lw	a0,28(sp)
9d005f98:	8fa30018 	lw	v1,24(sp)
9d005f9c:	8fa20014 	lw	v0,20(sp)
9d005fa0:	8fa10010 	lw	at,16(sp)
9d005fa4:	41606000 	di
9d005fa8:	000000c0 	ehb
9d005fac:	8fba006c 	lw	k0,108(sp)
9d005fb0:	8fbb0064 	lw	k1,100(sp)
9d005fb4:	409a7000 	mtc0	k0,c0_epc
9d005fb8:	8fba0068 	lw	k0,104(sp)
9d005fbc:	27bd0070 	addiu	sp,sp,112
9d005fc0:	409a6002 	mtc0	k0,c0_srsctl
9d005fc4:	41dde800 	wrpgpr	sp,sp
9d005fc8:	409b6000 	mtc0	k1,c0_status
9d005fcc:	42000018 	eret

9d005fd0 <_ZN9USBSerialcviEv>:
	_rx_buffer->head	=	0;
	_rx_buffer->tail	=	0;
}

USBSerial::operator int() {
    return gConnected ? 1 : 0;
9d005fd0:	9382809c 	lbu	v0,-32612(gp)
}
9d005fd4:	03e00008 	jr	ra
9d005fd8:	0002102b 	sltu	v0,zero,v0

9d005fdc <_ZN9USBSerial5beginEm>:
#endif


//*******************************************************************************************
void USBSerial::begin(unsigned long baudRate)
{
9d005fdc:	27bdffe8 	addiu	sp,sp,-24
9d005fe0:	afbf0014 	sw	ra,20(sp)
	DebugViaSerial0("USBSerial::begin");

	DebugViaSerial0("calling usb_initialize");
	usb_initialize();
9d005fe4:	0f401ac1 	jal	9d006b04 <usb_initialize>
9d005fe8:	00000000 	nop
	DebugViaSerial0("returned from usb_initialize");

	cdcacm_register(USBresetRoutine, USBstoreDataRoutine);
9d005fec:	3c049d00 	lui	a0,0x9d00
9d005ff0:	3c059d00 	lui	a1,0x9d00

	// Must enable glocal interrupts - in this case, we are using multi-vector mode
	//INTEnableSystemMultiVectoredInt();
	DebugViaSerial0("INTEnableSystemMultiVectoredInt");

}
9d005ff4:	8fbf0014 	lw	ra,20(sp)

	DebugViaSerial0("calling usb_initialize");
	usb_initialize();
	DebugViaSerial0("returned from usb_initialize");

	cdcacm_register(USBresetRoutine, USBstoreDataRoutine);
9d005ff8:	24845a14 	addiu	a0,a0,23060
9d005ffc:	24a55a1c 	addiu	a1,a1,23068
9d006000:	0b401ce7 	j	9d00739c <cdcacm_register>
9d006004:	27bd0018 	addiu	sp,sp,24

9d006008 <_GLOBAL__I__ZN14HardwareSerialC2EP8p32_uartiiiiPFvvE>:


//*******************************************************************************************
USBSerial::USBSerial(ring_buffer	*rx_buffer)
{
	_rx_buffer			=	rx_buffer;
9d006008:	3c04a000 	lui	a0,0xa000
9d00600c:	24840d44 	addiu	a0,a0,3396
*/

#if defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
9d006010:	3c0aa000 	lui	t2,0xa000
#endif
{
	uart = uartT;
9d006014:	25430f4c 	addiu	v1,t2,3916


//*******************************************************************************************
USBSerial::USBSerial(ring_buffer	*rx_buffer)
{
	_rx_buffer			=	rx_buffer;
9d006018:	af848064 	sw	a0,-32668(gp)
	_rx_buffer->head	=	0;
9d00601c:	ac800200 	sw	zero,512(a0)
	_rx_buffer->tail	=	0;
9d006020:	ac800204 	sw	zero,516(a0)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
#endif
{
	uart = uartT;
	irq  = irqT;
9d006024:	2404001a 	li	a0,26
9d006028:	a064000c 	sb	a0,12(v1)
	vec  = vecT;
9d00602c:	24040018 	li	a0,24
9d006030:	a064000d 	sb	a0,13(v1)
	irq  = (uint8_t)irqT;
	vec  = (uint8_t)vecT;
	ipl  = (uint8_t)iplT;
	spl  = (uint8_t)splT;
    isr  = isrHandler;
9d006034:	3c049d00 	lui	a0,0x9d00
9d006038:	24845e9c 	addiu	a0,a0,24220
9d00603c:	ac640008 	sw	a0,8(v1)
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
9d006040:	3c040400 	lui	a0,0x400
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
#endif
{
	uart = uartT;
9d006044:	3c0bbf80 	lui	t3,0xbf80
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
9d006048:	ac640018 	sw	a0,24(v1)
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d00604c:	3c09bf88 	lui	t1,0xbf88
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d006050:	3c040800 	lui	a0,0x800
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d006054:	3c08bf88 	lui	t0,0xbf88
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d006058:	25291030 	addiu	t1,t1,4144
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d00605c:	25081060 	addiu	t0,t0,4192
*/

#if defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
9d006060:	3c06a000 	lui	a2,0xa000
	uart = uartT;
	irq  = irqT;
	vec  = vecT;
	irq  = (uint8_t)irqT;
	vec  = (uint8_t)vecT;
	ipl  = (uint8_t)iplT;
9d006064:	24050002 	li	a1,2
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
#endif
{
	uart = uartT;
9d006068:	256e6000 	addiu	t6,t3,24576
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d00606c:	ac64001c 	sw	a0,28(v1)
	bit_tx  = 1 << ((irq+2) % 32);	//tx interrupt flag/enable bit
9d006070:	3c041000 	lui	a0,0x1000
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
#endif
{
	uart = uartT;
9d006074:	24c21178 	addiu	v0,a2,4472
9d006078:	ac6e0004 	sw	t6,4(v1)
	irq  = irqT;
	vec  = vecT;
	irq  = (uint8_t)irqT;
	vec  = (uint8_t)vecT;
	ipl  = (uint8_t)iplT;
9d00607c:	a065000e 	sb	a1,14(v1)
	spl  = (uint8_t)splT;
9d006080:	a060000f 	sb	zero,15(v1)
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d006084:	ac690010 	sw	t1,16(v1)
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d006088:	ac680014 	sw	t0,20(v1)

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
	bit_tx  = 1 << ((irq+2) % 32);	//tx interrupt flag/enable bit
9d00608c:	ac640020 	sw	a0,32(v1)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
#endif
{
	uart = uartT;
	irq  = irqT;
9d006090:	24030028 	li	v1,40
9d006094:	a043000c 	sb	v1,12(v0)
	vec  = vecT;
9d006098:	24030020 	li	v1,32
9d00609c:	a043000d 	sb	v1,13(v0)
	irq  = (uint8_t)irqT;
	vec  = (uint8_t)vecT;
	ipl  = (uint8_t)iplT;
	spl  = (uint8_t)splT;
    isr  = isrHandler;
9d0060a0:	3c039d00 	lui	v1,0x9d00
9d0060a4:	24635d68 	addiu	v1,v1,23912
9d0060a8:	ac430008 	sw	v1,8(v0)
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
9d0060ac:	24030100 	li	v1,256
*/

#if defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
9d0060b0:	3c079d01 	lui	a3,0x9d01
    }
}


//*******************************************************************************************
USBSerial::USBSerial(ring_buffer	*rx_buffer)
9d0060b4:	3c0f9d01 	lui	t7,0x9d01
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
9d0060b8:	ac430018 	sw	v1,24(v0)
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d0060bc:	24030200 	li	v1,512
*/

#if defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
9d0060c0:	24e78990 	addiu	a3,a3,-30320
#endif
{
	uart = uartT;
9d0060c4:	256b6800 	addiu	t3,t3,26624
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d0060c8:	252d0010 	addiu	t5,t1,16
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d0060cc:	250c0010 	addiu	t4,t0,16
    }
}


//*******************************************************************************************
USBSerial::USBSerial(ring_buffer	*rx_buffer)
9d0060d0:	25ef8968 	addiu	t7,t7,-30360
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d0060d4:	ac43001c 	sw	v1,28(v0)
	bit_tx  = 1 << ((irq+2) % 32);	//tx interrupt flag/enable bit
9d0060d8:	24030400 	li	v1,1024
    }
}


//*******************************************************************************************
USBSerial::USBSerial(ring_buffer	*rx_buffer)
9d0060dc:	af8f8060 	sw	t7,-32672(gp)
*/

#if defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler, int pinT, int pinR, ppsFunctionType ppsT, ppsFunctionType ppsR)
#else
HardwareSerial::HardwareSerial(p32_uart * uartT, int irqT, int vecT, int iplT, int splT, isrFunc isrHandler)
9d0060e0:	ad470f4c 	sw	a3,3916(t2)
9d0060e4:	acc71178 	sw	a3,4472(a2)
#endif
{
	uart = uartT;
9d0060e8:	ac4b0004 	sw	t3,4(v0)
	irq  = irqT;
	vec  = vecT;
	irq  = (uint8_t)irqT;
	vec  = (uint8_t)vecT;
	ipl  = (uint8_t)iplT;
9d0060ec:	a045000e 	sb	a1,14(v0)
	spl  = (uint8_t)splT;
9d0060f0:	a040000f 	sb	zero,15(v0)
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d0060f4:	ac4d0010 	sw	t5,16(v0)
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d0060f8:	ac4c0014 	sw	t4,20(v0)

extern "C" {
    void __attribute__((weak,used)) _mon_putc(char c) {
        Serial.write(c);
    }
}
9d0060fc:	03e00008 	jr	ra
9d006100:	ac430020 	sw	v1,32(v0)

9d006104 <usb_device_enqueue>:

//************************************************************************
// enqueue a packet to the usb engine for transfer to/from the host
//************************************************************************
void	usb_device_enqueue(int endpoint, boolean tx, byte *buffer, int length)
{
9d006104:	30a500ff 	andi	a1,a1,0xff
	int			flags;
	struct bdt	*bdt;

	assert(endpoint < LENGTHOF(endpoints));

	if (tx != (boolean)-1)
9d006108:	240200ff 	li	v0,255
9d00610c:	10a2001d 	beq	a1,v0,9d006184 <usb_device_enqueue+0x80>
9d006110:	00041140 	sll	v0,a0,0x5
	{
		// transfer up to one packet at a time
		assert(endpoints[endpoint].packetsize);
		length	=	MIN(length, endpoints[endpoint].packetsize);
9d006114:	000441c0 	sll	t0,a0,0x7
9d006118:	01024023 	subu	t0,t0,v0
9d00611c:	3c02a000 	lui	v0,0xa000

		// find the next bdt entry to use
		odd	=	endpoints[endpoint].bdtodd[tx];
9d006120:	01051821 	addu	v1,t0,a1

	if (tx != (boolean)-1)
	{
		// transfer up to one packet at a time
		assert(endpoints[endpoint].packetsize);
		length	=	MIN(length, endpoints[endpoint].packetsize);
9d006124:	24421790 	addiu	v0,v0,6032

		// find the next bdt entry to use
		odd	=	endpoints[endpoint].bdtodd[tx];
9d006128:	00621821 	addu	v1,v1,v0

		// initialize the bdt entry
		bdt	=	MYBDT(endpoint, tx, odd);
9d00612c:	90690002 	lbu	t1,2(v1)
9d006130:	00045040 	sll	t2,a0,0x1
9d006134:	00aa2821 	addu	a1,a1,t2

	if (tx != (boolean)-1)
	{
		// transfer up to one packet at a time
		assert(endpoints[endpoint].packetsize);
		length	=	MIN(length, endpoints[endpoint].packetsize);
9d006138:	01021021 	addu	v0,t0,v0

		// find the next bdt entry to use
		odd	=	endpoints[endpoint].bdtodd[tx];

		// initialize the bdt entry
		bdt	=	MYBDT(endpoint, tx, odd);
9d00613c:	00052840 	sll	a1,a1,0x1
9d006140:	8f888068 	lw	t0,-32664(gp)
9d006144:	01252821 	addu	a1,t1,a1
9d006148:	000528c0 	sll	a1,a1,0x3

	if (tx != (boolean)-1)
	{
		// transfer up to one packet at a time
		assert(endpoints[endpoint].packetsize);
		length	=	MIN(length, endpoints[endpoint].packetsize);
9d00614c:	90420004 	lbu	v0,4(v0)

		// find the next bdt entry to use
		odd	=	endpoints[endpoint].bdtodd[tx];

		// initialize the bdt entry
		bdt	=	MYBDT(endpoint, tx, odd);
9d006150:	01052821 	addu	a1,t0,a1
		bdt->buffer	=	(byte *)TF_LITTLE(KVA_TO_PA((int)buffer));
9d006154:	7cc6e000 	ext	a2,a2,0x0,0x1d
9d006158:	a8a60007 	swl	a2,7(a1)
9d00615c:	b8a60004 	swr	a2,4(a1)
		flags	=	TF_LITTLE(bdt->flags);
		assert(! (flags & BD_FLAGS_OWN));
		assert(length <= endpoints[endpoint].packetsize);
		bdt->flags	=	TF_LITTLE(BD_FLAGS_BC_ENC(length)|BD_FLAGS_OWN|endpoints[endpoint].toggle[tx]|BD_FLAGS_DTS);
9d006160:	90630000 	lbu	v1,0(v1)

	if (tx != (boolean)-1)
	{
		// transfer up to one packet at a time
		assert(endpoints[endpoint].packetsize);
		length	=	MIN(length, endpoints[endpoint].packetsize);
9d006164:	0047302a 	slt	a2,v0,a3
9d006168:	00e6100a 	movz	v0,a3,a2
		bdt	=	MYBDT(endpoint, tx, odd);
		bdt->buffer	=	(byte *)TF_LITTLE(KVA_TO_PA((int)buffer));
		flags	=	TF_LITTLE(bdt->flags);
		assert(! (flags & BD_FLAGS_OWN));
		assert(length <= endpoints[endpoint].packetsize);
		bdt->flags	=	TF_LITTLE(BD_FLAGS_BC_ENC(length)|BD_FLAGS_OWN|endpoints[endpoint].toggle[tx]|BD_FLAGS_DTS);
9d00616c:	304203ff 	andi	v0,v0,0x3ff
9d006170:	34670088 	ori	a3,v1,0x88
9d006174:	00021400 	sll	v0,v0,0x10
9d006178:	00e23825 	or	a3,a3,v0
9d00617c:	a8a70003 	swl	a3,3(a1)
9d006180:	b8a70000 	swr	a3,0(a1)
	}

	ep	=	MCF_USB_OTG_ENDPT_EP_HSHK|MCF_USB_OTG_ENDPT_EP_TX_EN|MCF_USB_OTG_ENDPT_EP_RX_EN;
	ep |= endpoint?MCF_USB_OTG_ENDPT_EP_CTL_DIS:0;
9d006184:	14800004 	bnez	a0,9d006198 <usb_device_enqueue+0x94>
9d006188:	2402000d 	li	v0,13
	// enable the packet transfer
	switch (endpoint)
	{
		case 0:
			U1EP0	=	(uint8)(ep);
9d00618c:	3c03bf88 	lui	v1,0xbf88
9d006190:	03e00008 	jr	ra
			break;
9d006194:	ac625300 	sw	v0,21248(v1)
	}

	ep	=	MCF_USB_OTG_ENDPT_EP_HSHK|MCF_USB_OTG_ENDPT_EP_TX_EN|MCF_USB_OTG_ENDPT_EP_RX_EN;
	ep |= endpoint?MCF_USB_OTG_ENDPT_EP_CTL_DIS:0;
	// enable the packet transfer
	switch (endpoint)
9d006198:	24020001 	li	v0,1
9d00619c:	1082000a 	beq	a0,v0,9d0061c8 <usb_device_enqueue+0xc4>
9d0061a0:	28820002 	slti	v0,a0,2
9d0061a4:	14400013 	bnez	v0,9d0061f4 <usb_device_enqueue+0xf0>
9d0061a8:	24020002 	li	v0,2
9d0061ac:	1082000a 	beq	a0,v0,9d0061d8 <usb_device_enqueue+0xd4>
9d0061b0:	24020003 	li	v0,3
9d0061b4:	1082000c 	beq	a0,v0,9d0061e8 <usb_device_enqueue+0xe4>
9d0061b8:	2403001d 	li	v1,29
			break;
		case 3:
			U1EP3	=	(uint8)(ep);
			break;
		default:
			ASSERT(0);
9d0061bc:	7000003f 	sdbbp
9d0061c0:	03e00008 	jr	ra
9d0061c4:	00000000 	nop
	{
		case 0:
			U1EP0	=	(uint8)(ep);
			break;
		case 1:
			U1EP1	=	(uint8)(ep);
9d0061c8:	2403001d 	li	v1,29
9d0061cc:	3c02bf88 	lui	v0,0xbf88
9d0061d0:	03e00008 	jr	ra
			break;
9d0061d4:	ac435310 	sw	v1,21264(v0)
		case 2:
			U1EP2	=	(uint8)(ep);
9d0061d8:	2403001d 	li	v1,29
9d0061dc:	3c02bf88 	lui	v0,0xbf88
9d0061e0:	03e00008 	jr	ra
			break;
9d0061e4:	ac435320 	sw	v1,21280(v0)
		case 3:
			U1EP3	=	(uint8)(ep);
9d0061e8:	3c02bf88 	lui	v0,0xbf88
9d0061ec:	03e00008 	jr	ra
			break;
9d0061f0:	ac435330 	sw	v1,21296(v0)
	}

	ep	=	MCF_USB_OTG_ENDPT_EP_HSHK|MCF_USB_OTG_ENDPT_EP_TX_EN|MCF_USB_OTG_ENDPT_EP_RX_EN;
	ep |= endpoint?MCF_USB_OTG_ENDPT_EP_CTL_DIS:0;
	// enable the packet transfer
	switch (endpoint)
9d0061f4:	1080ffe5 	beqz	a0,9d00618c <usb_device_enqueue+0x88>
9d0061f8:	2402001d 	li	v0,29
9d0061fc:	0b40186f 	j	9d0061bc <usb_device_enqueue+0xb8>
9d006200:	00000000 	nop

9d006204 <IntUSB1Handler>:
#ifdef _USE_USB_IRQ_
	void __attribute__((interrupt(),nomips16)) IntUSB1Handler(void)
#else
	void	usb_isr(void)
#endif
{
9d006204:	415de800 	rdpgpr	sp,sp
9d006208:	401b7000 	mfc0	k1,c0_epc
9d00620c:	401a6002 	mfc0	k0,c0_srsctl
9d006210:	27bdff78 	addiu	sp,sp,-136
9d006214:	afbb0084 	sw	k1,132(sp)
9d006218:	401b6000 	mfc0	k1,c0_status
9d00621c:	afba0080 	sw	k0,128(sp)
9d006220:	401a6800 	mfc0	k0,c0_cause
9d006224:	001ad282 	srl	k0,k0,0xa
9d006228:	afbb007c 	sw	k1,124(sp)
9d00622c:	7f5b7a84 	ins	k1,k0,0xa,0x6
9d006230:	7c1b2044 	ins	k1,zero,0x1,0x4
9d006234:	409b6000 	mtc0	k1,c0_status
9d006238:	afa3001c 	sw	v1,28(sp)
9d00623c:	8fa30080 	lw	v1,128(sp)
9d006240:	3063000f 	andi	v1,v1,0xf
9d006244:	14600016 	bnez	v1,9d0062a0 <IntUSB1Handler+0x9c>
9d006248:	afa20018 	sw	v0,24(sp)
9d00624c:	afbf006c 	sw	ra,108(sp)
9d006250:	afb90068 	sw	t9,104(sp)
9d006254:	afb80064 	sw	t8,100(sp)
9d006258:	afb40060 	sw	s4,96(sp)
9d00625c:	afb3005c 	sw	s3,92(sp)
9d006260:	afb20058 	sw	s2,88(sp)
9d006264:	afb10054 	sw	s1,84(sp)
9d006268:	afb00050 	sw	s0,80(sp)
9d00626c:	afaf004c 	sw	t7,76(sp)
9d006270:	afae0048 	sw	t6,72(sp)
9d006274:	afad0044 	sw	t5,68(sp)
9d006278:	afac0040 	sw	t4,64(sp)
9d00627c:	afab003c 	sw	t3,60(sp)
9d006280:	afaa0038 	sw	t2,56(sp)
9d006284:	afa90034 	sw	t1,52(sp)
9d006288:	afa80030 	sw	t0,48(sp)
9d00628c:	afa7002c 	sw	a3,44(sp)
9d006290:	afa60028 	sw	a2,40(sp)
9d006294:	afa50024 	sw	a1,36(sp)
9d006298:	afa40020 	sw	a0,32(sp)
9d00629c:	afa10014 	sw	at,20(sp)
9d0062a0:	00001810 	mfhi	v1
9d0062a4:	afa30070 	sw	v1,112(sp)
	int rv __attribute__((aligned));

	if (! bdts)
9d0062a8:	8f838068 	lw	v1,-32664(gp)
#ifdef _USE_USB_IRQ_
	void __attribute__((interrupt(),nomips16)) IntUSB1Handler(void)
#else
	void	usb_isr(void)
#endif
{
9d0062ac:	00001012 	mflo	v0
	int rv __attribute__((aligned));

	if (! bdts)
9d0062b0:	1060001a 	beqz	v1,9d00631c <IntUSB1Handler+0x118>
9d0062b4:	afa20074 	sw	v0,116(sp)
#ifdef _USE_USB_IRQ_
#if defined(__PIC32MX2XX__)
    /// TODO: Plib replacement function should go here
    IFS1CLR	=	0x00000008; // USBIF
#else
	IFS1CLR	=	0x02000000; // USBIF
9d0062b8:	3c02bf88 	lui	v0,0xbf88
9d0062bc:	3c040200 	lui	a0,0x200
9d0062c0:	ac441044 	sw	a0,4164(v0)
#endif
#endif	
	// *** device ***
	
	// if we just transferred a token...
	if (MCF_USB_OTG_INT_STAT & MCF_USB_OTG_INT_STAT_TOK_DNE)
9d0062c4:	3c10bf88 	lui	s0,0xbf88
9d0062c8:	8e025200 	lw	v0,20992(s0)
9d0062cc:	30420008 	andi	v0,v0,0x8
9d0062d0:	1440003b 	bnez	v0,9d0063c0 <IntUSB1Handler+0x1bc>
9d0062d4:	3c02bf88 	lui	v0,0xbf88

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_TOK_DNE;
	}

	// if we just got reset by the host...
	if (MCF_USB_OTG_INT_STAT & MCF_USB_OTG_INT_STAT_USB_RST)
9d0062d8:	8e025200 	lw	v0,20992(s0)
9d0062dc:	30420001 	andi	v0,v0,0x1
9d0062e0:	14400083 	bnez	v0,9d0064f0 <IntUSB1Handler+0x2ec>
9d0062e4:	3c02bf88 	lui	v0,0xbf88

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_USB_RST;
	}

	// if we just went idle...
	if (MCF_USB_OTG_INT_STAT & MCF_USB_OTG_INT_STAT_SLEEP)
9d0062e8:	8e025200 	lw	v0,20992(s0)
9d0062ec:	30420010 	andi	v0,v0,0x10
9d0062f0:	1040000a 	beqz	v0,9d00631c <IntUSB1Handler+0x118>
9d0062f4:	3c02bf88 	lui	v0,0xbf88
	{
		gCdcacm_active		=	0;
		gCdcacm_attached	=	0;

		// disable usb sleep interrupts
		MCF_USB_OTG_INT_ENB		&=	~MCF_USB_OTG_INT_ENB_SLEEP_EN;
9d0062f8:	8c445210 	lw	a0,21008(v0)
9d0062fc:	2403ffef 	li	v1,-17
	}

	// if we just went idle...
	if (MCF_USB_OTG_INT_STAT & MCF_USB_OTG_INT_STAT_SLEEP)
	{
		gCdcacm_active		=	0;
9d006300:	a38080de 	sb	zero,-32546(gp)
		gCdcacm_attached	=	0;

		// disable usb sleep interrupts
		MCF_USB_OTG_INT_ENB		&=	~MCF_USB_OTG_INT_ENB_SLEEP_EN;
9d006304:	00831824 	and	v1,a0,v1
9d006308:	ac435210 	sw	v1,21008(v0)
		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_SLEEP;
9d00630c:	24030010 	li	v1,16
9d006310:	3c02bf88 	lui	v0,0xbf88

	// if we just went idle...
	if (MCF_USB_OTG_INT_STAT & MCF_USB_OTG_INT_STAT_SLEEP)
	{
		gCdcacm_active		=	0;
		gCdcacm_attached	=	0;
9d006314:	a38080cc 	sb	zero,-32564(gp)

		// disable usb sleep interrupts
		MCF_USB_OTG_INT_ENB		&=	~MCF_USB_OTG_INT_ENB_SLEEP_EN;
		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_SLEEP;
9d006318:	ac435200 	sw	v1,20992(v0)
	}
	
//XXX_SKIP_XXX:
	assert(usb_in_isr);
	assert((usb_in_isr = false) ? true : true);
}
9d00631c:	8fa20074 	lw	v0,116(sp)
9d006320:	8fa30070 	lw	v1,112(sp)
9d006324:	00400013 	mtlo	v0
9d006328:	8fa20080 	lw	v0,128(sp)
9d00632c:	3042000f 	andi	v0,v0,0xf
9d006330:	14400018 	bnez	v0,9d006394 <IntUSB1Handler+0x190>
9d006334:	00600011 	mthi	v1
9d006338:	8fbf006c 	lw	ra,108(sp)
9d00633c:	8fb90068 	lw	t9,104(sp)
9d006340:	8fb80064 	lw	t8,100(sp)
9d006344:	8fb40060 	lw	s4,96(sp)
9d006348:	8fb3005c 	lw	s3,92(sp)
9d00634c:	8fb20058 	lw	s2,88(sp)
9d006350:	8fb10054 	lw	s1,84(sp)
9d006354:	8fb00050 	lw	s0,80(sp)
9d006358:	8faf004c 	lw	t7,76(sp)
9d00635c:	8fae0048 	lw	t6,72(sp)
9d006360:	8fad0044 	lw	t5,68(sp)
9d006364:	8fac0040 	lw	t4,64(sp)
9d006368:	8fab003c 	lw	t3,60(sp)
9d00636c:	8faa0038 	lw	t2,56(sp)
9d006370:	8fa90034 	lw	t1,52(sp)
9d006374:	8fa80030 	lw	t0,48(sp)
9d006378:	8fa7002c 	lw	a3,44(sp)
9d00637c:	8fa60028 	lw	a2,40(sp)
9d006380:	8fa50024 	lw	a1,36(sp)
9d006384:	8fa40020 	lw	a0,32(sp)
9d006388:	8fa3001c 	lw	v1,28(sp)
9d00638c:	8fa20018 	lw	v0,24(sp)
9d006390:	8fa10014 	lw	at,20(sp)
9d006394:	41606000 	di
9d006398:	000000c0 	ehb
9d00639c:	8fba0084 	lw	k0,132(sp)
9d0063a0:	8fbb007c 	lw	k1,124(sp)
9d0063a4:	409a7000 	mtc0	k0,c0_epc
9d0063a8:	8fba0080 	lw	k0,128(sp)
9d0063ac:	27bd0088 	addiu	sp,sp,136
9d0063b0:	409a6002 	mtc0	k0,c0_srsctl
9d0063b4:	41dde800 	wrpgpr	sp,sp
9d0063b8:	409b6000 	mtc0	k1,c0_status
9d0063bc:	42000018 	eret
		short value;
		volatile struct bdt *bdt;
		struct setup *setup;
		
		// we just completed a packet transfer
		stat		=	MCF_USB_OTG_STAT;
9d0063c0:	8c425240 	lw	v0,21056(v0)
		tx			=	!! (stat & MCF_USB_OTG_STAT_TX);
		odd			=	!! (stat & MCF_USB_OTG_STAT_ODD);
		endpoint	=	(stat & 0xf0) >> 4;

		// toggle the data toggle flag
		endpoints[endpoint].toggle[tx]	=	endpoints[endpoint].toggle[tx] ? 0 : BD_FLAGS_DATA;
9d0063c4:	3c12a000 	lui	s2,0xa000
9d0063c8:	26511790 	addiu	s1,s2,6032
		
		// we just completed a packet transfer
		stat		=	MCF_USB_OTG_STAT;
		tx			=	!! (stat & MCF_USB_OTG_STAT_TX);
		odd			=	!! (stat & MCF_USB_OTG_STAT_ODD);
		endpoint	=	(stat & 0xf0) >> 4;
9d0063cc:	7c471900 	ext	a3,v0,0x4,0x4

		// toggle the data toggle flag
		endpoints[endpoint].toggle[tx]	=	endpoints[endpoint].toggle[tx] ? 0 : BD_FLAGS_DATA;
9d0063d0:	00079940 	sll	s3,a3,0x5
9d0063d4:	0007a1c0 	sll	s4,a3,0x7
		volatile struct bdt *bdt;
		struct setup *setup;
		
		// we just completed a packet transfer
		stat		=	MCF_USB_OTG_STAT;
		tx			=	!! (stat & MCF_USB_OTG_STAT_TX);
9d0063d8:	7c4400c0 	ext	a0,v0,0x3,0x1
		odd			=	!! (stat & MCF_USB_OTG_STAT_ODD);
		endpoint	=	(stat & 0xf0) >> 4;

		// toggle the data toggle flag
		endpoints[endpoint].toggle[tx]	=	endpoints[endpoint].toggle[tx] ? 0 : BD_FLAGS_DATA;
9d0063dc:	02932823 	subu	a1,s4,s3
9d0063e0:	00a42821 	addu	a1,a1,a0
9d0063e4:	02252821 	addu	a1,s1,a1
9d0063e8:	90a90000 	lbu	t1,0(a1)
		
		// toggle the next bdt entry to use
		ASSERT(odd == endpoints[endpoint].bdtodd[tx]);
9d0063ec:	90a60002 	lbu	a2,2(a1)
		tx			=	!! (stat & MCF_USB_OTG_STAT_TX);
		odd			=	!! (stat & MCF_USB_OTG_STAT_ODD);
		endpoint	=	(stat & 0xf0) >> 4;

		// toggle the data toggle flag
		endpoints[endpoint].toggle[tx]	=	endpoints[endpoint].toggle[tx] ? 0 : BD_FLAGS_DATA;
9d0063f0:	24080040 	li	t0,64
9d0063f4:	0009400b 	movn	t0,zero,t1
		struct setup *setup;
		
		// we just completed a packet transfer
		stat		=	MCF_USB_OTG_STAT;
		tx			=	!! (stat & MCF_USB_OTG_STAT_TX);
		odd			=	!! (stat & MCF_USB_OTG_STAT_ODD);
9d0063f8:	7c420080 	ext	v0,v0,0x2,0x1

		// toggle the data toggle flag
		endpoints[endpoint].toggle[tx]	=	endpoints[endpoint].toggle[tx] ? 0 : BD_FLAGS_DATA;
		
		// toggle the next bdt entry to use
		ASSERT(odd == endpoints[endpoint].bdtodd[tx]);
9d0063fc:	10c20002 	beq	a2,v0,9d006408 <IntUSB1Handler+0x204>
9d006400:	a0a80000 	sb	t0,0(a1)
9d006404:	7000003f 	sdbbp
		endpoints[endpoint].bdtodd[tx]	=	! endpoints[endpoint].bdtodd[tx];

		bdt	=	MYBDT(endpoint, tx, odd);
9d006408:	00072840 	sll	a1,a3,0x1
9d00640c:	00a42821 	addu	a1,a1,a0
9d006410:	00052840 	sll	a1,a1,0x1
		// toggle the data toggle flag
		endpoints[endpoint].toggle[tx]	=	endpoints[endpoint].toggle[tx] ? 0 : BD_FLAGS_DATA;
		
		// toggle the next bdt entry to use
		ASSERT(odd == endpoints[endpoint].bdtodd[tx]);
		endpoints[endpoint].bdtodd[tx]	=	! endpoints[endpoint].bdtodd[tx];
9d006414:	02934023 	subu	t0,s4,s3

		bdt	=	MYBDT(endpoint, tx, odd);
9d006418:	00a21021 	addu	v0,a1,v0
		// toggle the data toggle flag
		endpoints[endpoint].toggle[tx]	=	endpoints[endpoint].toggle[tx] ? 0 : BD_FLAGS_DATA;
		
		// toggle the next bdt entry to use
		ASSERT(odd == endpoints[endpoint].bdtodd[tx]);
		endpoints[endpoint].bdtodd[tx]	=	! endpoints[endpoint].bdtodd[tx];
9d00641c:	01042021 	addu	a0,t0,a0
9d006420:	02242021 	addu	a0,s1,a0
9d006424:	2cc60001 	sltiu	a2,a2,1

		bdt	=	MYBDT(endpoint, tx, odd);
9d006428:	000210c0 	sll	v0,v0,0x3
		// toggle the data toggle flag
		endpoints[endpoint].toggle[tx]	=	endpoints[endpoint].toggle[tx] ? 0 : BD_FLAGS_DATA;
		
		// toggle the next bdt entry to use
		ASSERT(odd == endpoints[endpoint].bdtodd[tx]);
		endpoints[endpoint].bdtodd[tx]	=	! endpoints[endpoint].bdtodd[tx];
9d00642c:	a0860002 	sb	a2,2(a0)

		bdt	=	MYBDT(endpoint, tx, odd);
9d006430:	00621021 	addu	v0,v1,v0

		flags	=	TF_LITTLE(bdt->flags);
9d006434:	90450000 	lbu	a1,0(v0)
9d006438:	90440001 	lbu	a0,1(v0)
9d00643c:	90430002 	lbu	v1,2(v0)
9d006440:	90460003 	lbu	a2,3(v0)
9d006444:	308400ff 	andi	a0,a0,0xff
9d006448:	30a500ff 	andi	a1,a1,0xff
9d00644c:	00042200 	sll	a0,a0,0x8
9d006450:	306300ff 	andi	v1,v1,0xff
9d006454:	00852025 	or	a0,a0,a1
9d006458:	00031c00 	sll	v1,v1,0x10
9d00645c:	00641825 	or	v1,v1,a0
9d006460:	00063600 	sll	a2,a2,0x18
9d006464:	00c33025 	or	a2,a2,v1
		assert(! (flags & BD_FLAGS_OWN));

		bc	=	BD_FLAGS_BC_DEC(flags);
		assert(bc >= 0);

		pid	=	BD_FLAGS_TOK_PID_DEC(flags);
9d006468:	7cc31880 	ext	v1,a2,0x2,0x4

		// if we're starting a new control transfer...
		if (pid == TOKEN_SETUP)
9d00646c:	2404000d 	li	a0,13
9d006470:	10640099 	beq	v1,a0,9d0066d8 <IntUSB1Handler+0x4d4>
9d006474:	00000000 	nop
				}
			}
			assert((unsigned)endpoint < LENGTHOF(endpoints));
			assert(endpoints[endpoint].data_length <= sizeof(endpoints[endpoint].data_buffer));
		}
		else if (! endpoint)
9d006478:	14e0007a 	bnez	a3,9d006664 <IntUSB1Handler+0x460>
9d00647c:	7cc64c00 	ext	a2,a2,0x10,0xa
		{
			assert(pid == TOKEN_IN || pid == TOKEN_OUT);
			data	=	(byte *)TF_LITTLE((int)PA_TO_KVA1((int)bdt->buffer));

			// if this is part of the data transfer...
			if (pid == endpoints[endpoint].data_pid)
9d006480:	92240006 	lbu	a0,6(s1)
			assert(endpoints[endpoint].data_length <= sizeof(endpoints[endpoint].data_buffer));
		}
		else if (! endpoint)
		{
			assert(pid == TOKEN_IN || pid == TOKEN_OUT);
			data	=	(byte *)TF_LITTLE((int)PA_TO_KVA1((int)bdt->buffer));
9d006484:	90450004 	lbu	a1,4(v0)
9d006488:	90450005 	lbu	a1,5(v0)
9d00648c:	90450006 	lbu	a1,6(v0)
9d006490:	90420007 	lbu	v0,7(v0)

			// if this is part of the data transfer...
			if (pid == endpoints[endpoint].data_pid)
9d006494:	108300ff 	beq	a0,v1,9d006894 <IntUSB1Handler+0x690>
9d006498:	93828090 	lbu	v0,-32624(gp)
			else
			{
				assert(data == PA_TO_KVA1(0));

				// update our address after status
				if (next_address)
9d00649c:	50400007 	beqzl	v0,9d0064bc <IntUSB1Handler+0x2b8>
9d0064a0:	24020040 	li	v0,64
				{
					MCF_USB_OTG_ADDR |= next_address;
9d0064a4:	3c03bf88 	lui	v1,0xbf88
9d0064a8:	8c645260 	lw	a0,21088(v1)
					next_address	=	0;
9d0064ac:	a3808090 	sb	zero,-32624(gp)
				assert(data == PA_TO_KVA1(0));

				// update our address after status
				if (next_address)
				{
					MCF_USB_OTG_ADDR |= next_address;
9d0064b0:	00441025 	or	v0,v0,a0
9d0064b4:	ac625260 	sw	v0,21088(v1)
					next_address	=	0;
				}

				// setup always uses data0; following transactions start with data1
				endpoints[endpoint].toggle[0]	=	0;
				endpoints[endpoint].toggle[1]	=	BD_FLAGS_DATA;
9d0064b8:	24020040 	li	v0,64
					MCF_USB_OTG_ADDR |= next_address;
					next_address	=	0;
				}

				// setup always uses data0; following transactions start with data1
				endpoints[endpoint].toggle[0]	=	0;
9d0064bc:	a2401790 	sb	zero,6032(s2)
				endpoints[endpoint].toggle[1]	=	BD_FLAGS_DATA;

				// prepare to receive setup token
				usb_device_enqueue(0, 0, setup_buffer, sizeof(setup_buffer));
9d0064c0:	00002021 	move	a0,zero
9d0064c4:	00002821 	move	a1,zero
9d0064c8:	27868094 	addiu	a2,gp,-32620
9d0064cc:	24070008 	li	a3,8
9d0064d0:	0f401841 	jal	9d006104 <usb_device_enqueue>
9d0064d4:	a2220001 	sb	v0,1(s1)
			// we just received or sent data from or to the host
			assert(gBulk_transfer_cbfn);
			gBulk_transfer_cbfn(pid == TOKEN_IN, data, bc);
		}

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_TOK_DNE;
9d0064d8:	24020008 	li	v0,8
9d0064dc:	ae025200 	sw	v0,20992(s0)
	}

	// if we just got reset by the host...
	if (MCF_USB_OTG_INT_STAT & MCF_USB_OTG_INT_STAT_USB_RST)
9d0064e0:	8e025200 	lw	v0,20992(s0)
9d0064e4:	30420001 	andi	v0,v0,0x1
9d0064e8:	1040ff7f 	beqz	v0,9d0062e8 <IntUSB1Handler+0xe4>
9d0064ec:	3c02bf88 	lui	v0,0xbf88
// waiting for a "set configuration" command from the host.
//************************************************************************
static void	usb_device_default()
{
	// default to address 0 on reset
	MCF_USB_OTG_ADDR	=	(uint8)0;
9d0064f0:	ac405260 	sw	zero,21088(v0)

	// enable usb device mode
	MCF_USB_OTG_CTL |= MCF_USB_OTG_CTL_ODD_RST;
9d0064f4:	3c02bf88 	lui	v0,0xbf88
9d0064f8:	8c435250 	lw	v1,21072(v0)
	MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_ODD_RST;

	memset(bdts, 0, BDT_RAM_SIZE);
9d0064fc:	8f848068 	lw	a0,-32664(gp)
	memset(endpoints, 0, sizeof(endpoints));
9d006500:	3c12a000 	lui	s2,0xa000
{
	// default to address 0 on reset
	MCF_USB_OTG_ADDR	=	(uint8)0;

	// enable usb device mode
	MCF_USB_OTG_CTL |= MCF_USB_OTG_CTL_ODD_RST;
9d006504:	34630002 	ori	v1,v1,0x2
9d006508:	ac435250 	sw	v1,21072(v0)
	MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_ODD_RST;
9d00650c:	8c465250 	lw	a2,21072(v0)
9d006510:	2403fffd 	li	v1,-3

	memset(bdts, 0, BDT_RAM_SIZE);
9d006514:	00002821 	move	a1,zero
	// default to address 0 on reset
	MCF_USB_OTG_ADDR	=	(uint8)0;

	// enable usb device mode
	MCF_USB_OTG_CTL |= MCF_USB_OTG_CTL_ODD_RST;
	MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_ODD_RST;
9d006518:	00c31824 	and	v1,a2,v1

	memset(bdts, 0, BDT_RAM_SIZE);
	memset(endpoints, 0, sizeof(endpoints));
9d00651c:	26511790 	addiu	s1,s2,6032

	// enable usb device mode
	MCF_USB_OTG_CTL |= MCF_USB_OTG_CTL_ODD_RST;
	MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_ODD_RST;

	memset(bdts, 0, BDT_RAM_SIZE);
9d006520:	24060100 	li	a2,256
	// default to address 0 on reset
	MCF_USB_OTG_ADDR	=	(uint8)0;

	// enable usb device mode
	MCF_USB_OTG_CTL |= MCF_USB_OTG_CTL_ODD_RST;
	MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_ODD_RST;
9d006524:	ac435250 	sw	v1,21072(v0)
	}

	// if we just got reset by the host...
	if (MCF_USB_OTG_INT_STAT & MCF_USB_OTG_INT_STAT_USB_RST)
	{
		gCdcacm_active		=	0;
9d006528:	a38080de 	sb	zero,-32546(gp)

	// enable usb device mode
	MCF_USB_OTG_CTL |= MCF_USB_OTG_CTL_ODD_RST;
	MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_ODD_RST;

	memset(bdts, 0, BDT_RAM_SIZE);
9d00652c:	0f401ed5 	jal	9d007b54 <memset>
9d006530:	a38080cc 	sb	zero,-32564(gp)
	memset(endpoints, 0, sizeof(endpoints));
9d006534:	00002821 	move	a1,zero
9d006538:	24060180 	li	a2,384
9d00653c:	0f401ed5 	jal	9d007b54 <memset>
9d006540:	02202021 	move	a0,s1

	assert(configuration_descriptor);

	// extract the maximum packet size from the device descriptor
	endpoints[0].packetsize	=	device_descriptor[7];
9d006544:	8f82807c 	lw	v0,-32644(gp)
static void	parse_configuration(const byte *configuration, int size)
{
unsigned int ii;

	// extract the bulk endpoint information
	for (ii = 0; ii < size; ii += configuration[ii])
9d006548:	8f858078 	lw	a1,-32648(gp)

	// extract the maximum packet size from the device descriptor
	endpoints[0].packetsize	=	device_descriptor[7];

	// parse the configuration descriptor
	parse_configuration(configuration_descriptor, configuration_descriptor_length);
9d00654c:	8f868074 	lw	a2,-32652(gp)
	memset(endpoints, 0, sizeof(endpoints));

	assert(configuration_descriptor);

	// extract the maximum packet size from the device descriptor
	endpoints[0].packetsize	=	device_descriptor[7];
9d006550:	90420007 	lbu	v0,7(v0)
static void	parse_configuration(const byte *configuration, int size)
{
unsigned int ii;

	// extract the bulk endpoint information
	for (ii = 0; ii < size; ii += configuration[ii])
9d006554:	10a00024 	beqz	a1,9d0065e8 <IntUSB1Handler+0x3e4>
9d006558:	a2220004 	sb	v0,4(s1)
9d00655c:	00001021 	move	v0,zero
	{
		if (configuration[ii+1] == ENDPOINT_DESCRIPTOR)
9d006560:	24070005 	li	a3,5
		{
			if (configuration[ii+3] == BULK_ATTRIBUTES)
9d006564:	24080002 	li	t0,2
					assert(bulk_out_ep < LENGTHOF(endpoints));
					assert(configuration[ii+4]);
					endpoints[bulk_out_ep].packetsize	=	configuration[ii+4];
				}
			}
			else if (configuration[ii+3] == INTERRUPT_ATTRIBUTES)
9d006568:	24090003 	li	t1,3
			{
				int_ep	=	(byte)(configuration[ii+2] & 0xf);
				assert(int_ep < LENGTHOF(endpoints));
				assert(configuration[ii+4]);
				endpoints[int_ep].packetsize	=	configuration[ii+4];
				endpoints[int_ep].inter			=	1;
9d00656c:	0b401962 	j	9d006588 <IntUSB1Handler+0x384>
9d006570:	240d0001 	li	t5,1
static void	parse_configuration(const byte *configuration, int size)
{
unsigned int ii;

	// extract the bulk endpoint information
	for (ii = 0; ii < size; ii += configuration[ii])
9d006574:	90630000 	lbu	v1,0(v1)
9d006578:	00431021 	addu	v0,v0,v1
9d00657c:	0045182b 	sltu	v1,v0,a1
9d006580:	5060001a 	beqzl	v1,9d0065ec <IntUSB1Handler+0x3e8>
9d006584:	240200ff 	li	v0,255
	{
		if (configuration[ii+1] == ENDPOINT_DESCRIPTOR)
9d006588:	00c21821 	addu	v1,a2,v0
9d00658c:	90640001 	lbu	a0,1(v1)
9d006590:	5487fff9 	bnel	a0,a3,9d006578 <IntUSB1Handler+0x374>
9d006594:	90630000 	lbu	v1,0(v1)
		{
			if (configuration[ii+3] == BULK_ATTRIBUTES)
9d006598:	90640003 	lbu	a0,3(v1)
9d00659c:	50880026 	beql	a0,t0,9d006638 <IntUSB1Handler+0x434>
9d0065a0:	906a0002 	lbu	t2,2(v1)
					assert(bulk_out_ep < LENGTHOF(endpoints));
					assert(configuration[ii+4]);
					endpoints[bulk_out_ep].packetsize	=	configuration[ii+4];
				}
			}
			else if (configuration[ii+3] == INTERRUPT_ATTRIBUTES)
9d0065a4:	5489fff4 	bnel	a0,t1,9d006578 <IntUSB1Handler+0x374>
9d0065a8:	90630000 	lbu	v1,0(v1)
			{
				int_ep	=	(byte)(configuration[ii+2] & 0xf);
9d0065ac:	90640002 	lbu	a0,2(v1)
9d0065b0:	3084000f 	andi	a0,a0,0xf
9d0065b4:	a38480ce 	sb	a0,-32562(gp)
				assert(int_ep < LENGTHOF(endpoints));
				assert(configuration[ii+4]);
				endpoints[int_ep].packetsize	=	configuration[ii+4];
9d0065b8:	906a0004 	lbu	t2,4(v1)
9d0065bc:	00045940 	sll	t3,a0,0x5
9d0065c0:	000421c0 	sll	a0,a0,0x7
9d0065c4:	008b2023 	subu	a0,a0,t3
9d0065c8:	02242021 	addu	a0,s1,a0
9d0065cc:	a08a0004 	sb	t2,4(a0)
				endpoints[int_ep].inter			=	1;
9d0065d0:	a08d0005 	sb	t5,5(a0)
static void	parse_configuration(const byte *configuration, int size)
{
unsigned int ii;

	// extract the bulk endpoint information
	for (ii = 0; ii < size; ii += configuration[ii])
9d0065d4:	90630000 	lbu	v1,0(v1)
9d0065d8:	00431021 	addu	v0,v0,v1
9d0065dc:	0045182b 	sltu	v1,v0,a1
9d0065e0:	1460ffea 	bnez	v1,9d00658c <IntUSB1Handler+0x388>
9d0065e4:	00c21821 	addu	v1,a2,v0

	// parse the configuration descriptor
	parse_configuration(configuration_descriptor, configuration_descriptor_length);

	// enable (also) usb sleep and token done interrupts
	MCF_USB_OTG_INT_STAT	=	0xff;
9d0065e8:	240200ff 	li	v0,255
9d0065ec:	ae025200 	sw	v0,20992(s0)
	MCF_USB_OTG_INT_ENB |= MCF_USB_OTG_INT_ENB_SLEEP_EN|MCF_USB_OTG_INT_ENB_TOK_DNE_EN;
9d0065f0:	3c02bf88 	lui	v0,0xbf88
9d0065f4:	8c435210 	lw	v1,21008(v0)
9d0065f8:	34630018 	ori	v1,v1,0x18
9d0065fc:	ac435210 	sw	v1,21008(v0)
		gCdcacm_attached	=	0;

		usb_device_default();

		assert(gReset_cbfn);
		gReset_cbfn();
9d006600:	8f828084 	lw	v0,-32636(gp)
9d006604:	0040f809 	jalr	v0
9d006608:	00000000 	nop

		// setup always uses data0; following transactions start with data1
		endpoints[0].toggle[0]	=	0;
		endpoints[0].toggle[1]	=	BD_FLAGS_DATA;
9d00660c:	24020040 	li	v0,64

		assert(gReset_cbfn);
		gReset_cbfn();

		// setup always uses data0; following transactions start with data1
		endpoints[0].toggle[0]	=	0;
9d006610:	a2401790 	sb	zero,6032(s2)
		endpoints[0].toggle[1]	=	BD_FLAGS_DATA;

		// prepare to receive setup token
		usb_device_enqueue(0, 0, setup_buffer, sizeof(setup_buffer));
9d006614:	00002021 	move	a0,zero
		assert(gReset_cbfn);
		gReset_cbfn();

		// setup always uses data0; following transactions start with data1
		endpoints[0].toggle[0]	=	0;
		endpoints[0].toggle[1]	=	BD_FLAGS_DATA;
9d006618:	a2220001 	sb	v0,1(s1)

		// prepare to receive setup token
		usb_device_enqueue(0, 0, setup_buffer, sizeof(setup_buffer));
9d00661c:	00002821 	move	a1,zero
9d006620:	27868094 	addiu	a2,gp,-32620
9d006624:	0f401841 	jal	9d006104 <usb_device_enqueue>
9d006628:	24070008 	li	a3,8

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_USB_RST;
9d00662c:	24020001 	li	v0,1
9d006630:	0b4018ba 	j	9d0062e8 <IntUSB1Handler+0xe4>
9d006634:	ae025200 	sw	v0,20992(s0)
					assert(configuration[ii+4]);
					endpoints[bulk_in_ep].packetsize	=	configuration[ii+4];
				}
				else
				{
					bulk_out_ep	=	(byte)(configuration[ii+2] & 0xf);
9d006638:	3144000f 	andi	a0,t2,0xf
					assert(bulk_out_ep < LENGTHOF(endpoints));
					assert(configuration[ii+4]);
					endpoints[bulk_out_ep].packetsize	=	configuration[ii+4];
9d00663c:	00045940 	sll	t3,a0,0x5
9d006640:	000461c0 	sll	t4,a0,0x7
9d006644:	018b6023 	subu	t4,t4,t3
	{
		if (configuration[ii+1] == ENDPOINT_DESCRIPTOR)
		{
			if (configuration[ii+3] == BULK_ATTRIBUTES)
			{
				if (configuration[ii+2] & 0x80)
9d006648:	7c0a5c20 	seb	t3,t2
9d00664c:	0560001e 	bltz	t3,9d0066c8 <IntUSB1Handler+0x4c4>
9d006650:	022c6021 	addu	t4,s1,t4
					assert(configuration[ii+4]);
					endpoints[bulk_in_ep].packetsize	=	configuration[ii+4];
				}
				else
				{
					bulk_out_ep	=	(byte)(configuration[ii+2] & 0xf);
9d006654:	a38480cd 	sb	a0,-32563(gp)
					assert(bulk_out_ep < LENGTHOF(endpoints));
					assert(configuration[ii+4]);
					endpoints[bulk_out_ep].packetsize	=	configuration[ii+4];
9d006658:	90640004 	lbu	a0,4(v1)
9d00665c:	0b40195d 	j	9d006574 <IntUSB1Handler+0x370>
9d006660:	a1840004 	sb	a0,4(t4)

				// prepare to receive setup token
				usb_device_enqueue(0, 0, setup_buffer, sizeof(setup_buffer));
			}
		}
		else if (endpoint != int_ep)
9d006664:	938480ce 	lbu	a0,-32562(gp)
9d006668:	5087ff9c 	beql	a0,a3,9d0064dc <IntUSB1Handler+0x2d8>
9d00666c:	24020008 	li	v0,8
		{
			assert(pid == TOKEN_IN || pid == TOKEN_OUT);
			data	=	(byte *)TF_LITTLE((int)PA_TO_KVA1((int)bdt->buffer));
9d006670:	90470004 	lbu	a3,4(v0)
9d006674:	90440005 	lbu	a0,5(v0)
9d006678:	90480006 	lbu	t0,6(v0)
9d00667c:	90450007 	lbu	a1,7(v0)
9d006680:	308400ff 	andi	a0,a0,0xff
9d006684:	30e700ff 	andi	a3,a3,0xff
9d006688:	310200ff 	andi	v0,t0,0xff
9d00668c:	00042200 	sll	a0,a0,0x8
9d006690:	00872025 	or	a0,a0,a3
9d006694:	00021400 	sll	v0,v0,0x10
9d006698:	00441025 	or	v0,v0,a0
9d00669c:	00052e00 	sll	a1,a1,0x18
9d0066a0:	00a22825 	or	a1,a1,v0

			// we just received or sent data from or to the host
			assert(gBulk_transfer_cbfn);
			gBulk_transfer_cbfn(pid == TOKEN_IN, data, bc);
9d0066a4:	3c02a000 	lui	v0,0xa000
9d0066a8:	00a22825 	or	a1,a1,v0
9d0066ac:	8f82808c 	lw	v0,-32628(gp)
9d0066b0:	38630009 	xori	v1,v1,0x9
9d0066b4:	0040f809 	jalr	v0
9d0066b8:	2c640001 	sltiu	a0,v1,1
		}

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_TOK_DNE;
9d0066bc:	24020008 	li	v0,8
9d0066c0:	0b401938 	j	9d0064e0 <IntUSB1Handler+0x2dc>
9d0066c4:	ae025200 	sw	v0,20992(s0)
		{
			if (configuration[ii+3] == BULK_ATTRIBUTES)
			{
				if (configuration[ii+2] & 0x80)
				{
					bulk_in_ep	=	(byte)(configuration[ii+2] & 0xf);
9d0066c8:	a38480cf 	sb	a0,-32561(gp)
					assert(bulk_in_ep < LENGTHOF(endpoints));
					assert(configuration[ii+4]);
					endpoints[bulk_in_ep].packetsize	=	configuration[ii+4];
9d0066cc:	906b0004 	lbu	t3,4(v1)
9d0066d0:	0b40195d 	j	9d006574 <IntUSB1Handler+0x370>
9d0066d4:	a18b0004 	sb	t3,4(t4)
		{
			assert(! endpoint);
			assert(bc == 8);
			assert(! tx);

			setup	=	(struct setup *)TF_LITTLE((int)PA_TO_KVA1((int)bdt->buffer));
9d0066d8:	90490004 	lbu	t1,4(v0)
9d0066dc:	90460005 	lbu	a2,5(v0)
9d0066e0:	904a0006 	lbu	t2,6(v0)
9d0066e4:	90440007 	lbu	a0,7(v0)
9d0066e8:	30c600ff 	andi	a2,a2,0xff
			assert((void *)setup == (void *)setup_buffer);

			// unsuspend the usb packet engine
			MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_TXSUSPEND_TOKENBUSY;
9d0066ec:	3c03bf88 	lui	v1,0xbf88
		{
			assert(! endpoint);
			assert(bc == 8);
			assert(! tx);

			setup	=	(struct setup *)TF_LITTLE((int)PA_TO_KVA1((int)bdt->buffer));
9d0066f0:	312900ff 	andi	t1,t1,0xff
9d0066f4:	00063200 	sll	a2,a2,0x8
9d0066f8:	314200ff 	andi	v0,t2,0xff
			assert((void *)setup == (void *)setup_buffer);

			// unsuspend the usb packet engine
			MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_TXSUSPEND_TOKENBUSY;
9d0066fc:	8c655250 	lw	a1,21072(v1)
		{
			assert(! endpoint);
			assert(bc == 8);
			assert(! tx);

			setup	=	(struct setup *)TF_LITTLE((int)PA_TO_KVA1((int)bdt->buffer));
9d006700:	00c93025 	or	a2,a2,t1
9d006704:	00021400 	sll	v0,v0,0x10
9d006708:	00461025 	or	v0,v0,a2
9d00670c:	00042600 	sll	a0,a0,0x18
9d006710:	00822025 	or	a0,a0,v0
			assert((void *)setup == (void *)setup_buffer);

			// unsuspend the usb packet engine
			MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_TXSUSPEND_TOKENBUSY;
9d006714:	2402ffdf 	li	v0,-33
9d006718:	00a21024 	and	v0,a1,v0
		{
			assert(! endpoint);
			assert(bc == 8);
			assert(! tx);

			setup	=	(struct setup *)TF_LITTLE((int)PA_TO_KVA1((int)bdt->buffer));
9d00671c:	3c05a000 	lui	a1,0xa000
9d006720:	00852025 	or	a0,a0,a1
			// unsuspend the usb packet engine
			MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_TXSUSPEND_TOKENBUSY;

			length	=	TF_LITTLE(setup->length);

			endpoints[endpoint].data_pid	=	TOKEN_OUT;
9d006724:	01119021 	addu	s2,t0,s1

			setup	=	(struct setup *)TF_LITTLE((int)PA_TO_KVA1((int)bdt->buffer));
			assert((void *)setup == (void *)setup_buffer);

			// unsuspend the usb packet engine
			MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_TXSUSPEND_TOKENBUSY;
9d006728:	ac625250 	sw	v0,21072(v1)

			length	=	TF_LITTLE(setup->length);

			endpoints[endpoint].data_pid	=	TOKEN_OUT;
9d00672c:	24030001 	li	v1,1
			assert((void *)setup == (void *)setup_buffer);

			// unsuspend the usb packet engine
			MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_TXSUSPEND_TOKENBUSY;

			length	=	TF_LITTLE(setup->length);
9d006730:	90850006 	lbu	a1,6(a0)
9d006734:	90820007 	lbu	v0,7(a0)

			endpoints[endpoint].data_pid	=	TOKEN_OUT;
9d006738:	a2430006 	sb	v1,6(s2)
			endpoints[endpoint].data_length	=	0;
			endpoints[endpoint].data_offset	=	0;

			// is this a standard command...
			if (! (setup->requesttype & 0x60))
9d00673c:	90830000 	lbu	v1,0(a0)
			assert((void *)setup == (void *)setup_buffer);

			// unsuspend the usb packet engine
			MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_TXSUSPEND_TOKENBUSY;

			length	=	TF_LITTLE(setup->length);
9d006740:	00021200 	sll	v0,v0,0x8
9d006744:	00451025 	or	v0,v0,a1
			endpoints[endpoint].data_pid	=	TOKEN_OUT;
			endpoints[endpoint].data_length	=	0;
			endpoints[endpoint].data_offset	=	0;

			// is this a standard command...
			if (! (setup->requesttype & 0x60))
9d006748:	30650060 	andi	a1,v1,0x60
			assert((void *)setup == (void *)setup_buffer);

			// unsuspend the usb packet engine
			MCF_USB_OTG_CTL &= ~MCF_USB_OTG_CTL_TXSUSPEND_TOKENBUSY;

			length	=	TF_LITTLE(setup->length);
9d00674c:	7c021620 	seh	v0,v0

			endpoints[endpoint].data_pid	=	TOKEN_OUT;
			endpoints[endpoint].data_length	=	0;
9d006750:	ae40000c 	sw	zero,12(s2)
			endpoints[endpoint].data_offset	=	0;

			// is this a standard command...
			if (! (setup->requesttype & 0x60))
9d006754:	14a0001d 	bnez	a1,9d0067cc <IntUSB1Handler+0x5c8>
9d006758:	ae400008 	sw	zero,8(s2)
			{
				value	=	TF_LITTLE(setup->value);
9d00675c:	90860003 	lbu	a2,3(a0)
9d006760:	90890002 	lbu	t1,2(a0)
				if (setup->request == REQUEST_GET_DESCRIPTOR)
9d006764:	90850001 	lbu	a1,1(a0)
			endpoints[endpoint].data_offset	=	0;

			// is this a standard command...
			if (! (setup->requesttype & 0x60))
			{
				value	=	TF_LITTLE(setup->value);
9d006768:	00063200 	sll	a2,a2,0x8
9d00676c:	00c93025 	or	a2,a2,t1
9d006770:	7c064e20 	seh	t1,a2
				if (setup->request == REQUEST_GET_DESCRIPTOR)
9d006774:	24060006 	li	a2,6
9d006778:	50a60029 	beql	a1,a2,9d006820 <IntUSB1Handler+0x61c>
9d00677c:	24040009 	li	a0,9
					assert(endpoints[endpoint].toggle[1] == BD_FLAGS_DATA);
					usb_device_enqueue(0, 1, endpoints[endpoint].data_buffer, MIN(endpoints[endpoint].data_length, endpoints[endpoint].packetsize));
				}
				else
				{
					if (setup->request == REQUEST_CLEAR_FEATURE)
9d006780:	24020001 	li	v0,1
9d006784:	50a20053 	beql	a1,v0,9d0068d4 <IntUSB1Handler+0x6d0>
9d006788:	24020002 	li	v0,2
						else
						{
							assert(0);
						}
					}
					else if (setup->request == REQUEST_SET_ADDRESS)
9d00678c:	24030005 	li	v1,5
9d006790:	10a30069 	beq	a1,v1,9d006938 <IntUSB1Handler+0x734>
9d006794:	24030009 	li	v1,9
					{
						next_address	=	value;
					}
					else if (setup->request == REQUEST_SET_CONFIGURATION)
9d006798:	50a30081 	beql	a1,v1,9d0069a0 <IntUSB1Handler+0x79c>
9d00679c:	a38280cc 	sb	v0,-32564(gp)
					{
						assert(value == 1);
						gCdcacm_attached_count++;
						gCdcacm_attached	=	1;
					}
					else if (setup->request == REQUEST_GET_CONFIGURATION)
9d0067a0:	24040008 	li	a0,8
9d0067a4:	50a400ac 	beql	a1,a0,9d006a58 <IntUSB1Handler+0x854>
9d0067a8:	92450004 	lbu	a1,4(s2)

						// status uses data1
						assert(endpoints[endpoint].toggle[1] == BD_FLAGS_DATA);

						// prepare to transfer status (in the other direction)
						usb_device_enqueue(0, 1, NULL, 0);
9d0067ac:	00002021 	move	a0,zero
9d0067b0:	24050001 	li	a1,1
9d0067b4:	00003021 	move	a2,zero
9d0067b8:	0f401841 	jal	9d006104 <usb_device_enqueue>
9d0067bc:	00003821 	move	a3,zero
			// we just received or sent data from or to the host
			assert(gBulk_transfer_cbfn);
			gBulk_transfer_cbfn(pid == TOKEN_IN, data, bc);
		}

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_TOK_DNE;
9d0067c0:	24020008 	li	v0,8
9d0067c4:	0b401938 	j	9d0064e0 <IntUSB1Handler+0x2dc>
9d0067c8:	ae025200 	sw	v0,20992(s0)
				}
			// otherwise, this is a class or vendor command
			}
			else
			{
				if (setup->requesttype & 0x80/*in*/)
9d0067cc:	7c031c20 	seb	v1,v1
9d0067d0:	04620063 	bltzl	v1,9d006960 <IntUSB1Handler+0x75c>
9d0067d4:	25080010 	addiu	t0,t0,16
					usb_device_enqueue(0, 1, endpoints[endpoint].data_buffer, endpoints[endpoint].data_length);
				}
				else
				{
					// host is sending data
					if (length)
9d0067d8:	5040000b 	beqzl	v0,9d006808 <IntUSB1Handler+0x604>
9d0067dc:	8f828088 	lw	v0,-32632(gp)
					{
						// we will receive data, TOKEN_OUT(s) will follow
						endpoints[endpoint].data_length	=	length;
						usb_device_enqueue(0, 0, endpoints[endpoint].data_buffer, endpoints[endpoint].packetsize);
9d0067e0:	92470004 	lbu	a3,4(s2)
9d0067e4:	25060010 	addiu	a2,t0,16
				{
					// host is sending data
					if (length)
					{
						// we will receive data, TOKEN_OUT(s) will follow
						endpoints[endpoint].data_length	=	length;
9d0067e8:	ae42000c 	sw	v0,12(s2)
						usb_device_enqueue(0, 0, endpoints[endpoint].data_buffer, endpoints[endpoint].packetsize);
9d0067ec:	00002021 	move	a0,zero
9d0067f0:	00002821 	move	a1,zero
9d0067f4:	0f401841 	jal	9d006104 <usb_device_enqueue>
9d0067f8:	02263021 	addu	a2,s1,a2
			// we just received or sent data from or to the host
			assert(gBulk_transfer_cbfn);
			gBulk_transfer_cbfn(pid == TOKEN_IN, data, bc);
		}

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_TOK_DNE;
9d0067fc:	24020008 	li	v0,8
9d006800:	0b401938 	j	9d0064e0 <IntUSB1Handler+0x2dc>
9d006804:	ae025200 	sw	v0,20992(s0)
					}
					else
					{
						// data transfer is done; put it to our caller!
						assert(gControl_transfer_cbfn);
						rv	=	gControl_transfer_cbfn((struct setup *)setup_buffer, NULL, 0);
9d006808:	27848094 	addiu	a0,gp,-32620
9d00680c:	00002821 	move	a1,zero
9d006810:	0040f809 	jalr	v0
9d006814:	00003021 	move	a2,zero

						// status uses data1
						assert(endpoints[endpoint].toggle[1] == BD_FLAGS_DATA);

						// prepare to transfer status (in the other direction)
						usb_device_enqueue(0, 1, NULL, 0);
9d006818:	0b4019ec 	j	9d0067b0 <IntUSB1Handler+0x5ac>
9d00681c:	00002021 	move	a0,zero
			if (! (setup->requesttype & 0x60))
			{
				value	=	TF_LITTLE(setup->value);
				if (setup->request == REQUEST_GET_DESCRIPTOR)
				{
					endpoints[endpoint].data_pid	=	TOKEN_IN;
9d006820:	a2440006 	sb	a0,6(s2)

					if ((value >> 8) == DEVICE_DESCRIPTOR)
9d006824:	00091a03 	sra	v1,t1,0x8
9d006828:	24040001 	li	a0,1
9d00682c:	50640080 	beql	v1,a0,9d006a30 <IntUSB1Handler+0x82c>
9d006830:	8f838080 	lw	v1,-32640(gp)
					{
						assert(device_descriptor_length);
						endpoints[endpoint].data_length	=	MIN(device_descriptor_length, length);
						memcpy(endpoints[endpoint].data_buffer, device_descriptor, endpoints[endpoint].data_length);
					}
					else if ((value >> 8) == CONFIGURATION_DESCRIPTOR)
9d006834:	24040002 	li	a0,2
9d006838:	50640095 	beql	v1,a0,9d006a90 <IntUSB1Handler+0x88c>
9d00683c:	8f838078 	lw	v1,-32648(gp)
					{
						assert(configuration_descriptor_length);
						endpoints[endpoint].data_length	=	MIN(configuration_descriptor_length, length);
						memcpy(endpoints[endpoint].data_buffer, configuration_descriptor, endpoints[endpoint].data_length);
					}
					else if ((value >> 8) == STRING_DESCRIPTOR)
9d006840:	24040003 	li	a0,3
9d006844:	1064005a 	beq	v1,a0,9d0069b0 <IntUSB1Handler+0x7ac>
9d006848:	312900ff 	andi	t1,t1,0xff
							assert(string_descriptor[j]);
							endpoints[endpoint].data_length	=	MIN(string_descriptor[j], length);
							memcpy(endpoints[endpoint].data_buffer, string_descriptor+j, endpoints[endpoint].data_length);
						}
					}
					else if ((value >> 8) == DEVICE_QUALIFIER_DESCRIPTOR)
9d00684c:	50650001 	beql	v1,a1,9d006854 <IntUSB1Handler+0x650>
9d006850:	ae40000c 	sw	zero,12(s2)
					{
						endpoints[endpoint].data_length	=	0;
9d006854:	00001021 	move	v0,zero
						assert(0);
					}

					// data phase starts with data1
					assert(endpoints[endpoint].toggle[1] == BD_FLAGS_DATA);
					usb_device_enqueue(0, 1, endpoints[endpoint].data_buffer, MIN(endpoints[endpoint].data_length, endpoints[endpoint].packetsize));
9d006858:	02933023 	subu	a2,s4,s3
9d00685c:	02261821 	addu	v1,s1,a2
9d006860:	90630004 	lbu	v1,4(v1)
9d006864:	24c60010 	addiu	a2,a2,16
9d006868:	00002021 	move	a0,zero
9d00686c:	0062382a 	slt	a3,v1,v0
9d006870:	00602821 	move	a1,v1
9d006874:	0047280a 	movz	a1,v0,a3
9d006878:	00a03821 	move	a3,a1
9d00687c:	02263021 	addu	a2,s1,a2
9d006880:	0f401841 	jal	9d006104 <usb_device_enqueue>
9d006884:	24050001 	li	a1,1
			// we just received or sent data from or to the host
			assert(gBulk_transfer_cbfn);
			gBulk_transfer_cbfn(pid == TOKEN_IN, data, bc);
		}

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_TOK_DNE;
9d006888:	24020008 	li	v0,8
9d00688c:	0b401938 	j	9d0064e0 <IntUSB1Handler+0x2dc>
9d006890:	ae025200 	sw	v0,20992(s0)

			// if this is part of the data transfer...
			if (pid == endpoints[endpoint].data_pid)
			{
				assert((char *)data >= (char *)endpoints[endpoint].data_buffer && (char *)data < (char *)endpoints[endpoint].data_buffer+sizeof(endpoints[endpoint].data_buffer));
				if (pid == TOKEN_IN)
9d006894:	24020009 	li	v0,9
9d006898:	1082001a 	beq	a0,v0,9d006904 <IntUSB1Handler+0x700>
9d00689c:	8e220008 	lw	v0,8(s1)
					// we just received data from the host
					endpoints[endpoint].data_offset += bc;
					assert(endpoints[endpoint].data_offset <= endpoints[endpoint].data_length);

					// if there's more data to receive...
					if (endpoints[endpoint].data_offset != endpoints[endpoint].data_length)
9d0068a0:	8e27000c 	lw	a3,12(s1)
				}
				else
				{
					assert(! tx);
					// we just received data from the host
					endpoints[endpoint].data_offset += bc;
9d0068a4:	00c21021 	addu	v0,a2,v0
					assert(endpoints[endpoint].data_offset <= endpoints[endpoint].data_length);

					// if there's more data to receive...
					if (endpoints[endpoint].data_offset != endpoints[endpoint].data_length)
9d0068a8:	10470025 	beq	v0,a3,9d006940 <IntUSB1Handler+0x73c>
9d0068ac:	ae220008 	sw	v0,8(s1)
					{
						// receive it
						usb_device_enqueue(0, 0, endpoints[endpoint].data_buffer+endpoints[endpoint].data_offset, endpoints[endpoint].data_length-endpoints[endpoint].data_offset);
9d0068b0:	24460010 	addiu	a2,v0,16
9d0068b4:	00e23823 	subu	a3,a3,v0
9d0068b8:	00002021 	move	a0,zero
9d0068bc:	00002821 	move	a1,zero
9d0068c0:	0f401841 	jal	9d006104 <usb_device_enqueue>
9d0068c4:	02263021 	addu	a2,s1,a2
			// we just received or sent data from or to the host
			assert(gBulk_transfer_cbfn);
			gBulk_transfer_cbfn(pid == TOKEN_IN, data, bc);
		}

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_TOK_DNE;
9d0068c8:	24020008 	li	v0,8
9d0068cc:	0b401938 	j	9d0064e0 <IntUSB1Handler+0x2dc>
9d0068d0:	ae025200 	sw	v0,20992(s0)
				{
					if (setup->request == REQUEST_CLEAR_FEATURE)
					{
						assert(! length);
						// if we're recovering from an error...
						if (setup->requesttype == 0x02 && ! value)
9d0068d4:	5462ffb6 	bnel	v1,v0,9d0067b0 <IntUSB1Handler+0x5ac>
9d0068d8:	00002021 	move	a0,zero
9d0068dc:	5520ffb4 	bnezl	t1,9d0067b0 <IntUSB1Handler+0x5ac>
9d0068e0:	00002021 	move	a0,zero
						{
							endpoint2	=	TF_LITTLE(setup->index) & 0x0f;
9d0068e4:	90830004 	lbu	v1,4(a0)
							assert(endpoint2);
							// clear the data toggle
							endpoints[endpoint2].toggle[0]	=	0;
9d0068e8:	24020060 	li	v0,96
					{
						assert(! length);
						// if we're recovering from an error...
						if (setup->requesttype == 0x02 && ! value)
						{
							endpoint2	=	TF_LITTLE(setup->index) & 0x0f;
9d0068ec:	3063000f 	andi	v1,v1,0xf
							assert(endpoint2);
							// clear the data toggle
							endpoints[endpoint2].toggle[0]	=	0;
9d0068f0:	70622002 	mul	a0,v1,v0
9d0068f4:	00918821 	addu	s1,a0,s1
9d0068f8:	a2200000 	sb	zero,0(s1)
							endpoints[endpoint2].toggle[1]	=	0;
9d0068fc:	0b4019eb 	j	9d0067ac <IntUSB1Handler+0x5a8>
9d006900:	a2200001 	sb	zero,1(s1)
					// we just sent data to the host
					endpoints[endpoint].data_offset += bc;
					assert(endpoints[endpoint].data_offset <= endpoints[endpoint].data_length);

					// if there's more data to send...
					if (endpoints[endpoint].data_offset != endpoints[endpoint].data_length)
9d006904:	8e27000c 	lw	a3,12(s1)
				assert((char *)data >= (char *)endpoints[endpoint].data_buffer && (char *)data < (char *)endpoints[endpoint].data_buffer+sizeof(endpoints[endpoint].data_buffer));
				if (pid == TOKEN_IN)
				{
					assert(tx);
					// we just sent data to the host
					endpoints[endpoint].data_offset += bc;
9d006908:	00c21021 	addu	v0,a2,v0
					assert(endpoints[endpoint].data_offset <= endpoints[endpoint].data_length);

					// if there's more data to send...
					if (endpoints[endpoint].data_offset != endpoints[endpoint].data_length)
9d00690c:	10470040 	beq	v0,a3,9d006a10 <IntUSB1Handler+0x80c>
9d006910:	ae220008 	sw	v0,8(s1)
					{
						// send it
						usb_device_enqueue(0, 1, endpoints[endpoint].data_buffer+endpoints[endpoint].data_offset, endpoints[endpoint].data_length-endpoints[endpoint].data_offset);
9d006914:	24460010 	addiu	a2,v0,16
9d006918:	00e23823 	subu	a3,a3,v0
9d00691c:	00002021 	move	a0,zero
9d006920:	24050001 	li	a1,1
9d006924:	0f401841 	jal	9d006104 <usb_device_enqueue>
9d006928:	02263021 	addu	a2,s1,a2
			// we just received or sent data from or to the host
			assert(gBulk_transfer_cbfn);
			gBulk_transfer_cbfn(pid == TOKEN_IN, data, bc);
		}

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_TOK_DNE;
9d00692c:	24020008 	li	v0,8
9d006930:	0b401938 	j	9d0064e0 <IntUSB1Handler+0x2dc>
9d006934:	ae025200 	sw	v0,20992(s0)
							assert(0);
						}
					}
					else if (setup->request == REQUEST_SET_ADDRESS)
					{
						next_address	=	value;
9d006938:	0b4019eb 	j	9d0067ac <IntUSB1Handler+0x5a8>
9d00693c:	a3898090 	sb	t1,-32624(gp)
					}
					else
					{
						// put it to our caller!
						assert(gControl_transfer_cbfn);
						rv	=	gControl_transfer_cbfn((struct setup *)setup_buffer, endpoints[endpoint].data_buffer, endpoints[endpoint].data_length);
9d006940:	00403021 	move	a2,v0
9d006944:	8f828088 	lw	v0,-32632(gp)
9d006948:	3c05a000 	lui	a1,0xa000
9d00694c:	24a517a0 	addiu	a1,a1,6048
9d006950:	0040f809 	jalr	v0
9d006954:	27848094 	addiu	a0,gp,-32620

						// status uses data1
						assert(endpoints[endpoint].toggle[1] == BD_FLAGS_DATA);

						// prepare to transfer status (in the other direction)
						usb_device_enqueue(0, 1, NULL, 0);
9d006958:	0b4019ec 	j	9d0067b0 <IntUSB1Handler+0x5ac>
9d00695c:	00002021 	move	a0,zero
			{
				if (setup->requesttype & 0x80/*in*/)
				{
					// host wants to receive data, get it from our caller!
					assert(gControl_transfer_cbfn);
					rv	=	gControl_transfer_cbfn(setup, endpoints[endpoint].data_buffer, length);
9d006960:	00403021 	move	a2,v0
9d006964:	8f828088 	lw	v0,-32632(gp)
9d006968:	02288821 	addu	s1,s1,t0
9d00696c:	0040f809 	jalr	v0
9d006970:	02202821 	move	a1,s1
					assert(rv >= 0);
					assert(rv <= length);

					// prepare to send data, TOKEN_IN(s) will follow
					endpoints[endpoint].data_pid	=	TOKEN_IN;
9d006974:	24030009 	li	v1,9
					assert(rv > 0);	// if you don't have a length, use out!
					endpoints[endpoint].data_length	=	rv;
					usb_device_enqueue(0, 1, endpoints[endpoint].data_buffer, endpoints[endpoint].data_length);
9d006978:	00403821 	move	a3,v0
					assert(rv <= length);

					// prepare to send data, TOKEN_IN(s) will follow
					endpoints[endpoint].data_pid	=	TOKEN_IN;
					assert(rv > 0);	// if you don't have a length, use out!
					endpoints[endpoint].data_length	=	rv;
9d00697c:	ae42000c 	sw	v0,12(s2)
					usb_device_enqueue(0, 1, endpoints[endpoint].data_buffer, endpoints[endpoint].data_length);
9d006980:	00002021 	move	a0,zero
9d006984:	24050001 	li	a1,1
9d006988:	02203021 	move	a2,s1
9d00698c:	0f401841 	jal	9d006104 <usb_device_enqueue>
9d006990:	a2430006 	sb	v1,6(s2)
			// we just received or sent data from or to the host
			assert(gBulk_transfer_cbfn);
			gBulk_transfer_cbfn(pid == TOKEN_IN, data, bc);
		}

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_TOK_DNE;
9d006994:	24020008 	li	v0,8
9d006998:	0b401938 	j	9d0064e0 <IntUSB1Handler+0x2dc>
9d00699c:	ae025200 	sw	v0,20992(s0)
						next_address	=	value;
					}
					else if (setup->request == REQUEST_SET_CONFIGURATION)
					{
						assert(value == 1);
						gCdcacm_attached_count++;
9d0069a0:	8f8280d4 	lw	v0,-32556(gp)
9d0069a4:	24420001 	addiu	v0,v0,1
9d0069a8:	0b4019eb 	j	9d0067ac <IntUSB1Handler+0x5a8>
9d0069ac:	af8280d4 	sw	v0,-32556(gp)
						int j;

						// find the string descriptor
						i	=	value & 0xff;
						j	=	0;
						while (i-- && j < string_descriptor_length)
9d0069b0:	2524ffff 	addiu	a0,t1,-1
9d0069b4:	1120000e 	beqz	t1,9d0069f0 <IntUSB1Handler+0x7ec>
9d0069b8:	00001821 	move	v1,zero
9d0069bc:	8f868070 	lw	a2,-32656(gp)
9d0069c0:	18c0000b 	blez	a2,9d0069f0 <IntUSB1Handler+0x7ec>
9d0069c4:	8f89806c 	lw	t1,-32660(gp)
9d0069c8:	0b401a76 	j	9d0069d8 <IntUSB1Handler+0x7d4>
9d0069cc:	2408ffff 	li	t0,-1
9d0069d0:	50a00008 	beqzl	a1,9d0069f4 <IntUSB1Handler+0x7f0>
9d0069d4:	2405ffff 	li	a1,-1
						{
							j += string_descriptor[j];
9d0069d8:	01232821 	addu	a1,t1,v1
9d0069dc:	90a50000 	lbu	a1,0(a1)
						int j;

						// find the string descriptor
						i	=	value & 0xff;
						j	=	0;
						while (i-- && j < string_descriptor_length)
9d0069e0:	2484ffff 	addiu	a0,a0,-1
						{
							j += string_descriptor[j];
9d0069e4:	00651821 	addu	v1,v1,a1
						int j;

						// find the string descriptor
						i	=	value & 0xff;
						j	=	0;
						while (i-- && j < string_descriptor_length)
9d0069e8:	1488fff9 	bne	a0,t0,9d0069d0 <IntUSB1Handler+0x7cc>
9d0069ec:	0066282a 	slt	a1,v1,a2
						{
							j += string_descriptor[j];
						}
						if (i != -1)
9d0069f0:	2405ffff 	li	a1,-1
9d0069f4:	50850028 	beql	a0,a1,9d006a98 <IntUSB1Handler+0x894>
9d0069f8:	24120060 	li	s2,96
						{
							assert(j == string_descriptor_length);
							endpoints[endpoint].data_length	=	0;	// what to return here?
9d0069fc:	02931023 	subu	v0,s4,s3
9d006a00:	02221021 	addu	v0,s1,v0
9d006a04:	ac40000c 	sw	zero,12(v0)
9d006a08:	0b401a16 	j	9d006858 <IntUSB1Handler+0x654>
9d006a0c:	00001021 	move	v0,zero
					{
						// status uses data1
						assert(endpoints[endpoint].toggle[0] == BD_FLAGS_DATA);

						// prepare to transfer status (in the other direction)
						usb_device_enqueue(0, 0, NULL, 0);
9d006a10:	00002021 	move	a0,zero
9d006a14:	00002821 	move	a1,zero
9d006a18:	00003021 	move	a2,zero
9d006a1c:	0f401841 	jal	9d006104 <usb_device_enqueue>
9d006a20:	00003821 	move	a3,zero
			// we just received or sent data from or to the host
			assert(gBulk_transfer_cbfn);
			gBulk_transfer_cbfn(pid == TOKEN_IN, data, bc);
		}

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_TOK_DNE;
9d006a24:	24020008 	li	v0,8
9d006a28:	0b401938 	j	9d0064e0 <IntUSB1Handler+0x2dc>
9d006a2c:	ae025200 	sw	v0,20992(s0)

					if ((value >> 8) == DEVICE_DESCRIPTOR)
					{
						assert(device_descriptor_length);
						endpoints[endpoint].data_length	=	MIN(device_descriptor_length, length);
						memcpy(endpoints[endpoint].data_buffer, device_descriptor, endpoints[endpoint].data_length);
9d006a30:	8f85807c 	lw	a1,-32644(gp)
					}
					else if ((value >> 8) == CONFIGURATION_DESCRIPTOR)
					{
						assert(configuration_descriptor_length);
						endpoints[endpoint].data_length	=	MIN(configuration_descriptor_length, length);
9d006a34:	0062302a 	slt	a2,v1,v0
9d006a38:	0066100b 	movn	v0,v1,a2
						memcpy(endpoints[endpoint].data_buffer, configuration_descriptor, endpoints[endpoint].data_length);
9d006a3c:	25040010 	addiu	a0,t0,16
9d006a40:	02242021 	addu	a0,s1,a0
9d006a44:	00403021 	move	a2,v0
9d006a48:	0f401eca 	jal	9d007b28 <memcpy>
9d006a4c:	ae42000c 	sw	v0,12(s2)
9d006a50:	0b401a16 	j	9d006858 <IntUSB1Handler+0x654>
9d006a54:	8e42000c 	lw	v0,12(s2)
						endpoints[endpoint].data_length	=	1;
						endpoints[endpoint].data_buffer[0]	=	1;

						// data phase starts with data1
						assert(endpoints[endpoint].toggle[1] == BD_FLAGS_DATA);
						usb_device_enqueue(0, 1, endpoints[endpoint].data_buffer, MIN(endpoints[endpoint].data_length, endpoints[endpoint].packetsize));
9d006a58:	25060010 	addiu	a2,t0,16
					}
					else if (setup->request == REQUEST_GET_CONFIGURATION)
					{
						endpoints[endpoint].data_pid	=	TOKEN_IN;

						endpoints[endpoint].data_length	=	1;
9d006a5c:	ae42000c 	sw	v0,12(s2)
						endpoints[endpoint].data_buffer[0]	=	1;

						// data phase starts with data1
						assert(endpoints[endpoint].toggle[1] == BD_FLAGS_DATA);
						usb_device_enqueue(0, 1, endpoints[endpoint].data_buffer, MIN(endpoints[endpoint].data_length, endpoints[endpoint].packetsize));
9d006a60:	0045382a 	slt	a3,v0,a1
9d006a64:	0047280b 	movn	a1,v0,a3
9d006a68:	00a03821 	move	a3,a1
					else if (setup->request == REQUEST_GET_CONFIGURATION)
					{
						endpoints[endpoint].data_pid	=	TOKEN_IN;

						endpoints[endpoint].data_length	=	1;
						endpoints[endpoint].data_buffer[0]	=	1;
9d006a6c:	a2420010 	sb	v0,16(s2)

						// data phase starts with data1
						assert(endpoints[endpoint].toggle[1] == BD_FLAGS_DATA);
						usb_device_enqueue(0, 1, endpoints[endpoint].data_buffer, MIN(endpoints[endpoint].data_length, endpoints[endpoint].packetsize));
9d006a70:	00002021 	move	a0,zero
9d006a74:	24050001 	li	a1,1
9d006a78:	02263021 	addu	a2,s1,a2
9d006a7c:	0f401841 	jal	9d006104 <usb_device_enqueue>
9d006a80:	a2430006 	sb	v1,6(s2)
			// we just received or sent data from or to the host
			assert(gBulk_transfer_cbfn);
			gBulk_transfer_cbfn(pid == TOKEN_IN, data, bc);
		}

		MCF_USB_OTG_INT_STAT	=	MCF_USB_OTG_INT_STAT_TOK_DNE;
9d006a84:	24020008 	li	v0,8
9d006a88:	0b401938 	j	9d0064e0 <IntUSB1Handler+0x2dc>
9d006a8c:	ae025200 	sw	v0,20992(s0)
					}
					else if ((value >> 8) == CONFIGURATION_DESCRIPTOR)
					{
						assert(configuration_descriptor_length);
						endpoints[endpoint].data_length	=	MIN(configuration_descriptor_length, length);
						memcpy(endpoints[endpoint].data_buffer, configuration_descriptor, endpoints[endpoint].data_length);
9d006a90:	0b401a8d 	j	9d006a34 <IntUSB1Handler+0x830>
9d006a94:	8f858074 	lw	a1,-32652(gp)
							endpoints[endpoint].data_length	=	0;	// what to return here?
						}
						else
						{
							assert(string_descriptor[j]);
							endpoints[endpoint].data_length	=	MIN(string_descriptor[j], length);
9d006a98:	70f29002 	mul	s2,a3,s2
9d006a9c:	8f85806c 	lw	a1,-32660(gp)
9d006aa0:	00a32821 	addu	a1,a1,v1
9d006aa4:	90a30000 	lbu	v1,0(a1)
9d006aa8:	0043202a 	slt	a0,v0,v1
9d006aac:	0064100a 	movz	v0,v1,a0
							memcpy(endpoints[endpoint].data_buffer, string_descriptor+j, endpoints[endpoint].data_length);
9d006ab0:	00403021 	move	a2,v0
9d006ab4:	26440010 	addiu	a0,s2,16
							endpoints[endpoint].data_length	=	0;	// what to return here?
						}
						else
						{
							assert(string_descriptor[j]);
							endpoints[endpoint].data_length	=	MIN(string_descriptor[j], length);
9d006ab8:	02329021 	addu	s2,s1,s2
							memcpy(endpoints[endpoint].data_buffer, string_descriptor+j, endpoints[endpoint].data_length);
9d006abc:	02242021 	addu	a0,s1,a0
9d006ac0:	0f401eca 	jal	9d007b28 <memcpy>
9d006ac4:	ae42000c 	sw	v0,12(s2)
9d006ac8:	0b401a16 	j	9d006858 <IntUSB1Handler+0x654>
9d006acc:	8e42000c 	lw	v0,12(s2)

9d006ad0 <usb_register>:
// this function is called by upper level code to register callback
// functions.
//************************************************************************
void	usb_register(usb_reset_cbfn reset, usb_control_cbfn control_transfer, usb_bulk_cbfn bulk_transfer)
{
	gReset_cbfn				=	reset;
9d006ad0:	af848084 	sw	a0,-32636(gp)
	gControl_transfer_cbfn	=	control_transfer;
9d006ad4:	af858088 	sw	a1,-32632(gp)
	gBulk_transfer_cbfn		=	bulk_transfer;
}
9d006ad8:	03e00008 	jr	ra
9d006adc:	af86808c 	sw	a2,-32628(gp)

9d006ae0 <usb_device_descriptor>:
// called by upper level code to specify the device descriptor to
// return to the host.
//************************************************************************
void	usb_device_descriptor(const byte *descriptor, int length)
{
	device_descriptor = descriptor;
9d006ae0:	af84807c 	sw	a0,-32644(gp)
	device_descriptor_length = length;
}
9d006ae4:	03e00008 	jr	ra
9d006ae8:	af858080 	sw	a1,-32640(gp)

9d006aec <usb_configuration_descriptor>:
// called by upper level code to specify the configuration descriptor
// to return to the host.
//************************************************************************
void	usb_configuration_descriptor(const byte *descriptor, int length)
{
	configuration_descriptor = descriptor;
9d006aec:	af848074 	sw	a0,-32652(gp)
	configuration_descriptor_length = length;
}
9d006af0:	03e00008 	jr	ra
9d006af4:	af858078 	sw	a1,-32648(gp)

9d006af8 <usb_string_descriptor>:
// called by upper level code to specify the string descriptors to
// return to the host.
//************************************************************************
void	usb_string_descriptor(const byte *descriptor, int length)
{
	string_descriptor = descriptor;
9d006af8:	af84806c 	sw	a0,-32660(gp)
	string_descriptor_length = length;
}
9d006afc:	03e00008 	jr	ra
9d006b00:	af858070 	sw	a1,-32656(gp)

9d006b04 <usb_initialize>:
void	usb_initialize(void)
{
	static __attribute__ ((aligned(512))) byte bdt_ram[BDT_RAM_SIZE];

#ifdef _USE_USB_IRQ_
    setIntVector(_USB_1_VECTOR, IntUSB1Handler);
9d006b04:	3c059d00 	lui	a1,0x9d00
#endif
}

//************************************************************************
void	usb_initialize(void)
{
9d006b08:	27bdffe8 	addiu	sp,sp,-24
	static __attribute__ ((aligned(512))) byte bdt_ram[BDT_RAM_SIZE];

#ifdef _USE_USB_IRQ_
    setIntVector(_USB_1_VECTOR, IntUSB1Handler);
9d006b0c:	2404002d 	li	a0,45
#endif
}

//************************************************************************
void	usb_initialize(void)
{
9d006b10:	afbf0014 	sw	ra,20(sp)
	static __attribute__ ((aligned(512))) byte bdt_ram[BDT_RAM_SIZE];

#ifdef _USE_USB_IRQ_
    setIntVector(_USB_1_VECTOR, IntUSB1Handler);
9d006b14:	0f4012bf 	jal	9d004afc <setIntVector>
9d006b18:	24a56204 	addiu	a1,a1,25092
	bdts = (struct bdt *)bdt_ram;

	assert(BDT_RAM_SIZE >= LENGTHOF(endpoints)*4*sizeof(struct bdt));

	// power on
	U1PWRCbits.USBPWR = 1;
9d006b1c:	3c03bf88 	lui	v1,0xbf88
9d006b20:	8c655080 	lw	a1,20608(v1)
9d006b24:	24020001 	li	v0,1
    /// TODO: Plib replacement function should go here
	IEC1bits.USBIE = 1;
    IPC7bits.USBIP = 6;
    IPC7bits.USBIS = 0;
#else
	IEC1bits.USBIE = 1;
9d006b28:	3c04bf88 	lui	a0,0xbf88
	bdts = (struct bdt *)bdt_ram;

	assert(BDT_RAM_SIZE >= LENGTHOF(endpoints)*4*sizeof(struct bdt));

	// power on
	U1PWRCbits.USBPWR = 1;
9d006b2c:	7c450004 	ins	a1,v0,0x0,0x1
9d006b30:	ac655080 	sw	a1,20608(v1)
    /// TODO: Plib replacement function should go here
	IEC1bits.USBIE = 1;
    IPC7bits.USBIP = 6;
    IPC7bits.USBIS = 0;
#else
	IEC1bits.USBIE = 1;
9d006b34:	8c851070 	lw	a1,4208(a0)
	IPC11bits.USBIP = 6;
9d006b38:	3c03bf88 	lui	v1,0xbf88
9d006b3c:	24060006 	li	a2,6
    /// TODO: Plib replacement function should go here
	IEC1bits.USBIE = 1;
    IPC7bits.USBIP = 6;
    IPC7bits.USBIS = 0;
#else
	IEC1bits.USBIE = 1;
9d006b40:	7c45ce44 	ins	a1,v0,0x19,0x1
9d006b44:	ac851070 	sw	a1,4208(a0)
	IPC11bits.USBIP = 6;
9d006b48:	8c641140 	lw	a0,4416(v1)

#ifdef _USE_USB_IRQ_
    setIntVector(_USB_1_VECTOR, IntUSB1Handler);
#endif

	bdts = (struct bdt *)bdt_ram;
9d006b4c:	3c05a000 	lui	a1,0xa000
9d006b50:	24a51400 	addiu	a1,a1,5120
	IEC1bits.USBIE = 1;
    IPC7bits.USBIP = 6;
    IPC7bits.USBIS = 0;
#else
	IEC1bits.USBIE = 1;
	IPC11bits.USBIP = 6;
9d006b54:	7cc46284 	ins	a0,a2,0xa,0x3
9d006b58:	ac641140 	sw	a0,4416(v1)
	IPC11bits.USBIS = 0;
9d006b5c:	8c661140 	lw	a2,4416(v1)

	MCF_USB_OTG_SOF_THLD = 74;

	// initialize usb bdt
	assert(! ((unsigned int)bdts & 0x1ff));
	MCF_USB_OTG_BDT_PAGE_01 = (uint8)(KVA_TO_PA((unsigned int)bdts) >> 8);
9d006b60:	7ca4e000 	ext	a0,a1,0x0,0x1d

#ifdef _USE_USB_IRQ_
    setIntVector(_USB_1_VECTOR, IntUSB1Handler);
#endif

	bdts = (struct bdt *)bdt_ram;
9d006b64:	af858068 	sw	a1,-32664(gp)
    IPC7bits.USBIP = 6;
    IPC7bits.USBIS = 0;
#else
	IEC1bits.USBIE = 1;
	IPC11bits.USBIP = 6;
	IPC11bits.USBIS = 0;
9d006b68:	7c064a04 	ins	a2,zero,0x8,0x2
9d006b6c:	ac661140 	sw	a2,4416(v1)
#endif
#endif

	MCF_USB_OTG_SOF_THLD = 74;
9d006b70:	2405004a 	li	a1,74
9d006b74:	3c03bf88 	lui	v1,0xbf88
9d006b78:	ac6552b0 	sw	a1,21168(v1)

	// initialize usb bdt
	assert(! ((unsigned int)bdts & 0x1ff));
	MCF_USB_OTG_BDT_PAGE_01 = (uint8)(KVA_TO_PA((unsigned int)bdts) >> 8);
9d006b7c:	7c883a00 	ext	t0,a0,0x8,0x8
9d006b80:	3c03bf88 	lui	v1,0xbf88
9d006b84:	ac685270 	sw	t0,21104(v1)
	MCF_USB_OTG_BDT_PAGE_02 = (uint8)(KVA_TO_PA((unsigned int)bdts) >> 16);
9d006b88:	7c873c00 	ext	a3,a0,0x10,0x8
9d006b8c:	3c03bf88 	lui	v1,0xbf88
9d006b90:	ac6752c0 	sw	a3,21184(v1)
	MCF_USB_OTG_BDT_PAGE_03 = (uint8)(KVA_TO_PA((unsigned int)bdts) >> 24);
9d006b94:	00042602 	srl	a0,a0,0x18
9d006b98:	3c03bf88 	lui	v1,0xbf88
9d006b9c:	ac6452d0 	sw	a0,21200(v1)
// for a usb reset from the host.
//************************************************************************
static void	usb_device_wait()
{
	// enable usb device mode
	MCF_USB_OTG_CTL			=	MCF_USB_OTG_CTL_USB_EN_SOF_EN;
9d006ba0:	3c03bf88 	lui	v1,0xbf88
9d006ba4:	ac625250 	sw	v0,21072(v1)

	// enable usb pull ups
	MCF_USB_OTG_OTG_CTRL	=	MCF_USB_OTG_OTG_CTRL_DP_HIGH|MCF_USB_OTG_OTG_CTRL_OTG_EN;
9d006ba8:	24040084 	li	a0,132
9d006bac:	3c03bf88 	lui	v1,0xbf88
	MCF_USB_OTG_BDT_PAGE_02 = (uint8)(KVA_TO_PA((unsigned int)bdts) >> 16);
	MCF_USB_OTG_BDT_PAGE_03 = (uint8)(KVA_TO_PA((unsigned int)bdts) >> 24);

	// enable usb to interrupt on reset
	usb_device_wait();
}
9d006bb0:	8fbf0014 	lw	ra,20(sp)
{
	// enable usb device mode
	MCF_USB_OTG_CTL			=	MCF_USB_OTG_CTL_USB_EN_SOF_EN;

	// enable usb pull ups
	MCF_USB_OTG_OTG_CTRL	=	MCF_USB_OTG_OTG_CTRL_DP_HIGH|MCF_USB_OTG_OTG_CTRL_OTG_EN;
9d006bb4:	ac645070 	sw	a0,20592(v1)

	// enable (only) usb reset interrupt
	MCF_USB_OTG_INT_STAT	=	0xff;
9d006bb8:	3c03bf88 	lui	v1,0xbf88
9d006bbc:	240400ff 	li	a0,255
9d006bc0:	ac645200 	sw	a0,20992(v1)
	MCF_USB_OTG_INT_ENB		=	MCF_USB_OTG_INT_ENB_USB_RST_EN;
9d006bc4:	3c03bf88 	lui	v1,0xbf88
9d006bc8:	ac625210 	sw	v0,21008(v1)
	MCF_USB_OTG_BDT_PAGE_02 = (uint8)(KVA_TO_PA((unsigned int)bdts) >> 16);
	MCF_USB_OTG_BDT_PAGE_03 = (uint8)(KVA_TO_PA((unsigned int)bdts) >> 24);

	// enable usb to interrupt on reset
	usb_device_wait();
}
9d006bcc:	03e00008 	jr	ra
9d006bd0:	27bd0018 	addiu	sp,sp,24

9d006bd4 <cdcacm_bulk_transfer>:

//************************************************************************
// this function implements the CDCACM usb bulk transfer.
//************************************************************************
static int	cdcacm_bulk_transfer(boolean in, byte *buffer, int length)
{
9d006bd4:	27bdffe8 	addiu	sp,sp,-24
9d006bd8:	308200ff 	andi	v0,a0,0xff
9d006bdc:	afbf0014 	sw	ra,20(sp)
	if (! in)
9d006be0:	1040002d 	beqz	v0,9d006c98 <cdcacm_bulk_transfer+0xc4>
9d006be4:	afb00010 	sw	s0,16(sp)
			gWaiting	=	true;
		}
	}
	else
	{
		gRX_length[gRX_out]	=	0;
9d006be8:	938480a9 	lbu	a0,-32599(gp)
		gRX_out	=	(gRX_out+1)%NRX;
9d006bec:	938280a9 	lbu	v0,-32599(gp)
			gWaiting	=	true;
		}
	}
	else
	{
		gRX_length[gRX_out]	=	0;
9d006bf0:	3c03a000 	lui	v1,0xa000
9d006bf4:	308400ff 	andi	a0,a0,0xff
		gRX_out	=	(gRX_out+1)%NRX;
9d006bf8:	24420001 	addiu	v0,v0,1
9d006bfc:	30420003 	andi	v0,v0,0x3
9d006c00:	a38280a9 	sb	v0,-32599(gp)

		// if there is more data to transfer...
		if (gRX_length[gRX_out] > 0)
9d006c04:	938280a9 	lbu	v0,-32599(gp)
			gWaiting	=	true;
		}
	}
	else
	{
		gRX_length[gRX_out]	=	0;
9d006c08:	24631600 	addiu	v1,v1,5632
9d006c0c:	00042080 	sll	a0,a0,0x2
		gRX_out	=	(gRX_out+1)%NRX;

		// if there is more data to transfer...
		if (gRX_length[gRX_out] > 0)
9d006c10:	304200ff 	andi	v0,v0,0xff
			gWaiting	=	true;
		}
	}
	else
	{
		gRX_length[gRX_out]	=	0;
9d006c14:	00642021 	addu	a0,v1,a0
		gRX_out	=	(gRX_out+1)%NRX;

		// if there is more data to transfer...
		if (gRX_length[gRX_out] > 0)
9d006c18:	00021080 	sll	v0,v0,0x2
			gWaiting	=	true;
		}
	}
	else
	{
		gRX_length[gRX_out]	=	0;
9d006c1c:	ac800000 	sw	zero,0(a0)
		gRX_out	=	(gRX_out+1)%NRX;

		// if there is more data to transfer...
		if (gRX_length[gRX_out] > 0)
9d006c20:	00621021 	addu	v0,v1,v0
9d006c24:	8c420000 	lw	v0,0(v0)
9d006c28:	18400017 	blez	v0,9d006c88 <cdcacm_bulk_transfer+0xb4>
9d006c2c:	8fbf0014 	lw	ra,20(sp)
		{
			if (gRX_in == gRX_out)
9d006c30:	938480aa 	lbu	a0,-32598(gp)
9d006c34:	938280a9 	lbu	v0,-32599(gp)
9d006c38:	308400ff 	andi	a0,a0,0xff
9d006c3c:	304200ff 	andi	v0,v0,0xff
9d006c40:	10820022 	beq	a0,v0,9d006ccc <cdcacm_bulk_transfer+0xf8>
9d006c44:	00000000 	nop
			}

			// keep the rx ball rolling
			assert(gRX_out != gRX_in);
			assert(gRX_length[gRX_out] > 0 && gRX_length[gRX_out] < PACKET_SIZE);
			usb_device_enqueue(bulk_in_ep, 1, gRXbuffer[gRX_out], gRX_length[gRX_out]);
9d006c48:	938280a9 	lbu	v0,-32599(gp)
9d006c4c:	938580a9 	lbu	a1,-32599(gp)
9d006c50:	3c06a000 	lui	a2,0xa000
9d006c54:	304200ff 	andi	v0,v0,0xff
9d006c58:	30a500ff 	andi	a1,a1,0xff
9d006c5c:	00052880 	sll	a1,a1,0x2
9d006c60:	00652821 	addu	a1,v1,a1
9d006c64:	8ca70000 	lw	a3,0(a1)
9d006c68:	00021980 	sll	v1,v0,0x6
9d006c6c:	938480cf 	lbu	a0,-32561(gp)
9d006c70:	00621023 	subu	v0,v1,v0
9d006c74:	24c61650 	addiu	a2,a2,5712
9d006c78:	24050001 	li	a1,1
9d006c7c:	0f401841 	jal	9d006104 <usb_device_enqueue>
9d006c80:	00c23021 	addu	a2,a2,v0
		}
	}

	return 0;
}
9d006c84:	8fbf0014 	lw	ra,20(sp)
9d006c88:	00001021 	move	v0,zero
9d006c8c:	8fb00010 	lw	s0,16(sp)
9d006c90:	03e00008 	jr	ra
9d006c94:	27bd0018 	addiu	sp,sp,24
	if (! in)
	{
		gCdcacm_active	=	true;
		
		// accumulate commands
		if (gStoredata_cbfn(buffer, length))
9d006c98:	8f8280a4 	lw	v0,-32604(gp)
//************************************************************************
static int	cdcacm_bulk_transfer(boolean in, byte *buffer, int length)
{
	if (! in)
	{
		gCdcacm_active	=	true;
9d006c9c:	24100001 	li	s0,1
		
		// accumulate commands
		if (gStoredata_cbfn(buffer, length))
9d006ca0:	00a02021 	move	a0,a1
//************************************************************************
static int	cdcacm_bulk_transfer(boolean in, byte *buffer, int length)
{
	if (! in)
	{
		gCdcacm_active	=	true;
9d006ca4:	a39080de 	sb	s0,-32546(gp)
		
		// accumulate commands
		if (gStoredata_cbfn(buffer, length))
9d006ca8:	0040f809 	jalr	v0
9d006cac:	00c02821 	move	a1,a2
9d006cb0:	1440000c 	bnez	v0,9d006ce4 <cdcacm_bulk_transfer+0x110>
9d006cb4:	00001021 	move	v0,zero
			usb_device_enqueue(bulk_in_ep, 1, gRXbuffer[gRX_out], gRX_length[gRX_out]);
		}
	}

	return 0;
}
9d006cb8:	8fbf0014 	lw	ra,20(sp)
			usb_device_enqueue(bulk_out_ep, 0, gTXbuffer, sizeof(gTXbuffer));
		}
		else
		{
			// drop the ball
			gWaiting	=	true;
9d006cbc:	a39080a8 	sb	s0,-32600(gp)
			usb_device_enqueue(bulk_in_ep, 1, gRXbuffer[gRX_out], gRX_length[gRX_out]);
		}
	}

	return 0;
}
9d006cc0:	8fb00010 	lw	s0,16(sp)
9d006cc4:	03e00008 	jr	ra
9d006cc8:	27bd0018 	addiu	sp,sp,24
		// if there is more data to transfer...
		if (gRX_length[gRX_out] > 0)
		{
			if (gRX_in == gRX_out)
			{
				gRX_in	=	(gRX_in+1)%NRX;
9d006ccc:	938280aa 	lbu	v0,-32598(gp)
9d006cd0:	24420001 	addiu	v0,v0,1
9d006cd4:	30420003 	andi	v0,v0,0x3
9d006cd8:	a38280aa 	sb	v0,-32598(gp)
9d006cdc:	0b401b12 	j	9d006c48 <cdcacm_bulk_transfer+0x74>
9d006ce0:	00000000 	nop
		
		// accumulate commands
		if (gStoredata_cbfn(buffer, length))
		{
			// keep the tx ball rolling
			usb_device_enqueue(bulk_out_ep, 0, gTXbuffer, sizeof(gTXbuffer));
9d006ce4:	938480cd 	lbu	a0,-32563(gp)
9d006ce8:	3c06a000 	lui	a2,0xa000
9d006cec:	00002821 	move	a1,zero
9d006cf0:	24c61610 	addiu	a2,a2,5648
9d006cf4:	0f401841 	jal	9d006104 <usb_device_enqueue>
9d006cf8:	24070040 	li	a3,64
			usb_device_enqueue(bulk_in_ep, 1, gRXbuffer[gRX_out], gRX_length[gRX_out]);
		}
	}

	return 0;
}
9d006cfc:	0b401b22 	j	9d006c88 <cdcacm_bulk_transfer+0xb4>
9d006d00:	8fbf0014 	lw	ra,20(sp)

9d006d04 <cdcacm_reset>:
	{
		gRX_length[i]	=	0;
	}

	// prepare for rx
	usb_device_enqueue(bulk_in_ep, -1, NULL, 0);
9d006d04:	938480cf 	lbu	a0,-32561(gp)
{
	int i;

	for (i=0; i < NRX; i++)
	{
		gRX_length[i]	=	0;
9d006d08:	3c03a000 	lui	v1,0xa000
//************************************************************************
// this function is called by the usb driver when the USB device
// is reset.
//************************************************************************
static void	cdcacm_reset(void)
{
9d006d0c:	27bdffe8 	addiu	sp,sp,-24
	int i;

	for (i=0; i < NRX; i++)
	{
		gRX_length[i]	=	0;
9d006d10:	24621600 	addiu	v0,v1,5632
	}

	// prepare for rx
	usb_device_enqueue(bulk_in_ep, -1, NULL, 0);
9d006d14:	240500ff 	li	a1,255
9d006d18:	00003021 	move	a2,zero
9d006d1c:	00003821 	move	a3,zero
//************************************************************************
// this function is called by the usb driver when the USB device
// is reset.
//************************************************************************
static void	cdcacm_reset(void)
{
9d006d20:	afbf0014 	sw	ra,20(sp)
	int i;

	for (i=0; i < NRX; i++)
	{
		gRX_length[i]	=	0;
9d006d24:	ac601600 	sw	zero,5632(v1)
9d006d28:	ac400004 	sw	zero,4(v0)
9d006d2c:	ac400008 	sw	zero,8(v0)
	}

	// prepare for rx
	usb_device_enqueue(bulk_in_ep, -1, NULL, 0);
9d006d30:	0f401841 	jal	9d006104 <usb_device_enqueue>
9d006d34:	ac40000c 	sw	zero,12(v0)
	usb_device_enqueue(int_ep, -1, NULL, 0);
9d006d38:	938480ce 	lbu	a0,-32562(gp)
9d006d3c:	240500ff 	li	a1,255
9d006d40:	00003021 	move	a2,zero
9d006d44:	0f401841 	jal	9d006104 <usb_device_enqueue>
9d006d48:	00003821 	move	a3,zero
	
	// start the tx ball rolling
	usb_device_enqueue(bulk_out_ep, 0, gTXbuffer, sizeof(gTXbuffer));
9d006d4c:	938480cd 	lbu	a0,-32563(gp)
9d006d50:	3c06a000 	lui	a2,0xa000
9d006d54:	00002821 	move	a1,zero
9d006d58:	24c61610 	addiu	a2,a2,5648
9d006d5c:	0f401841 	jal	9d006104 <usb_device_enqueue>
9d006d60:	24070040 	li	a3,64
	
	assert(gReset_cbfn);
	gReset_cbfn();
9d006d64:	8f9980a0 	lw	t9,-32608(gp)
}
9d006d68:	8fbf0014 	lw	ra,20(sp)
	
	// start the tx ball rolling
	usb_device_enqueue(bulk_out_ep, 0, gTXbuffer, sizeof(gTXbuffer));
	
	assert(gReset_cbfn);
	gReset_cbfn();
9d006d6c:	03200008 	jr	t9
9d006d70:	27bd0018 	addiu	sp,sp,24

9d006d74 <cdcacm_control_transfer>:

//************************************************************************
// this function implements the CDCACM usb setup control transfer.
//************************************************************************
static int	cdcacm_control_transfer(struct setup *setup, byte *buffer, int length)
{
9d006d74:	27bdffe8 	addiu	sp,sp,-24
9d006d78:	afb00010 	sw	s0,16(sp)
9d006d7c:	afbf0014 	sw	ra,20(sp)
	if (setup->index != 0 /*comm*/)
	{
		return 0;
	}
#endif
	switch(setup->request)
9d006d80:	90820001 	lbu	v0,1(a0)
9d006d84:	24030020 	li	v1,32
9d006d88:	10430021 	beq	v0,v1,9d006e10 <cdcacm_control_transfer+0x9c>
9d006d8c:	00c08021 	move	s0,a2
9d006d90:	2c430021 	sltiu	v1,v0,33
9d006d94:	1460000c 	bnez	v1,9d006dc8 <cdcacm_control_transfer+0x54>
9d006d98:	24030001 	li	v1,1
9d006d9c:	24030021 	li	v1,33
9d006da0:	1043002b 	beq	v0,v1,9d006e50 <cdcacm_control_transfer+0xdc>
9d006da4:	24030022 	li	v1,34
9d006da8:	50430011 	beql	v0,v1,9d006df0 <cdcacm_control_transfer+0x7c>
9d006dac:	90820002 	lbu	v0,2(a0)
			length	=	0;
			break;
	}
	
	return length;
}
9d006db0:	8fbf0014 	lw	ra,20(sp)
#endif
	switch(setup->request)
	{
		case CDCRQ_SEND_ENCAPSULATED_COMMAND:
			assert(! (setup->requesttype & 0x80));
			length	=	0;
9d006db4:	00008021 	move	s0,zero
			length	=	0;
			break;
	}
	
	return length;
}
9d006db8:	02001021 	move	v0,s0
9d006dbc:	8fb00010 	lw	s0,16(sp)
9d006dc0:	03e00008 	jr	ra
9d006dc4:	27bd0018 	addiu	sp,sp,24
	if (setup->index != 0 /*comm*/)
	{
		return 0;
	}
#endif
	switch(setup->request)
9d006dc8:	1443fffa 	bne	v0,v1,9d006db4 <cdcacm_control_transfer+0x40>
9d006dcc:	8fbf0014 	lw	ra,20(sp)
			length	=	0;
			break;
		case CDCRQ_GET_ENCAPSULATED_RESPONSE:
			assert(setup->requesttype & 0x80);
			assert(length <= 64);
			memset(buffer, 0, length);
9d006dd0:	00a02021 	move	a0,a1
9d006dd4:	0f401ed5 	jal	9d007b54 <memset>
9d006dd8:	00002821 	move	a1,zero
			length	=	0;
			break;
	}
	
	return length;
}
9d006ddc:	8fbf0014 	lw	ra,20(sp)
9d006de0:	02001021 	move	v0,s0
9d006de4:	8fb00010 	lw	s0,16(sp)
9d006de8:	03e00008 	jr	ra
9d006dec:	27bd0018 	addiu	sp,sp,24
9d006df0:	8fbf0014 	lw	ra,20(sp)
			memcpy(buffer, line_coding, sizeof(line_coding));
			break;
		case CDCRQ_SET_CONTROL_LINE_STATE:
			assert(! (setup->requesttype & 0x80));
            gConnected = setup->value & 0x01; 
			length	=	0;
9d006df4:	00008021 	move	s0,zero
			assert(length == sizeof(line_coding));
			memcpy(buffer, line_coding, sizeof(line_coding));
			break;
		case CDCRQ_SET_CONTROL_LINE_STATE:
			assert(! (setup->requesttype & 0x80));
            gConnected = setup->value & 0x01; 
9d006df8:	30420001 	andi	v0,v0,0x1
9d006dfc:	a382809c 	sb	v0,-32612(gp)
			length	=	0;
			break;
	}
	
	return length;
}
9d006e00:	02001021 	move	v0,s0
9d006e04:	8fb00010 	lw	s0,16(sp)
9d006e08:	03e00008 	jr	ra
9d006e0c:	27bd0018 	addiu	sp,sp,24
			memset(buffer, 0, length);
			break;
		case CDCRQ_SET_LINE_CODING:
			assert(! (setup->requesttype & 0x80));
			assert(length == sizeof(line_coding));
			memcpy(line_coding, buffer, sizeof(line_coding));
9d006e10:	88a20003 	lwl	v0,3(a1)
9d006e14:	27838018 	addiu	v1,gp,-32744
			length	=	0;
9d006e18:	00008021 	move	s0,zero
			memset(buffer, 0, length);
			break;
		case CDCRQ_SET_LINE_CODING:
			assert(! (setup->requesttype & 0x80));
			assert(length == sizeof(line_coding));
			memcpy(line_coding, buffer, sizeof(line_coding));
9d006e1c:	98a20000 	lwr	v0,0(a1)
9d006e20:	af828014 	sw	v0,-32748(gp)
9d006e24:	90a20004 	lbu	v0,4(a1)
9d006e28:	a3828018 	sb	v0,-32744(gp)
9d006e2c:	90a20005 	lbu	v0,5(a1)
9d006e30:	a0620001 	sb	v0,1(v1)
9d006e34:	90a20006 	lbu	v0,6(a1)
9d006e38:	a0620002 	sb	v0,2(v1)
			length	=	0;
			break;
	}
	
	return length;
}
9d006e3c:	8fbf0014 	lw	ra,20(sp)
9d006e40:	02001021 	move	v0,s0
9d006e44:	8fb00010 	lw	s0,16(sp)
9d006e48:	03e00008 	jr	ra
9d006e4c:	27bd0018 	addiu	sp,sp,24
			length	=	0;
			break;
		case CDCRQ_GET_LINE_CODING:
			assert(setup->requesttype & 0x80);
			assert(length == sizeof(line_coding));
			memcpy(buffer, line_coding, sizeof(line_coding));
9d006e50:	8f828014 	lw	v0,-32748(gp)
9d006e54:	a8a20003 	swl	v0,3(a1)
9d006e58:	b8a20000 	swr	v0,0(a1)
9d006e5c:	93828018 	lbu	v0,-32744(gp)
9d006e60:	a0a20004 	sb	v0,4(a1)
9d006e64:	93828019 	lbu	v0,-32743(gp)
9d006e68:	a0a20005 	sb	v0,5(a1)
9d006e6c:	9382801a 	lbu	v0,-32742(gp)
9d006e70:	a0a20006 	sb	v0,6(a1)
			length	=	0;
			break;
	}
	
	return length;
}
9d006e74:	8fbf0014 	lw	ra,20(sp)
9d006e78:	02001021 	move	v0,s0
9d006e7c:	8fb00010 	lw	s0,16(sp)
9d006e80:	03e00008 	jr	ra
9d006e84:	27bd0018 	addiu	sp,sp,24

9d006e88 <SPLX>:
{
	int csr;
	int oldlevel;

	// get the sr
	csr	=	_CP0_GET_STATUS();
9d006e88:	40036000 	mfc0	v1,c0_status

	oldlevel	=	(csr >> 10) & 7;
	if (level <= 0)
9d006e8c:	1880000b 	blez	a0,9d006ebc <SPLX+0x34>
9d006e90:	7c621280 	ext	v0,v1,0xa,0x3
		level	=	-level;
	}
	else
	{
		// we're going up
		level	=	MAX(level, oldlevel);
9d006e94:	0044282a 	slt	a1,v0,a0
9d006e98:	0045200a 	movz	a0,v0,a1
	}
	assert(level >= 0 && level <= 7);
	csr	=	(csr & 0xffffe3ff) | (level << 10);
9d006e9c:	2405e3ff 	li	a1,-7169
9d006ea0:	00042280 	sll	a0,a0,0xa
9d006ea4:	00651824 	and	v1,v1,a1
9d006ea8:	00831825 	or	v1,a0,v1

	// update the sr
	_CP0_SET_STATUS(csr);
9d006eac:	40836000 	mtc0	v1,c0_status
9d006eb0:	000000c0 	ehb

	assert(oldlevel >= 0 && oldlevel <= 7);
	return -oldlevel;
}
9d006eb4:	03e00008 	jr	ra
9d006eb8:	00021023 	negu	v0,v0
	{
		// we're going up
		level	=	MAX(level, oldlevel);
	}
	assert(level >= 0 && level <= 7);
	csr	=	(csr & 0xffffe3ff) | (level << 10);
9d006ebc:	2405e3ff 	li	a1,-7169

	oldlevel	=	(csr >> 10) & 7;
	if (level <= 0)
	{
		// we're going down
		level	=	-level;
9d006ec0:	00042023 	negu	a0,a0
	{
		// we're going up
		level	=	MAX(level, oldlevel);
	}
	assert(level >= 0 && level <= 7);
	csr	=	(csr & 0xffffe3ff) | (level << 10);
9d006ec4:	00042280 	sll	a0,a0,0xa
9d006ec8:	00651824 	and	v1,v1,a1
9d006ecc:	00831825 	or	v1,a0,v1

	// update the sr
	_CP0_SET_STATUS(csr);
9d006ed0:	40836000 	mtc0	v1,c0_status
9d006ed4:	000000c0 	ehb

	assert(oldlevel >= 0 && oldlevel <= 7);
	return -oldlevel;
}
9d006ed8:	03e00008 	jr	ra
9d006edc:	00021023 	negu	v0,v0

9d006ee0 <setStrings>:
boolean      gConnected = false;

void setStrings(char *man, char *prod, char *ser) {
    int i;
    int pos = 0;
    if (cdcacm_string_descriptor) {
9d006ee0:	8f8280ac 	lw	v0,-32596(gp)
static volatile byte			gRX_in;
static volatile byte			gRX_out;

boolean      gConnected = false;

void setStrings(char *man, char *prod, char *ser) {
9d006ee4:	27bdffc8 	addiu	sp,sp,-56
9d006ee8:	afb2001c 	sw	s2,28(sp)
9d006eec:	afb10018 	sw	s1,24(sp)
9d006ef0:	afb00014 	sw	s0,20(sp)
9d006ef4:	afbf0034 	sw	ra,52(sp)
9d006ef8:	afb70030 	sw	s7,48(sp)
9d006efc:	afb6002c 	sw	s6,44(sp)
9d006f00:	afb50028 	sw	s5,40(sp)
9d006f04:	afb40024 	sw	s4,36(sp)
9d006f08:	afb30020 	sw	s3,32(sp)
9d006f0c:	00808821 	move	s1,a0
9d006f10:	00a09021 	move	s2,a1
    int i;
    int pos = 0;
    if (cdcacm_string_descriptor) {
9d006f14:	10400003 	beqz	v0,9d006f24 <setStrings+0x44>
9d006f18:	00c08021 	move	s0,a2
        free(cdcacm_string_descriptor);
9d006f1c:	0f401d13 	jal	9d00744c <free>
9d006f20:	00402021 	move	a0,v0
    }
    int totlen = 4;
    totlen += strlen(man) * 2 + 2;
9d006f24:	0f401f18 	jal	9d007c60 <strlen>
9d006f28:	02202021 	move	a0,s1
    totlen += strlen(prod) * 2 + 2;
9d006f2c:	02402021 	move	a0,s2
9d006f30:	0f401f18 	jal	9d007c60 <strlen>
9d006f34:	0040a021 	move	s4,v0
9d006f38:	00409821 	move	s3,v0
    totlen += strlen(ser) * 2 + 2;
9d006f3c:	02002021 	move	a0,s0
9d006f40:	0f401f18 	jal	9d007c60 <strlen>
9d006f44:	0293a021 	addu	s4,s4,s3
    int pos = 0;
    if (cdcacm_string_descriptor) {
        free(cdcacm_string_descriptor);
    }
    int totlen = 4;
    totlen += strlen(man) * 2 + 2;
9d006f48:	26940003 	addiu	s4,s4,3
9d006f4c:	0282a021 	addu	s4,s4,v0
    totlen += strlen(prod) * 2 + 2;
    totlen += strlen(ser) * 2 + 2;
9d006f50:	0014a040 	sll	s4,s4,0x1
9d006f54:	26940004 	addiu	s4,s4,4

    cdcacm_string_descriptor = malloc(totlen);
9d006f58:	0f401d09 	jal	9d007424 <malloc>
9d006f5c:	02802021 	move	a0,s4
9d006f60:	00409821 	move	s3,v0

    // Header
    cdcacm_string_descriptor[pos++] = 0x04;
    cdcacm_string_descriptor[pos++] = 0x03;
9d006f64:	24150003 	li	s5,3
    totlen += strlen(ser) * 2 + 2;

    cdcacm_string_descriptor = malloc(totlen);

    // Header
    cdcacm_string_descriptor[pos++] = 0x04;
9d006f68:	24020004 	li	v0,4
    cdcacm_string_descriptor[pos++] = 0x03;
    cdcacm_string_descriptor[pos++] = 0x09;
9d006f6c:	24030009 	li	v1,9
    int totlen = 4;
    totlen += strlen(man) * 2 + 2;
    totlen += strlen(prod) * 2 + 2;
    totlen += strlen(ser) * 2 + 2;

    cdcacm_string_descriptor = malloc(totlen);
9d006f70:	af9380ac 	sw	s3,-32596(gp)
    cdcacm_string_descriptor[pos++] = 0x09;
    cdcacm_string_descriptor[pos++] = 0x04;

    // Manufacturer
    
    cdcacm_string_descriptor[pos++] = strlen(man)*2 + 2;
9d006f74:	02202021 	move	a0,s1

    cdcacm_string_descriptor = malloc(totlen);

    // Header
    cdcacm_string_descriptor[pos++] = 0x04;
    cdcacm_string_descriptor[pos++] = 0x03;
9d006f78:	a2750001 	sb	s5,1(s3)
    totlen += strlen(ser) * 2 + 2;

    cdcacm_string_descriptor = malloc(totlen);

    // Header
    cdcacm_string_descriptor[pos++] = 0x04;
9d006f7c:	a2620000 	sb	v0,0(s3)
    cdcacm_string_descriptor[pos++] = 0x03;
    cdcacm_string_descriptor[pos++] = 0x09;
9d006f80:	a2630002 	sb	v1,2(s3)
    cdcacm_string_descriptor[pos++] = 0x04;

    // Manufacturer
    
    cdcacm_string_descriptor[pos++] = strlen(man)*2 + 2;
9d006f84:	0f401f18 	jal	9d007c60 <strlen>
9d006f88:	a2620003 	sb	v0,3(s3)
9d006f8c:	24420001 	addiu	v0,v0,1
9d006f90:	00021040 	sll	v0,v0,0x1
    cdcacm_string_descriptor[pos++] = 0x03;
9d006f94:	a2750005 	sb	s5,5(s3)
    cdcacm_string_descriptor[pos++] = 0x09;
    cdcacm_string_descriptor[pos++] = 0x04;

    // Manufacturer
    
    cdcacm_string_descriptor[pos++] = strlen(man)*2 + 2;
9d006f98:	a2620004 	sb	v0,4(s3)
    cdcacm_string_descriptor[pos++] = 0x03;
9d006f9c:	0260b021 	move	s6,s3
9d006fa0:	24170006 	li	s7,6
    for (i = 0; i < strlen(man); i++) {
9d006fa4:	0b401bf0 	j	9d006fc0 <setStrings+0xe0>
9d006fa8:	0000a821 	move	s5,zero
        cdcacm_string_descriptor[pos++] = man[i];
9d006fac:	90620000 	lbu	v0,0(v1)
static volatile byte			gRX_in;
static volatile byte			gRX_out;

boolean      gConnected = false;

void setStrings(char *man, char *prod, char *ser) {
9d006fb0:	26f70002 	addiu	s7,s7,2
    
    cdcacm_string_descriptor[pos++] = strlen(man)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(man); i++) {
        cdcacm_string_descriptor[pos++] = man[i];
        cdcacm_string_descriptor[pos++] = 0;
9d006fb4:	a2c00005 	sb	zero,5(s6)
    // Manufacturer
    
    cdcacm_string_descriptor[pos++] = strlen(man)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(man); i++) {
        cdcacm_string_descriptor[pos++] = man[i];
9d006fb8:	a2c20004 	sb	v0,4(s6)

    // Manufacturer
    
    cdcacm_string_descriptor[pos++] = strlen(man)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(man); i++) {
9d006fbc:	26b50001 	addiu	s5,s5,1
9d006fc0:	0f401f18 	jal	9d007c60 <strlen>
9d006fc4:	02202021 	move	a0,s1
9d006fc8:	02a2102b 	sltu	v0,s5,v0
static volatile byte			gRX_in;
static volatile byte			gRX_out;

boolean      gConnected = false;

void setStrings(char *man, char *prod, char *ser) {
9d006fcc:	02351821 	addu	v1,s1,s5

    // Manufacturer
    
    cdcacm_string_descriptor[pos++] = strlen(man)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(man); i++) {
9d006fd0:	1440fff6 	bnez	v0,9d006fac <setStrings+0xcc>
9d006fd4:	26d60002 	addiu	s6,s6,2
        cdcacm_string_descriptor[pos++] = man[i];
        cdcacm_string_descriptor[pos++] = 0;
    }

    // Product
    cdcacm_string_descriptor[pos++] = strlen(prod)*2 + 2;
9d006fd8:	0f401f18 	jal	9d007c60 <strlen>
9d006fdc:	02402021 	move	a0,s2
9d006fe0:	24420001 	addiu	v0,v0,1
9d006fe4:	0277b021 	addu	s6,s3,s7
9d006fe8:	00021040 	sll	v0,v0,0x1
9d006fec:	a2c20000 	sb	v0,0(s6)
    cdcacm_string_descriptor[pos++] = 0x03;
9d006ff0:	24020003 	li	v0,3
9d006ff4:	26f10002 	addiu	s1,s7,2
9d006ff8:	a2c20001 	sb	v0,1(s6)
    for (i = 0; i < strlen(prod); i++) {
9d006ffc:	0b401c06 	j	9d007018 <setStrings+0x138>
9d007000:	0000a821 	move	s5,zero
        cdcacm_string_descriptor[pos++] = prod[i];
9d007004:	90620000 	lbu	v0,0(v1)
static volatile byte			gRX_in;
static volatile byte			gRX_out;

boolean      gConnected = false;

void setStrings(char *man, char *prod, char *ser) {
9d007008:	26310002 	addiu	s1,s1,2
    // Product
    cdcacm_string_descriptor[pos++] = strlen(prod)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(prod); i++) {
        cdcacm_string_descriptor[pos++] = prod[i];
        cdcacm_string_descriptor[pos++] = 0;
9d00700c:	a2c00001 	sb	zero,1(s6)

    // Product
    cdcacm_string_descriptor[pos++] = strlen(prod)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(prod); i++) {
        cdcacm_string_descriptor[pos++] = prod[i];
9d007010:	a2c20000 	sb	v0,0(s6)
    }

    // Product
    cdcacm_string_descriptor[pos++] = strlen(prod)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(prod); i++) {
9d007014:	26b50001 	addiu	s5,s5,1
9d007018:	0f401f18 	jal	9d007c60 <strlen>
9d00701c:	02402021 	move	a0,s2
9d007020:	02a2102b 	sltu	v0,s5,v0
static volatile byte			gRX_in;
static volatile byte			gRX_out;

boolean      gConnected = false;

void setStrings(char *man, char *prod, char *ser) {
9d007024:	02551821 	addu	v1,s2,s5
    }

    // Product
    cdcacm_string_descriptor[pos++] = strlen(prod)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(prod); i++) {
9d007028:	1440fff6 	bnez	v0,9d007004 <setStrings+0x124>
9d00702c:	26d60002 	addiu	s6,s6,2
        cdcacm_string_descriptor[pos++] = prod[i];
        cdcacm_string_descriptor[pos++] = 0;
    }

    // Serial number
    cdcacm_string_descriptor[pos++] = strlen(ser)*2 + 2;
9d007030:	0f401f18 	jal	9d007c60 <strlen>
9d007034:	02002021 	move	a0,s0
9d007038:	24420001 	addiu	v0,v0,1
9d00703c:	02718821 	addu	s1,s3,s1
9d007040:	00021040 	sll	v0,v0,0x1
9d007044:	a2220000 	sb	v0,0(s1)
    cdcacm_string_descriptor[pos++] = 0x03;
9d007048:	24020003 	li	v0,3
9d00704c:	a2220001 	sb	v0,1(s1)
    for (i = 0; i < strlen(ser); i++) {
9d007050:	0b401c1a 	j	9d007068 <setStrings+0x188>
9d007054:	00009021 	move	s2,zero
        cdcacm_string_descriptor[pos++] = ser[i];
9d007058:	90620000 	lbu	v0,0(v1)
    }

    // Serial number
    cdcacm_string_descriptor[pos++] = strlen(ser)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(ser); i++) {
9d00705c:	26520001 	addiu	s2,s2,1
        cdcacm_string_descriptor[pos++] = ser[i];
        cdcacm_string_descriptor[pos++] = 0;
9d007060:	a2200001 	sb	zero,1(s1)

    // Serial number
    cdcacm_string_descriptor[pos++] = strlen(ser)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(ser); i++) {
        cdcacm_string_descriptor[pos++] = ser[i];
9d007064:	a2220000 	sb	v0,0(s1)
    }

    // Serial number
    cdcacm_string_descriptor[pos++] = strlen(ser)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(ser); i++) {
9d007068:	0f401f18 	jal	9d007c60 <strlen>
9d00706c:	02002021 	move	a0,s0
9d007070:	0242102b 	sltu	v0,s2,v0
static volatile byte			gRX_in;
static volatile byte			gRX_out;

boolean      gConnected = false;

void setStrings(char *man, char *prod, char *ser) {
9d007074:	02121821 	addu	v1,s0,s2
    }

    // Serial number
    cdcacm_string_descriptor[pos++] = strlen(ser)*2 + 2;
    cdcacm_string_descriptor[pos++] = 0x03;
    for (i = 0; i < strlen(ser); i++) {
9d007078:	1440fff7 	bnez	v0,9d007058 <setStrings+0x178>
9d00707c:	26310002 	addiu	s1,s1,2
        cdcacm_string_descriptor[pos++] = ser[i];
        cdcacm_string_descriptor[pos++] = 0;
    }

	usb_string_descriptor(cdcacm_string_descriptor, totlen);
9d007080:	02602021 	move	a0,s3
9d007084:	02802821 	move	a1,s4
}
9d007088:	8fbf0034 	lw	ra,52(sp)
9d00708c:	8fb70030 	lw	s7,48(sp)
9d007090:	8fb6002c 	lw	s6,44(sp)
9d007094:	8fb50028 	lw	s5,40(sp)
9d007098:	8fb40024 	lw	s4,36(sp)
9d00709c:	8fb30020 	lw	s3,32(sp)
9d0070a0:	8fb2001c 	lw	s2,28(sp)
9d0070a4:	8fb10018 	lw	s1,24(sp)
9d0070a8:	8fb00014 	lw	s0,20(sp)
    for (i = 0; i < strlen(ser); i++) {
        cdcacm_string_descriptor[pos++] = ser[i];
        cdcacm_string_descriptor[pos++] = 0;
    }

	usb_string_descriptor(cdcacm_string_descriptor, totlen);
9d0070ac:	0b401abe 	j	9d006af8 <usb_string_descriptor>
9d0070b0:	27bd0038 	addiu	sp,sp,56

9d0070b4 <cdcacm_print>:
    int m;
    int previousInterrutLevel;
		
	// ASSERT(length);

	if (! gCdcacm_attached || !gConnected || (length <= 0))
9d0070b4:	938280cc 	lbu	v0,-32564(gp)
// this function waits for space to be available in the transport
// buffers and then prints the specified line to the CDCACM transport
// console.
//************************************************************************
void	cdcacm_print(const byte *buffer, int length)
{
9d0070b8:	27bdffc0 	addiu	sp,sp,-64
9d0070bc:	afb5002c 	sw	s5,44(sp)
9d0070c0:	afb1001c 	sw	s1,28(sp)
9d0070c4:	afbf003c 	sw	ra,60(sp)
9d0070c8:	afbe0038 	sw	s8,56(sp)
9d0070cc:	afb70034 	sw	s7,52(sp)
9d0070d0:	afb60030 	sw	s6,48(sp)
9d0070d4:	afb40028 	sw	s4,40(sp)
9d0070d8:	afb30024 	sw	s3,36(sp)
9d0070dc:	afb20020 	sw	s2,32(sp)
9d0070e0:	afb00018 	sw	s0,24(sp)
9d0070e4:	0080a821 	move	s5,a0
    int m;
    int previousInterrutLevel;
		
	// ASSERT(length);

	if (! gCdcacm_attached || !gConnected || (length <= 0))
9d0070e8:	1040006f 	beqz	v0,9d0072a8 <cdcacm_print+0x1f4>
9d0070ec:	00a08821 	move	s1,a1
9d0070f0:	9382809c 	lbu	v0,-32612(gp)
9d0070f4:	1040006d 	beqz	v0,9d0072ac <cdcacm_print+0x1f8>
9d0070f8:	8fbf003c 	lw	ra,60(sp)
9d0070fc:	18a0006b 	blez	a1,9d0072ac <cdcacm_print+0x1f8>
9d007100:	3c020410 	lui	v0,0x410
	{
		return;
	}

	// figure out how many buffers we need
	buffersNeeded	=	(length + sizeof(gRXbuffer[0]) - 1) / sizeof(gRXbuffer[0]) + 1;
9d007104:	24a3003e 	addiu	v1,a1,62
9d007108:	24424105 	addiu	v0,v0,16645
9d00710c:	00620019 	multu	v1,v0

	previousInterrutLevel	=	SPLX(7);
9d007110:	24040007 	li	a0,7

	// forever...
	m	=	0;
9d007114:	00008021 	move	s0,zero
	{
		// compute the number of available buffers
		availableBuffers	=	(gRX_out + NRX-gRX_in) % NRX;
		if (! availableBuffers)
		{
			availableBuffers	=	NRX;
9d007118:	24130004 	li	s3,4
		}
#ifdef _USE_USB_IRQ_
		SPLX(previousInterrutLevel);

		delay(1);
		if (m++ > 1000)
9d00711c:	241403e9 	li	s4,1001
	{
		return;
	}

	// figure out how many buffers we need
	buffersNeeded	=	(length + sizeof(gRXbuffer[0]) - 1) / sizeof(gRXbuffer[0]) + 1;
9d007120:	00001010 	mfhi	v0
9d007124:	00629023 	subu	s2,v1,v0
9d007128:	00129042 	srl	s2,s2,0x1
9d00712c:	00529021 	addu	s2,v0,s2

	previousInterrutLevel	=	SPLX(7);
9d007130:	0f401ba2 	jal	9d006e88 <SPLX>
9d007134:	00129142 	srl	s2,s2,0x5
	{
		return;
	}

	// figure out how many buffers we need
	buffersNeeded	=	(length + sizeof(gRXbuffer[0]) - 1) / sizeof(gRXbuffer[0]) + 1;
9d007138:	26520001 	addiu	s2,s2,1

	previousInterrutLevel	=	SPLX(7);
9d00713c:	0b401c5a 	j	9d007168 <cdcacm_print+0xb4>
9d007140:	0040b021 	move	s6,v0
		{
			// we're ready to go
			break;
		}
#ifdef _USE_USB_IRQ_
		SPLX(previousInterrutLevel);
9d007144:	0f401ba2 	jal	9d006e88 <SPLX>
9d007148:	00000000 	nop

		delay(1);
9d00714c:	0f4014db 	jal	9d00536c <delay>
9d007150:	24040001 	li	a0,1
		if (m++ > 1000)
9d007154:	12140054 	beq	s0,s4,9d0072a8 <cdcacm_print+0x1f4>
9d007158:	24040007 	li	a0,7
		{
			return;
		}
		previousInterrutLevel	=	SPLX(7);
9d00715c:	0f401ba2 	jal	9d006e88 <SPLX>
9d007160:	26100001 	addiu	s0,s0,1
9d007164:	0040b021 	move	s6,v0
	// forever...
	m	=	0;
	for (;;)
	{
		// compute the number of available buffers
		availableBuffers	=	(gRX_out + NRX-gRX_in) % NRX;
9d007168:	938380a9 	lbu	v1,-32599(gp)
9d00716c:	938280aa 	lbu	v0,-32598(gp)
9d007170:	306300ff 	andi	v1,v1,0xff
9d007174:	304200ff 	andi	v0,v0,0xff
9d007178:	24630004 	addiu	v1,v1,4
9d00717c:	00621823 	subu	v1,v1,v0
9d007180:	000317c3 	sra	v0,v1,0x1f
9d007184:	00021782 	srl	v0,v0,0x1e
9d007188:	0062b821 	addu	s7,v1,v0
9d00718c:	32f70003 	andi	s7,s7,0x3
9d007190:	02e2b823 	subu	s7,s7,v0
		if (! availableBuffers)
		{
			availableBuffers	=	NRX;
9d007194:	0277b80a 	movz	s7,s3,s7
		}

		// if we have as many as we need...
		if (availableBuffers >= buffersNeeded)
9d007198:	02f2102a 	slt	v0,s7,s2
9d00719c:	1440ffe9 	bnez	v0,9d007144 <cdcacm_print+0x90>
9d0071a0:	02c02021 	move	a0,s6
9d0071a4:	3c07a000 	lui	a3,0xa000
9d0071a8:	24e71600 	addiu	a3,a3,5632
9d0071ac:	3c12a000 	lui	s2,0xa000
9d0071b0:	26521650 	addiu	s2,s2,5712

	// while there is more data to send...
	do
	{
		// append to next gRX_in(s)
		m	=	MIN(length, sizeof(gRXbuffer[gRX_in])-gRX_length[gRX_in]);
9d0071b4:	00e0a021 	move	s4,a3
9d0071b8:	2410003f 	li	s0,63

		buffer	+=	m;
		length	-=	m;

		// if this is the first buffer of the transfer or if the transfer will need more buffers...
		if (availableBuffers == NRX || length)
9d0071bc:	24130004 	li	s3,4

	// while there is more data to send...
	do
	{
		// append to next gRX_in(s)
		m	=	MIN(length, sizeof(gRXbuffer[gRX_in])-gRX_length[gRX_in]);
9d0071c0:	938280aa 	lbu	v0,-32598(gp)
9d0071c4:	02201821 	move	v1,s1
9d0071c8:	304200ff 	andi	v0,v0,0xff
9d0071cc:	00021080 	sll	v0,v0,0x2
9d0071d0:	00e21021 	addu	v0,a3,v0
9d0071d4:	8c420000 	lw	v0,0(v0)
9d0071d8:	02021023 	subu	v0,s0,v0
9d0071dc:	0222102b 	sltu	v0,s1,v0
9d0071e0:	1440003d 	bnez	v0,9d0072d8 <cdcacm_print+0x224>
9d0071e4:	0220f021 	move	s8,s1
9d0071e8:	938280aa 	lbu	v0,-32598(gp)
9d0071ec:	304200ff 	andi	v0,v0,0xff
9d0071f0:	00021080 	sll	v0,v0,0x2
9d0071f4:	00541021 	addu	v0,v0,s4
9d0071f8:	8c5e0000 	lw	s8,0(v0)
9d0071fc:	021ef023 	subu	s8,s0,s8
9d007200:	03c01821 	move	v1,s8
9d007204:	023e8823 	subu	s1,s1,s8

		assert(gRX_length[gRX_in]+m <= sizeof(gRXbuffer[gRX_in]));
		memcpy(gRXbuffer[gRX_in]+gRX_length[gRX_in], buffer, m);
9d007208:	938280aa 	lbu	v0,-32598(gp)
9d00720c:	938480aa 	lbu	a0,-32598(gp)
9d007210:	02a02821 	move	a1,s5
9d007214:	304200ff 	andi	v0,v0,0xff
9d007218:	308400ff 	andi	a0,a0,0xff
9d00721c:	00042080 	sll	a0,a0,0x2
9d007220:	00e42021 	addu	a0,a3,a0
9d007224:	8c860000 	lw	a2,0(a0)
9d007228:	00022180 	sll	a0,v0,0x6
9d00722c:	00821023 	subu	v0,a0,v0
9d007230:	00462021 	addu	a0,v0,a2
9d007234:	02442021 	addu	a0,s2,a0
9d007238:	00603021 	move	a2,v1
9d00723c:	afa30010 	sw	v1,16(sp)
9d007240:	0f401eca 	jal	9d007b28 <memcpy>
9d007244:	afa70014 	sw	a3,20(sp)

		gRX_length[gRX_in]	+=	m;
9d007248:	938280aa 	lbu	v0,-32598(gp)
9d00724c:	8fa70014 	lw	a3,20(sp)

		buffer	+=	m;
		length	-=	m;

		// if this is the first buffer of the transfer or if the transfer will need more buffers...
		if (availableBuffers == NRX || length)
9d007250:	8fa30010 	lw	v1,16(sp)
		m	=	MIN(length, sizeof(gRXbuffer[gRX_in])-gRX_length[gRX_in]);

		assert(gRX_length[gRX_in]+m <= sizeof(gRXbuffer[gRX_in]));
		memcpy(gRXbuffer[gRX_in]+gRX_length[gRX_in], buffer, m);

		gRX_length[gRX_in]	+=	m;
9d007254:	304200ff 	andi	v0,v0,0xff
9d007258:	00021080 	sll	v0,v0,0x2
9d00725c:	00e21021 	addu	v0,a3,v0
9d007260:	8c440000 	lw	a0,0(v0)
9d007264:	03c4f021 	addu	s8,s8,a0

		buffer	+=	m;
		length	-=	m;

		// if this is the first buffer of the transfer or if the transfer will need more buffers...
		if (availableBuffers == NRX || length)
9d007268:	12f30023 	beq	s7,s3,9d0072f8 <cdcacm_print+0x244>
9d00726c:	ac5e0000 	sw	s8,0(v0)
9d007270:	1620001b 	bnez	s1,9d0072e0 <cdcacm_print+0x22c>
9d007274:	02c02021 	move	a0,s6
		assert(gRX_length[gRX_out] > 0 && gRX_length[gRX_out] < PACKET_SIZE);
		usb_device_enqueue(bulk_in_ep, 1, gRXbuffer[gRX_out], gRX_length[gRX_out]);
	}

	SPLX(previousInterrutLevel);
}
9d007278:	8fbf003c 	lw	ra,60(sp)
9d00727c:	8fbe0038 	lw	s8,56(sp)
9d007280:	8fb70034 	lw	s7,52(sp)
9d007284:	8fb60030 	lw	s6,48(sp)
9d007288:	8fb5002c 	lw	s5,44(sp)
9d00728c:	8fb40028 	lw	s4,40(sp)
9d007290:	8fb30024 	lw	s3,36(sp)
9d007294:	8fb20020 	lw	s2,32(sp)
9d007298:	8fb1001c 	lw	s1,28(sp)
9d00729c:	8fb00018 	lw	s0,24(sp)
		assert(gRX_out != gRX_in);
		assert(gRX_length[gRX_out] > 0 && gRX_length[gRX_out] < PACKET_SIZE);
		usb_device_enqueue(bulk_in_ep, 1, gRXbuffer[gRX_out], gRX_length[gRX_out]);
	}

	SPLX(previousInterrutLevel);
9d0072a0:	0b401ba2 	j	9d006e88 <SPLX>
9d0072a4:	27bd0040 	addiu	sp,sp,64
}
9d0072a8:	8fbf003c 	lw	ra,60(sp)
9d0072ac:	8fbe0038 	lw	s8,56(sp)
9d0072b0:	8fb70034 	lw	s7,52(sp)
9d0072b4:	8fb60030 	lw	s6,48(sp)
9d0072b8:	8fb5002c 	lw	s5,44(sp)
9d0072bc:	8fb40028 	lw	s4,40(sp)
9d0072c0:	8fb30024 	lw	s3,36(sp)
9d0072c4:	8fb20020 	lw	s2,32(sp)
9d0072c8:	8fb1001c 	lw	s1,28(sp)
9d0072cc:	8fb00018 	lw	s0,24(sp)
9d0072d0:	03e00008 	jr	ra
9d0072d4:	27bd0040 	addiu	sp,sp,64

	// while there is more data to send...
	do
	{
		// append to next gRX_in(s)
		m	=	MIN(length, sizeof(gRXbuffer[gRX_in])-gRX_length[gRX_in]);
9d0072d8:	0b401c82 	j	9d007208 <cdcacm_print+0x154>
9d0072dc:	00008821 	move	s1,zero
		// if this is the first buffer of the transfer or if the transfer will need more buffers...
		if (availableBuffers == NRX || length)
		{
			// advance to the next buffer
			assert(length ? gRX_length[gRX_in] == sizeof(gRXbuffer[gRX_in]) : true);
			gRX_in	=	(gRX_in+1)%NRX;
9d0072e0:	938280aa 	lbu	v0,-32598(gp)
9d0072e4:	24420001 	addiu	v0,v0,1
9d0072e8:	30420003 	andi	v0,v0,0x3
9d0072ec:	a38280aa 	sb	v0,-32598(gp)
		assert(gRX_length[gRX_in]+m <= sizeof(gRXbuffer[gRX_in]));
		memcpy(gRXbuffer[gRX_in]+gRX_length[gRX_in], buffer, m);

		gRX_length[gRX_in]	+=	m;

		buffer	+=	m;
9d0072f0:	0b401c70 	j	9d0071c0 <cdcacm_print+0x10c>
9d0072f4:	02a3a821 	addu	s5,s5,v1
		// if this is the first buffer of the transfer or if the transfer will need more buffers...
		if (availableBuffers == NRX || length)
		{
			// advance to the next buffer
			assert(length ? gRX_length[gRX_in] == sizeof(gRXbuffer[gRX_in]) : true);
			gRX_in	=	(gRX_in+1)%NRX;
9d0072f8:	938280aa 	lbu	v0,-32598(gp)
9d0072fc:	24420001 	addiu	v0,v0,1
9d007300:	30420003 	andi	v0,v0,0x3
9d007304:	a38280aa 	sb	v0,-32598(gp)
			assert(gRX_in != gRX_out);
			assert(! gRX_length[gRX_in]);
		}
	} while (length);
9d007308:	1620ffad 	bnez	s1,9d0071c0 <cdcacm_print+0x10c>
9d00730c:	02a3a821 	addu	s5,s5,v1
	if (availableBuffers == NRX)
	{
		// start the rx ball rolling
		assert(gRX_out != gRX_in);
		assert(gRX_length[gRX_out] > 0 && gRX_length[gRX_out] < PACKET_SIZE);
		usb_device_enqueue(bulk_in_ep, 1, gRXbuffer[gRX_out], gRX_length[gRX_out]);
9d007310:	938680a9 	lbu	a2,-32599(gp)
9d007314:	2403003f 	li	v1,63
9d007318:	938280a9 	lbu	v0,-32599(gp)
9d00731c:	30c600ff 	andi	a2,a2,0xff
9d007320:	70c32002 	mul	a0,a2,v1
9d007324:	24050001 	li	a1,1
9d007328:	304200ff 	andi	v0,v0,0xff
9d00732c:	00021080 	sll	v0,v0,0x2
9d007330:	0054a021 	addu	s4,v0,s4
9d007334:	8e870000 	lw	a3,0(s4)
9d007338:	00923021 	addu	a2,a0,s2
9d00733c:	0f401841 	jal	9d006104 <usb_device_enqueue>
9d007340:	938480cf 	lbu	a0,-32561(gp)
	}

	SPLX(previousInterrutLevel);
9d007344:	0b401c9e 	j	9d007278 <cdcacm_print+0x1c4>
9d007348:	02c02021 	move	a0,s6

9d00734c <cdcacm_command_ack>:
//************************************************************************
// this function acknowledges receipt of an CDCACM command from upper
// level code.
//************************************************************************
void	cdcacm_command_ack(void)
{
9d00734c:	27bdffe0 	addiu	sp,sp,-32
9d007350:	afbf001c 	sw	ra,28(sp)
	int x;

	x	=	SPLX(7);
9d007354:	0f401ba2 	jal	9d006e88 <SPLX>
9d007358:	24040007 	li	a0,7

	if (gWaiting)
9d00735c:	938380a8 	lbu	v1,-32600(gp)
9d007360:	1060000b 	beqz	v1,9d007390 <cdcacm_command_ack+0x44>
9d007364:	8fbf001c 	lw	ra,28(sp)
	{
		// start the tx ball rolling
		usb_device_enqueue(bulk_out_ep, 0, gTXbuffer, sizeof(gTXbuffer));
9d007368:	938480cd 	lbu	a0,-32563(gp)
9d00736c:	3c06a000 	lui	a2,0xa000
9d007370:	00002821 	move	a1,zero
9d007374:	24c61610 	addiu	a2,a2,5648
9d007378:	24070040 	li	a3,64
9d00737c:	0f401841 	jal	9d006104 <usb_device_enqueue>
9d007380:	afa20010 	sw	v0,16(sp)
		gWaiting	=	false;
9d007384:	8fa20010 	lw	v0,16(sp)
9d007388:	a38080a8 	sb	zero,-32600(gp)
	}

	SPLX(x);
}
9d00738c:	8fbf001c 	lw	ra,28(sp)
		// start the tx ball rolling
		usb_device_enqueue(bulk_out_ep, 0, gTXbuffer, sizeof(gTXbuffer));
		gWaiting	=	false;
	}

	SPLX(x);
9d007390:	00402021 	move	a0,v0
9d007394:	0b401ba2 	j	9d006e88 <SPLX>
9d007398:	27bd0020 	addiu	sp,sp,32

9d00739c <cdcacm_register>:
{
	int i;

	for (i = 0; i < NRX; i++)
	{
		gRX_length[i]	=	0;
9d00739c:	3c03a000 	lui	v1,0xa000
	}

	gReset_cbfn		=	reset;
9d0073a0:	af8480a0 	sw	a0,-32608(gp)
	gStoredata_cbfn	=	storeData;
9d0073a4:	af8580a4 	sw	a1,-32604(gp)

	usb_register(cdcacm_reset, cdcacm_control_transfer, cdcacm_bulk_transfer);
9d0073a8:	3c069d00 	lui	a2,0x9d00
9d0073ac:	3c049d00 	lui	a0,0x9d00
9d0073b0:	3c059d00 	lui	a1,0x9d00
//************************************************************************
// this function is called by upper level code to register callback
// functions.
//************************************************************************
void	cdcacm_register(cdcacm_reset_cbfn reset, cdcacm_storedata_cbfn storeData)
{
9d0073b4:	27bdffe8 	addiu	sp,sp,-24
	int i;

	for (i = 0; i < NRX; i++)
	{
		gRX_length[i]	=	0;
9d0073b8:	24621600 	addiu	v0,v1,5632
	}

	gReset_cbfn		=	reset;
	gStoredata_cbfn	=	storeData;

	usb_register(cdcacm_reset, cdcacm_control_transfer, cdcacm_bulk_transfer);
9d0073bc:	24c66bd4 	addiu	a2,a2,27604
9d0073c0:	24846d04 	addiu	a0,a0,27908
9d0073c4:	24a56d74 	addiu	a1,a1,28020
//************************************************************************
// this function is called by upper level code to register callback
// functions.
//************************************************************************
void	cdcacm_register(cdcacm_reset_cbfn reset, cdcacm_storedata_cbfn storeData)
{
9d0073c8:	afbf0014 	sw	ra,20(sp)
	int i;

	for (i = 0; i < NRX; i++)
	{
		gRX_length[i]	=	0;
9d0073cc:	ac601600 	sw	zero,5632(v1)
9d0073d0:	ac400004 	sw	zero,4(v0)
9d0073d4:	ac400008 	sw	zero,8(v0)
	}

	gReset_cbfn		=	reset;
	gStoredata_cbfn	=	storeData;

	usb_register(cdcacm_reset, cdcacm_control_transfer, cdcacm_bulk_transfer);
9d0073d8:	0f401ab4 	jal	9d006ad0 <usb_register>
9d0073dc:	ac40000c 	sw	zero,12(v0)

	assert(check(cdcacm_device_descriptor, sizeof(cdcacm_device_descriptor)) == 1);
	usb_device_descriptor(cdcacm_device_descriptor, sizeof(cdcacm_device_descriptor));
9d0073e0:	3c049d01 	lui	a0,0x9d01
9d0073e4:	248489d0 	addiu	a0,a0,-30256
9d0073e8:	0f401ab8 	jal	9d006ae0 <usb_device_descriptor>
9d0073ec:	24050012 	li	a1,18

	assert(check(cdcacm_configuration_descriptor, sizeof(cdcacm_configuration_descriptor)) == 10);
	usb_configuration_descriptor(cdcacm_configuration_descriptor, sizeof(cdcacm_configuration_descriptor));
9d0073f0:	3c049d01 	lui	a0,0x9d01
9d0073f4:	248489e4 	addiu	a0,a0,-30236
9d0073f8:	0f401abb 	jal	9d006aec <usb_configuration_descriptor>
9d0073fc:	24050043 	li	a1,67

	assert(check(cdcacm_string_descriptor, sizeof(cdcacm_string_descriptor)) == 3);
    setStrings(CDCACM_MAN, CDCACM_PROD, CDCACM_SER);
9d007400:	3c049d01 	lui	a0,0x9d01
9d007404:	3c059d01 	lui	a1,0x9d01
9d007408:	3c069d01 	lui	a2,0x9d01
//	usb_string_descriptor(cdcacm_string_descriptor, sizeof(cdcacm_string_descriptor));
}
9d00740c:	8fbf0014 	lw	ra,20(sp)

	assert(check(cdcacm_configuration_descriptor, sizeof(cdcacm_configuration_descriptor)) == 10);
	usb_configuration_descriptor(cdcacm_configuration_descriptor, sizeof(cdcacm_configuration_descriptor));

	assert(check(cdcacm_string_descriptor, sizeof(cdcacm_string_descriptor)) == 3);
    setStrings(CDCACM_MAN, CDCACM_PROD, CDCACM_SER);
9d007410:	248489b0 	addiu	a0,a0,-30288
9d007414:	24a589c4 	addiu	a1,a1,-30268
9d007418:	24c687b8 	addiu	a2,a2,-30792
9d00741c:	0b401bb8 	j	9d006ee0 <setStrings>
9d007420:	27bd0018 	addiu	sp,sp,24

9d007424 <malloc>:
9d007424:	3c02a000 	lui	v0,0xa000
9d007428:	00802821 	move	a1,a0
9d00742c:	8c440924 	lw	a0,2340(v0)
9d007430:	27bdffe8 	addiu	sp,sp,-24
9d007434:	afbf0014 	sw	ra,20(sp)
9d007438:	0f401d1d 	jal	9d007474 <_malloc_r>
9d00743c:	00000000 	nop
9d007440:	8fbf0014 	lw	ra,20(sp)
9d007444:	03e00008 	jr	ra
9d007448:	27bd0018 	addiu	sp,sp,24

9d00744c <free>:
9d00744c:	3c02a000 	lui	v0,0xa000
9d007450:	00802821 	move	a1,a0
9d007454:	8c440924 	lw	a0,2340(v0)
9d007458:	27bdffe8 	addiu	sp,sp,-24
9d00745c:	afbf0014 	sw	ra,20(sp)
9d007460:	0f401f79 	jal	9d007de4 <_free_r>
9d007464:	00000000 	nop
9d007468:	8fbf0014 	lw	ra,20(sp)
9d00746c:	03e00008 	jr	ra
9d007470:	27bd0018 	addiu	sp,sp,24

9d007474 <_malloc_r>:
9d007474:	24a2000b 	addiu	v0,a1,11
9d007478:	27bdffc8 	addiu	sp,sp,-56
9d00747c:	2c430017 	sltiu	v1,v0,23
9d007480:	afb3001c 	sw	s3,28(sp)
9d007484:	afb00010 	sw	s0,16(sp)
9d007488:	afbf0034 	sw	ra,52(sp)
9d00748c:	afbe0030 	sw	s8,48(sp)
9d007490:	afb7002c 	sw	s7,44(sp)
9d007494:	afb60028 	sw	s6,40(sp)
9d007498:	afb50024 	sw	s5,36(sp)
9d00749c:	afb40020 	sw	s4,32(sp)
9d0074a0:	afb20018 	sw	s2,24(sp)
9d0074a4:	afb10014 	sw	s1,20(sp)
9d0074a8:	00809821 	move	s3,a0
9d0074ac:	14600005 	bnez	v1,9d0074c4 <_malloc_r+0x50>
9d0074b0:	24100010 	li	s0,16
9d0074b4:	2410fff8 	li	s0,-8
9d0074b8:	00508024 	and	s0,v0,s0
9d0074bc:	06000004 	bltz	s0,9d0074d0 <_malloc_r+0x5c>
9d0074c0:	2402000c 	li	v0,12
9d0074c4:	0205282b 	sltu	a1,s0,a1
9d0074c8:	10a00003 	beqz	a1,9d0074d8 <_malloc_r+0x64>
9d0074cc:	2402000c 	li	v0,12
9d0074d0:	0b401ea6 	j	9d007a98 <_malloc_r+0x624>
9d0074d4:	ae620000 	sw	v0,0(s3)
9d0074d8:	0f401ede 	jal	9d007b78 <__malloc_lock>
9d0074dc:	02602021 	move	a0,s3
9d0074e0:	2e0201f8 	sltiu	v0,s0,504
9d0074e4:	1040000e 	beqz	v0,9d007520 <_malloc_r+0xac>
9d0074e8:	3c11a000 	lui	s1,0xa000
9d0074ec:	262200f0 	addiu	v0,s1,240
9d0074f0:	00501021 	addu	v0,v0,s0
9d0074f4:	8c52000c 	lw	s2,12(v0)
9d0074f8:	16420005 	bne	s2,v0,9d007510 <_malloc_r+0x9c>
9d0074fc:	001020c2 	srl	a0,s0,0x3
9d007500:	26420008 	addiu	v0,s2,8
9d007504:	8e520014 	lw	s2,20(s2)
9d007508:	12420038 	beq	s2,v0,9d0075ec <_malloc_r+0x178>
9d00750c:	24840002 	addiu	a0,a0,2
9d007510:	8e420004 	lw	v0,4(s2)
9d007514:	2403fffc 	li	v1,-4
9d007518:	0b401d73 	j	9d0075cc <_malloc_r+0x158>
9d00751c:	00621024 	and	v0,v1,v0
9d007520:	00102242 	srl	a0,s0,0x9
9d007524:	14800003 	bnez	a0,9d007534 <_malloc_r+0xc0>
9d007528:	2c820005 	sltiu	v0,a0,5
9d00752c:	0b401d64 	j	9d007590 <_malloc_r+0x11c>
9d007530:	001020c2 	srl	a0,s0,0x3
9d007534:	10400004 	beqz	v0,9d007548 <_malloc_r+0xd4>
9d007538:	2c820015 	sltiu	v0,a0,21
9d00753c:	00102182 	srl	a0,s0,0x6
9d007540:	0b401d64 	j	9d007590 <_malloc_r+0x11c>
9d007544:	24840038 	addiu	a0,a0,56
9d007548:	10400003 	beqz	v0,9d007558 <_malloc_r+0xe4>
9d00754c:	2c820055 	sltiu	v0,a0,85
9d007550:	0b401d64 	j	9d007590 <_malloc_r+0x11c>
9d007554:	2484005b 	addiu	a0,a0,91
9d007558:	10400004 	beqz	v0,9d00756c <_malloc_r+0xf8>
9d00755c:	2c820155 	sltiu	v0,a0,341
9d007560:	00102302 	srl	a0,s0,0xc
9d007564:	0b401d64 	j	9d007590 <_malloc_r+0x11c>
9d007568:	2484006e 	addiu	a0,a0,110
9d00756c:	10400004 	beqz	v0,9d007580 <_malloc_r+0x10c>
9d007570:	2c820555 	sltiu	v0,a0,1365
9d007574:	001023c2 	srl	a0,s0,0xf
9d007578:	0b401d64 	j	9d007590 <_malloc_r+0x11c>
9d00757c:	24840077 	addiu	a0,a0,119
9d007580:	10400003 	beqz	v0,9d007590 <_malloc_r+0x11c>
9d007584:	2404007e 	li	a0,126
9d007588:	00102482 	srl	a0,s0,0x12
9d00758c:	2484007c 	addiu	a0,a0,124
9d007590:	000410c0 	sll	v0,a0,0x3
9d007594:	262300f0 	addiu	v1,s1,240
9d007598:	00621821 	addu	v1,v1,v0
9d00759c:	8c72000c 	lw	s2,12(v1)
9d0075a0:	0b401d78 	j	9d0075e0 <_malloc_r+0x16c>
9d0075a4:	2406fffc 	li	a2,-4
9d0075a8:	00c21024 	and	v0,a2,v0
9d0075ac:	00502823 	subu	a1,v0,s0
9d0075b0:	28a70010 	slti	a3,a1,16
9d0075b4:	14e00003 	bnez	a3,9d0075c4 <_malloc_r+0x150>
9d0075b8:	00000000 	nop
9d0075bc:	0b401d7a 	j	9d0075e8 <_malloc_r+0x174>
9d0075c0:	2484ffff 	addiu	a0,a0,-1
9d0075c4:	04a20006 	bltzl	a1,9d0075e0 <_malloc_r+0x16c>
9d0075c8:	8e52000c 	lw	s2,12(s2)
9d0075cc:	8e43000c 	lw	v1,12(s2)
9d0075d0:	8e440008 	lw	a0,8(s2)
9d0075d4:	ac83000c 	sw	v1,12(a0)
9d0075d8:	0b401d8c 	j	9d007630 <_malloc_r+0x1bc>
9d0075dc:	ac640008 	sw	a0,8(v1)
9d0075e0:	5643fff1 	bnel	s2,v1,9d0075a8 <_malloc_r+0x134>
9d0075e4:	8e420004 	lw	v0,4(s2)
9d0075e8:	24840001 	addiu	a0,a0,1
9d0075ec:	263100f0 	addiu	s1,s1,240
9d0075f0:	26230008 	addiu	v1,s1,8
9d0075f4:	8c720008 	lw	s2,8(v1)
9d0075f8:	12430051 	beq	s2,v1,9d007740 <_malloc_r+0x2cc>
9d0075fc:	2405fffc 	li	a1,-4
9d007600:	8e420004 	lw	v0,4(s2)
9d007604:	00a21024 	and	v0,a1,v0
9d007608:	00502823 	subu	a1,v0,s0
9d00760c:	28a60010 	slti	a2,a1,16
9d007610:	54c00005 	bnezl	a2,9d007628 <_malloc_r+0x1b4>
9d007614:	ac63000c 	sw	v1,12(v1)
9d007618:	02501021 	addu	v0,s2,s0
9d00761c:	36100001 	ori	s0,s0,0x1
9d007620:	0b401df3 	j	9d0077cc <_malloc_r+0x358>
9d007624:	ae500004 	sw	s0,4(s2)
9d007628:	04a00006 	bltz	a1,9d007644 <_malloc_r+0x1d0>
9d00762c:	ac630008 	sw	v1,8(v1)
9d007630:	02421021 	addu	v0,s2,v0
9d007634:	8c430004 	lw	v1,4(v0)
9d007638:	34630001 	ori	v1,v1,0x1
9d00763c:	0b401eae 	j	9d007ab8 <_malloc_r+0x644>
9d007640:	ac430004 	sw	v1,4(v0)
9d007644:	2c450200 	sltiu	a1,v0,512
9d007648:	10a0000c 	beqz	a1,9d00767c <_malloc_r+0x208>
9d00764c:	00023242 	srl	a2,v0,0x9
9d007650:	000210c2 	srl	v0,v0,0x3
9d007654:	00022883 	sra	a1,v0,0x2
9d007658:	24060001 	li	a2,1
9d00765c:	00a62804 	sllv	a1,a2,a1
9d007660:	8e260004 	lw	a2,4(s1)
9d007664:	000210c0 	sll	v0,v0,0x3
9d007668:	02221021 	addu	v0,s1,v0
9d00766c:	00c52825 	or	a1,a2,a1
9d007670:	ae250004 	sw	a1,4(s1)
9d007674:	0b401dcc 	j	9d007730 <_malloc_r+0x2bc>
9d007678:	8c450008 	lw	a1,8(v0)
9d00767c:	2cc50005 	sltiu	a1,a2,5
9d007680:	10a00004 	beqz	a1,9d007694 <_malloc_r+0x220>
9d007684:	2cc50015 	sltiu	a1,a2,21
9d007688:	00023182 	srl	a2,v0,0x6
9d00768c:	0b401db7 	j	9d0076dc <_malloc_r+0x268>
9d007690:	24c60038 	addiu	a2,a2,56
9d007694:	10a00003 	beqz	a1,9d0076a4 <_malloc_r+0x230>
9d007698:	2cc50055 	sltiu	a1,a2,85
9d00769c:	0b401db7 	j	9d0076dc <_malloc_r+0x268>
9d0076a0:	24c6005b 	addiu	a2,a2,91
9d0076a4:	10a00004 	beqz	a1,9d0076b8 <_malloc_r+0x244>
9d0076a8:	2cc50155 	sltiu	a1,a2,341
9d0076ac:	00023302 	srl	a2,v0,0xc
9d0076b0:	0b401db7 	j	9d0076dc <_malloc_r+0x268>
9d0076b4:	24c6006e 	addiu	a2,a2,110
9d0076b8:	10a00004 	beqz	a1,9d0076cc <_malloc_r+0x258>
9d0076bc:	2cc50555 	sltiu	a1,a2,1365
9d0076c0:	000233c2 	srl	a2,v0,0xf
9d0076c4:	0b401db7 	j	9d0076dc <_malloc_r+0x268>
9d0076c8:	24c60077 	addiu	a2,a2,119
9d0076cc:	10a00003 	beqz	a1,9d0076dc <_malloc_r+0x268>
9d0076d0:	2406007e 	li	a2,126
9d0076d4:	00023482 	srl	a2,v0,0x12
9d0076d8:	24c6007c 	addiu	a2,a2,124
9d0076dc:	000638c0 	sll	a3,a2,0x3
9d0076e0:	02273821 	addu	a3,s1,a3
9d0076e4:	8ce50008 	lw	a1,8(a3)
9d0076e8:	14a7000b 	bne	a1,a3,9d007718 <_malloc_r+0x2a4>
9d0076ec:	2408fffc 	li	t0,-4
9d0076f0:	24020001 	li	v0,1
9d0076f4:	00063083 	sra	a2,a2,0x2
9d0076f8:	00c23004 	sllv	a2,v0,a2
9d0076fc:	8e220004 	lw	v0,4(s1)
9d007700:	00463025 	or	a2,v0,a2
9d007704:	ae260004 	sw	a2,4(s1)
9d007708:	0b401dcc 	j	9d007730 <_malloc_r+0x2bc>
9d00770c:	00a01021 	move	v0,a1
9d007710:	50a70007 	beql	a1,a3,9d007730 <_malloc_r+0x2bc>
9d007714:	8ca2000c 	lw	v0,12(a1)
9d007718:	8ca60004 	lw	a2,4(a1)
9d00771c:	01063024 	and	a2,t0,a2
9d007720:	0046302b 	sltu	a2,v0,a2
9d007724:	54c0fffa 	bnezl	a2,9d007710 <_malloc_r+0x29c>
9d007728:	8ca50008 	lw	a1,8(a1)
9d00772c:	8ca2000c 	lw	v0,12(a1)
9d007730:	ae42000c 	sw	v0,12(s2)
9d007734:	ae450008 	sw	a1,8(s2)
9d007738:	ac520008 	sw	s2,8(v0)
9d00773c:	acb2000c 	sw	s2,12(a1)
9d007740:	24050001 	li	a1,1
9d007744:	00041083 	sra	v0,a0,0x2
9d007748:	00451004 	sllv	v0,a1,v0
9d00774c:	8e250004 	lw	a1,4(s1)
9d007750:	00a2302b 	sltu	a2,a1,v0
9d007754:	54c00053 	bnezl	a2,9d0078a4 <_malloc_r+0x430>
9d007758:	8e340008 	lw	s4,8(s1)
9d00775c:	00453024 	and	a2,v0,a1
9d007760:	14c00008 	bnez	a2,9d007784 <_malloc_r+0x310>
9d007764:	240afffc 	li	t2,-4
9d007768:	2406fffc 	li	a2,-4
9d00776c:	00862024 	and	a0,a0,a2
9d007770:	00021040 	sll	v0,v0,0x1
9d007774:	00453024 	and	a2,v0,a1
9d007778:	10c0fffd 	beqz	a2,9d007770 <_malloc_r+0x2fc>
9d00777c:	24840004 	addiu	a0,a0,4
9d007780:	240afffc 	li	t2,-4
9d007784:	000448c0 	sll	t1,a0,0x3
9d007788:	02294821 	addu	t1,s1,t1
9d00778c:	01203821 	move	a3,t1
9d007790:	00803021 	move	a2,a0
9d007794:	0b401e07 	j	9d00781c <_malloc_r+0x3a8>
9d007798:	8cf2000c 	lw	s2,12(a3)
9d00779c:	01484024 	and	t0,t2,t0
9d0077a0:	01102823 	subu	a1,t0,s0
9d0077a4:	28ab0010 	slti	t3,a1,16
9d0077a8:	15600011 	bnez	t3,9d0077f0 <_malloc_r+0x37c>
9d0077ac:	00000000 	nop
9d0077b0:	8e44000c 	lw	a0,12(s2)
9d0077b4:	8e460008 	lw	a2,8(s2)
9d0077b8:	02501021 	addu	v0,s2,s0
9d0077bc:	36100001 	ori	s0,s0,0x1
9d0077c0:	ae500004 	sw	s0,4(s2)
9d0077c4:	acc4000c 	sw	a0,12(a2)
9d0077c8:	ac860008 	sw	a2,8(a0)
9d0077cc:	ac62000c 	sw	v0,12(v1)
9d0077d0:	ac620008 	sw	v0,8(v1)
9d0077d4:	ac43000c 	sw	v1,12(v0)
9d0077d8:	ac430008 	sw	v1,8(v0)
9d0077dc:	34a30001 	ori	v1,a1,0x1
9d0077e0:	ac430004 	sw	v1,4(v0)
9d0077e4:	00451021 	addu	v0,v0,a1
9d0077e8:	0b401eae 	j	9d007ab8 <_malloc_r+0x644>
9d0077ec:	ac450000 	sw	a1,0(v0)
9d0077f0:	04a2000a 	bltzl	a1,9d00781c <_malloc_r+0x3a8>
9d0077f4:	8e52000c 	lw	s2,12(s2)
9d0077f8:	02481021 	addu	v0,s2,t0
9d0077fc:	8c430004 	lw	v1,4(v0)
9d007800:	34630001 	ori	v1,v1,0x1
9d007804:	ac430004 	sw	v1,4(v0)
9d007808:	8e42000c 	lw	v0,12(s2)
9d00780c:	8e430008 	lw	v1,8(s2)
9d007810:	ac62000c 	sw	v0,12(v1)
9d007814:	0b401eae 	j	9d007ab8 <_malloc_r+0x644>
9d007818:	ac430008 	sw	v1,8(v0)
9d00781c:	5647ffdf 	bnel	s2,a3,9d00779c <_malloc_r+0x328>
9d007820:	8e480004 	lw	t0,4(s2)
9d007824:	24c60001 	addiu	a2,a2,1
9d007828:	30c50003 	andi	a1,a2,0x3
9d00782c:	14a0ffd9 	bnez	a1,9d007794 <_malloc_r+0x320>
9d007830:	24e70008 	addiu	a3,a3,8
9d007834:	01202821 	move	a1,t1
9d007838:	30870003 	andi	a3,a0,0x3
9d00783c:	14e00006 	bnez	a3,9d007858 <_malloc_r+0x3e4>
9d007840:	24a7fff8 	addiu	a3,a1,-8
9d007844:	8e250004 	lw	a1,4(s1)
9d007848:	00022027 	nor	a0,zero,v0
9d00784c:	00a42024 	and	a0,a1,a0
9d007850:	0b401e19 	j	9d007864 <_malloc_r+0x3f0>
9d007854:	ae240004 	sw	a0,4(s1)
9d007858:	8ca50000 	lw	a1,0(a1)
9d00785c:	10a7fff6 	beq	a1,a3,9d007838 <_malloc_r+0x3c4>
9d007860:	2484ffff 	addiu	a0,a0,-1
9d007864:	8e250004 	lw	a1,4(s1)
9d007868:	00021040 	sll	v0,v0,0x1
9d00786c:	00a2202b 	sltu	a0,a1,v0
9d007870:	5480000c 	bnezl	a0,9d0078a4 <_malloc_r+0x430>
9d007874:	8e340008 	lw	s4,8(s1)
9d007878:	10400009 	beqz	v0,9d0078a0 <_malloc_r+0x42c>
9d00787c:	00c02021 	move	a0,a2
9d007880:	0b401e24 	j	9d007890 <_malloc_r+0x41c>
9d007884:	00453024 	and	a2,v0,a1
9d007888:	00021040 	sll	v0,v0,0x1
9d00788c:	00453024 	and	a2,v0,a1
9d007890:	14c0ffbd 	bnez	a2,9d007788 <_malloc_r+0x314>
9d007894:	000448c0 	sll	t1,a0,0x3
9d007898:	0b401e22 	j	9d007888 <_malloc_r+0x414>
9d00789c:	24840004 	addiu	a0,a0,4
9d0078a0:	8e340008 	lw	s4,8(s1)
9d0078a4:	2415fffc 	li	s5,-4
9d0078a8:	8e820004 	lw	v0,4(s4)
9d0078ac:	02a2a824 	and	s5,s5,v0
9d0078b0:	02b0102b 	sltu	v0,s5,s0
9d0078b4:	14400004 	bnez	v0,9d0078c8 <_malloc_r+0x454>
9d0078b8:	02b01023 	subu	v0,s5,s0
9d0078bc:	28430010 	slti	v1,v0,16
9d0078c0:	50600077 	beqzl	v1,9d007aa0 <_malloc_r+0x62c>
9d0078c4:	8e320008 	lw	s2,8(s1)
9d0078c8:	3c02a000 	lui	v0,0xa000
9d0078cc:	8c5609b0 	lw	s6,2480(v0)
9d0078d0:	3c1ea000 	lui	s8,0xa000
9d0078d4:	8fc30920 	lw	v1,2336(s8)
9d0078d8:	26d60010 	addiu	s6,s6,16
9d0078dc:	2402ffff 	li	v0,-1
9d0078e0:	10620004 	beq	v1,v0,9d0078f4 <_malloc_r+0x480>
9d0078e4:	02d0b021 	addu	s6,s6,s0
9d0078e8:	26d6007f 	addiu	s6,s6,127
9d0078ec:	2402ff80 	li	v0,-128
9d0078f0:	02c2b024 	and	s6,s6,v0
9d0078f4:	02602021 	move	a0,s3
9d0078f8:	0f401ef8 	jal	9d007be0 <_sbrk_r>
9d0078fc:	02c02821 	move	a1,s6
9d007900:	00409021 	move	s2,v0
9d007904:	2402ffff 	li	v0,-1
9d007908:	12420056 	beq	s2,v0,9d007a64 <_malloc_r+0x5f0>
9d00790c:	02951021 	addu	v0,s4,s5
9d007910:	0242182b 	sltu	v1,s2,v0
9d007914:	10600004 	beqz	v1,9d007928 <_malloc_r+0x4b4>
9d007918:	3c17a000 	lui	s7,0xa000
9d00791c:	56910052 	bnel	s4,s1,9d007a68 <_malloc_r+0x5f4>
9d007920:	8e220008 	lw	v0,8(s1)
9d007924:	3c17a000 	lui	s7,0xa000
9d007928:	8ee3174c 	lw	v1,5964(s7)
9d00792c:	02c31821 	addu	v1,s6,v1
9d007930:	16420009 	bne	s2,v0,9d007958 <_malloc_r+0x4e4>
9d007934:	aee3174c 	sw	v1,5964(s7)
9d007938:	3244007f 	andi	a0,s2,0x7f
9d00793c:	54800007 	bnezl	a0,9d00795c <_malloc_r+0x4e8>
9d007940:	8fc50920 	lw	a1,2336(s8)
9d007944:	8e220008 	lw	v0,8(s1)
9d007948:	02d5a821 	addu	s5,s6,s5
9d00794c:	36b50001 	ori	s5,s5,0x1
9d007950:	0b401e8e 	j	9d007a38 <_malloc_r+0x5c4>
9d007954:	ac550004 	sw	s5,4(v0)
9d007958:	8fc50920 	lw	a1,2336(s8)
9d00795c:	2404ffff 	li	a0,-1
9d007960:	14a40004 	bne	a1,a0,9d007974 <_malloc_r+0x500>
9d007964:	02431821 	addu	v1,s2,v1
9d007968:	3c02a000 	lui	v0,0xa000
9d00796c:	0b401e5f 	j	9d00797c <_malloc_r+0x508>
9d007970:	ac520920 	sw	s2,2336(v0)
9d007974:	00621023 	subu	v0,v1,v0
9d007978:	aee2174c 	sw	v0,5964(s7)
9d00797c:	32430007 	andi	v1,s2,0x7
9d007980:	10600004 	beqz	v1,9d007994 <_malloc_r+0x520>
9d007984:	00001021 	move	v0,zero
9d007988:	24020008 	li	v0,8
9d00798c:	00431023 	subu	v0,v0,v1
9d007990:	02429021 	addu	s2,s2,v0
9d007994:	0256b021 	addu	s6,s2,s6
9d007998:	24420080 	addiu	v0,v0,128
9d00799c:	32d6007f 	andi	s6,s6,0x7f
9d0079a0:	0056b023 	subu	s6,v0,s6
9d0079a4:	02602021 	move	a0,s3
9d0079a8:	0f401ef8 	jal	9d007be0 <_sbrk_r>
9d0079ac:	02c02821 	move	a1,s6
9d0079b0:	2403ffff 	li	v1,-1
9d0079b4:	14430003 	bne	v0,v1,9d0079c4 <_malloc_r+0x550>
9d0079b8:	8ee3174c 	lw	v1,5964(s7)
9d0079bc:	02401021 	move	v0,s2
9d0079c0:	0000b021 	move	s6,zero
9d0079c4:	00521023 	subu	v0,v0,s2
9d0079c8:	ae320008 	sw	s2,8(s1)
9d0079cc:	02c31821 	addu	v1,s6,v1
9d0079d0:	0056b021 	addu	s6,v0,s6
9d0079d4:	36d60001 	ori	s6,s6,0x1
9d0079d8:	aee3174c 	sw	v1,5964(s7)
9d0079dc:	12910016 	beq	s4,s1,9d007a38 <_malloc_r+0x5c4>
9d0079e0:	ae560004 	sw	s6,4(s2)
9d0079e4:	2ea20010 	sltiu	v0,s5,16
9d0079e8:	10400004 	beqz	v0,9d0079fc <_malloc_r+0x588>
9d0079ec:	2402fff8 	li	v0,-8
9d0079f0:	24020001 	li	v0,1
9d0079f4:	0b401e99 	j	9d007a64 <_malloc_r+0x5f0>
9d0079f8:	ae420004 	sw	v0,4(s2)
9d0079fc:	26b5fff4 	addiu	s5,s5,-12
9d007a00:	02a2a824 	and	s5,s5,v0
9d007a04:	8e820004 	lw	v0,4(s4)
9d007a08:	24030005 	li	v1,5
9d007a0c:	30420001 	andi	v0,v0,0x1
9d007a10:	02a21025 	or	v0,s5,v0
9d007a14:	ae820004 	sw	v0,4(s4)
9d007a18:	02951021 	addu	v0,s4,s5
9d007a1c:	2eb50010 	sltiu	s5,s5,16
9d007a20:	ac430004 	sw	v1,4(v0)
9d007a24:	16a00004 	bnez	s5,9d007a38 <_malloc_r+0x5c4>
9d007a28:	ac430008 	sw	v1,8(v0)
9d007a2c:	02602021 	move	a0,s3
9d007a30:	0f401f79 	jal	9d007de4 <_free_r>
9d007a34:	26850008 	addiu	a1,s4,8
9d007a38:	3c03a000 	lui	v1,0xa000
9d007a3c:	8ee2174c 	lw	v0,5964(s7)
9d007a40:	8c6409b4 	lw	a0,2484(v1)
9d007a44:	0082202b 	sltu	a0,a0,v0
9d007a48:	54800001 	bnezl	a0,9d007a50 <_malloc_r+0x5dc>
9d007a4c:	ac6209b4 	sw	v0,2484(v1)
9d007a50:	3c03a000 	lui	v1,0xa000
9d007a54:	8c6409b8 	lw	a0,2488(v1)
9d007a58:	0082202b 	sltu	a0,a0,v0
9d007a5c:	54800001 	bnezl	a0,9d007a64 <_malloc_r+0x5f0>
9d007a60:	ac6209b8 	sw	v0,2488(v1)
9d007a64:	8e220008 	lw	v0,8(s1)
9d007a68:	2403fffc 	li	v1,-4
9d007a6c:	8c420004 	lw	v0,4(v0)
9d007a70:	00621024 	and	v0,v1,v0
9d007a74:	0050182b 	sltu	v1,v0,s0
9d007a78:	14600005 	bnez	v1,9d007a90 <_malloc_r+0x61c>
9d007a7c:	00000000 	nop
9d007a80:	00501023 	subu	v0,v0,s0
9d007a84:	28430010 	slti	v1,v0,16
9d007a88:	50600005 	beqzl	v1,9d007aa0 <_malloc_r+0x62c>
9d007a8c:	8e320008 	lw	s2,8(s1)
9d007a90:	0f401ee0 	jal	9d007b80 <__malloc_unlock>
9d007a94:	02602021 	move	a0,s3
9d007a98:	0b401eb1 	j	9d007ac4 <_malloc_r+0x650>
9d007a9c:	00001021 	move	v0,zero
9d007aa0:	36030001 	ori	v1,s0,0x1
9d007aa4:	34420001 	ori	v0,v0,0x1
9d007aa8:	02508021 	addu	s0,s2,s0
9d007aac:	ae430004 	sw	v1,4(s2)
9d007ab0:	ae300008 	sw	s0,8(s1)
9d007ab4:	ae020004 	sw	v0,4(s0)
9d007ab8:	0f401ee0 	jal	9d007b80 <__malloc_unlock>
9d007abc:	02602021 	move	a0,s3
9d007ac0:	26420008 	addiu	v0,s2,8
9d007ac4:	8fbf0034 	lw	ra,52(sp)
9d007ac8:	8fbe0030 	lw	s8,48(sp)
9d007acc:	8fb7002c 	lw	s7,44(sp)
9d007ad0:	8fb60028 	lw	s6,40(sp)
9d007ad4:	8fb50024 	lw	s5,36(sp)
9d007ad8:	8fb40020 	lw	s4,32(sp)
9d007adc:	8fb3001c 	lw	s3,28(sp)
9d007ae0:	8fb20018 	lw	s2,24(sp)
9d007ae4:	8fb10014 	lw	s1,20(sp)
9d007ae8:	8fb00010 	lw	s0,16(sp)
9d007aec:	03e00008 	jr	ra
9d007af0:	27bd0038 	addiu	sp,sp,56

9d007af4 <memcmp>:
9d007af4:	0b401ec6 	j	9d007b18 <memcmp+0x24>
9d007af8:	00000000 	nop
9d007afc:	90a20000 	lbu	v0,0(a1)
9d007b00:	10620003 	beq	v1,v0,9d007b10 <memcmp+0x1c>
9d007b04:	24c6ffff 	addiu	a2,a2,-1
9d007b08:	03e00008 	jr	ra
9d007b0c:	00621023 	subu	v0,v1,v0
9d007b10:	24840001 	addiu	a0,a0,1
9d007b14:	24a50001 	addiu	a1,a1,1
9d007b18:	54c0fff8 	bnezl	a2,9d007afc <memcmp+0x8>
9d007b1c:	90830000 	lbu	v1,0(a0)
9d007b20:	03e00008 	jr	ra
9d007b24:	00001021 	move	v0,zero

9d007b28 <memcpy>:
9d007b28:	00801021 	move	v0,a0
9d007b2c:	0b401ed1 	j	9d007b44 <memcpy+0x1c>
9d007b30:	00801821 	move	v1,a0
9d007b34:	24c6ffff 	addiu	a2,a2,-1
9d007b38:	24a50001 	addiu	a1,a1,1
9d007b3c:	a0640000 	sb	a0,0(v1)
9d007b40:	24630001 	addiu	v1,v1,1
9d007b44:	54c0fffb 	bnezl	a2,9d007b34 <memcpy+0xc>
9d007b48:	90a40000 	lbu	a0,0(a1)
9d007b4c:	03e00008 	jr	ra
9d007b50:	00000000 	nop

9d007b54 <memset>:
9d007b54:	00801021 	move	v0,a0
9d007b58:	0b401eda 	j	9d007b68 <memset+0x14>
9d007b5c:	00801821 	move	v1,a0
9d007b60:	24c6ffff 	addiu	a2,a2,-1
9d007b64:	24630001 	addiu	v1,v1,1
9d007b68:	54c0fffd 	bnezl	a2,9d007b60 <memset+0xc>
9d007b6c:	a0650000 	sb	a1,0(v1)
9d007b70:	03e00008 	jr	ra
9d007b74:	00000000 	nop

9d007b78 <__malloc_lock>:
9d007b78:	03e00008 	jr	ra
9d007b7c:	00000000 	nop

9d007b80 <__malloc_unlock>:
9d007b80:	03e00008 	jr	ra
9d007b84:	00000000 	nop

9d007b88 <rand>:
9d007b88:	3c02a000 	lui	v0,0xa000
9d007b8c:	8c430924 	lw	v1,2340(v0)
9d007b90:	3c025851 	lui	v0,0x5851
9d007b94:	3442f42d 	ori	v0,v0,0xf42d
9d007b98:	8c6500a8 	lw	a1,168(v1)
9d007b9c:	8c6600ac 	lw	a2,172(v1)
9d007ba0:	3c044c95 	lui	a0,0x4c95
9d007ba4:	00a20018 	mult	a1,v0
9d007ba8:	24847f2d 	addiu	a0,a0,32557
9d007bac:	70c40000 	madd	a2,a0
9d007bb0:	00001012 	mflo	v0
9d007bb4:	00a40019 	multu	a1,a0
9d007bb8:	00003012 	mflo	a2
9d007bbc:	24c40001 	addiu	a0,a2,1
9d007bc0:	0086282b 	sltu	a1,a0,a2
9d007bc4:	00003810 	mfhi	a3
9d007bc8:	ac6400a8 	sw	a0,168(v1)
9d007bcc:	00471021 	addu	v0,v0,a3
9d007bd0:	00a21021 	addu	v0,a1,v0
9d007bd4:	ac6200ac 	sw	v0,172(v1)
9d007bd8:	03e00008 	jr	ra
9d007bdc:	7c42f000 	ext	v0,v0,0x0,0x1f

9d007be0 <_sbrk_r>:
9d007be0:	27bdffe0 	addiu	sp,sp,-32
9d007be4:	afb10018 	sw	s1,24(sp)
9d007be8:	afb00014 	sw	s0,20(sp)
9d007bec:	00808821 	move	s1,a0
9d007bf0:	3c10a000 	lui	s0,0xa000
9d007bf4:	00a02021 	move	a0,a1
9d007bf8:	afbf001c 	sw	ra,28(sp)
9d007bfc:	0f40210b 	jal	9d00842c <sbrk>
9d007c00:	ae0009e0 	sw	zero,2528(s0)
9d007c04:	2403ffff 	li	v1,-1
9d007c08:	14430005 	bne	v0,v1,9d007c20 <_sbrk_r+0x40>
9d007c0c:	8fbf001c 	lw	ra,28(sp)
9d007c10:	8e0309e0 	lw	v1,2528(s0)
9d007c14:	54600001 	bnezl	v1,9d007c1c <_sbrk_r+0x3c>
9d007c18:	ae230000 	sw	v1,0(s1)
9d007c1c:	8fbf001c 	lw	ra,28(sp)
9d007c20:	8fb10018 	lw	s1,24(sp)
9d007c24:	8fb00014 	lw	s0,20(sp)
9d007c28:	03e00008 	jr	ra
9d007c2c:	27bd0020 	addiu	sp,sp,32

9d007c30 <strchr>:
9d007c30:	30a500ff 	andi	a1,a1,0xff
9d007c34:	90820000 	lbu	v0,0(a0)
9d007c38:	14400005 	bnez	v0,9d007c50 <strchr+0x20>
9d007c3c:	00000000 	nop
9d007c40:	10a00005 	beqz	a1,9d007c58 <strchr+0x28>
9d007c44:	00000000 	nop
9d007c48:	03e00008 	jr	ra
9d007c4c:	00000000 	nop
9d007c50:	5445fff8 	bnel	v0,a1,9d007c34 <strchr+0x4>
9d007c54:	24840001 	addiu	a0,a0,1
9d007c58:	03e00008 	jr	ra
9d007c5c:	00801021 	move	v0,a0

9d007c60 <strlen>:
9d007c60:	24820001 	addiu	v0,a0,1
9d007c64:	90830000 	lbu	v1,0(a0)
9d007c68:	1460fffe 	bnez	v1,9d007c64 <strlen+0x4>
9d007c6c:	24840001 	addiu	a0,a0,1
9d007c70:	03e00008 	jr	ra
9d007c74:	00821023 	subu	v0,a0,v0

9d007c78 <strncpy>:
9d007c78:	00801021 	move	v0,a0
9d007c7c:	00863021 	addu	a2,a0,a2
9d007c80:	0b401f2d 	j	9d007cb4 <strncpy+0x3c>
9d007c84:	00801821 	move	v1,a0
9d007c88:	a0640000 	sb	a0,0(v1)
9d007c8c:	14800008 	bnez	a0,9d007cb0 <strncpy+0x38>
9d007c90:	24630001 	addiu	v1,v1,1
9d007c94:	0b401f28 	j	9d007ca0 <strncpy+0x28>
9d007c98:	00000000 	nop
9d007c9c:	24630001 	addiu	v1,v1,1
9d007ca0:	5466fffe 	bnel	v1,a2,9d007c9c <strncpy+0x24>
9d007ca4:	a0600000 	sb	zero,0(v1)
9d007ca8:	03e00008 	jr	ra
9d007cac:	00000000 	nop
9d007cb0:	24a50001 	addiu	a1,a1,1
9d007cb4:	5466fff4 	bnel	v1,a2,9d007c88 <strncpy+0x10>
9d007cb8:	80a40000 	lb	a0,0(a1)
9d007cbc:	03e00008 	jr	ra
9d007cc0:	00000000 	nop

9d007cc4 <_malloc_trim_r>:
9d007cc4:	27bdffd0 	addiu	sp,sp,-48
9d007cc8:	afb20024 	sw	s2,36(sp)
9d007ccc:	3c12a000 	lui	s2,0xa000
9d007cd0:	265200f0 	addiu	s2,s2,240
9d007cd4:	afb30028 	sw	s3,40(sp)
9d007cd8:	afb10020 	sw	s1,32(sp)
9d007cdc:	afb0001c 	sw	s0,28(sp)
9d007ce0:	afa50010 	sw	a1,16(sp)
9d007ce4:	afbf002c 	sw	ra,44(sp)
9d007ce8:	0f401ede 	jal	9d007b78 <__malloc_lock>
9d007cec:	00808021 	move	s0,a0
9d007cf0:	8e420008 	lw	v0,8(s2)
9d007cf4:	2413fffc 	li	s3,-4
9d007cf8:	8fa50010 	lw	a1,16(sp)
9d007cfc:	8c420004 	lw	v0,4(v0)
9d007d00:	02629824 	and	s3,s3,v0
9d007d04:	2671006f 	addiu	s1,s3,111
9d007d08:	02258823 	subu	s1,s1,a1
9d007d0c:	001189c2 	srl	s1,s1,0x7
9d007d10:	2631ffff 	addiu	s1,s1,-1
9d007d14:	001189c0 	sll	s1,s1,0x7
9d007d18:	2a220080 	slti	v0,s1,128
9d007d1c:	1440001c 	bnez	v0,9d007d90 <_malloc_trim_r+0xcc>
9d007d20:	00000000 	nop
9d007d24:	02002021 	move	a0,s0
9d007d28:	0f401ef8 	jal	9d007be0 <_sbrk_r>
9d007d2c:	00002821 	move	a1,zero
9d007d30:	8e430008 	lw	v1,8(s2)
9d007d34:	00731821 	addu	v1,v1,s3
9d007d38:	14430015 	bne	v0,v1,9d007d90 <_malloc_trim_r+0xcc>
9d007d3c:	00000000 	nop
9d007d40:	02002021 	move	a0,s0
9d007d44:	0f401ef8 	jal	9d007be0 <_sbrk_r>
9d007d48:	00112823 	negu	a1,s1
9d007d4c:	2403ffff 	li	v1,-1
9d007d50:	54430013 	bnel	v0,v1,9d007da0 <_malloc_trim_r+0xdc>
9d007d54:	8e420008 	lw	v0,8(s2)
9d007d58:	02002021 	move	a0,s0
9d007d5c:	0f401ef8 	jal	9d007be0 <_sbrk_r>
9d007d60:	00002821 	move	a1,zero
9d007d64:	8e430008 	lw	v1,8(s2)
9d007d68:	00432023 	subu	a0,v0,v1
9d007d6c:	28850010 	slti	a1,a0,16
9d007d70:	14a00007 	bnez	a1,9d007d90 <_malloc_trim_r+0xcc>
9d007d74:	3c05a000 	lui	a1,0xa000
9d007d78:	8ca50920 	lw	a1,2336(a1)
9d007d7c:	34840001 	ori	a0,a0,0x1
9d007d80:	ac640004 	sw	a0,4(v1)
9d007d84:	00451023 	subu	v0,v0,a1
9d007d88:	3c05a000 	lui	a1,0xa000
9d007d8c:	aca2174c 	sw	v0,5964(a1)
9d007d90:	0f401ee0 	jal	9d007b80 <__malloc_unlock>
9d007d94:	02002021 	move	a0,s0
9d007d98:	0b401f72 	j	9d007dc8 <_malloc_trim_r+0x104>
9d007d9c:	00001021 	move	v0,zero
9d007da0:	02719823 	subu	s3,s3,s1
9d007da4:	36730001 	ori	s3,s3,0x1
9d007da8:	ac530004 	sw	s3,4(v0)
9d007dac:	3c02a000 	lui	v0,0xa000
9d007db0:	8c43174c 	lw	v1,5964(v0)
9d007db4:	02002021 	move	a0,s0
9d007db8:	00718823 	subu	s1,v1,s1
9d007dbc:	0f401ee0 	jal	9d007b80 <__malloc_unlock>
9d007dc0:	ac51174c 	sw	s1,5964(v0)
9d007dc4:	24020001 	li	v0,1
9d007dc8:	8fbf002c 	lw	ra,44(sp)
9d007dcc:	8fb30028 	lw	s3,40(sp)
9d007dd0:	8fb20024 	lw	s2,36(sp)
9d007dd4:	8fb10020 	lw	s1,32(sp)
9d007dd8:	8fb0001c 	lw	s0,28(sp)
9d007ddc:	03e00008 	jr	ra
9d007de0:	27bd0030 	addiu	sp,sp,48

9d007de4 <_free_r>:
9d007de4:	27bdffe0 	addiu	sp,sp,-32
9d007de8:	afb00018 	sw	s0,24(sp)
9d007dec:	afbf001c 	sw	ra,28(sp)
9d007df0:	10a00093 	beqz	a1,9d008040 <_free_r+0x25c>
9d007df4:	00808021 	move	s0,a0
9d007df8:	0f401ede 	jal	9d007b78 <__malloc_lock>
9d007dfc:	afa50010 	sw	a1,16(sp)
9d007e00:	8fa50010 	lw	a1,16(sp)
9d007e04:	2403fffe 	li	v1,-2
9d007e08:	2408fffc 	li	t0,-4
9d007e0c:	24a2fff8 	addiu	v0,a1,-8
9d007e10:	8c490004 	lw	t1,4(v0)
9d007e14:	01231824 	and	v1,t1,v1
9d007e18:	00433021 	addu	a2,v0,v1
9d007e1c:	8cc40004 	lw	a0,4(a2)
9d007e20:	01044024 	and	t0,t0,a0
9d007e24:	3c04a000 	lui	a0,0xa000
9d007e28:	248400f0 	addiu	a0,a0,240
9d007e2c:	8c870008 	lw	a3,8(a0)
9d007e30:	14c70017 	bne	a2,a3,9d007e90 <_free_r+0xac>
9d007e34:	31290001 	andi	t1,t1,0x1
9d007e38:	15200008 	bnez	t1,9d007e5c <_free_r+0x78>
9d007e3c:	01031821 	addu	v1,t0,v1
9d007e40:	8ca5fff8 	lw	a1,-8(a1)
9d007e44:	00451023 	subu	v0,v0,a1
9d007e48:	8c460008 	lw	a2,8(v0)
9d007e4c:	00651821 	addu	v1,v1,a1
9d007e50:	8c45000c 	lw	a1,12(v0)
9d007e54:	acc5000c 	sw	a1,12(a2)
9d007e58:	aca60008 	sw	a2,8(a1)
9d007e5c:	34650001 	ori	a1,v1,0x1
9d007e60:	ac450004 	sw	a1,4(v0)
9d007e64:	ac820008 	sw	v0,8(a0)
9d007e68:	3c02a000 	lui	v0,0xa000
9d007e6c:	8c48091c 	lw	t0,2332(v0)
9d007e70:	0068182b 	sltu	v1,v1,t0
9d007e74:	14600070 	bnez	v1,9d008038 <_free_r+0x254>
9d007e78:	3c02a000 	lui	v0,0xa000
9d007e7c:	8c4509b0 	lw	a1,2480(v0)
9d007e80:	0f401f31 	jal	9d007cc4 <_malloc_trim_r>
9d007e84:	02002021 	move	a0,s0
9d007e88:	0b40200e 	j	9d008038 <_free_r+0x254>
9d007e8c:	00000000 	nop
9d007e90:	acc80004 	sw	t0,4(a2)
9d007e94:	1520000c 	bnez	t1,9d007ec8 <_free_r+0xe4>
9d007e98:	00003821 	move	a3,zero
9d007e9c:	8ca5fff8 	lw	a1,-8(a1)
9d007ea0:	24890008 	addiu	t1,a0,8
9d007ea4:	00451023 	subu	v0,v0,a1
9d007ea8:	00651821 	addu	v1,v1,a1
9d007eac:	8c450008 	lw	a1,8(v0)
9d007eb0:	10a90005 	beq	a1,t1,9d007ec8 <_free_r+0xe4>
9d007eb4:	24070001 	li	a3,1
9d007eb8:	8c47000c 	lw	a3,12(v0)
9d007ebc:	aca7000c 	sw	a3,12(a1)
9d007ec0:	ace50008 	sw	a1,8(a3)
9d007ec4:	00003821 	move	a3,zero
9d007ec8:	00c82821 	addu	a1,a2,t0
9d007ecc:	8ca50004 	lw	a1,4(a1)
9d007ed0:	30a50001 	andi	a1,a1,0x1
9d007ed4:	14a00011 	bnez	a1,9d007f1c <_free_r+0x138>
9d007ed8:	34650001 	ori	a1,v1,0x1
9d007edc:	00681821 	addu	v1,v1,t0
9d007ee0:	14e0000a 	bnez	a3,9d007f0c <_free_r+0x128>
9d007ee4:	8cc50008 	lw	a1,8(a2)
9d007ee8:	24880008 	addiu	t0,a0,8
9d007eec:	54a80008 	bnel	a1,t0,9d007f10 <_free_r+0x12c>
9d007ef0:	8cc6000c 	lw	a2,12(a2)
9d007ef4:	aca2000c 	sw	v0,12(a1)
9d007ef8:	aca20008 	sw	v0,8(a1)
9d007efc:	ac45000c 	sw	a1,12(v0)
9d007f00:	ac450008 	sw	a1,8(v0)
9d007f04:	0b401fc6 	j	9d007f18 <_free_r+0x134>
9d007f08:	24070001 	li	a3,1
9d007f0c:	8cc6000c 	lw	a2,12(a2)
9d007f10:	aca6000c 	sw	a2,12(a1)
9d007f14:	acc50008 	sw	a1,8(a2)
9d007f18:	34650001 	ori	a1,v1,0x1
9d007f1c:	ac450004 	sw	a1,4(v0)
9d007f20:	00432821 	addu	a1,v0,v1
9d007f24:	14e00044 	bnez	a3,9d008038 <_free_r+0x254>
9d007f28:	aca30000 	sw	v1,0(a1)
9d007f2c:	2c650200 	sltiu	a1,v1,512
9d007f30:	10a00010 	beqz	a1,9d007f74 <_free_r+0x190>
9d007f34:	00033242 	srl	a2,v1,0x9
9d007f38:	000318c2 	srl	v1,v1,0x3
9d007f3c:	00032883 	sra	a1,v1,0x2
9d007f40:	24060001 	li	a2,1
9d007f44:	00a62804 	sllv	a1,a2,a1
9d007f48:	8c860004 	lw	a2,4(a0)
9d007f4c:	000318c0 	sll	v1,v1,0x3
9d007f50:	00c52825 	or	a1,a2,a1
9d007f54:	ac850004 	sw	a1,4(a0)
9d007f58:	00832021 	addu	a0,a0,v1
9d007f5c:	8c830008 	lw	v1,8(a0)
9d007f60:	ac44000c 	sw	a0,12(v0)
9d007f64:	ac430008 	sw	v1,8(v0)
9d007f68:	ac62000c 	sw	v0,12(v1)
9d007f6c:	0b40200e 	j	9d008038 <_free_r+0x254>
9d007f70:	ac820008 	sw	v0,8(a0)
9d007f74:	2cc50005 	sltiu	a1,a2,5
9d007f78:	10a00004 	beqz	a1,9d007f8c <_free_r+0x1a8>
9d007f7c:	2cc50015 	sltiu	a1,a2,21
9d007f80:	00033182 	srl	a2,v1,0x6
9d007f84:	0b401ff5 	j	9d007fd4 <_free_r+0x1f0>
9d007f88:	24c60038 	addiu	a2,a2,56
9d007f8c:	10a00003 	beqz	a1,9d007f9c <_free_r+0x1b8>
9d007f90:	2cc50055 	sltiu	a1,a2,85
9d007f94:	0b401ff5 	j	9d007fd4 <_free_r+0x1f0>
9d007f98:	24c6005b 	addiu	a2,a2,91
9d007f9c:	10a00004 	beqz	a1,9d007fb0 <_free_r+0x1cc>
9d007fa0:	2cc50155 	sltiu	a1,a2,341
9d007fa4:	00033302 	srl	a2,v1,0xc
9d007fa8:	0b401ff5 	j	9d007fd4 <_free_r+0x1f0>
9d007fac:	24c6006e 	addiu	a2,a2,110
9d007fb0:	10a00004 	beqz	a1,9d007fc4 <_free_r+0x1e0>
9d007fb4:	2cc50555 	sltiu	a1,a2,1365
9d007fb8:	000333c2 	srl	a2,v1,0xf
9d007fbc:	0b401ff5 	j	9d007fd4 <_free_r+0x1f0>
9d007fc0:	24c60077 	addiu	a2,a2,119
9d007fc4:	10a00003 	beqz	a1,9d007fd4 <_free_r+0x1f0>
9d007fc8:	2406007e 	li	a2,126
9d007fcc:	00033482 	srl	a2,v1,0x12
9d007fd0:	24c6007c 	addiu	a2,a2,124
9d007fd4:	000638c0 	sll	a3,a2,0x3
9d007fd8:	00873821 	addu	a3,a0,a3
9d007fdc:	8ce50008 	lw	a1,8(a3)
9d007fe0:	14a7000b 	bne	a1,a3,9d008010 <_free_r+0x22c>
9d007fe4:	2408fffc 	li	t0,-4
9d007fe8:	24030001 	li	v1,1
9d007fec:	00063083 	sra	a2,a2,0x2
9d007ff0:	00c33004 	sllv	a2,v1,a2
9d007ff4:	8c830004 	lw	v1,4(a0)
9d007ff8:	00663025 	or	a2,v1,a2
9d007ffc:	ac860004 	sw	a2,4(a0)
9d008000:	0b40200a 	j	9d008028 <_free_r+0x244>
9d008004:	00a01821 	move	v1,a1
9d008008:	50a70007 	beql	a1,a3,9d008028 <_free_r+0x244>
9d00800c:	8ca3000c 	lw	v1,12(a1)
9d008010:	8ca40004 	lw	a0,4(a1)
9d008014:	01042024 	and	a0,t0,a0
9d008018:	0064202b 	sltu	a0,v1,a0
9d00801c:	5480fffa 	bnezl	a0,9d008008 <_free_r+0x224>
9d008020:	8ca50008 	lw	a1,8(a1)
9d008024:	8ca3000c 	lw	v1,12(a1)
9d008028:	ac43000c 	sw	v1,12(v0)
9d00802c:	ac450008 	sw	a1,8(v0)
9d008030:	aca2000c 	sw	v0,12(a1)
9d008034:	ac620008 	sw	v0,8(v1)
9d008038:	0f401ee0 	jal	9d007b80 <__malloc_unlock>
9d00803c:	02002021 	move	a0,s0
9d008040:	8fbf001c 	lw	ra,28(sp)
9d008044:	8fb00018 	lw	s0,24(sp)
9d008048:	03e00008 	jr	ra
9d00804c:	27bd0020 	addiu	sp,sp,32

9d008050 <_Znwm>:
9d008050:	27bdffe8 	addiu	sp,sp,-24
9d008054:	afb00010 	sw	s0,16(sp)
9d008058:	24100001 	li	s0,1
9d00805c:	0084800b 	movn	s0,a0,a0
9d008060:	afbf0014 	sw	ra,20(sp)
9d008064:	0f401d09 	jal	9d007424 <malloc>
9d008068:	02002021 	move	a0,s0
9d00806c:	1440000b 	bnez	v0,9d00809c <_Znwm+0x4c>
9d008070:	8fbf0014 	lw	ra,20(sp)
9d008074:	8f8280bc 	lw	v0,-32580(gp)
9d008078:	1040000b 	beqz	v0,9d0080a8 <_Znwm+0x58>
9d00807c:	00000000 	nop
9d008080:	0040f809 	jalr	v0
9d008084:	00000000 	nop
9d008088:	0f401d09 	jal	9d007424 <malloc>
9d00808c:	02002021 	move	a0,s0
9d008090:	5040fff9 	beqzl	v0,9d008078 <_Znwm+0x28>
9d008094:	8f8280bc 	lw	v0,-32580(gp)
9d008098:	8fbf0014 	lw	ra,20(sp)
9d00809c:	8fb00010 	lw	s0,16(sp)
9d0080a0:	03e00008 	jr	ra
9d0080a4:	27bd0018 	addiu	sp,sp,24
9d0080a8:	0f40211f 	jal	9d00847c <abort>
9d0080ac:	00000000 	nop

9d0080b0 <_general_exception_context>:
9d0080b0:	27bdffa8 	addiu	sp,sp,-88
9d0080b4:	afa10004 	sw	at,4(sp)
9d0080b8:	afa20008 	sw	v0,8(sp)
9d0080bc:	afa3000c 	sw	v1,12(sp)
9d0080c0:	afa40010 	sw	a0,16(sp)
9d0080c4:	afa50014 	sw	a1,20(sp)
9d0080c8:	afa60018 	sw	a2,24(sp)
9d0080cc:	afa7001c 	sw	a3,28(sp)
9d0080d0:	afa80020 	sw	t0,32(sp)
9d0080d4:	afa90024 	sw	t1,36(sp)
9d0080d8:	afaa0028 	sw	t2,40(sp)
9d0080dc:	afab002c 	sw	t3,44(sp)
9d0080e0:	afac0030 	sw	t4,48(sp)
9d0080e4:	afad0034 	sw	t5,52(sp)
9d0080e8:	afae0038 	sw	t6,56(sp)
9d0080ec:	afaf003c 	sw	t7,60(sp)
9d0080f0:	afb80040 	sw	t8,64(sp)
9d0080f4:	afb90044 	sw	t9,68(sp)
9d0080f8:	afbf0048 	sw	ra,72(sp)
9d0080fc:	00004012 	mflo	t0
9d008100:	afa8004c 	sw	t0,76(sp)
9d008104:	00004010 	mfhi	t0
9d008108:	afa80050 	sw	t0,80(sp)
9d00810c:	40046800 	mfc0	a0,c0_cause
9d008110:	40056000 	mfc0	a1,c0_status
9d008114:	0f402060 	jal	9d008180 <_general_exception_handler>
9d008118:	00000000 	nop
9d00811c:	8fa80050 	lw	t0,80(sp)
9d008120:	01000011 	mthi	t0
9d008124:	8fa8004c 	lw	t0,76(sp)
9d008128:	01000013 	mtlo	t0
9d00812c:	8fa10004 	lw	at,4(sp)
9d008130:	8fa20008 	lw	v0,8(sp)
9d008134:	8fa3000c 	lw	v1,12(sp)
9d008138:	8fa40010 	lw	a0,16(sp)
9d00813c:	8fa50014 	lw	a1,20(sp)
9d008140:	8fa60018 	lw	a2,24(sp)
9d008144:	8fa7001c 	lw	a3,28(sp)
9d008148:	8fa80020 	lw	t0,32(sp)
9d00814c:	8fa90024 	lw	t1,36(sp)
9d008150:	8faa0028 	lw	t2,40(sp)
9d008154:	8fab002c 	lw	t3,44(sp)
9d008158:	8fac0030 	lw	t4,48(sp)
9d00815c:	8fad0034 	lw	t5,52(sp)
9d008160:	8fae0038 	lw	t6,56(sp)
9d008164:	8faf003c 	lw	t7,60(sp)
9d008168:	8fb80040 	lw	t8,64(sp)
9d00816c:	8fb90044 	lw	t9,68(sp)
9d008170:	8fbf0048 	lw	ra,72(sp)
9d008174:	27bd0058 	addiu	sp,sp,88
9d008178:	000000c0 	ehb
9d00817c:	42000018 	eret

9d008180 <_general_exception_handler>:
9d008180:	0b402060 	j	9d008180 <_general_exception_handler>
9d008184:	00000000 	nop

9d008188 <_on_reset>:
9d008188:	03e00008 	jr	ra
9d00818c:	00000000 	nop

9d008190 <_on_bootstrap>:
9d008190:	03e00008 	jr	ra
9d008194:	00000000 	nop

9d008198 <_nmi_handler>:
9d008198:	401a6000 	mfc0	k0,c0_status
9d00819c:	3c1bffbf 	lui	k1,0xffbf
9d0081a0:	377bffff 	ori	k1,k1,0xffff
9d0081a4:	035bd024 	and	k0,k0,k1
9d0081a8:	409a6000 	mtc0	k0,c0_status
9d0081ac:	42000018 	eret

9d0081b0 <_stub_sbd_memlayout>:
9d0081b0:	3c03a000 	lui	v1,0xa000
9d0081b4:	24621778 	addiu	v0,v1,6008
9d0081b8:	24040001 	li	a0,1
9d0081bc:	ac440008 	sw	a0,8(v0)
9d0081c0:	3c04a000 	lui	a0,0xa000
9d0081c4:	24841910 	addiu	a0,a0,6416
9d0081c8:	ac641778 	sw	a0,6008(v1)
9d0081cc:	3c030000 	lui	v1,0x0
9d0081d0:	24630800 	addiu	v1,v1,2048
9d0081d4:	03e00008 	jr	ra
9d0081d8:	ac430004 	sw	v1,4(v0)

9d0081dc <_sbrk_init>:
9d0081dc:	27bdffd8 	addiu	sp,sp,-40
9d0081e0:	afb00010 	sw	s0,16(sp)
9d0081e4:	3c10a000 	lui	s0,0xa000
9d0081e8:	8e021774 	lw	v0,6004(s0)
9d0081ec:	afbf0024 	sw	ra,36(sp)
9d0081f0:	afb40020 	sw	s4,32(sp)
9d0081f4:	afb3001c 	sw	s3,28(sp)
9d0081f8:	afb20018 	sw	s2,24(sp)
9d0081fc:	10400009 	beqz	v0,9d008224 <_sbrk_init+0x48>
9d008200:	afb10014 	sw	s1,20(sp)
9d008204:	8fbf0024 	lw	ra,36(sp)
9d008208:	8fb40020 	lw	s4,32(sp)
9d00820c:	8fb3001c 	lw	s3,28(sp)
9d008210:	8fb20018 	lw	s2,24(sp)
9d008214:	8fb10014 	lw	s1,20(sp)
9d008218:	8fb00010 	lw	s0,16(sp)
9d00821c:	03e00008 	jr	ra
9d008220:	27bd0028 	addiu	sp,sp,40
9d008224:	3c13a000 	lui	s3,0xa000
9d008228:	8e6309c0 	lw	v1,2496(s3)
9d00822c:	50600040 	beqzl	v1,9d008330 <_sbrk_init+0x154>
9d008230:	3c03a000 	lui	v1,0xa000
9d008234:	3c14a000 	lui	s4,0xa000
9d008238:	8e8209c4 	lw	v0,2500(s4)
9d00823c:	10400039 	beqz	v0,9d008324 <_sbrk_init+0x148>
9d008240:	00000000 	nop
9d008244:	00038f82 	srl	s1,v1,0x1e
9d008248:	00029782 	srl	s2,v0,0x1e
9d00824c:	7c44e000 	ext	a0,v0,0x0,0x1d
9d008250:	7c65e000 	ext	a1,v1,0x0,0x1d
9d008254:	3a310002 	xori	s1,s1,0x2
9d008258:	3a520002 	xori	s2,s2,0x2
9d00825c:	00b1180a 	movz	v1,a1,s1
9d008260:	0092100a 	movz	v0,a0,s2
9d008264:	00608821 	move	s1,v1
9d008268:	0f40206c 	jal	9d0081b0 <_stub_sbd_memlayout>
9d00826c:	00409021 	move	s2,v0
9d008270:	8c430000 	lw	v1,0(v0)
9d008274:	8c420004 	lw	v0,4(v0)
9d008278:	0223202b 	sltu	a0,s1,v1
9d00827c:	10800024 	beqz	a0,9d008310 <_sbrk_init+0x134>
9d008280:	00621021 	addu	v0,v1,v0
9d008284:	3c04a000 	lui	a0,0xa000
9d008288:	24841910 	addiu	a0,a0,6416
9d00828c:	7c84e000 	ext	a0,a0,0x0,0x1d
9d008290:	0064202b 	sltu	a0,v1,a0
9d008294:	1480ffdb 	bnez	a0,9d008204 <_sbrk_init+0x28>
9d008298:	00608821 	move	s1,v1
9d00829c:	0251182b 	sltu	v1,s2,s1
9d0082a0:	14600005 	bnez	v1,9d0082b8 <_sbrk_init+0xdc>
9d0082a4:	0222182b 	sltu	v1,s1,v0
9d0082a8:	0242182b 	sltu	v1,s2,v0
9d0082ac:	54600005 	bnezl	v1,9d0082c4 <_sbrk_init+0xe8>
9d0082b0:	3c02a000 	lui	v0,0xa000
9d0082b4:	0222182b 	sltu	v1,s1,v0
9d0082b8:	1060ffd2 	beqz	v1,9d008204 <_sbrk_init+0x28>
9d0082bc:	00409021 	move	s2,v0
9d0082c0:	3c02a000 	lui	v0,0xa000
9d0082c4:	24421910 	addiu	v0,v0,6416
9d0082c8:	00021742 	srl	v0,v0,0x1d
9d0082cc:	24030005 	li	v1,5
9d0082d0:	14430019 	bne	v0,v1,9d008338 <_sbrk_init+0x15c>
9d0082d4:	24030004 	li	v1,4
9d0082d8:	3c02a000 	lui	v0,0xa000
9d0082dc:	02228825 	or	s1,s1,v0
9d0082e0:	02429025 	or	s2,s2,v0
9d0082e4:	ae7109c0 	sw	s1,2496(s3)
9d0082e8:	ae9209c4 	sw	s2,2500(s4)
9d0082ec:	ae111774 	sw	s1,6004(s0)
9d0082f0:	8fbf0024 	lw	ra,36(sp)
9d0082f4:	8fb40020 	lw	s4,32(sp)
9d0082f8:	8fb3001c 	lw	s3,28(sp)
9d0082fc:	8fb20018 	lw	s2,24(sp)
9d008300:	8fb10014 	lw	s1,20(sp)
9d008304:	8fb00010 	lw	s0,16(sp)
9d008308:	03e00008 	jr	ra
9d00830c:	27bd0028 	addiu	sp,sp,40
9d008310:	0222202b 	sltu	a0,s1,v0
9d008314:	5480ffe2 	bnezl	a0,9d0082a0 <_sbrk_init+0xc4>
9d008318:	0251182b 	sltu	v1,s2,s1
9d00831c:	0b4020a2 	j	9d008288 <_sbrk_init+0xac>
9d008320:	3c04a000 	lui	a0,0xa000
9d008324:	03a01021 	move	v0,sp
9d008328:	0b402091 	j	9d008244 <_sbrk_init+0x68>
9d00832c:	2442f800 	addiu	v0,v0,-2048
9d008330:	0b40208d 	j	9d008234 <_sbrk_init+0x58>
9d008334:	24631910 	addiu	v1,v1,6416
9d008338:	14430007 	bne	v0,v1,9d008358 <_sbrk_init+0x17c>
9d00833c:	3c028000 	lui	v0,0x8000
9d008340:	02228825 	or	s1,s1,v0
9d008344:	02421025 	or	v0,s2,v0
9d008348:	ae7109c0 	sw	s1,2496(s3)
9d00834c:	ae8209c4 	sw	v0,2500(s4)
9d008350:	0b4020bc 	j	9d0082f0 <_sbrk_init+0x114>
9d008354:	ae111774 	sw	s1,6004(s0)
9d008358:	02408821 	move	s1,s2
9d00835c:	ae7209c0 	sw	s2,2496(s3)
9d008360:	0b4020bc 	j	9d0082f0 <_sbrk_init+0x114>
9d008364:	ae111774 	sw	s1,6004(s0)

9d008368 <_sbrk>:
9d008368:	27bdffe0 	addiu	sp,sp,-32
9d00836c:	afb00018 	sw	s0,24(sp)
9d008370:	3c10a000 	lui	s0,0xa000
9d008374:	8e021774 	lw	v0,6004(s0)
9d008378:	1040000e 	beqz	v0,9d0083b4 <_sbrk+0x4c>
9d00837c:	afbf001c 	sw	ra,28(sp)
9d008380:	1880001a 	blez	a0,9d0083ec <_sbrk+0x84>
9d008384:	00441821 	addu	v1,v0,a0
9d008388:	0062202b 	sltu	a0,v1,v0
9d00838c:	1480000e 	bnez	a0,9d0083c8 <_sbrk+0x60>
9d008390:	3c04a000 	lui	a0,0xa000
9d008394:	8c8409c4 	lw	a0,2500(a0)
9d008398:	0083202b 	sltu	a0,a0,v1
9d00839c:	1480000a 	bnez	a0,9d0083c8 <_sbrk+0x60>
9d0083a0:	8fbf001c 	lw	ra,28(sp)
9d0083a4:	ae031774 	sw	v1,6004(s0)
9d0083a8:	8fb00018 	lw	s0,24(sp)
9d0083ac:	03e00008 	jr	ra
9d0083b0:	27bd0020 	addiu	sp,sp,32
9d0083b4:	0f402077 	jal	9d0081dc <_sbrk_init>
9d0083b8:	afa40010 	sw	a0,16(sp)
9d0083bc:	8e021774 	lw	v0,6004(s0)
9d0083c0:	1440ffef 	bnez	v0,9d008380 <_sbrk+0x18>
9d0083c4:	8fa40010 	lw	a0,16(sp)
9d0083c8:	0f402125 	jal	9d008494 <__errno>
9d0083cc:	00000000 	nop
9d0083d0:	8fbf001c 	lw	ra,28(sp)
9d0083d4:	2403000c 	li	v1,12
9d0083d8:	ac430000 	sw	v1,0(v0)
9d0083dc:	8fb00018 	lw	s0,24(sp)
9d0083e0:	2402ffff 	li	v0,-1
9d0083e4:	03e00008 	jr	ra
9d0083e8:	27bd0020 	addiu	sp,sp,32
9d0083ec:	0043202b 	sltu	a0,v0,v1
9d0083f0:	14800005 	bnez	a0,9d008408 <_sbrk+0xa0>
9d0083f4:	3c04a000 	lui	a0,0xa000
9d0083f8:	8c8409c0 	lw	a0,2496(a0)
9d0083fc:	0064202b 	sltu	a0,v1,a0
9d008400:	1080ffe8 	beqz	a0,9d0083a4 <_sbrk+0x3c>
9d008404:	8fbf001c 	lw	ra,28(sp)
9d008408:	0f402125 	jal	9d008494 <__errno>
9d00840c:	00000000 	nop
9d008410:	8fbf001c 	lw	ra,28(sp)
9d008414:	24030016 	li	v1,22
9d008418:	ac430000 	sw	v1,0(v0)
9d00841c:	8fb00018 	lw	s0,24(sp)
9d008420:	2402ffff 	li	v0,-1
9d008424:	03e00008 	jr	ra
9d008428:	27bd0020 	addiu	sp,sp,32

9d00842c <sbrk>:
9d00842c:	27bdffe0 	addiu	sp,sp,-32
9d008430:	afb10018 	sw	s1,24(sp)
9d008434:	afb00014 	sw	s0,20(sp)
9d008438:	afbf001c 	sw	ra,28(sp)
9d00843c:	0f4020da 	jal	9d008368 <_sbrk>
9d008440:	00808821 	move	s1,a0
9d008444:	1a200007 	blez	s1,9d008464 <sbrk+0x38>
9d008448:	00408021 	move	s0,v0
9d00844c:	2402ffff 	li	v0,-1
9d008450:	12020004 	beq	s0,v0,9d008464 <sbrk+0x38>
9d008454:	02002021 	move	a0,s0
9d008458:	00002821 	move	a1,zero
9d00845c:	0f401ed5 	jal	9d007b54 <memset>
9d008460:	02203021 	move	a2,s1
9d008464:	8fbf001c 	lw	ra,28(sp)
9d008468:	02001021 	move	v0,s0
9d00846c:	8fb10018 	lw	s1,24(sp)
9d008470:	8fb00014 	lw	s0,20(sp)
9d008474:	03e00008 	jr	ra
9d008478:	27bd0020 	addiu	sp,sp,32

9d00847c <abort>:
9d00847c:	27bdffe8 	addiu	sp,sp,-24
9d008480:	afbf0014 	sw	ra,20(sp)
9d008484:	0f402155 	jal	9d008554 <raise>
9d008488:	24040006 	li	a0,6
9d00848c:	0f402175 	jal	9d0085d4 <_exit>
9d008490:	24040001 	li	a0,1

9d008494 <__errno>:
9d008494:	3c02a000 	lui	v0,0xa000
9d008498:	03e00008 	jr	ra
9d00849c:	8c420924 	lw	v0,2340(v0)

9d0084a0 <_raise_r>:
9d0084a0:	27bdffe0 	addiu	sp,sp,-32
9d0084a4:	2ca20020 	sltiu	v0,a1,32
9d0084a8:	afb00018 	sw	s0,24(sp)
9d0084ac:	afbf001c 	sw	ra,28(sp)
9d0084b0:	00808021 	move	s0,a0
9d0084b4:	14400005 	bnez	v0,9d0084cc <_raise_r+0x2c>
9d0084b8:	00a03021 	move	a2,a1
9d0084bc:	24020016 	li	v0,22
9d0084c0:	ac820000 	sw	v0,0(a0)
9d0084c4:	0b402151 	j	9d008544 <_raise_r+0xa4>
9d0084c8:	2402ffff 	li	v0,-1
9d0084cc:	8c8202dc 	lw	v0,732(a0)
9d0084d0:	10400007 	beqz	v0,9d0084f0 <_raise_r+0x50>
9d0084d4:	02002021 	move	a0,s0
9d0084d8:	00052080 	sll	a0,a1,0x2
9d0084dc:	00442021 	addu	a0,v0,a0
9d0084e0:	8c830000 	lw	v1,0(a0)
9d0084e4:	1460000a 	bnez	v1,9d008510 <_raise_r+0x70>
9d0084e8:	24050001 	li	a1,1
9d0084ec:	02002021 	move	a0,s0
9d0084f0:	0f40216e 	jal	9d0085b8 <_getpid_r>
9d0084f4:	afa60010 	sw	a2,16(sp)
9d0084f8:	8fa60010 	lw	a2,16(sp)
9d0084fc:	02002021 	move	a0,s0
9d008500:	0f402159 	jal	9d008564 <_kill_r>
9d008504:	00402821 	move	a1,v0
9d008508:	0b402152 	j	9d008548 <_raise_r+0xa8>
9d00850c:	8fbf001c 	lw	ra,28(sp)
9d008510:	1065000c 	beq	v1,a1,9d008544 <_raise_r+0xa4>
9d008514:	00001021 	move	v0,zero
9d008518:	2405ffff 	li	a1,-1
9d00851c:	54650005 	bnel	v1,a1,9d008534 <_raise_r+0x94>
9d008520:	ac800000 	sw	zero,0(a0)
9d008524:	24020016 	li	v0,22
9d008528:	ae020000 	sw	v0,0(s0)
9d00852c:	0b402151 	j	9d008544 <_raise_r+0xa4>
9d008530:	24020001 	li	v0,1
9d008534:	afa20010 	sw	v0,16(sp)
9d008538:	0060f809 	jalr	v1
9d00853c:	00c02021 	move	a0,a2
9d008540:	8fa20010 	lw	v0,16(sp)
9d008544:	8fbf001c 	lw	ra,28(sp)
9d008548:	8fb00018 	lw	s0,24(sp)
9d00854c:	03e00008 	jr	ra
9d008550:	27bd0020 	addiu	sp,sp,32

9d008554 <raise>:
9d008554:	3c02a000 	lui	v0,0xa000
9d008558:	00802821 	move	a1,a0
9d00855c:	0b402128 	j	9d0084a0 <_raise_r>
9d008560:	8c440924 	lw	a0,2340(v0)

9d008564 <_kill_r>:
9d008564:	27bdffe0 	addiu	sp,sp,-32
9d008568:	afb10018 	sw	s1,24(sp)
9d00856c:	afb00014 	sw	s0,20(sp)
9d008570:	00808821 	move	s1,a0
9d008574:	3c10a000 	lui	s0,0xa000
9d008578:	00a02021 	move	a0,a1
9d00857c:	00c02821 	move	a1,a2
9d008580:	afbf001c 	sw	ra,28(sp)
9d008584:	0f402177 	jal	9d0085dc <kill>
9d008588:	ae0009e0 	sw	zero,2528(s0)
9d00858c:	2403ffff 	li	v1,-1
9d008590:	14430005 	bne	v0,v1,9d0085a8 <_kill_r+0x44>
9d008594:	8fbf001c 	lw	ra,28(sp)
9d008598:	8e0309e0 	lw	v1,2528(s0)
9d00859c:	54600001 	bnezl	v1,9d0085a4 <_kill_r+0x40>
9d0085a0:	ae230000 	sw	v1,0(s1)
9d0085a4:	8fbf001c 	lw	ra,28(sp)
9d0085a8:	8fb10018 	lw	s1,24(sp)
9d0085ac:	8fb00014 	lw	s0,20(sp)
9d0085b0:	03e00008 	jr	ra
9d0085b4:	27bd0020 	addiu	sp,sp,32

9d0085b8 <_getpid_r>:
9d0085b8:	27bdffe8 	addiu	sp,sp,-24
9d0085bc:	afbf0014 	sw	ra,20(sp)
9d0085c0:	0f402185 	jal	9d008614 <getpid>
9d0085c4:	00000000 	nop
9d0085c8:	8fbf0014 	lw	ra,20(sp)
9d0085cc:	03e00008 	jr	ra
9d0085d0:	27bd0018 	addiu	sp,sp,24

9d0085d4 <_exit>:
9d0085d4:	0b402175 	j	9d0085d4 <_exit>
9d0085d8:	00000000 	nop

9d0085dc <kill>:
9d0085dc:	27bdffe8 	addiu	sp,sp,-24
9d0085e0:	24020001 	li	v0,1
9d0085e4:	10820005 	beq	a0,v0,9d0085fc <kill+0x20>
9d0085e8:	afbf0014 	sw	ra,20(sp)
9d0085ec:	8fbf0014 	lw	ra,20(sp)
9d0085f0:	00001021 	move	v0,zero
9d0085f4:	03e00008 	jr	ra
9d0085f8:	27bd0018 	addiu	sp,sp,24
9d0085fc:	0f402175 	jal	9d0085d4 <_exit>
9d008600:	00a02021 	move	a0,a1
9d008604:	8fbf0014 	lw	ra,20(sp)
9d008608:	00001021 	move	v0,zero
9d00860c:	03e00008 	jr	ra
9d008610:	27bd0018 	addiu	sp,sp,24

9d008614 <getpid>:
9d008614:	03e00008 	jr	ra
9d008618:	24020001 	li	v0,1

9d00861c <__do_global_ctors_aux>:
9d00861c:	3c029d01 	lui	v0,0x9d01
9d008620:	8c4286bc 	lw	v0,-31044(v0)
9d008624:	27bdffe0 	addiu	sp,sp,-32
9d008628:	2403ffff 	li	v1,-1
9d00862c:	afbf001c 	sw	ra,28(sp)
9d008630:	afb10018 	sw	s1,24(sp)
9d008634:	10430009 	beq	v0,v1,9d00865c <__do_global_ctors_aux+0x40>
9d008638:	afb00014 	sw	s0,20(sp)
9d00863c:	3c119d01 	lui	s1,0x9d01
9d008640:	263186bc 	addiu	s1,s1,-31044
9d008644:	2410ffff 	li	s0,-1
9d008648:	0040f809 	jalr	v0
9d00864c:	2631fffc 	addiu	s1,s1,-4
9d008650:	8e220000 	lw	v0,0(s1)
9d008654:	1450fffc 	bne	v0,s0,9d008648 <__do_global_ctors_aux+0x2c>
9d008658:	00000000 	nop
9d00865c:	8fbf001c 	lw	ra,28(sp)
9d008660:	8fb10018 	lw	s1,24(sp)
9d008664:	8fb00014 	lw	s0,20(sp)
9d008668:	03e00008 	jr	ra
9d00866c:	27bd0020 	addiu	sp,sp,32

Disassembly of section .init:

9d008670 <_init>:
9d008670:	27bdffe0 	addiu	sp,sp,-32
9d008674:	afbf0014 	sw	ra,20(sp)
9d008678:	0f4004b3 	jal	9d0012cc <frame_dummy>
9d00867c:	00000000 	nop
9d008680:	0f402187 	jal	9d00861c <__do_global_ctors_aux>
9d008684:	00000000 	nop
9d008688:	8fbf0014 	lw	ra,20(sp)
9d00868c:	03e00008 	jr	ra
9d008690:	27bd0020 	addiu	sp,sp,32

Disassembly of section .fini:

9d008694 <_fini>:
9d008694:	27bdffe0 	addiu	sp,sp,-32
9d008698:	afbf0014 	sw	ra,20(sp)
9d00869c:	0f400484 	jal	9d001210 <__do_global_dtors_aux>
9d0086a0:	00000000 	nop
9d0086a4:	8fbf0014 	lw	ra,20(sp)
9d0086a8:	03e00008 	jr	ra
9d0086ac:	27bd0020 	addiu	sp,sp,32
